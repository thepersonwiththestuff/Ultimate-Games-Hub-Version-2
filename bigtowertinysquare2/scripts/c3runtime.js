// Generated by Construct 3, the game and app creator :: https://www.construct.net
"use strict";
"use strict";
(function (e, b) {
  "object" === typeof exports && "undefined" !== typeof module
    ? b(exports)
    : "function" === typeof define && define.amd
    ? define(["exports"], b)
    : ((e = "undefined" !== typeof globalThis ? globalThis : e || self),
      b((e.glMatrix = {})));
})(this, function (e) {
  function b(l, t, x) {
    var A = t[0],
      F = t[1],
      G = t[2];
    t = t[3];
    var I = x[0],
      L = x[1],
      M = x[2];
    x = x[3];
    l[0] = A * I + G * L;
    l[1] = F * I + t * L;
    l[2] = A * M + G * x;
    l[3] = F * M + t * x;
    return l;
  }
  function a(l, t, x) {
    l[0] = t[0] - x[0];
    l[1] = t[1] - x[1];
    l[2] = t[2] - x[2];
    l[3] = t[3] - x[3];
    return l;
  }
  function c(l, t, x) {
    var A = t[0],
      F = t[1],
      G = t[2],
      I = t[3],
      L = t[4];
    t = t[5];
    var M = x[0],
      O = x[1],
      R = x[2],
      T = x[3],
      Y = x[4];
    x = x[5];
    l[0] = A * M + G * O;
    l[1] = F * M + I * O;
    l[2] = A * R + G * T;
    l[3] = F * R + I * T;
    l[4] = A * Y + G * x + L;
    l[5] = F * Y + I * x + t;
    return l;
  }
  function d(l, t, x) {
    l[0] = t[0] - x[0];
    l[1] = t[1] - x[1];
    l[2] = t[2] - x[2];
    l[3] = t[3] - x[3];
    l[4] = t[4] - x[4];
    l[5] = t[5] - x[5];
    return l;
  }
  function f() {
    var l = new sa(9);
    sa != Float32Array &&
      ((l[1] = 0), (l[2] = 0), (l[3] = 0), (l[5] = 0), (l[6] = 0), (l[7] = 0));
    l[0] = 1;
    l[4] = 1;
    l[8] = 1;
    return l;
  }
  function h(l, t, x) {
    var A = t[0],
      F = t[1],
      G = t[2],
      I = t[3],
      L = t[4],
      M = t[5],
      O = t[6],
      R = t[7];
    t = t[8];
    var T = x[0],
      Y = x[1],
      X = x[2],
      fa = x[3],
      ha = x[4],
      ba = x[5],
      qa = x[6],
      ka = x[7];
    x = x[8];
    l[0] = T * A + Y * I + X * O;
    l[1] = T * F + Y * L + X * R;
    l[2] = T * G + Y * M + X * t;
    l[3] = fa * A + ha * I + ba * O;
    l[4] = fa * F + ha * L + ba * R;
    l[5] = fa * G + ha * M + ba * t;
    l[6] = qa * A + ka * I + x * O;
    l[7] = qa * F + ka * L + x * R;
    l[8] = qa * G + ka * M + x * t;
    return l;
  }
  function g(l, t, x) {
    l[0] = t[0] - x[0];
    l[1] = t[1] - x[1];
    l[2] = t[2] - x[2];
    l[3] = t[3] - x[3];
    l[4] = t[4] - x[4];
    l[5] = t[5] - x[5];
    l[6] = t[6] - x[6];
    l[7] = t[7] - x[7];
    l[8] = t[8] - x[8];
    return l;
  }
  function k(l) {
    l[0] = 1;
    l[1] = 0;
    l[2] = 0;
    l[3] = 0;
    l[4] = 0;
    l[5] = 1;
    l[6] = 0;
    l[7] = 0;
    l[8] = 0;
    l[9] = 0;
    l[10] = 1;
    l[11] = 0;
    l[12] = 0;
    l[13] = 0;
    l[14] = 0;
    l[15] = 1;
    return l;
  }
  function m(l, t, x) {
    var A = t[0],
      F = t[1],
      G = t[2],
      I = t[3],
      L = t[4],
      M = t[5],
      O = t[6],
      R = t[7],
      T = t[8],
      Y = t[9],
      X = t[10],
      fa = t[11],
      ha = t[12],
      ba = t[13],
      qa = t[14];
    t = t[15];
    var ka = x[0],
      ta = x[1],
      ua = x[2],
      ra = x[3];
    l[0] = ka * A + ta * L + ua * T + ra * ha;
    l[1] = ka * F + ta * M + ua * Y + ra * ba;
    l[2] = ka * G + ta * O + ua * X + ra * qa;
    l[3] = ka * I + ta * R + ua * fa + ra * t;
    ka = x[4];
    ta = x[5];
    ua = x[6];
    ra = x[7];
    l[4] = ka * A + ta * L + ua * T + ra * ha;
    l[5] = ka * F + ta * M + ua * Y + ra * ba;
    l[6] = ka * G + ta * O + ua * X + ra * qa;
    l[7] = ka * I + ta * R + ua * fa + ra * t;
    ka = x[8];
    ta = x[9];
    ua = x[10];
    ra = x[11];
    l[8] = ka * A + ta * L + ua * T + ra * ha;
    l[9] = ka * F + ta * M + ua * Y + ra * ba;
    l[10] = ka * G + ta * O + ua * X + ra * qa;
    l[11] = ka * I + ta * R + ua * fa + ra * t;
    ka = x[12];
    ta = x[13];
    ua = x[14];
    ra = x[15];
    l[12] = ka * A + ta * L + ua * T + ra * ha;
    l[13] = ka * F + ta * M + ua * Y + ra * ba;
    l[14] = ka * G + ta * O + ua * X + ra * qa;
    l[15] = ka * I + ta * R + ua * fa + ra * t;
    return l;
  }
  function q(l, t, x) {
    var A = t[0],
      F = t[1],
      G = t[2],
      I = t[3],
      L = A + A,
      M = F + F,
      O = G + G;
    t = A * L;
    var R = A * M;
    A *= O;
    var T = F * M;
    F *= O;
    G *= O;
    L *= I;
    M *= I;
    I *= O;
    l[0] = 1 - (T + G);
    l[1] = R + I;
    l[2] = A - M;
    l[3] = 0;
    l[4] = R - I;
    l[5] = 1 - (t + G);
    l[6] = F + L;
    l[7] = 0;
    l[8] = A + M;
    l[9] = F - L;
    l[10] = 1 - (t + T);
    l[11] = 0;
    l[12] = x[0];
    l[13] = x[1];
    l[14] = x[2];
    l[15] = 1;
    return l;
  }
  function v(l, t) {
    l[0] = t[12];
    l[1] = t[13];
    l[2] = t[14];
    return l;
  }
  function r(l, t) {
    var x = t[4],
      A = t[5],
      F = t[6],
      G = t[8],
      I = t[9],
      L = t[10];
    l[0] = Math.hypot(t[0], t[1], t[2]);
    l[1] = Math.hypot(x, A, F);
    l[2] = Math.hypot(G, I, L);
    return l;
  }
  function n(l, t) {
    var x = new sa(3);
    r(x, t);
    var A = 1 / x[0],
      F = 1 / x[1],
      G = 1 / x[2],
      I = t[0] * A;
    x = t[1] * F;
    var L = t[2] * G,
      M = t[4] * A,
      O = t[5] * F,
      R = t[6] * G;
    A *= t[8];
    F *= t[9];
    t = t[10] * G;
    G = I + O + t;
    0 < G
      ? ((I = 2 * Math.sqrt(G + 1)),
        (l[3] = 0.25 * I),
        (l[0] = (R - F) / I),
        (l[1] = (A - L) / I),
        (l[2] = (x - M) / I))
      : I > O && I > t
      ? ((I = 2 * Math.sqrt(1 + I - O - t)),
        (l[3] = (R - F) / I),
        (l[0] = 0.25 * I),
        (l[1] = (x + M) / I),
        (l[2] = (A + L) / I))
      : O > t
      ? ((I = 2 * Math.sqrt(1 + O - I - t)),
        (l[3] = (A - L) / I),
        (l[0] = (x + M) / I),
        (l[1] = 0.25 * I),
        (l[2] = (R + F) / I))
      : ((I = 2 * Math.sqrt(1 + t - I - O)),
        (l[3] = (x - M) / I),
        (l[0] = (A + L) / I),
        (l[1] = (R + F) / I),
        (l[2] = 0.25 * I));
    return l;
  }
  function p(l, t, x, A, F) {
    t = 1 / Math.tan(t / 2);
    l[0] = t / x;
    l[1] = 0;
    l[2] = 0;
    l[3] = 0;
    l[4] = 0;
    l[5] = t;
    l[6] = 0;
    l[7] = 0;
    l[8] = 0;
    l[9] = 0;
    l[11] = -1;
    l[12] = 0;
    l[13] = 0;
    l[15] = 0;
    null != F && Infinity !== F
      ? ((x = 1 / (A - F)), (l[10] = (F + A) * x), (l[14] = 2 * F * A * x))
      : ((l[10] = -1), (l[14] = -2 * A));
    return l;
  }
  function u(l, t, x, A, F, G, I) {
    var L = 1 / (t - x),
      M = 1 / (A - F),
      O = 1 / (G - I);
    l[0] = -2 * L;
    l[1] = 0;
    l[2] = 0;
    l[3] = 0;
    l[4] = 0;
    l[5] = -2 * M;
    l[6] = 0;
    l[7] = 0;
    l[8] = 0;
    l[9] = 0;
    l[10] = 2 * O;
    l[11] = 0;
    l[12] = (t + x) * L;
    l[13] = (F + A) * M;
    l[14] = (I + G) * O;
    l[15] = 1;
    return l;
  }
  function w(l, t, x) {
    l[0] = t[0] - x[0];
    l[1] = t[1] - x[1];
    l[2] = t[2] - x[2];
    l[3] = t[3] - x[3];
    l[4] = t[4] - x[4];
    l[5] = t[5] - x[5];
    l[6] = t[6] - x[6];
    l[7] = t[7] - x[7];
    l[8] = t[8] - x[8];
    l[9] = t[9] - x[9];
    l[10] = t[10] - x[10];
    l[11] = t[11] - x[11];
    l[12] = t[12] - x[12];
    l[13] = t[13] - x[13];
    l[14] = t[14] - x[14];
    l[15] = t[15] - x[15];
    return l;
  }
  function y() {
    var l = new sa(3);
    sa != Float32Array && ((l[0] = 0), (l[1] = 0), (l[2] = 0));
    return l;
  }
  function B(l) {
    return Math.hypot(l[0], l[1], l[2]);
  }
  function E(l, t, x) {
    var A = new sa(3);
    A[0] = l;
    A[1] = t;
    A[2] = x;
    return A;
  }
  function z(l, t, x) {
    l[0] = t[0] - x[0];
    l[1] = t[1] - x[1];
    l[2] = t[2] - x[2];
    return l;
  }
  function D(l, t, x) {
    l[0] = t[0] * x[0];
    l[1] = t[1] * x[1];
    l[2] = t[2] * x[2];
    return l;
  }
  function J(l, t, x) {
    l[0] = t[0] / x[0];
    l[1] = t[1] / x[1];
    l[2] = t[2] / x[2];
    return l;
  }
  function C(l, t) {
    return Math.hypot(t[0] - l[0], t[1] - l[1], t[2] - l[2]);
  }
  function H(l, t) {
    var x = t[0] - l[0],
      A = t[1] - l[1];
    l = t[2] - l[2];
    return x * x + A * A + l * l;
  }
  function K(l) {
    var t = l[0],
      x = l[1];
    l = l[2];
    return t * t + x * x + l * l;
  }
  function P(l, t) {
    var x = t[0],
      A = t[1],
      F = t[2];
    x = x * x + A * A + F * F;
    0 < x && (x = 1 / Math.sqrt(x));
    l[0] = t[0] * x;
    l[1] = t[1] * x;
    l[2] = t[2] * x;
    return l;
  }
  function S(l, t) {
    return l[0] * t[0] + l[1] * t[1] + l[2] * t[2];
  }
  function U(l, t, x) {
    var A = t[0],
      F = t[1];
    t = t[2];
    var G = x[0],
      I = x[1];
    x = x[2];
    l[0] = F * x - t * I;
    l[1] = t * G - A * x;
    l[2] = A * I - F * G;
    return l;
  }
  function V() {
    var l = new sa(4);
    sa != Float32Array && ((l[0] = 0), (l[1] = 0), (l[2] = 0), (l[3] = 0));
    return l;
  }
  function aa(l) {
    var t = new sa(4);
    t[0] = l[0];
    t[1] = l[1];
    t[2] = l[2];
    t[3] = l[3];
    return t;
  }
  function ma(l, t, x, A) {
    var F = new sa(4);
    F[0] = l;
    F[1] = t;
    F[2] = x;
    F[3] = A;
    return F;
  }
  function va(l, t) {
    l[0] = t[0];
    l[1] = t[1];
    l[2] = t[2];
    l[3] = t[3];
    return l;
  }
  function Na(l, t, x, A, F) {
    l[0] = t;
    l[1] = x;
    l[2] = A;
    l[3] = F;
    return l;
  }
  function Ea(l, t, x) {
    l[0] = t[0] + x[0];
    l[1] = t[1] + x[1];
    l[2] = t[2] + x[2];
    l[3] = t[3] + x[3];
    return l;
  }
  function Ia(l, t, x) {
    l[0] = t[0] - x[0];
    l[1] = t[1] - x[1];
    l[2] = t[2] - x[2];
    l[3] = t[3] - x[3];
    return l;
  }
  function Ma(l, t, x) {
    l[0] = t[0] * x[0];
    l[1] = t[1] * x[1];
    l[2] = t[2] * x[2];
    l[3] = t[3] * x[3];
    return l;
  }
  function Fa(l, t, x) {
    l[0] = t[0] / x[0];
    l[1] = t[1] / x[1];
    l[2] = t[2] / x[2];
    l[3] = t[3] / x[3];
    return l;
  }
  function ya(l, t, x) {
    l[0] = t[0] * x;
    l[1] = t[1] * x;
    l[2] = t[2] * x;
    l[3] = t[3] * x;
    return l;
  }
  function na(l, t) {
    return Math.hypot(t[0] - l[0], t[1] - l[1], t[2] - l[2], t[3] - l[3]);
  }
  function Va(l, t) {
    var x = t[0] - l[0],
      A = t[1] - l[1],
      F = t[2] - l[2];
    l = t[3] - l[3];
    return x * x + A * A + F * F + l * l;
  }
  function xa(l) {
    return Math.hypot(l[0], l[1], l[2], l[3]);
  }
  function Ga(l) {
    var t = l[0],
      x = l[1],
      A = l[2];
    l = l[3];
    return t * t + x * x + A * A + l * l;
  }
  function bb(l, t) {
    var x = t[0],
      A = t[1],
      F = t[2];
    t = t[3];
    var G = x * x + A * A + F * F + t * t;
    0 < G && (G = 1 / Math.sqrt(G));
    l[0] = x * G;
    l[1] = A * G;
    l[2] = F * G;
    l[3] = t * G;
    return l;
  }
  function Xa(l, t) {
    return l[0] * t[0] + l[1] * t[1] + l[2] * t[2] + l[3] * t[3];
  }
  function ob(l, t, x, A) {
    var F = t[0],
      G = t[1],
      I = t[2];
    t = t[3];
    l[0] = F + A * (x[0] - F);
    l[1] = G + A * (x[1] - G);
    l[2] = I + A * (x[2] - I);
    l[3] = t + A * (x[3] - t);
    return l;
  }
  function pb(l, t) {
    return l[0] === t[0] && l[1] === t[1] && l[2] === t[2] && l[3] === t[3];
  }
  function cb() {
    var l = new sa(4);
    sa != Float32Array && ((l[0] = 0), (l[1] = 0), (l[2] = 0));
    l[3] = 1;
    return l;
  }
  function qb(l, t, x) {
    x *= 0.5;
    var A = Math.sin(x);
    l[0] = A * t[0];
    l[1] = A * t[1];
    l[2] = A * t[2];
    l[3] = Math.cos(x);
    return l;
  }
  function rb(l, t, x) {
    var A = t[0],
      F = t[1],
      G = t[2];
    t = t[3];
    var I = x[0],
      L = x[1],
      M = x[2];
    x = x[3];
    l[0] = A * x + t * I + F * M - G * L;
    l[1] = F * x + t * L + G * I - A * M;
    l[2] = G * x + t * M + A * L - F * I;
    l[3] = t * x - A * I - F * L - G * M;
    return l;
  }
  function sb(l, t, x) {
    x *= 0.5;
    var A = t[0],
      F = t[1],
      G = t[2];
    t = t[3];
    var I = Math.sin(x);
    x = Math.cos(x);
    l[0] = A * x + t * I;
    l[1] = F * x + G * I;
    l[2] = G * x - F * I;
    l[3] = t * x - A * I;
    return l;
  }
  function tb(l, t, x) {
    x *= 0.5;
    var A = t[0],
      F = t[1],
      G = t[2];
    t = t[3];
    var I = Math.sin(x);
    x = Math.cos(x);
    l[0] = A * x - G * I;
    l[1] = F * x + t * I;
    l[2] = G * x + A * I;
    l[3] = t * x - F * I;
    return l;
  }
  function ub(l, t, x) {
    x *= 0.5;
    var A = t[0],
      F = t[1],
      G = t[2];
    t = t[3];
    var I = Math.sin(x);
    x = Math.cos(x);
    l[0] = A * x + F * I;
    l[1] = F * x - A * I;
    l[2] = G * x + t * I;
    l[3] = t * x - G * I;
    return l;
  }
  function vb(l, t) {
    var x = t[0],
      A = t[1],
      F = t[2],
      G = Math.sqrt(x * x + A * A + F * F);
    t = Math.exp(t[3]);
    var I = 0 < G ? (t * Math.sin(G)) / G : 0;
    l[0] = x * I;
    l[1] = A * I;
    l[2] = F * I;
    l[3] = t * Math.cos(G);
    return l;
  }
  function wb(l, t) {
    var x = t[0],
      A = t[1],
      F = t[2];
    t = t[3];
    var G = Math.sqrt(x * x + A * A + F * F);
    G = 0 < G ? Math.atan2(G, t) / G : 0;
    l[0] = x * G;
    l[1] = A * G;
    l[2] = F * G;
    l[3] = 0.5 * Math.log(x * x + A * A + F * F + t * t);
    return l;
  }
  function db(l, t, x, A) {
    var F = t[0],
      G = t[1],
      I = t[2];
    t = t[3];
    var L = x[0],
      M = x[1],
      O = x[2];
    x = x[3];
    var R = F * L + G * M + I * O + t * x;
    0 > R && ((R = -R), (L = -L), (M = -M), (O = -O), (x = -x));
    if (1e-6 < 1 - R) {
      var T = Math.acos(R);
      var Y = Math.sin(T);
      R = Math.sin((1 - A) * T) / Y;
      A = Math.sin(A * T) / Y;
    } else R = 1 - A;
    l[0] = R * F + A * L;
    l[1] = R * G + A * M;
    l[2] = R * I + A * O;
    l[3] = R * t + A * x;
    return l;
  }
  function xb(l, t) {
    var x = t[0] + t[4] + t[8];
    if (0 < x)
      (x = Math.sqrt(x + 1)),
        (l[3] = 0.5 * x),
        (x = 0.5 / x),
        (l[0] = (t[5] - t[7]) * x),
        (l[1] = (t[6] - t[2]) * x),
        (l[2] = (t[1] - t[3]) * x);
    else {
      var A = 0;
      t[4] > t[0] && (A = 1);
      t[8] > t[3 * A + A] && (A = 2);
      var F = (A + 1) % 3,
        G = (A + 2) % 3;
      x = Math.sqrt(t[3 * A + A] - t[3 * F + F] - t[3 * G + G] + 1);
      l[A] = 0.5 * x;
      x = 0.5 / x;
      l[3] = (t[3 * F + G] - t[3 * G + F]) * x;
      l[F] = (t[3 * F + A] + t[3 * A + F]) * x;
      l[G] = (t[3 * G + A] + t[3 * A + G]) * x;
    }
    return l;
  }
  function yb(l, t, x) {
    var A = 0.5 * x[0],
      F = 0.5 * x[1];
    x = 0.5 * x[2];
    var G = t[0],
      I = t[1],
      L = t[2];
    t = t[3];
    l[0] = G;
    l[1] = I;
    l[2] = L;
    l[3] = t;
    l[4] = A * t + F * L - x * I;
    l[5] = F * t + x * G - A * L;
    l[6] = x * t + A * I - F * G;
    l[7] = -A * G - F * I - x * L;
    return l;
  }
  function zb(l, t) {
    l[0] = t[0];
    l[1] = t[1];
    l[2] = t[2];
    l[3] = t[3];
    l[4] = t[4];
    l[5] = t[5];
    l[6] = t[6];
    l[7] = t[7];
    return l;
  }
  function eb(l, t, x) {
    var A = t[0],
      F = t[1],
      G = t[2],
      I = t[3],
      L = x[4],
      M = x[5],
      O = x[6],
      R = x[7],
      T = t[4],
      Y = t[5],
      X = t[6];
    t = t[7];
    var fa = x[0],
      ha = x[1],
      ba = x[2];
    x = x[3];
    l[0] = A * x + I * fa + F * ba - G * ha;
    l[1] = F * x + I * ha + G * fa - A * ba;
    l[2] = G * x + I * ba + A * ha - F * fa;
    l[3] = I * x - A * fa - F * ha - G * ba;
    l[4] = A * R + I * L + F * O - G * M + T * x + t * fa + Y * ba - X * ha;
    l[5] = F * R + I * M + G * L - A * O + Y * x + t * ha + X * fa - T * ba;
    l[6] = G * R + I * O + A * M - F * L + X * x + t * ba + T * ha - Y * fa;
    l[7] = I * R - A * L - F * M - G * O + t * x - T * fa - Y * ha - X * ba;
    return l;
  }
  function Wa() {
    var l = new sa(2);
    sa != Float32Array && ((l[0] = 0), (l[1] = 0));
    return l;
  }
  function fb(l, t, x) {
    l[0] = t[0] - x[0];
    l[1] = t[1] - x[1];
    return l;
  }
  function gb(l, t, x) {
    l[0] = t[0] * x[0];
    l[1] = t[1] * x[1];
    return l;
  }
  function Ya(l, t, x) {
    l[0] = t[0] / x[0];
    l[1] = t[1] / x[1];
    return l;
  }
  function hb(l, t) {
    return Math.hypot(t[0] - l[0], t[1] - l[1]);
  }
  function Ta(l, t) {
    var x = t[0] - l[0];
    l = t[1] - l[1];
    return x * x + l * l;
  }
  function ib(l) {
    return Math.hypot(l[0], l[1]);
  }
  function jb(l) {
    var t = l[0];
    l = l[1];
    return t * t + l * l;
  }
  var sa = "undefined" !== typeof Float32Array ? Float32Array : Array,
    Sa = Math.random,
    Ab = Math.PI / 180;
  Math.hypot ||
    (Math.hypot = function () {
      for (var l = 0, t = arguments.length; t--; )
        l += arguments[t] * arguments[t];
      return Math.sqrt(l);
    });
  var Db = Object.freeze({
      __proto__: null,
      EPSILON: 1e-6,
      get ARRAY_TYPE() {
        return sa;
      },
      RANDOM: Sa,
      ANGLE_ORDER: "zyx",
      setMatrixArrayType: function (l) {
        sa = l;
      },
      toRadian: function (l) {
        return l * Ab;
      },
      equals: function (l, t) {
        return Math.abs(l - t) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(t));
      },
    }),
    Eb = Object.freeze({
      __proto__: null,
      create: function () {
        var l = new sa(4);
        sa != Float32Array && ((l[1] = 0), (l[2] = 0));
        l[0] = 1;
        l[3] = 1;
        return l;
      },
      clone: function (l) {
        var t = new sa(4);
        t[0] = l[0];
        t[1] = l[1];
        t[2] = l[2];
        t[3] = l[3];
        return t;
      },
      copy: function (l, t) {
        l[0] = t[0];
        l[1] = t[1];
        l[2] = t[2];
        l[3] = t[3];
        return l;
      },
      identity: function (l) {
        l[0] = 1;
        l[1] = 0;
        l[2] = 0;
        l[3] = 1;
        return l;
      },
      fromValues: function (l, t, x, A) {
        var F = new sa(4);
        F[0] = l;
        F[1] = t;
        F[2] = x;
        F[3] = A;
        return F;
      },
      set: function (l, t, x, A, F) {
        l[0] = t;
        l[1] = x;
        l[2] = A;
        l[3] = F;
        return l;
      },
      transpose: function (l, t) {
        if (l === t) {
          var x = t[1];
          l[1] = t[2];
          l[2] = x;
        } else (l[0] = t[0]), (l[1] = t[2]), (l[2] = t[1]), (l[3] = t[3]);
        return l;
      },
      invert: function (l, t) {
        var x = t[0],
          A = t[1],
          F = t[2];
        t = t[3];
        var G = x * t - F * A;
        if (!G) return null;
        G = 1 / G;
        l[0] = t * G;
        l[1] = -A * G;
        l[2] = -F * G;
        l[3] = x * G;
        return l;
      },
      adjoint: function (l, t) {
        var x = t[0];
        l[0] = t[3];
        l[1] = -t[1];
        l[2] = -t[2];
        l[3] = x;
        return l;
      },
      determinant: function (l) {
        return l[0] * l[3] - l[2] * l[1];
      },
      multiply: b,
      rotate: function (l, t, x) {
        var A = t[0],
          F = t[1],
          G = t[2];
        t = t[3];
        var I = Math.sin(x);
        x = Math.cos(x);
        l[0] = A * x + G * I;
        l[1] = F * x + t * I;
        l[2] = A * -I + G * x;
        l[3] = F * -I + t * x;
        return l;
      },
      scale: function (l, t, x) {
        var A = t[1],
          F = t[2],
          G = t[3],
          I = x[0];
        x = x[1];
        l[0] = t[0] * I;
        l[1] = A * I;
        l[2] = F * x;
        l[3] = G * x;
        return l;
      },
      fromRotation: function (l, t) {
        var x = Math.sin(t);
        t = Math.cos(t);
        l[0] = t;
        l[1] = x;
        l[2] = -x;
        l[3] = t;
        return l;
      },
      fromScaling: function (l, t) {
        l[0] = t[0];
        l[1] = 0;
        l[2] = 0;
        l[3] = t[1];
        return l;
      },
      str: function (l) {
        return "mat2(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ")";
      },
      frob: function (l) {
        return Math.hypot(l[0], l[1], l[2], l[3]);
      },
      LDU: function (l, t, x, A) {
        l[2] = A[2] / A[0];
        x[0] = A[0];
        x[1] = A[1];
        x[3] = A[3] - l[2] * x[1];
        return [l, t, x];
      },
      add: function (l, t, x) {
        l[0] = t[0] + x[0];
        l[1] = t[1] + x[1];
        l[2] = t[2] + x[2];
        l[3] = t[3] + x[3];
        return l;
      },
      subtract: a,
      exactEquals: function (l, t) {
        return l[0] === t[0] && l[1] === t[1] && l[2] === t[2] && l[3] === t[3];
      },
      equals: function (l, t) {
        var x = l[0],
          A = l[1],
          F = l[2];
        l = l[3];
        var G = t[0],
          I = t[1],
          L = t[2];
        t = t[3];
        return (
          Math.abs(x - G) <= 1e-6 * Math.max(1, Math.abs(x), Math.abs(G)) &&
          Math.abs(A - I) <= 1e-6 * Math.max(1, Math.abs(A), Math.abs(I)) &&
          Math.abs(F - L) <= 1e-6 * Math.max(1, Math.abs(F), Math.abs(L)) &&
          Math.abs(l - t) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(t))
        );
      },
      multiplyScalar: function (l, t, x) {
        l[0] = t[0] * x;
        l[1] = t[1] * x;
        l[2] = t[2] * x;
        l[3] = t[3] * x;
        return l;
      },
      multiplyScalarAndAdd: function (l, t, x, A) {
        l[0] = t[0] + x[0] * A;
        l[1] = t[1] + x[1] * A;
        l[2] = t[2] + x[2] * A;
        l[3] = t[3] + x[3] * A;
        return l;
      },
      mul: b,
      sub: a,
    }),
    Fb = Object.freeze({
      __proto__: null,
      create: function () {
        var l = new sa(6);
        sa != Float32Array && ((l[1] = 0), (l[2] = 0), (l[4] = 0), (l[5] = 0));
        l[0] = 1;
        l[3] = 1;
        return l;
      },
      clone: function (l) {
        var t = new sa(6);
        t[0] = l[0];
        t[1] = l[1];
        t[2] = l[2];
        t[3] = l[3];
        t[4] = l[4];
        t[5] = l[5];
        return t;
      },
      copy: function (l, t) {
        l[0] = t[0];
        l[1] = t[1];
        l[2] = t[2];
        l[3] = t[3];
        l[4] = t[4];
        l[5] = t[5];
        return l;
      },
      identity: function (l) {
        l[0] = 1;
        l[1] = 0;
        l[2] = 0;
        l[3] = 1;
        l[4] = 0;
        l[5] = 0;
        return l;
      },
      fromValues: function (l, t, x, A, F, G) {
        var I = new sa(6);
        I[0] = l;
        I[1] = t;
        I[2] = x;
        I[3] = A;
        I[4] = F;
        I[5] = G;
        return I;
      },
      set: function (l, t, x, A, F, G, I) {
        l[0] = t;
        l[1] = x;
        l[2] = A;
        l[3] = F;
        l[4] = G;
        l[5] = I;
        return l;
      },
      invert: function (l, t) {
        var x = t[0],
          A = t[1],
          F = t[2],
          G = t[3],
          I = t[4];
        t = t[5];
        var L = x * G - A * F;
        if (!L) return null;
        L = 1 / L;
        l[0] = G * L;
        l[1] = -A * L;
        l[2] = -F * L;
        l[3] = x * L;
        l[4] = (F * t - G * I) * L;
        l[5] = (A * I - x * t) * L;
        return l;
      },
      determinant: function (l) {
        return l[0] * l[3] - l[1] * l[2];
      },
      multiply: c,
      rotate: function (l, t, x) {
        var A = t[0],
          F = t[1],
          G = t[2],
          I = t[3],
          L = t[4];
        t = t[5];
        var M = Math.sin(x);
        x = Math.cos(x);
        l[0] = A * x + G * M;
        l[1] = F * x + I * M;
        l[2] = A * -M + G * x;
        l[3] = F * -M + I * x;
        l[4] = L;
        l[5] = t;
        return l;
      },
      scale: function (l, t, x) {
        var A = t[1],
          F = t[2],
          G = t[3],
          I = t[4],
          L = t[5],
          M = x[0];
        x = x[1];
        l[0] = t[0] * M;
        l[1] = A * M;
        l[2] = F * x;
        l[3] = G * x;
        l[4] = I;
        l[5] = L;
        return l;
      },
      translate: function (l, t, x) {
        var A = t[0],
          F = t[1],
          G = t[2],
          I = t[3],
          L = t[4];
        t = t[5];
        var M = x[0];
        x = x[1];
        l[0] = A;
        l[1] = F;
        l[2] = G;
        l[3] = I;
        l[4] = A * M + G * x + L;
        l[5] = F * M + I * x + t;
        return l;
      },
      fromRotation: function (l, t) {
        var x = Math.sin(t);
        t = Math.cos(t);
        l[0] = t;
        l[1] = x;
        l[2] = -x;
        l[3] = t;
        l[4] = 0;
        l[5] = 0;
        return l;
      },
      fromScaling: function (l, t) {
        l[0] = t[0];
        l[1] = 0;
        l[2] = 0;
        l[3] = t[1];
        l[4] = 0;
        l[5] = 0;
        return l;
      },
      fromTranslation: function (l, t) {
        l[0] = 1;
        l[1] = 0;
        l[2] = 0;
        l[3] = 1;
        l[4] = t[0];
        l[5] = t[1];
        return l;
      },
      str: function (l) {
        return (
          "mat2d(" +
          l[0] +
          ", " +
          l[1] +
          ", " +
          l[2] +
          ", " +
          l[3] +
          ", " +
          l[4] +
          ", " +
          l[5] +
          ")"
        );
      },
      frob: function (l) {
        return Math.hypot(l[0], l[1], l[2], l[3], l[4], l[5], 1);
      },
      add: function (l, t, x) {
        l[0] = t[0] + x[0];
        l[1] = t[1] + x[1];
        l[2] = t[2] + x[2];
        l[3] = t[3] + x[3];
        l[4] = t[4] + x[4];
        l[5] = t[5] + x[5];
        return l;
      },
      subtract: d,
      multiplyScalar: function (l, t, x) {
        l[0] = t[0] * x;
        l[1] = t[1] * x;
        l[2] = t[2] * x;
        l[3] = t[3] * x;
        l[4] = t[4] * x;
        l[5] = t[5] * x;
        return l;
      },
      multiplyScalarAndAdd: function (l, t, x, A) {
        l[0] = t[0] + x[0] * A;
        l[1] = t[1] + x[1] * A;
        l[2] = t[2] + x[2] * A;
        l[3] = t[3] + x[3] * A;
        l[4] = t[4] + x[4] * A;
        l[5] = t[5] + x[5] * A;
        return l;
      },
      exactEquals: function (l, t) {
        return (
          l[0] === t[0] &&
          l[1] === t[1] &&
          l[2] === t[2] &&
          l[3] === t[3] &&
          l[4] === t[4] &&
          l[5] === t[5]
        );
      },
      equals: function (l, t) {
        var x = l[0],
          A = l[1],
          F = l[2],
          G = l[3],
          I = l[4];
        l = l[5];
        var L = t[0],
          M = t[1],
          O = t[2],
          R = t[3],
          T = t[4];
        t = t[5];
        return (
          Math.abs(x - L) <= 1e-6 * Math.max(1, Math.abs(x), Math.abs(L)) &&
          Math.abs(A - M) <= 1e-6 * Math.max(1, Math.abs(A), Math.abs(M)) &&
          Math.abs(F - O) <= 1e-6 * Math.max(1, Math.abs(F), Math.abs(O)) &&
          Math.abs(G - R) <= 1e-6 * Math.max(1, Math.abs(G), Math.abs(R)) &&
          Math.abs(I - T) <= 1e-6 * Math.max(1, Math.abs(I), Math.abs(T)) &&
          Math.abs(l - t) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(t))
        );
      },
      mul: c,
      sub: d,
    }),
    Gb = Object.freeze({
      __proto__: null,
      create: f,
      fromMat4: function (l, t) {
        l[0] = t[0];
        l[1] = t[1];
        l[2] = t[2];
        l[3] = t[4];
        l[4] = t[5];
        l[5] = t[6];
        l[6] = t[8];
        l[7] = t[9];
        l[8] = t[10];
        return l;
      },
      clone: function (l) {
        var t = new sa(9);
        t[0] = l[0];
        t[1] = l[1];
        t[2] = l[2];
        t[3] = l[3];
        t[4] = l[4];
        t[5] = l[5];
        t[6] = l[6];
        t[7] = l[7];
        t[8] = l[8];
        return t;
      },
      copy: function (l, t) {
        l[0] = t[0];
        l[1] = t[1];
        l[2] = t[2];
        l[3] = t[3];
        l[4] = t[4];
        l[5] = t[5];
        l[6] = t[6];
        l[7] = t[7];
        l[8] = t[8];
        return l;
      },
      fromValues: function (l, t, x, A, F, G, I, L, M) {
        var O = new sa(9);
        O[0] = l;
        O[1] = t;
        O[2] = x;
        O[3] = A;
        O[4] = F;
        O[5] = G;
        O[6] = I;
        O[7] = L;
        O[8] = M;
        return O;
      },
      set: function (l, t, x, A, F, G, I, L, M, O) {
        l[0] = t;
        l[1] = x;
        l[2] = A;
        l[3] = F;
        l[4] = G;
        l[5] = I;
        l[6] = L;
        l[7] = M;
        l[8] = O;
        return l;
      },
      identity: function (l) {
        l[0] = 1;
        l[1] = 0;
        l[2] = 0;
        l[3] = 0;
        l[4] = 1;
        l[5] = 0;
        l[6] = 0;
        l[7] = 0;
        l[8] = 1;
        return l;
      },
      transpose: function (l, t) {
        if (l === t) {
          var x = t[1],
            A = t[2],
            F = t[5];
          l[1] = t[3];
          l[2] = t[6];
          l[3] = x;
          l[5] = t[7];
          l[6] = A;
          l[7] = F;
        } else
          (l[0] = t[0]),
            (l[1] = t[3]),
            (l[2] = t[6]),
            (l[3] = t[1]),
            (l[4] = t[4]),
            (l[5] = t[7]),
            (l[6] = t[2]),
            (l[7] = t[5]),
            (l[8] = t[8]);
        return l;
      },
      invert: function (l, t) {
        var x = t[0],
          A = t[1],
          F = t[2],
          G = t[3],
          I = t[4],
          L = t[5],
          M = t[6],
          O = t[7];
        t = t[8];
        var R = t * I - L * O,
          T = -t * G + L * M,
          Y = O * G - I * M,
          X = x * R + A * T + F * Y;
        if (!X) return null;
        X = 1 / X;
        l[0] = R * X;
        l[1] = (-t * A + F * O) * X;
        l[2] = (L * A - F * I) * X;
        l[3] = T * X;
        l[4] = (t * x - F * M) * X;
        l[5] = (-L * x + F * G) * X;
        l[6] = Y * X;
        l[7] = (-O * x + A * M) * X;
        l[8] = (I * x - A * G) * X;
        return l;
      },
      adjoint: function (l, t) {
        var x = t[0],
          A = t[1],
          F = t[2],
          G = t[3],
          I = t[4],
          L = t[5],
          M = t[6],
          O = t[7];
        t = t[8];
        l[0] = I * t - L * O;
        l[1] = F * O - A * t;
        l[2] = A * L - F * I;
        l[3] = L * M - G * t;
        l[4] = x * t - F * M;
        l[5] = F * G - x * L;
        l[6] = G * O - I * M;
        l[7] = A * M - x * O;
        l[8] = x * I - A * G;
        return l;
      },
      determinant: function (l) {
        var t = l[3],
          x = l[4],
          A = l[5],
          F = l[6],
          G = l[7],
          I = l[8];
        return (
          l[0] * (I * x - A * G) +
          l[1] * (-I * t + A * F) +
          l[2] * (G * t - x * F)
        );
      },
      multiply: h,
      translate: function (l, t, x) {
        var A = t[0],
          F = t[1],
          G = t[2],
          I = t[3],
          L = t[4],
          M = t[5],
          O = t[6],
          R = t[7];
        t = t[8];
        var T = x[0];
        x = x[1];
        l[0] = A;
        l[1] = F;
        l[2] = G;
        l[3] = I;
        l[4] = L;
        l[5] = M;
        l[6] = T * A + x * I + O;
        l[7] = T * F + x * L + R;
        l[8] = T * G + x * M + t;
        return l;
      },
      rotate: function (l, t, x) {
        var A = t[0],
          F = t[1],
          G = t[2],
          I = t[3],
          L = t[4],
          M = t[5],
          O = t[6],
          R = t[7];
        t = t[8];
        var T = Math.sin(x);
        x = Math.cos(x);
        l[0] = x * A + T * I;
        l[1] = x * F + T * L;
        l[2] = x * G + T * M;
        l[3] = x * I - T * A;
        l[4] = x * L - T * F;
        l[5] = x * M - T * G;
        l[6] = O;
        l[7] = R;
        l[8] = t;
        return l;
      },
      scale: function (l, t, x) {
        var A = x[0];
        x = x[1];
        l[0] = A * t[0];
        l[1] = A * t[1];
        l[2] = A * t[2];
        l[3] = x * t[3];
        l[4] = x * t[4];
        l[5] = x * t[5];
        l[6] = t[6];
        l[7] = t[7];
        l[8] = t[8];
        return l;
      },
      fromTranslation: function (l, t) {
        l[0] = 1;
        l[1] = 0;
        l[2] = 0;
        l[3] = 0;
        l[4] = 1;
        l[5] = 0;
        l[6] = t[0];
        l[7] = t[1];
        l[8] = 1;
        return l;
      },
      fromRotation: function (l, t) {
        var x = Math.sin(t);
        t = Math.cos(t);
        l[0] = t;
        l[1] = x;
        l[2] = 0;
        l[3] = -x;
        l[4] = t;
        l[5] = 0;
        l[6] = 0;
        l[7] = 0;
        l[8] = 1;
        return l;
      },
      fromScaling: function (l, t) {
        l[0] = t[0];
        l[1] = 0;
        l[2] = 0;
        l[3] = 0;
        l[4] = t[1];
        l[5] = 0;
        l[6] = 0;
        l[7] = 0;
        l[8] = 1;
        return l;
      },
      fromMat2d: function (l, t) {
        l[0] = t[0];
        l[1] = t[1];
        l[2] = 0;
        l[3] = t[2];
        l[4] = t[3];
        l[5] = 0;
        l[6] = t[4];
        l[7] = t[5];
        l[8] = 1;
        return l;
      },
      fromQuat: function (l, t) {
        var x = t[0],
          A = t[1],
          F = t[2];
        t = t[3];
        var G = x + x,
          I = A + A,
          L = F + F;
        x *= G;
        var M = A * G;
        A *= I;
        var O = F * G,
          R = F * I;
        F *= L;
        G *= t;
        I *= t;
        t *= L;
        l[0] = 1 - A - F;
        l[3] = M - t;
        l[6] = O + I;
        l[1] = M + t;
        l[4] = 1 - x - F;
        l[7] = R - G;
        l[2] = O - I;
        l[5] = R + G;
        l[8] = 1 - x - A;
        return l;
      },
      normalFromMat4: function (l, t) {
        var x = t[0],
          A = t[1],
          F = t[2],
          G = t[3],
          I = t[4],
          L = t[5],
          M = t[6],
          O = t[7],
          R = t[8],
          T = t[9],
          Y = t[10],
          X = t[11],
          fa = t[12],
          ha = t[13],
          ba = t[14];
        t = t[15];
        var qa = x * L - A * I,
          ka = x * M - F * I,
          ta = x * O - G * I,
          ua = A * M - F * L,
          ra = A * O - G * L,
          za = F * O - G * M,
          Aa = R * ha - T * fa,
          Ba = R * ba - Y * fa;
        R = R * t - X * fa;
        var Ca = T * ba - Y * ha;
        T = T * t - X * ha;
        Y = Y * t - X * ba;
        X = qa * Y - ka * T + ta * Ca + ua * R - ra * Ba + za * Aa;
        if (!X) return null;
        X = 1 / X;
        l[0] = (L * Y - M * T + O * Ca) * X;
        l[1] = (M * R - I * Y - O * Ba) * X;
        l[2] = (I * T - L * R + O * Aa) * X;
        l[3] = (F * T - A * Y - G * Ca) * X;
        l[4] = (x * Y - F * R + G * Ba) * X;
        l[5] = (A * R - x * T - G * Aa) * X;
        l[6] = (ha * za - ba * ra + t * ua) * X;
        l[7] = (ba * ta - fa * za - t * ka) * X;
        l[8] = (fa * ra - ha * ta + t * qa) * X;
        return l;
      },
      projection: function (l, t, x) {
        l[0] = 2 / t;
        l[1] = 0;
        l[2] = 0;
        l[3] = 0;
        l[4] = -2 / x;
        l[5] = 0;
        l[6] = -1;
        l[7] = 1;
        l[8] = 1;
        return l;
      },
      str: function (l) {
        return (
          "mat3(" +
          l[0] +
          ", " +
          l[1] +
          ", " +
          l[2] +
          ", " +
          l[3] +
          ", " +
          l[4] +
          ", " +
          l[5] +
          ", " +
          l[6] +
          ", " +
          l[7] +
          ", " +
          l[8] +
          ")"
        );
      },
      frob: function (l) {
        return Math.hypot(l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8]);
      },
      add: function (l, t, x) {
        l[0] = t[0] + x[0];
        l[1] = t[1] + x[1];
        l[2] = t[2] + x[2];
        l[3] = t[3] + x[3];
        l[4] = t[4] + x[4];
        l[5] = t[5] + x[5];
        l[6] = t[6] + x[6];
        l[7] = t[7] + x[7];
        l[8] = t[8] + x[8];
        return l;
      },
      subtract: g,
      multiplyScalar: function (l, t, x) {
        l[0] = t[0] * x;
        l[1] = t[1] * x;
        l[2] = t[2] * x;
        l[3] = t[3] * x;
        l[4] = t[4] * x;
        l[5] = t[5] * x;
        l[6] = t[6] * x;
        l[7] = t[7] * x;
        l[8] = t[8] * x;
        return l;
      },
      multiplyScalarAndAdd: function (l, t, x, A) {
        l[0] = t[0] + x[0] * A;
        l[1] = t[1] + x[1] * A;
        l[2] = t[2] + x[2] * A;
        l[3] = t[3] + x[3] * A;
        l[4] = t[4] + x[4] * A;
        l[5] = t[5] + x[5] * A;
        l[6] = t[6] + x[6] * A;
        l[7] = t[7] + x[7] * A;
        l[8] = t[8] + x[8] * A;
        return l;
      },
      exactEquals: function (l, t) {
        return (
          l[0] === t[0] &&
          l[1] === t[1] &&
          l[2] === t[2] &&
          l[3] === t[3] &&
          l[4] === t[4] &&
          l[5] === t[5] &&
          l[6] === t[6] &&
          l[7] === t[7] &&
          l[8] === t[8]
        );
      },
      equals: function (l, t) {
        var x = l[0],
          A = l[1],
          F = l[2],
          G = l[3],
          I = l[4],
          L = l[5],
          M = l[6],
          O = l[7];
        l = l[8];
        var R = t[0],
          T = t[1],
          Y = t[2],
          X = t[3],
          fa = t[4],
          ha = t[5],
          ba = t[6],
          qa = t[7];
        t = t[8];
        return (
          Math.abs(x - R) <= 1e-6 * Math.max(1, Math.abs(x), Math.abs(R)) &&
          Math.abs(A - T) <= 1e-6 * Math.max(1, Math.abs(A), Math.abs(T)) &&
          Math.abs(F - Y) <= 1e-6 * Math.max(1, Math.abs(F), Math.abs(Y)) &&
          Math.abs(G - X) <= 1e-6 * Math.max(1, Math.abs(G), Math.abs(X)) &&
          Math.abs(I - fa) <= 1e-6 * Math.max(1, Math.abs(I), Math.abs(fa)) &&
          Math.abs(L - ha) <= 1e-6 * Math.max(1, Math.abs(L), Math.abs(ha)) &&
          Math.abs(M - ba) <= 1e-6 * Math.max(1, Math.abs(M), Math.abs(ba)) &&
          Math.abs(O - qa) <= 1e-6 * Math.max(1, Math.abs(O), Math.abs(qa)) &&
          Math.abs(l - t) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(t))
        );
      },
      mul: h,
      sub: g,
    }),
    Hb = Object.freeze({
      __proto__: null,
      create: function () {
        var l = new sa(16);
        sa != Float32Array &&
          ((l[1] = 0),
          (l[2] = 0),
          (l[3] = 0),
          (l[4] = 0),
          (l[6] = 0),
          (l[7] = 0),
          (l[8] = 0),
          (l[9] = 0),
          (l[11] = 0),
          (l[12] = 0),
          (l[13] = 0),
          (l[14] = 0));
        l[0] = 1;
        l[5] = 1;
        l[10] = 1;
        l[15] = 1;
        return l;
      },
      clone: function (l) {
        var t = new sa(16);
        t[0] = l[0];
        t[1] = l[1];
        t[2] = l[2];
        t[3] = l[3];
        t[4] = l[4];
        t[5] = l[5];
        t[6] = l[6];
        t[7] = l[7];
        t[8] = l[8];
        t[9] = l[9];
        t[10] = l[10];
        t[11] = l[11];
        t[12] = l[12];
        t[13] = l[13];
        t[14] = l[14];
        t[15] = l[15];
        return t;
      },
      copy: function (l, t) {
        l[0] = t[0];
        l[1] = t[1];
        l[2] = t[2];
        l[3] = t[3];
        l[4] = t[4];
        l[5] = t[5];
        l[6] = t[6];
        l[7] = t[7];
        l[8] = t[8];
        l[9] = t[9];
        l[10] = t[10];
        l[11] = t[11];
        l[12] = t[12];
        l[13] = t[13];
        l[14] = t[14];
        l[15] = t[15];
        return l;
      },
      fromValues: function (l, t, x, A, F, G, I, L, M, O, R, T, Y, X, fa, ha) {
        var ba = new sa(16);
        ba[0] = l;
        ba[1] = t;
        ba[2] = x;
        ba[3] = A;
        ba[4] = F;
        ba[5] = G;
        ba[6] = I;
        ba[7] = L;
        ba[8] = M;
        ba[9] = O;
        ba[10] = R;
        ba[11] = T;
        ba[12] = Y;
        ba[13] = X;
        ba[14] = fa;
        ba[15] = ha;
        return ba;
      },
      set: function (l, t, x, A, F, G, I, L, M, O, R, T, Y, X, fa, ha, ba) {
        l[0] = t;
        l[1] = x;
        l[2] = A;
        l[3] = F;
        l[4] = G;
        l[5] = I;
        l[6] = L;
        l[7] = M;
        l[8] = O;
        l[9] = R;
        l[10] = T;
        l[11] = Y;
        l[12] = X;
        l[13] = fa;
        l[14] = ha;
        l[15] = ba;
        return l;
      },
      identity: k,
      transpose: function (l, t) {
        if (l === t) {
          var x = t[1],
            A = t[2],
            F = t[3],
            G = t[6],
            I = t[7],
            L = t[11];
          l[1] = t[4];
          l[2] = t[8];
          l[3] = t[12];
          l[4] = x;
          l[6] = t[9];
          l[7] = t[13];
          l[8] = A;
          l[9] = G;
          l[11] = t[14];
          l[12] = F;
          l[13] = I;
          l[14] = L;
        } else
          (l[0] = t[0]),
            (l[1] = t[4]),
            (l[2] = t[8]),
            (l[3] = t[12]),
            (l[4] = t[1]),
            (l[5] = t[5]),
            (l[6] = t[9]),
            (l[7] = t[13]),
            (l[8] = t[2]),
            (l[9] = t[6]),
            (l[10] = t[10]),
            (l[11] = t[14]),
            (l[12] = t[3]),
            (l[13] = t[7]),
            (l[14] = t[11]),
            (l[15] = t[15]);
        return l;
      },
      invert: function (l, t) {
        var x = t[0],
          A = t[1],
          F = t[2],
          G = t[3],
          I = t[4],
          L = t[5],
          M = t[6],
          O = t[7],
          R = t[8],
          T = t[9],
          Y = t[10],
          X = t[11],
          fa = t[12],
          ha = t[13],
          ba = t[14];
        t = t[15];
        var qa = x * L - A * I,
          ka = x * M - F * I,
          ta = x * O - G * I,
          ua = A * M - F * L,
          ra = A * O - G * L,
          za = F * O - G * M,
          Aa = R * ha - T * fa,
          Ba = R * ba - Y * fa,
          Ca = R * t - X * fa,
          Ja = T * ba - Y * ha,
          Pa = T * t - X * ha,
          Qa = Y * t - X * ba,
          Da = qa * Qa - ka * Pa + ta * Ja + ua * Ca - ra * Ba + za * Aa;
        if (!Da) return null;
        Da = 1 / Da;
        l[0] = (L * Qa - M * Pa + O * Ja) * Da;
        l[1] = (F * Pa - A * Qa - G * Ja) * Da;
        l[2] = (ha * za - ba * ra + t * ua) * Da;
        l[3] = (Y * ra - T * za - X * ua) * Da;
        l[4] = (M * Ca - I * Qa - O * Ba) * Da;
        l[5] = (x * Qa - F * Ca + G * Ba) * Da;
        l[6] = (ba * ta - fa * za - t * ka) * Da;
        l[7] = (R * za - Y * ta + X * ka) * Da;
        l[8] = (I * Pa - L * Ca + O * Aa) * Da;
        l[9] = (A * Ca - x * Pa - G * Aa) * Da;
        l[10] = (fa * ra - ha * ta + t * qa) * Da;
        l[11] = (T * ta - R * ra - X * qa) * Da;
        l[12] = (L * Ba - I * Ja - M * Aa) * Da;
        l[13] = (x * Ja - A * Ba + F * Aa) * Da;
        l[14] = (ha * ka - fa * ua - ba * qa) * Da;
        l[15] = (R * ua - T * ka + Y * qa) * Da;
        return l;
      },
      adjoint: function (l, t) {
        var x = t[0],
          A = t[1],
          F = t[2],
          G = t[3],
          I = t[4],
          L = t[5],
          M = t[6],
          O = t[7],
          R = t[8],
          T = t[9],
          Y = t[10],
          X = t[11],
          fa = t[12],
          ha = t[13],
          ba = t[14];
        t = t[15];
        var qa = x * L - A * I,
          ka = x * M - F * I,
          ta = x * O - G * I,
          ua = A * M - F * L,
          ra = A * O - G * L,
          za = F * O - G * M,
          Aa = R * ha - T * fa,
          Ba = R * ba - Y * fa,
          Ca = R * t - X * fa,
          Ja = T * ba - Y * ha,
          Pa = T * t - X * ha,
          Qa = Y * t - X * ba;
        l[0] = L * Qa - M * Pa + O * Ja;
        l[1] = F * Pa - A * Qa - G * Ja;
        l[2] = ha * za - ba * ra + t * ua;
        l[3] = Y * ra - T * za - X * ua;
        l[4] = M * Ca - I * Qa - O * Ba;
        l[5] = x * Qa - F * Ca + G * Ba;
        l[6] = ba * ta - fa * za - t * ka;
        l[7] = R * za - Y * ta + X * ka;
        l[8] = I * Pa - L * Ca + O * Aa;
        l[9] = A * Ca - x * Pa - G * Aa;
        l[10] = fa * ra - ha * ta + t * qa;
        l[11] = T * ta - R * ra - X * qa;
        l[12] = L * Ba - I * Ja - M * Aa;
        l[13] = x * Ja - A * Ba + F * Aa;
        l[14] = ha * ka - fa * ua - ba * qa;
        l[15] = R * ua - T * ka + Y * qa;
        return l;
      },
      determinant: function (l) {
        var t = l[0],
          x = l[1],
          A = l[2],
          F = l[4],
          G = l[5],
          I = l[6],
          L = l[8],
          M = l[9],
          O = l[10],
          R = l[12],
          T = l[13],
          Y = l[14],
          X = t * G - x * F,
          fa = t * I - A * F,
          ha = x * I - A * G,
          ba = L * T - M * R,
          qa = L * Y - O * R,
          ka = M * Y - O * T;
        return (
          l[7] * (t * ka - x * qa + A * ba) -
          l[3] * (F * ka - G * qa + I * ba) +
          l[15] * (L * ha - M * fa + O * X) -
          l[11] * (R * ha - T * fa + Y * X)
        );
      },
      multiply: m,
      translate: function (l, t, x) {
        var A = x[0],
          F = x[1];
        x = x[2];
        if (t === l)
          (l[12] = t[0] * A + t[4] * F + t[8] * x + t[12]),
            (l[13] = t[1] * A + t[5] * F + t[9] * x + t[13]),
            (l[14] = t[2] * A + t[6] * F + t[10] * x + t[14]),
            (l[15] = t[3] * A + t[7] * F + t[11] * x + t[15]);
        else {
          var G = t[0];
          var I = t[1];
          var L = t[2];
          var M = t[3];
          var O = t[4];
          var R = t[5];
          var T = t[6];
          var Y = t[7];
          var X = t[8];
          var fa = t[9];
          var ha = t[10];
          var ba = t[11];
          l[0] = G;
          l[1] = I;
          l[2] = L;
          l[3] = M;
          l[4] = O;
          l[5] = R;
          l[6] = T;
          l[7] = Y;
          l[8] = X;
          l[9] = fa;
          l[10] = ha;
          l[11] = ba;
          l[12] = G * A + O * F + X * x + t[12];
          l[13] = I * A + R * F + fa * x + t[13];
          l[14] = L * A + T * F + ha * x + t[14];
          l[15] = M * A + Y * F + ba * x + t[15];
        }
        return l;
      },
      scale: function (l, t, x) {
        var A = x[0],
          F = x[1];
        x = x[2];
        l[0] = t[0] * A;
        l[1] = t[1] * A;
        l[2] = t[2] * A;
        l[3] = t[3] * A;
        l[4] = t[4] * F;
        l[5] = t[5] * F;
        l[6] = t[6] * F;
        l[7] = t[7] * F;
        l[8] = t[8] * x;
        l[9] = t[9] * x;
        l[10] = t[10] * x;
        l[11] = t[11] * x;
        l[12] = t[12];
        l[13] = t[13];
        l[14] = t[14];
        l[15] = t[15];
        return l;
      },
      rotate: function (l, t, x, A) {
        var F = A[0],
          G = A[1];
        A = A[2];
        var I = Math.hypot(F, G, A);
        if (1e-6 > I) return null;
        I = 1 / I;
        F *= I;
        G *= I;
        A *= I;
        var L = Math.sin(x);
        var M = Math.cos(x);
        var O = 1 - M;
        x = t[0];
        I = t[1];
        var R = t[2];
        var T = t[3];
        var Y = t[4];
        var X = t[5];
        var fa = t[6];
        var ha = t[7];
        var ba = t[8];
        var qa = t[9];
        var ka = t[10];
        var ta = t[11];
        var ua = F * F * O + M;
        var ra = G * F * O + A * L;
        var za = A * F * O - G * L;
        var Aa = F * G * O - A * L;
        var Ba = G * G * O + M;
        var Ca = A * G * O + F * L;
        var Ja = F * A * O + G * L;
        F = G * A * O - F * L;
        G = A * A * O + M;
        l[0] = x * ua + Y * ra + ba * za;
        l[1] = I * ua + X * ra + qa * za;
        l[2] = R * ua + fa * ra + ka * za;
        l[3] = T * ua + ha * ra + ta * za;
        l[4] = x * Aa + Y * Ba + ba * Ca;
        l[5] = I * Aa + X * Ba + qa * Ca;
        l[6] = R * Aa + fa * Ba + ka * Ca;
        l[7] = T * Aa + ha * Ba + ta * Ca;
        l[8] = x * Ja + Y * F + ba * G;
        l[9] = I * Ja + X * F + qa * G;
        l[10] = R * Ja + fa * F + ka * G;
        l[11] = T * Ja + ha * F + ta * G;
        t !== l &&
          ((l[12] = t[12]), (l[13] = t[13]), (l[14] = t[14]), (l[15] = t[15]));
        return l;
      },
      rotateX: function (l, t, x) {
        var A = Math.sin(x);
        x = Math.cos(x);
        var F = t[4],
          G = t[5],
          I = t[6],
          L = t[7],
          M = t[8],
          O = t[9],
          R = t[10],
          T = t[11];
        t !== l &&
          ((l[0] = t[0]),
          (l[1] = t[1]),
          (l[2] = t[2]),
          (l[3] = t[3]),
          (l[12] = t[12]),
          (l[13] = t[13]),
          (l[14] = t[14]),
          (l[15] = t[15]));
        l[4] = F * x + M * A;
        l[5] = G * x + O * A;
        l[6] = I * x + R * A;
        l[7] = L * x + T * A;
        l[8] = M * x - F * A;
        l[9] = O * x - G * A;
        l[10] = R * x - I * A;
        l[11] = T * x - L * A;
        return l;
      },
      rotateY: function (l, t, x) {
        var A = Math.sin(x);
        x = Math.cos(x);
        var F = t[0],
          G = t[1],
          I = t[2],
          L = t[3],
          M = t[8],
          O = t[9],
          R = t[10],
          T = t[11];
        t !== l &&
          ((l[4] = t[4]),
          (l[5] = t[5]),
          (l[6] = t[6]),
          (l[7] = t[7]),
          (l[12] = t[12]),
          (l[13] = t[13]),
          (l[14] = t[14]),
          (l[15] = t[15]));
        l[0] = F * x - M * A;
        l[1] = G * x - O * A;
        l[2] = I * x - R * A;
        l[3] = L * x - T * A;
        l[8] = F * A + M * x;
        l[9] = G * A + O * x;
        l[10] = I * A + R * x;
        l[11] = L * A + T * x;
        return l;
      },
      rotateZ: function (l, t, x) {
        var A = Math.sin(x);
        x = Math.cos(x);
        var F = t[0],
          G = t[1],
          I = t[2],
          L = t[3],
          M = t[4],
          O = t[5],
          R = t[6],
          T = t[7];
        t !== l &&
          ((l[8] = t[8]),
          (l[9] = t[9]),
          (l[10] = t[10]),
          (l[11] = t[11]),
          (l[12] = t[12]),
          (l[13] = t[13]),
          (l[14] = t[14]),
          (l[15] = t[15]));
        l[0] = F * x + M * A;
        l[1] = G * x + O * A;
        l[2] = I * x + R * A;
        l[3] = L * x + T * A;
        l[4] = M * x - F * A;
        l[5] = O * x - G * A;
        l[6] = R * x - I * A;
        l[7] = T * x - L * A;
        return l;
      },
      fromTranslation: function (l, t) {
        l[0] = 1;
        l[1] = 0;
        l[2] = 0;
        l[3] = 0;
        l[4] = 0;
        l[5] = 1;
        l[6] = 0;
        l[7] = 0;
        l[8] = 0;
        l[9] = 0;
        l[10] = 1;
        l[11] = 0;
        l[12] = t[0];
        l[13] = t[1];
        l[14] = t[2];
        l[15] = 1;
        return l;
      },
      fromScaling: function (l, t) {
        l[0] = t[0];
        l[1] = 0;
        l[2] = 0;
        l[3] = 0;
        l[4] = 0;
        l[5] = t[1];
        l[6] = 0;
        l[7] = 0;
        l[8] = 0;
        l[9] = 0;
        l[10] = t[2];
        l[11] = 0;
        l[12] = 0;
        l[13] = 0;
        l[14] = 0;
        l[15] = 1;
        return l;
      },
      fromRotation: function (l, t, x) {
        var A = x[0],
          F = x[1];
        x = x[2];
        var G = Math.hypot(A, F, x);
        if (1e-6 > G) return null;
        G = 1 / G;
        A *= G;
        F *= G;
        x *= G;
        G = Math.sin(t);
        t = Math.cos(t);
        var I = 1 - t;
        l[0] = A * A * I + t;
        l[1] = F * A * I + x * G;
        l[2] = x * A * I - F * G;
        l[3] = 0;
        l[4] = A * F * I - x * G;
        l[5] = F * F * I + t;
        l[6] = x * F * I + A * G;
        l[7] = 0;
        l[8] = A * x * I + F * G;
        l[9] = F * x * I - A * G;
        l[10] = x * x * I + t;
        l[11] = 0;
        l[12] = 0;
        l[13] = 0;
        l[14] = 0;
        l[15] = 1;
        return l;
      },
      fromXRotation: function (l, t) {
        var x = Math.sin(t);
        t = Math.cos(t);
        l[0] = 1;
        l[1] = 0;
        l[2] = 0;
        l[3] = 0;
        l[4] = 0;
        l[5] = t;
        l[6] = x;
        l[7] = 0;
        l[8] = 0;
        l[9] = -x;
        l[10] = t;
        l[11] = 0;
        l[12] = 0;
        l[13] = 0;
        l[14] = 0;
        l[15] = 1;
        return l;
      },
      fromYRotation: function (l, t) {
        var x = Math.sin(t);
        t = Math.cos(t);
        l[0] = t;
        l[1] = 0;
        l[2] = -x;
        l[3] = 0;
        l[4] = 0;
        l[5] = 1;
        l[6] = 0;
        l[7] = 0;
        l[8] = x;
        l[9] = 0;
        l[10] = t;
        l[11] = 0;
        l[12] = 0;
        l[13] = 0;
        l[14] = 0;
        l[15] = 1;
        return l;
      },
      fromZRotation: function (l, t) {
        var x = Math.sin(t);
        t = Math.cos(t);
        l[0] = t;
        l[1] = x;
        l[2] = 0;
        l[3] = 0;
        l[4] = -x;
        l[5] = t;
        l[6] = 0;
        l[7] = 0;
        l[8] = 0;
        l[9] = 0;
        l[10] = 1;
        l[11] = 0;
        l[12] = 0;
        l[13] = 0;
        l[14] = 0;
        l[15] = 1;
        return l;
      },
      fromRotationTranslation: q,
      fromQuat2: function (l, t) {
        var x = new sa(3),
          A = -t[0],
          F = -t[1],
          G = -t[2],
          I = t[3],
          L = t[4],
          M = t[5],
          O = t[6],
          R = t[7],
          T = A * A + F * F + G * G + I * I;
        0 < T
          ? ((x[0] = (2 * (L * I + R * A + M * G - O * F)) / T),
            (x[1] = (2 * (M * I + R * F + O * A - L * G)) / T),
            (x[2] = (2 * (O * I + R * G + L * F - M * A)) / T))
          : ((x[0] = 2 * (L * I + R * A + M * G - O * F)),
            (x[1] = 2 * (M * I + R * F + O * A - L * G)),
            (x[2] = 2 * (O * I + R * G + L * F - M * A)));
        q(l, t, x);
        return l;
      },
      getTranslation: v,
      getScaling: r,
      getRotation: n,
      decompose: function (l, t, x, A) {
        t[0] = A[12];
        t[1] = A[13];
        t[2] = A[14];
        var F = A[0],
          G = A[1],
          I = A[2],
          L = A[4],
          M = A[5],
          O = A[6],
          R = A[8];
        t = A[9];
        A = A[10];
        x[0] = Math.hypot(F, G, I);
        x[1] = Math.hypot(L, M, O);
        x[2] = Math.hypot(R, t, A);
        var T = 1 / x[0],
          Y = 1 / x[1],
          X = 1 / x[2];
        x = F * T;
        G *= Y;
        I *= X;
        L *= T;
        M *= Y;
        O *= X;
        R *= T;
        t *= Y;
        A *= X;
        Y = x + M + A;
        0 < Y
          ? ((A = 2 * Math.sqrt(Y + 1)),
            (l[3] = 0.25 * A),
            (l[0] = (O - t) / A),
            (l[1] = (R - I) / A),
            (l[2] = (G - L) / A))
          : x > M && x > A
          ? ((A = 2 * Math.sqrt(1 + x - M - A)),
            (l[3] = (O - t) / A),
            (l[0] = 0.25 * A),
            (l[1] = (G + L) / A),
            (l[2] = (R + I) / A))
          : M > A
          ? ((A = 2 * Math.sqrt(1 + M - x - A)),
            (l[3] = (R - I) / A),
            (l[0] = (G + L) / A),
            (l[1] = 0.25 * A),
            (l[2] = (O + t) / A))
          : ((A = 2 * Math.sqrt(1 + A - x - M)),
            (l[3] = (G - L) / A),
            (l[0] = (R + I) / A),
            (l[1] = (O + t) / A),
            (l[2] = 0.25 * A));
        return l;
      },
      fromRotationTranslationScale: function (l, t, x, A) {
        var F = t[0],
          G = t[1],
          I = t[2],
          L = t[3],
          M = F + F,
          O = G + G,
          R = I + I;
        t = F * M;
        var T = F * O;
        F *= R;
        var Y = G * O;
        G *= R;
        I *= R;
        M *= L;
        O *= L;
        L *= R;
        R = A[0];
        var X = A[1];
        A = A[2];
        l[0] = (1 - (Y + I)) * R;
        l[1] = (T + L) * R;
        l[2] = (F - O) * R;
        l[3] = 0;
        l[4] = (T - L) * X;
        l[5] = (1 - (t + I)) * X;
        l[6] = (G + M) * X;
        l[7] = 0;
        l[8] = (F + O) * A;
        l[9] = (G - M) * A;
        l[10] = (1 - (t + Y)) * A;
        l[11] = 0;
        l[12] = x[0];
        l[13] = x[1];
        l[14] = x[2];
        l[15] = 1;
        return l;
      },
      fromRotationTranslationScaleOrigin: function (l, t, x, A, F) {
        var G = t[0],
          I = t[1],
          L = t[2],
          M = t[3],
          O = G + G,
          R = I + I,
          T = L + L;
        t = G * O;
        var Y = G * R,
          X = G * T;
        G = I * R;
        I *= T;
        var fa = L * T;
        L = M * O;
        R *= M;
        var ha = M * T,
          ba = A[0],
          qa = A[1];
        T = A[2];
        A = F[0];
        M = F[1];
        F = F[2];
        O = (1 - (G + fa)) * ba;
        var ka = (Y + ha) * ba;
        ba *= X - R;
        Y = (Y - ha) * qa;
        fa = (1 - (t + fa)) * qa;
        qa *= I + L;
        X = (X + R) * T;
        I = (I - L) * T;
        t = (1 - (t + G)) * T;
        l[0] = O;
        l[1] = ka;
        l[2] = ba;
        l[3] = 0;
        l[4] = Y;
        l[5] = fa;
        l[6] = qa;
        l[7] = 0;
        l[8] = X;
        l[9] = I;
        l[10] = t;
        l[11] = 0;
        l[12] = x[0] + A - (O * A + Y * M + X * F);
        l[13] = x[1] + M - (ka * A + fa * M + I * F);
        l[14] = x[2] + F - (ba * A + qa * M + t * F);
        l[15] = 1;
        return l;
      },
      fromQuat: function (l, t) {
        var x = t[0],
          A = t[1],
          F = t[2];
        t = t[3];
        var G = x + x,
          I = A + A,
          L = F + F;
        x *= G;
        var M = A * G;
        A *= I;
        var O = F * G,
          R = F * I;
        F *= L;
        G *= t;
        I *= t;
        t *= L;
        l[0] = 1 - A - F;
        l[1] = M + t;
        l[2] = O - I;
        l[3] = 0;
        l[4] = M - t;
        l[5] = 1 - x - F;
        l[6] = R + G;
        l[7] = 0;
        l[8] = O + I;
        l[9] = R - G;
        l[10] = 1 - x - A;
        l[11] = 0;
        l[12] = 0;
        l[13] = 0;
        l[14] = 0;
        l[15] = 1;
        return l;
      },
      frustum: function (l, t, x, A, F, G, I) {
        var L = 1 / (x - t),
          M = 1 / (F - A),
          O = 1 / (G - I);
        l[0] = 2 * G * L;
        l[1] = 0;
        l[2] = 0;
        l[3] = 0;
        l[4] = 0;
        l[5] = 2 * G * M;
        l[6] = 0;
        l[7] = 0;
        l[8] = (x + t) * L;
        l[9] = (F + A) * M;
        l[10] = (I + G) * O;
        l[11] = -1;
        l[12] = 0;
        l[13] = 0;
        l[14] = I * G * 2 * O;
        l[15] = 0;
        return l;
      },
      perspectiveNO: p,
      perspective: p,
      perspectiveZO: function (l, t, x, A, F) {
        t = 1 / Math.tan(t / 2);
        l[0] = t / x;
        l[1] = 0;
        l[2] = 0;
        l[3] = 0;
        l[4] = 0;
        l[5] = t;
        l[6] = 0;
        l[7] = 0;
        l[8] = 0;
        l[9] = 0;
        l[11] = -1;
        l[12] = 0;
        l[13] = 0;
        l[15] = 0;
        null != F && Infinity !== F
          ? ((x = 1 / (A - F)), (l[10] = F * x), (l[14] = F * A * x))
          : ((l[10] = -1), (l[14] = -A));
        return l;
      },
      perspectiveFromFieldOfView: function (l, t, x, A) {
        var F = Math.tan((t.upDegrees * Math.PI) / 180),
          G = Math.tan((t.downDegrees * Math.PI) / 180),
          I = Math.tan((t.leftDegrees * Math.PI) / 180);
        t = Math.tan((t.rightDegrees * Math.PI) / 180);
        var L = 2 / (I + t),
          M = 2 / (F + G);
        l[0] = L;
        l[1] = 0;
        l[2] = 0;
        l[3] = 0;
        l[4] = 0;
        l[5] = M;
        l[6] = 0;
        l[7] = 0;
        l[8] = -((I - t) * L * 0.5);
        l[9] = (F - G) * M * 0.5;
        l[10] = A / (x - A);
        l[11] = -1;
        l[12] = 0;
        l[13] = 0;
        l[14] = (A * x) / (x - A);
        l[15] = 0;
        return l;
      },
      orthoNO: u,
      ortho: u,
      orthoZO: function (l, t, x, A, F, G, I) {
        var L = 1 / (t - x),
          M = 1 / (A - F);
        I = 1 / (G - I);
        l[0] = -2 * L;
        l[1] = 0;
        l[2] = 0;
        l[3] = 0;
        l[4] = 0;
        l[5] = -2 * M;
        l[6] = 0;
        l[7] = 0;
        l[8] = 0;
        l[9] = 0;
        l[10] = I;
        l[11] = 0;
        l[12] = (t + x) * L;
        l[13] = (F + A) * M;
        l[14] = G * I;
        l[15] = 1;
        return l;
      },
      lookAt: function (l, t, x, A) {
        var F = t[0],
          G = t[1];
        t = t[2];
        var I = A[0];
        var L = A[1];
        var M = A[2];
        var O = x[0];
        A = x[1];
        var R = x[2];
        if (
          1e-6 > Math.abs(F - O) &&
          1e-6 > Math.abs(G - A) &&
          1e-6 > Math.abs(t - R)
        )
          return k(l);
        x = F - O;
        A = G - A;
        O = t - R;
        var T = 1 / Math.hypot(x, A, O);
        x *= T;
        A *= T;
        O *= T;
        R = L * O - M * A;
        M = M * x - I * O;
        I = I * A - L * x;
        (T = Math.hypot(R, M, I))
          ? ((T = 1 / T), (R *= T), (M *= T), (I *= T))
          : (I = M = R = 0);
        L = A * I - O * M;
        var Y = O * R - x * I;
        var X = x * M - A * R;
        (T = Math.hypot(L, Y, X))
          ? ((T = 1 / T), (L *= T), (Y *= T), (X *= T))
          : (X = Y = L = 0);
        l[0] = R;
        l[1] = L;
        l[2] = x;
        l[3] = 0;
        l[4] = M;
        l[5] = Y;
        l[6] = A;
        l[7] = 0;
        l[8] = I;
        l[9] = X;
        l[10] = O;
        l[11] = 0;
        l[12] = -(R * F + M * G + I * t);
        l[13] = -(L * F + Y * G + X * t);
        l[14] = -(x * F + A * G + O * t);
        l[15] = 1;
        return l;
      },
      targetTo: function (l, t, x, A) {
        var F = t[0],
          G = t[1];
        t = t[2];
        var I = A[0],
          L = A[1],
          M = A[2];
        A = F - x[0];
        var O = G - x[1];
        x = t - x[2];
        var R = A * A + O * O + x * x;
        0 < R && ((R = 1 / Math.sqrt(R)), (A *= R), (O *= R), (x *= R));
        var T = L * x - M * O;
        M = M * A - I * x;
        I = I * O - L * A;
        R = T * T + M * M + I * I;
        0 < R && ((R = 1 / Math.sqrt(R)), (T *= R), (M *= R), (I *= R));
        l[0] = T;
        l[1] = M;
        l[2] = I;
        l[3] = 0;
        l[4] = O * I - x * M;
        l[5] = x * T - A * I;
        l[6] = A * M - O * T;
        l[7] = 0;
        l[8] = A;
        l[9] = O;
        l[10] = x;
        l[11] = 0;
        l[12] = F;
        l[13] = G;
        l[14] = t;
        l[15] = 1;
        return l;
      },
      str: function (l) {
        return (
          "mat4(" +
          l[0] +
          ", " +
          l[1] +
          ", " +
          l[2] +
          ", " +
          l[3] +
          ", " +
          l[4] +
          ", " +
          l[5] +
          ", " +
          l[6] +
          ", " +
          l[7] +
          ", " +
          l[8] +
          ", " +
          l[9] +
          ", " +
          l[10] +
          ", " +
          l[11] +
          ", " +
          l[12] +
          ", " +
          l[13] +
          ", " +
          l[14] +
          ", " +
          l[15] +
          ")"
        );
      },
      frob: function (l) {
        return Math.hypot(
          l[0],
          l[1],
          l[2],
          l[3],
          l[4],
          l[5],
          l[6],
          l[7],
          l[8],
          l[9],
          l[10],
          l[11],
          l[12],
          l[13],
          l[14],
          l[15]
        );
      },
      add: function (l, t, x) {
        l[0] = t[0] + x[0];
        l[1] = t[1] + x[1];
        l[2] = t[2] + x[2];
        l[3] = t[3] + x[3];
        l[4] = t[4] + x[4];
        l[5] = t[5] + x[5];
        l[6] = t[6] + x[6];
        l[7] = t[7] + x[7];
        l[8] = t[8] + x[8];
        l[9] = t[9] + x[9];
        l[10] = t[10] + x[10];
        l[11] = t[11] + x[11];
        l[12] = t[12] + x[12];
        l[13] = t[13] + x[13];
        l[14] = t[14] + x[14];
        l[15] = t[15] + x[15];
        return l;
      },
      subtract: w,
      multiplyScalar: function (l, t, x) {
        l[0] = t[0] * x;
        l[1] = t[1] * x;
        l[2] = t[2] * x;
        l[3] = t[3] * x;
        l[4] = t[4] * x;
        l[5] = t[5] * x;
        l[6] = t[6] * x;
        l[7] = t[7] * x;
        l[8] = t[8] * x;
        l[9] = t[9] * x;
        l[10] = t[10] * x;
        l[11] = t[11] * x;
        l[12] = t[12] * x;
        l[13] = t[13] * x;
        l[14] = t[14] * x;
        l[15] = t[15] * x;
        return l;
      },
      multiplyScalarAndAdd: function (l, t, x, A) {
        l[0] = t[0] + x[0] * A;
        l[1] = t[1] + x[1] * A;
        l[2] = t[2] + x[2] * A;
        l[3] = t[3] + x[3] * A;
        l[4] = t[4] + x[4] * A;
        l[5] = t[5] + x[5] * A;
        l[6] = t[6] + x[6] * A;
        l[7] = t[7] + x[7] * A;
        l[8] = t[8] + x[8] * A;
        l[9] = t[9] + x[9] * A;
        l[10] = t[10] + x[10] * A;
        l[11] = t[11] + x[11] * A;
        l[12] = t[12] + x[12] * A;
        l[13] = t[13] + x[13] * A;
        l[14] = t[14] + x[14] * A;
        l[15] = t[15] + x[15] * A;
        return l;
      },
      exactEquals: function (l, t) {
        return (
          l[0] === t[0] &&
          l[1] === t[1] &&
          l[2] === t[2] &&
          l[3] === t[3] &&
          l[4] === t[4] &&
          l[5] === t[5] &&
          l[6] === t[6] &&
          l[7] === t[7] &&
          l[8] === t[8] &&
          l[9] === t[9] &&
          l[10] === t[10] &&
          l[11] === t[11] &&
          l[12] === t[12] &&
          l[13] === t[13] &&
          l[14] === t[14] &&
          l[15] === t[15]
        );
      },
      equals: function (l, t) {
        var x = l[0],
          A = l[1],
          F = l[2],
          G = l[3],
          I = l[4],
          L = l[5],
          M = l[6],
          O = l[7],
          R = l[8],
          T = l[9],
          Y = l[10],
          X = l[11],
          fa = l[12],
          ha = l[13],
          ba = l[14];
        l = l[15];
        var qa = t[0],
          ka = t[1],
          ta = t[2],
          ua = t[3],
          ra = t[4],
          za = t[5],
          Aa = t[6],
          Ba = t[7],
          Ca = t[8],
          Ja = t[9],
          Pa = t[10],
          Qa = t[11],
          Da = t[12],
          Bb = t[13],
          Cb = t[14];
        t = t[15];
        return (
          Math.abs(x - qa) <= 1e-6 * Math.max(1, Math.abs(x), Math.abs(qa)) &&
          Math.abs(A - ka) <= 1e-6 * Math.max(1, Math.abs(A), Math.abs(ka)) &&
          Math.abs(F - ta) <= 1e-6 * Math.max(1, Math.abs(F), Math.abs(ta)) &&
          Math.abs(G - ua) <= 1e-6 * Math.max(1, Math.abs(G), Math.abs(ua)) &&
          Math.abs(I - ra) <= 1e-6 * Math.max(1, Math.abs(I), Math.abs(ra)) &&
          Math.abs(L - za) <= 1e-6 * Math.max(1, Math.abs(L), Math.abs(za)) &&
          Math.abs(M - Aa) <= 1e-6 * Math.max(1, Math.abs(M), Math.abs(Aa)) &&
          Math.abs(O - Ba) <= 1e-6 * Math.max(1, Math.abs(O), Math.abs(Ba)) &&
          Math.abs(R - Ca) <= 1e-6 * Math.max(1, Math.abs(R), Math.abs(Ca)) &&
          Math.abs(T - Ja) <= 1e-6 * Math.max(1, Math.abs(T), Math.abs(Ja)) &&
          Math.abs(Y - Pa) <= 1e-6 * Math.max(1, Math.abs(Y), Math.abs(Pa)) &&
          Math.abs(X - Qa) <= 1e-6 * Math.max(1, Math.abs(X), Math.abs(Qa)) &&
          Math.abs(fa - Da) <= 1e-6 * Math.max(1, Math.abs(fa), Math.abs(Da)) &&
          Math.abs(ha - Bb) <= 1e-6 * Math.max(1, Math.abs(ha), Math.abs(Bb)) &&
          Math.abs(ba - Cb) <= 1e-6 * Math.max(1, Math.abs(ba), Math.abs(Cb)) &&
          Math.abs(l - t) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(t))
        );
      },
      mul: m,
      sub: w,
    }),
    kb = (function () {
      var l = y();
      return function (t, x, A, F, G, I) {
        x || (x = 3);
        A || (A = 0);
        for (F = F ? Math.min(F * x + A, t.length) : t.length; A < F; A += x)
          (l[0] = t[A]),
            (l[1] = t[A + 1]),
            (l[2] = t[A + 2]),
            G(l, l, I),
            (t[A] = l[0]),
            (t[A + 1] = l[1]),
            (t[A + 2] = l[2]);
        return t;
      };
    })();
  kb = Object.freeze({
    __proto__: null,
    create: y,
    clone: function (l) {
      var t = new sa(3);
      t[0] = l[0];
      t[1] = l[1];
      t[2] = l[2];
      return t;
    },
    length: B,
    fromValues: E,
    copy: function (l, t) {
      l[0] = t[0];
      l[1] = t[1];
      l[2] = t[2];
      return l;
    },
    set: function (l, t, x, A) {
      l[0] = t;
      l[1] = x;
      l[2] = A;
      return l;
    },
    add: function (l, t, x) {
      l[0] = t[0] + x[0];
      l[1] = t[1] + x[1];
      l[2] = t[2] + x[2];
      return l;
    },
    subtract: z,
    multiply: D,
    divide: J,
    ceil: function (l, t) {
      l[0] = Math.ceil(t[0]);
      l[1] = Math.ceil(t[1]);
      l[2] = Math.ceil(t[2]);
      return l;
    },
    floor: function (l, t) {
      l[0] = Math.floor(t[0]);
      l[1] = Math.floor(t[1]);
      l[2] = Math.floor(t[2]);
      return l;
    },
    min: function (l, t, x) {
      l[0] = Math.min(t[0], x[0]);
      l[1] = Math.min(t[1], x[1]);
      l[2] = Math.min(t[2], x[2]);
      return l;
    },
    max: function (l, t, x) {
      l[0] = Math.max(t[0], x[0]);
      l[1] = Math.max(t[1], x[1]);
      l[2] = Math.max(t[2], x[2]);
      return l;
    },
    round: function (l, t) {
      l[0] = Math.round(t[0]);
      l[1] = Math.round(t[1]);
      l[2] = Math.round(t[2]);
      return l;
    },
    scale: function (l, t, x) {
      l[0] = t[0] * x;
      l[1] = t[1] * x;
      l[2] = t[2] * x;
      return l;
    },
    scaleAndAdd: function (l, t, x, A) {
      l[0] = t[0] + x[0] * A;
      l[1] = t[1] + x[1] * A;
      l[2] = t[2] + x[2] * A;
      return l;
    },
    distance: C,
    squaredDistance: H,
    squaredLength: K,
    negate: function (l, t) {
      l[0] = -t[0];
      l[1] = -t[1];
      l[2] = -t[2];
      return l;
    },
    inverse: function (l, t) {
      l[0] = 1 / t[0];
      l[1] = 1 / t[1];
      l[2] = 1 / t[2];
      return l;
    },
    normalize: P,
    dot: S,
    cross: U,
    lerp: function (l, t, x, A) {
      var F = t[0],
        G = t[1];
      t = t[2];
      l[0] = F + A * (x[0] - F);
      l[1] = G + A * (x[1] - G);
      l[2] = t + A * (x[2] - t);
      return l;
    },
    slerp: function (l, t, x, A) {
      var F = Math.acos(Math.min(Math.max(S(t, x), -1), 1)),
        G = Math.sin(F),
        I = Math.sin((1 - A) * F) / G;
      A = Math.sin(A * F) / G;
      l[0] = I * t[0] + A * x[0];
      l[1] = I * t[1] + A * x[1];
      l[2] = I * t[2] + A * x[2];
      return l;
    },
    hermite: function (l, t, x, A, F, G) {
      var I = G * G,
        L = I * (2 * G - 3) + 1,
        M = I * (G - 2) + G,
        O = I * (G - 1);
      G = I * (3 - 2 * G);
      l[0] = t[0] * L + x[0] * M + A[0] * O + F[0] * G;
      l[1] = t[1] * L + x[1] * M + A[1] * O + F[1] * G;
      l[2] = t[2] * L + x[2] * M + A[2] * O + F[2] * G;
      return l;
    },
    bezier: function (l, t, x, A, F, G) {
      var I = 1 - G,
        L = I * I,
        M = G * G,
        O = L * I;
      L *= 3 * G;
      I *= 3 * M;
      G *= M;
      l[0] = t[0] * O + x[0] * L + A[0] * I + F[0] * G;
      l[1] = t[1] * O + x[1] * L + A[1] * I + F[1] * G;
      l[2] = t[2] * O + x[2] * L + A[2] * I + F[2] * G;
      return l;
    },
    random: function (l, t) {
      t = t || 1;
      var x = 2 * Sa() * Math.PI,
        A = 2 * Sa() - 1,
        F = Math.sqrt(1 - A * A) * t;
      l[0] = Math.cos(x) * F;
      l[1] = Math.sin(x) * F;
      l[2] = A * t;
      return l;
    },
    transformMat4: function (l, t, x) {
      var A = t[0],
        F = t[1];
      t = t[2];
      var G = x[3] * A + x[7] * F + x[11] * t + x[15];
      G = G || 1;
      l[0] = (x[0] * A + x[4] * F + x[8] * t + x[12]) / G;
      l[1] = (x[1] * A + x[5] * F + x[9] * t + x[13]) / G;
      l[2] = (x[2] * A + x[6] * F + x[10] * t + x[14]) / G;
      return l;
    },
    transformMat3: function (l, t, x) {
      var A = t[0],
        F = t[1];
      t = t[2];
      l[0] = A * x[0] + F * x[3] + t * x[6];
      l[1] = A * x[1] + F * x[4] + t * x[7];
      l[2] = A * x[2] + F * x[5] + t * x[8];
      return l;
    },
    transformQuat: function (l, t, x) {
      var A = x[0],
        F = x[1],
        G = x[2],
        I = t[0],
        L = t[1];
      t = t[2];
      var M = F * t - G * L,
        O = G * I - A * t,
        R = A * L - F * I;
      x = 2 * x[3];
      l[0] = I + M * x + 2 * (F * R - G * O);
      l[1] = L + O * x + 2 * (G * M - A * R);
      l[2] = t + R * x + 2 * (A * O - F * M);
      return l;
    },
    rotateX: function (l, t, x, A) {
      var F = [],
        G = [];
      F[0] = t[0] - x[0];
      F[1] = t[1] - x[1];
      F[2] = t[2] - x[2];
      G[0] = F[0];
      G[1] = F[1] * Math.cos(A) - F[2] * Math.sin(A);
      G[2] = F[1] * Math.sin(A) + F[2] * Math.cos(A);
      l[0] = G[0] + x[0];
      l[1] = G[1] + x[1];
      l[2] = G[2] + x[2];
      return l;
    },
    rotateY: function (l, t, x, A) {
      var F = [],
        G = [];
      F[0] = t[0] - x[0];
      F[1] = t[1] - x[1];
      F[2] = t[2] - x[2];
      G[0] = F[2] * Math.sin(A) + F[0] * Math.cos(A);
      G[1] = F[1];
      G[2] = F[2] * Math.cos(A) - F[0] * Math.sin(A);
      l[0] = G[0] + x[0];
      l[1] = G[1] + x[1];
      l[2] = G[2] + x[2];
      return l;
    },
    rotateZ: function (l, t, x, A) {
      var F = [],
        G = [];
      F[0] = t[0] - x[0];
      F[1] = t[1] - x[1];
      F[2] = t[2] - x[2];
      G[0] = F[0] * Math.cos(A) - F[1] * Math.sin(A);
      G[1] = F[0] * Math.sin(A) + F[1] * Math.cos(A);
      G[2] = F[2];
      l[0] = G[0] + x[0];
      l[1] = G[1] + x[1];
      l[2] = G[2] + x[2];
      return l;
    },
    angle: function (l, t) {
      var x = l[0],
        A = l[1],
        F = l[2],
        G = t[0],
        I = t[1],
        L = t[2];
      l =
        (x = Math.sqrt((x * x + A * A + F * F) * (G * G + I * I + L * L))) &&
        S(l, t) / x;
      return Math.acos(Math.min(Math.max(l, -1), 1));
    },
    zero: function (l) {
      l[0] = 0;
      l[1] = 0;
      l[2] = 0;
      return l;
    },
    str: function (l) {
      return "vec3(" + l[0] + ", " + l[1] + ", " + l[2] + ")";
    },
    exactEquals: function (l, t) {
      return l[0] === t[0] && l[1] === t[1] && l[2] === t[2];
    },
    equals: function (l, t) {
      var x = l[0],
        A = l[1];
      l = l[2];
      var F = t[0],
        G = t[1];
      t = t[2];
      return (
        Math.abs(x - F) <= 1e-6 * Math.max(1, Math.abs(x), Math.abs(F)) &&
        Math.abs(A - G) <= 1e-6 * Math.max(1, Math.abs(A), Math.abs(G)) &&
        Math.abs(l - t) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(t))
      );
    },
    sub: z,
    mul: D,
    div: J,
    dist: C,
    sqrDist: H,
    len: B,
    sqrLen: K,
    forEach: kb,
  });
  var lb = (function () {
    var l = V();
    return function (t, x, A, F, G, I) {
      x || (x = 4);
      A || (A = 0);
      for (F = F ? Math.min(F * x + A, t.length) : t.length; A < F; A += x)
        (l[0] = t[A]),
          (l[1] = t[A + 1]),
          (l[2] = t[A + 2]),
          (l[3] = t[A + 3]),
          G(l, l, I),
          (t[A] = l[0]),
          (t[A + 1] = l[1]),
          (t[A + 2] = l[2]),
          (t[A + 3] = l[3]);
      return t;
    };
  })();
  lb = Object.freeze({
    __proto__: null,
    create: V,
    clone: aa,
    fromValues: ma,
    copy: va,
    set: Na,
    add: Ea,
    subtract: Ia,
    multiply: Ma,
    divide: Fa,
    ceil: function (l, t) {
      l[0] = Math.ceil(t[0]);
      l[1] = Math.ceil(t[1]);
      l[2] = Math.ceil(t[2]);
      l[3] = Math.ceil(t[3]);
      return l;
    },
    floor: function (l, t) {
      l[0] = Math.floor(t[0]);
      l[1] = Math.floor(t[1]);
      l[2] = Math.floor(t[2]);
      l[3] = Math.floor(t[3]);
      return l;
    },
    min: function (l, t, x) {
      l[0] = Math.min(t[0], x[0]);
      l[1] = Math.min(t[1], x[1]);
      l[2] = Math.min(t[2], x[2]);
      l[3] = Math.min(t[3], x[3]);
      return l;
    },
    max: function (l, t, x) {
      l[0] = Math.max(t[0], x[0]);
      l[1] = Math.max(t[1], x[1]);
      l[2] = Math.max(t[2], x[2]);
      l[3] = Math.max(t[3], x[3]);
      return l;
    },
    round: function (l, t) {
      l[0] = Math.round(t[0]);
      l[1] = Math.round(t[1]);
      l[2] = Math.round(t[2]);
      l[3] = Math.round(t[3]);
      return l;
    },
    scale: ya,
    scaleAndAdd: function (l, t, x, A) {
      l[0] = t[0] + x[0] * A;
      l[1] = t[1] + x[1] * A;
      l[2] = t[2] + x[2] * A;
      l[3] = t[3] + x[3] * A;
      return l;
    },
    distance: na,
    squaredDistance: Va,
    length: xa,
    squaredLength: Ga,
    negate: function (l, t) {
      l[0] = -t[0];
      l[1] = -t[1];
      l[2] = -t[2];
      l[3] = -t[3];
      return l;
    },
    inverse: function (l, t) {
      l[0] = 1 / t[0];
      l[1] = 1 / t[1];
      l[2] = 1 / t[2];
      l[3] = 1 / t[3];
      return l;
    },
    normalize: bb,
    dot: Xa,
    cross: function (l, t, x, A) {
      var F = x[0] * A[1] - x[1] * A[0],
        G = x[0] * A[2] - x[2] * A[0],
        I = x[0] * A[3] - x[3] * A[0],
        L = x[1] * A[2] - x[2] * A[1],
        M = x[1] * A[3] - x[3] * A[1];
      x = x[2] * A[3] - x[3] * A[2];
      A = t[0];
      var O = t[1],
        R = t[2];
      t = t[3];
      l[0] = O * x - R * M + t * L;
      l[1] = -(A * x) + R * I - t * G;
      l[2] = A * M - O * I + t * F;
      l[3] = -(A * L) + O * G - R * F;
      return l;
    },
    lerp: ob,
    random: function (l, t) {
      t = t || 1;
      do {
        var x = 2 * Sa() - 1;
        var A = 2 * Sa() - 1;
        var F = x * x + A * A;
      } while (1 <= F);
      do {
        var G = 2 * Sa() - 1;
        var I = 2 * Sa() - 1;
        var L = G * G + I * I;
      } while (1 <= L);
      F = Math.sqrt((1 - F) / L);
      l[0] = t * x;
      l[1] = t * A;
      l[2] = t * G * F;
      l[3] = t * I * F;
      return l;
    },
    transformMat4: function (l, t, x) {
      var A = t[0],
        F = t[1],
        G = t[2];
      t = t[3];
      l[0] = x[0] * A + x[4] * F + x[8] * G + x[12] * t;
      l[1] = x[1] * A + x[5] * F + x[9] * G + x[13] * t;
      l[2] = x[2] * A + x[6] * F + x[10] * G + x[14] * t;
      l[3] = x[3] * A + x[7] * F + x[11] * G + x[15] * t;
      return l;
    },
    transformQuat: function (l, t, x) {
      var A = t[0],
        F = t[1],
        G = t[2],
        I = x[0],
        L = x[1],
        M = x[2];
      x = x[3];
      var O = x * A + L * G - M * F,
        R = x * F + M * A - I * G,
        T = x * G + I * F - L * A;
      A = -I * A - L * F - M * G;
      l[0] = O * x + A * -I + R * -M - T * -L;
      l[1] = R * x + A * -L + T * -I - O * -M;
      l[2] = T * x + A * -M + O * -L - R * -I;
      l[3] = t[3];
      return l;
    },
    zero: function (l) {
      l[0] = 0;
      l[1] = 0;
      l[2] = 0;
      l[3] = 0;
      return l;
    },
    str: function (l) {
      return "vec4(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ")";
    },
    exactEquals: pb,
    equals: function (l, t) {
      var x = l[0],
        A = l[1],
        F = l[2];
      l = l[3];
      var G = t[0],
        I = t[1],
        L = t[2];
      t = t[3];
      return (
        Math.abs(x - G) <= 1e-6 * Math.max(1, Math.abs(x), Math.abs(G)) &&
        Math.abs(A - I) <= 1e-6 * Math.max(1, Math.abs(A), Math.abs(I)) &&
        Math.abs(F - L) <= 1e-6 * Math.max(1, Math.abs(F), Math.abs(L)) &&
        Math.abs(l - t) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(t))
      );
    },
    sub: Ia,
    mul: Ma,
    div: Fa,
    dist: na,
    sqrDist: Va,
    len: xa,
    sqrLen: Ga,
    forEach: lb,
  });
  var mb = (function () {
      var l = y(),
        t = E(1, 0, 0),
        x = E(0, 1, 0);
      return function (A, F, G) {
        var I = S(F, G);
        if (-0.999999 > I)
          return (
            U(l, t, F), 1e-6 > B(l) && U(l, x, F), P(l, l), qb(A, l, Math.PI), A
          );
        if (0.999999 < I)
          return (A[0] = 0), (A[1] = 0), (A[2] = 0), (A[3] = 1), A;
        U(l, F, G);
        A[0] = l[0];
        A[1] = l[1];
        A[2] = l[2];
        A[3] = 1 + I;
        return bb(A, A);
      };
    })(),
    nb = (function () {
      var l = cb(),
        t = cb();
      return function (x, A, F, G, I, L) {
        db(l, A, I, L);
        db(t, F, G, L);
        db(x, l, t, 2 * L * (1 - L));
        return x;
      };
    })(),
    $a = (function () {
      var l = f();
      return function (t, x, A, F) {
        l[0] = A[0];
        l[3] = A[1];
        l[6] = A[2];
        l[1] = F[0];
        l[4] = F[1];
        l[7] = F[2];
        l[2] = -x[0];
        l[5] = -x[1];
        l[8] = -x[2];
        return bb(t, xb(t, l));
      };
    })();
  mb = Object.freeze({
    __proto__: null,
    create: cb,
    identity: function (l) {
      l[0] = 0;
      l[1] = 0;
      l[2] = 0;
      l[3] = 1;
      return l;
    },
    setAxisAngle: qb,
    getAxisAngle: function (l, t) {
      var x = 2 * Math.acos(t[3]),
        A = Math.sin(x / 2);
      1e-6 < A
        ? ((l[0] = t[0] / A), (l[1] = t[1] / A), (l[2] = t[2] / A))
        : ((l[0] = 1), (l[1] = 0), (l[2] = 0));
      return x;
    },
    getAngle: function (l, t) {
      l = Xa(l, t);
      return Math.acos(2 * l * l - 1);
    },
    multiply: rb,
    rotateX: sb,
    rotateY: tb,
    rotateZ: ub,
    calculateW: function (l, t) {
      var x = t[0],
        A = t[1];
      t = t[2];
      l[0] = x;
      l[1] = A;
      l[2] = t;
      l[3] = Math.sqrt(Math.abs(1 - x * x - A * A - t * t));
      return l;
    },
    exp: vb,
    ln: wb,
    pow: function (l, t, x) {
      wb(l, t);
      ya(l, l, x);
      vb(l, l);
      return l;
    },
    slerp: db,
    random: function (l) {
      var t = Sa(),
        x = Sa(),
        A = Sa(),
        F = Math.sqrt(1 - t);
      t = Math.sqrt(t);
      l[0] = F * Math.sin(2 * Math.PI * x);
      l[1] = F * Math.cos(2 * Math.PI * x);
      l[2] = t * Math.sin(2 * Math.PI * A);
      l[3] = t * Math.cos(2 * Math.PI * A);
      return l;
    },
    invert: function (l, t) {
      var x = t[0],
        A = t[1],
        F = t[2];
      t = t[3];
      var G = x * x + A * A + F * F + t * t;
      G = G ? 1 / G : 0;
      l[0] = -x * G;
      l[1] = -A * G;
      l[2] = -F * G;
      l[3] = t * G;
      return l;
    },
    conjugate: function (l, t) {
      l[0] = -t[0];
      l[1] = -t[1];
      l[2] = -t[2];
      l[3] = t[3];
      return l;
    },
    fromMat3: xb,
    fromEuler: function (l, t, x, A) {
      var F =
          4 < arguments.length && void 0 !== arguments[4]
            ? arguments[4]
            : "zyx",
        G = Math.PI / 360;
      t *= G;
      A *= G;
      x *= G;
      G = Math.sin(t);
      var I = Math.cos(t),
        L = Math.sin(x),
        M = Math.cos(x),
        O = Math.sin(A),
        R = Math.cos(A);
      switch (F) {
        case "xyz":
          l[0] = G * M * R + I * L * O;
          l[1] = I * L * R - G * M * O;
          l[2] = I * M * O + G * L * R;
          l[3] = I * M * R - G * L * O;
          break;
        case "xzy":
          l[0] = G * M * R - I * L * O;
          l[1] = I * L * R - G * M * O;
          l[2] = I * M * O + G * L * R;
          l[3] = I * M * R + G * L * O;
          break;
        case "yxz":
          l[0] = G * M * R + I * L * O;
          l[1] = I * L * R - G * M * O;
          l[2] = I * M * O - G * L * R;
          l[3] = I * M * R + G * L * O;
          break;
        case "yzx":
          l[0] = G * M * R + I * L * O;
          l[1] = I * L * R + G * M * O;
          l[2] = I * M * O - G * L * R;
          l[3] = I * M * R - G * L * O;
          break;
        case "zxy":
          l[0] = G * M * R - I * L * O;
          l[1] = I * L * R + G * M * O;
          l[2] = I * M * O + G * L * R;
          l[3] = I * M * R - G * L * O;
          break;
        case "zyx":
          l[0] = G * M * R - I * L * O;
          l[1] = I * L * R + G * M * O;
          l[2] = I * M * O - G * L * R;
          l[3] = I * M * R + G * L * O;
          break;
        default:
          throw Error("Unknown angle order " + F);
      }
      return l;
    },
    str: function (l) {
      return "quat(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ")";
    },
    clone: aa,
    fromValues: ma,
    copy: va,
    set: Na,
    add: Ea,
    mul: rb,
    scale: ya,
    dot: Xa,
    lerp: ob,
    length: xa,
    len: xa,
    squaredLength: Ga,
    sqrLen: Ga,
    normalize: bb,
    exactEquals: pb,
    equals: function (l, t) {
      return 0.999999 <= Math.abs(Xa(l, t));
    },
    rotationTo: mb,
    sqlerp: nb,
    setAxes: $a,
  });
  nb = Object.freeze({
    __proto__: null,
    create: function () {
      var l = new sa(8);
      sa != Float32Array &&
        ((l[0] = 0),
        (l[1] = 0),
        (l[2] = 0),
        (l[4] = 0),
        (l[5] = 0),
        (l[6] = 0),
        (l[7] = 0));
      l[3] = 1;
      return l;
    },
    clone: function (l) {
      var t = new sa(8);
      t[0] = l[0];
      t[1] = l[1];
      t[2] = l[2];
      t[3] = l[3];
      t[4] = l[4];
      t[5] = l[5];
      t[6] = l[6];
      t[7] = l[7];
      return t;
    },
    fromValues: function (l, t, x, A, F, G, I, L) {
      var M = new sa(8);
      M[0] = l;
      M[1] = t;
      M[2] = x;
      M[3] = A;
      M[4] = F;
      M[5] = G;
      M[6] = I;
      M[7] = L;
      return M;
    },
    fromRotationTranslationValues: function (l, t, x, A, F, G, I) {
      var L = new sa(8);
      L[0] = l;
      L[1] = t;
      L[2] = x;
      L[3] = A;
      F *= 0.5;
      G *= 0.5;
      I *= 0.5;
      L[4] = F * A + G * x - I * t;
      L[5] = G * A + I * l - F * x;
      L[6] = I * A + F * t - G * l;
      L[7] = -F * l - G * t - I * x;
      return L;
    },
    fromRotationTranslation: yb,
    fromTranslation: function (l, t) {
      l[0] = 0;
      l[1] = 0;
      l[2] = 0;
      l[3] = 1;
      l[4] = 0.5 * t[0];
      l[5] = 0.5 * t[1];
      l[6] = 0.5 * t[2];
      l[7] = 0;
      return l;
    },
    fromRotation: function (l, t) {
      l[0] = t[0];
      l[1] = t[1];
      l[2] = t[2];
      l[3] = t[3];
      l[4] = 0;
      l[5] = 0;
      l[6] = 0;
      l[7] = 0;
      return l;
    },
    fromMat4: function (l, t) {
      var x = cb();
      n(x, t);
      var A = new sa(3);
      v(A, t);
      yb(l, x, A);
      return l;
    },
    copy: zb,
    identity: function (l) {
      l[0] = 0;
      l[1] = 0;
      l[2] = 0;
      l[3] = 1;
      l[4] = 0;
      l[5] = 0;
      l[6] = 0;
      l[7] = 0;
      return l;
    },
    set: function (l, t, x, A, F, G, I, L, M) {
      l[0] = t;
      l[1] = x;
      l[2] = A;
      l[3] = F;
      l[4] = G;
      l[5] = I;
      l[6] = L;
      l[7] = M;
      return l;
    },
    getReal: va,
    getDual: function (l, t) {
      l[0] = t[4];
      l[1] = t[5];
      l[2] = t[6];
      l[3] = t[7];
      return l;
    },
    setReal: va,
    setDual: function (l, t) {
      l[4] = t[0];
      l[5] = t[1];
      l[6] = t[2];
      l[7] = t[3];
      return l;
    },
    getTranslation: function (l, t) {
      var x = t[4],
        A = t[5],
        F = t[6],
        G = t[7],
        I = -t[0],
        L = -t[1],
        M = -t[2];
      t = t[3];
      l[0] = 2 * (x * t + G * I + A * M - F * L);
      l[1] = 2 * (A * t + G * L + F * I - x * M);
      l[2] = 2 * (F * t + G * M + x * L - A * I);
      return l;
    },
    translate: function (l, t, x) {
      var A = t[0],
        F = t[1],
        G = t[2],
        I = t[3],
        L = 0.5 * x[0],
        M = 0.5 * x[1];
      x = 0.5 * x[2];
      var O = t[4],
        R = t[5],
        T = t[6];
      t = t[7];
      l[0] = A;
      l[1] = F;
      l[2] = G;
      l[3] = I;
      l[4] = I * L + F * x - G * M + O;
      l[5] = I * M + G * L - A * x + R;
      l[6] = I * x + A * M - F * L + T;
      l[7] = -A * L - F * M - G * x + t;
      return l;
    },
    rotateX: function (l, t, x) {
      var A = -t[0],
        F = -t[1],
        G = -t[2],
        I = t[3],
        L = t[4],
        M = t[5],
        O = t[6],
        R = t[7],
        T = L * I + R * A + M * G - O * F,
        Y = M * I + R * F + O * A - L * G,
        X = O * I + R * G + L * F - M * A;
      L = R * I - L * A - M * F - O * G;
      sb(l, t, x);
      A = l[0];
      F = l[1];
      G = l[2];
      I = l[3];
      l[4] = T * I + L * A + Y * G - X * F;
      l[5] = Y * I + L * F + X * A - T * G;
      l[6] = X * I + L * G + T * F - Y * A;
      l[7] = L * I - T * A - Y * F - X * G;
      return l;
    },
    rotateY: function (l, t, x) {
      var A = -t[0],
        F = -t[1],
        G = -t[2],
        I = t[3],
        L = t[4],
        M = t[5],
        O = t[6],
        R = t[7],
        T = L * I + R * A + M * G - O * F,
        Y = M * I + R * F + O * A - L * G,
        X = O * I + R * G + L * F - M * A;
      L = R * I - L * A - M * F - O * G;
      tb(l, t, x);
      A = l[0];
      F = l[1];
      G = l[2];
      I = l[3];
      l[4] = T * I + L * A + Y * G - X * F;
      l[5] = Y * I + L * F + X * A - T * G;
      l[6] = X * I + L * G + T * F - Y * A;
      l[7] = L * I - T * A - Y * F - X * G;
      return l;
    },
    rotateZ: function (l, t, x) {
      var A = -t[0],
        F = -t[1],
        G = -t[2],
        I = t[3],
        L = t[4],
        M = t[5],
        O = t[6],
        R = t[7],
        T = L * I + R * A + M * G - O * F,
        Y = M * I + R * F + O * A - L * G,
        X = O * I + R * G + L * F - M * A;
      L = R * I - L * A - M * F - O * G;
      ub(l, t, x);
      A = l[0];
      F = l[1];
      G = l[2];
      I = l[3];
      l[4] = T * I + L * A + Y * G - X * F;
      l[5] = Y * I + L * F + X * A - T * G;
      l[6] = X * I + L * G + T * F - Y * A;
      l[7] = L * I - T * A - Y * F - X * G;
      return l;
    },
    rotateByQuatAppend: function (l, t, x) {
      var A = x[0],
        F = x[1],
        G = x[2];
      x = x[3];
      var I = t[0],
        L = t[1],
        M = t[2],
        O = t[3];
      l[0] = I * x + O * A + L * G - M * F;
      l[1] = L * x + O * F + M * A - I * G;
      l[2] = M * x + O * G + I * F - L * A;
      l[3] = O * x - I * A - L * F - M * G;
      I = t[4];
      L = t[5];
      M = t[6];
      O = t[7];
      l[4] = I * x + O * A + L * G - M * F;
      l[5] = L * x + O * F + M * A - I * G;
      l[6] = M * x + O * G + I * F - L * A;
      l[7] = O * x - I * A - L * F - M * G;
      return l;
    },
    rotateByQuatPrepend: function (l, t, x) {
      var A = t[0],
        F = t[1],
        G = t[2];
      t = t[3];
      var I = x[0],
        L = x[1],
        M = x[2],
        O = x[3];
      l[0] = A * O + t * I + F * M - G * L;
      l[1] = F * O + t * L + G * I - A * M;
      l[2] = G * O + t * M + A * L - F * I;
      l[3] = t * O - A * I - F * L - G * M;
      I = x[4];
      L = x[5];
      M = x[6];
      O = x[7];
      l[4] = A * O + t * I + F * M - G * L;
      l[5] = F * O + t * L + G * I - A * M;
      l[6] = G * O + t * M + A * L - F * I;
      l[7] = t * O - A * I - F * L - G * M;
      return l;
    },
    rotateAroundAxis: function (l, t, x, A) {
      if (1e-6 > Math.abs(A)) return zb(l, t);
      var F = Math.hypot(x[0], x[1], x[2]);
      A *= 0.5;
      var G = Math.sin(A),
        I = (G * x[0]) / F,
        L = (G * x[1]) / F;
      x = (G * x[2]) / F;
      A = Math.cos(A);
      F = t[0];
      G = t[1];
      var M = t[2],
        O = t[3];
      l[0] = F * A + O * I + G * x - M * L;
      l[1] = G * A + O * L + M * I - F * x;
      l[2] = M * A + O * x + F * L - G * I;
      l[3] = O * A - F * I - G * L - M * x;
      F = t[4];
      G = t[5];
      M = t[6];
      t = t[7];
      l[4] = F * A + t * I + G * x - M * L;
      l[5] = G * A + t * L + M * I - F * x;
      l[6] = M * A + t * x + F * L - G * I;
      l[7] = t * A - F * I - G * L - M * x;
      return l;
    },
    add: function (l, t, x) {
      l[0] = t[0] + x[0];
      l[1] = t[1] + x[1];
      l[2] = t[2] + x[2];
      l[3] = t[3] + x[3];
      l[4] = t[4] + x[4];
      l[5] = t[5] + x[5];
      l[6] = t[6] + x[6];
      l[7] = t[7] + x[7];
      return l;
    },
    multiply: eb,
    mul: eb,
    scale: function (l, t, x) {
      l[0] = t[0] * x;
      l[1] = t[1] * x;
      l[2] = t[2] * x;
      l[3] = t[3] * x;
      l[4] = t[4] * x;
      l[5] = t[5] * x;
      l[6] = t[6] * x;
      l[7] = t[7] * x;
      return l;
    },
    dot: Xa,
    lerp: function (l, t, x, A) {
      var F = 1 - A;
      0 > Xa(t, x) && (A = -A);
      l[0] = t[0] * F + x[0] * A;
      l[1] = t[1] * F + x[1] * A;
      l[2] = t[2] * F + x[2] * A;
      l[3] = t[3] * F + x[3] * A;
      l[4] = t[4] * F + x[4] * A;
      l[5] = t[5] * F + x[5] * A;
      l[6] = t[6] * F + x[6] * A;
      l[7] = t[7] * F + x[7] * A;
      return l;
    },
    invert: function (l, t) {
      var x = Ga(t);
      l[0] = -t[0] / x;
      l[1] = -t[1] / x;
      l[2] = -t[2] / x;
      l[3] = t[3] / x;
      l[4] = -t[4] / x;
      l[5] = -t[5] / x;
      l[6] = -t[6] / x;
      l[7] = t[7] / x;
      return l;
    },
    conjugate: function (l, t) {
      l[0] = -t[0];
      l[1] = -t[1];
      l[2] = -t[2];
      l[3] = t[3];
      l[4] = -t[4];
      l[5] = -t[5];
      l[6] = -t[6];
      l[7] = t[7];
      return l;
    },
    length: xa,
    len: xa,
    squaredLength: Ga,
    sqrLen: Ga,
    normalize: function (l, t) {
      var x = Ga(t);
      if (0 < x) {
        x = Math.sqrt(x);
        var A = t[0] / x,
          F = t[1] / x,
          G = t[2] / x,
          I = t[3] / x,
          L = t[4],
          M = t[5],
          O = t[6];
        t = t[7];
        var R = A * L + F * M + G * O + I * t;
        l[0] = A;
        l[1] = F;
        l[2] = G;
        l[3] = I;
        l[4] = (L - A * R) / x;
        l[5] = (M - F * R) / x;
        l[6] = (O - G * R) / x;
        l[7] = (t - I * R) / x;
      }
      return l;
    },
    str: function (l) {
      return (
        "quat2(" +
        l[0] +
        ", " +
        l[1] +
        ", " +
        l[2] +
        ", " +
        l[3] +
        ", " +
        l[4] +
        ", " +
        l[5] +
        ", " +
        l[6] +
        ", " +
        l[7] +
        ")"
      );
    },
    exactEquals: function (l, t) {
      return (
        l[0] === t[0] &&
        l[1] === t[1] &&
        l[2] === t[2] &&
        l[3] === t[3] &&
        l[4] === t[4] &&
        l[5] === t[5] &&
        l[6] === t[6] &&
        l[7] === t[7]
      );
    },
    equals: function (l, t) {
      var x = l[0],
        A = l[1],
        F = l[2],
        G = l[3],
        I = l[4],
        L = l[5],
        M = l[6];
      l = l[7];
      var O = t[0],
        R = t[1],
        T = t[2],
        Y = t[3],
        X = t[4],
        fa = t[5],
        ha = t[6];
      t = t[7];
      return (
        Math.abs(x - O) <= 1e-6 * Math.max(1, Math.abs(x), Math.abs(O)) &&
        Math.abs(A - R) <= 1e-6 * Math.max(1, Math.abs(A), Math.abs(R)) &&
        Math.abs(F - T) <= 1e-6 * Math.max(1, Math.abs(F), Math.abs(T)) &&
        Math.abs(G - Y) <= 1e-6 * Math.max(1, Math.abs(G), Math.abs(Y)) &&
        Math.abs(I - X) <= 1e-6 * Math.max(1, Math.abs(I), Math.abs(X)) &&
        Math.abs(L - fa) <= 1e-6 * Math.max(1, Math.abs(L), Math.abs(fa)) &&
        Math.abs(M - ha) <= 1e-6 * Math.max(1, Math.abs(M), Math.abs(ha)) &&
        Math.abs(l - t) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(t))
      );
    },
  });
  $a = (function () {
    var l = Wa();
    return function (t, x, A, F, G, I) {
      x || (x = 2);
      A || (A = 0);
      for (F = F ? Math.min(F * x + A, t.length) : t.length; A < F; A += x)
        (l[0] = t[A]),
          (l[1] = t[A + 1]),
          G(l, l, I),
          (t[A] = l[0]),
          (t[A + 1] = l[1]);
      return t;
    };
  })();
  $a = Object.freeze({
    __proto__: null,
    create: Wa,
    clone: function (l) {
      var t = new sa(2);
      t[0] = l[0];
      t[1] = l[1];
      return t;
    },
    fromValues: function (l, t) {
      var x = new sa(2);
      x[0] = l;
      x[1] = t;
      return x;
    },
    copy: function (l, t) {
      l[0] = t[0];
      l[1] = t[1];
      return l;
    },
    set: function (l, t, x) {
      l[0] = t;
      l[1] = x;
      return l;
    },
    add: function (l, t, x) {
      l[0] = t[0] + x[0];
      l[1] = t[1] + x[1];
      return l;
    },
    subtract: fb,
    multiply: gb,
    divide: Ya,
    ceil: function (l, t) {
      l[0] = Math.ceil(t[0]);
      l[1] = Math.ceil(t[1]);
      return l;
    },
    floor: function (l, t) {
      l[0] = Math.floor(t[0]);
      l[1] = Math.floor(t[1]);
      return l;
    },
    min: function (l, t, x) {
      l[0] = Math.min(t[0], x[0]);
      l[1] = Math.min(t[1], x[1]);
      return l;
    },
    max: function (l, t, x) {
      l[0] = Math.max(t[0], x[0]);
      l[1] = Math.max(t[1], x[1]);
      return l;
    },
    round: function (l, t) {
      l[0] = Math.round(t[0]);
      l[1] = Math.round(t[1]);
      return l;
    },
    scale: function (l, t, x) {
      l[0] = t[0] * x;
      l[1] = t[1] * x;
      return l;
    },
    scaleAndAdd: function (l, t, x, A) {
      l[0] = t[0] + x[0] * A;
      l[1] = t[1] + x[1] * A;
      return l;
    },
    distance: hb,
    squaredDistance: Ta,
    length: ib,
    squaredLength: jb,
    negate: function (l, t) {
      l[0] = -t[0];
      l[1] = -t[1];
      return l;
    },
    inverse: function (l, t) {
      l[0] = 1 / t[0];
      l[1] = 1 / t[1];
      return l;
    },
    normalize: function (l, t) {
      var x = t[0],
        A = t[1];
      x = x * x + A * A;
      0 < x && (x = 1 / Math.sqrt(x));
      l[0] = t[0] * x;
      l[1] = t[1] * x;
      return l;
    },
    dot: function (l, t) {
      return l[0] * t[0] + l[1] * t[1];
    },
    cross: function (l, t, x) {
      t = t[0] * x[1] - t[1] * x[0];
      l[0] = l[1] = 0;
      l[2] = t;
      return l;
    },
    lerp: function (l, t, x, A) {
      var F = t[0];
      t = t[1];
      l[0] = F + A * (x[0] - F);
      l[1] = t + A * (x[1] - t);
      return l;
    },
    random: function (l, t) {
      t = t || 1;
      var x = 2 * Sa() * Math.PI;
      l[0] = Math.cos(x) * t;
      l[1] = Math.sin(x) * t;
      return l;
    },
    transformMat2: function (l, t, x) {
      var A = t[0];
      t = t[1];
      l[0] = x[0] * A + x[2] * t;
      l[1] = x[1] * A + x[3] * t;
      return l;
    },
    transformMat2d: function (l, t, x) {
      var A = t[0];
      t = t[1];
      l[0] = x[0] * A + x[2] * t + x[4];
      l[1] = x[1] * A + x[3] * t + x[5];
      return l;
    },
    transformMat3: function (l, t, x) {
      var A = t[0];
      t = t[1];
      l[0] = x[0] * A + x[3] * t + x[6];
      l[1] = x[1] * A + x[4] * t + x[7];
      return l;
    },
    transformMat4: function (l, t, x) {
      var A = t[0];
      t = t[1];
      l[0] = x[0] * A + x[4] * t + x[12];
      l[1] = x[1] * A + x[5] * t + x[13];
      return l;
    },
    rotate: function (l, t, x, A) {
      var F = t[0] - x[0];
      t = t[1] - x[1];
      var G = Math.sin(A);
      A = Math.cos(A);
      l[0] = F * A - t * G + x[0];
      l[1] = F * G + t * A + x[1];
      return l;
    },
    angle: function (l, t) {
      var x = l[0];
      l = l[1];
      var A = t[0];
      t = t[1];
      var F = Math.sqrt((x * x + l * l) * (A * A + t * t));
      return Math.acos(Math.min(Math.max(F && (x * A + l * t) / F, -1), 1));
    },
    zero: function (l) {
      l[0] = 0;
      l[1] = 0;
      return l;
    },
    str: function (l) {
      return "vec2(" + l[0] + ", " + l[1] + ")";
    },
    exactEquals: function (l, t) {
      return l[0] === t[0] && l[1] === t[1];
    },
    equals: function (l, t) {
      var x = l[0];
      l = l[1];
      var A = t[0];
      t = t[1];
      return (
        Math.abs(x - A) <= 1e-6 * Math.max(1, Math.abs(x), Math.abs(A)) &&
        Math.abs(l - t) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(t))
      );
    },
    len: ib,
    sub: fb,
    mul: gb,
    div: Ya,
    dist: hb,
    sqrDist: Ta,
    sqrLen: jb,
    forEach: $a,
  });
  e.glMatrix = Db;
  e.mat2 = Eb;
  e.mat2d = Fb;
  e.mat3 = Gb;
  e.mat4 = Hb;
  e.quat = mb;
  e.quat2 = nb;
  e.vec2 = $a;
  e.vec3 = kb;
  e.vec4 = lb;
  Object.defineProperty(e, "__esModule", { value: !0 });
});
{
  ("use strict");
  function e(C, H, K) {
    var P = [0, 0];
    var S = C[1][1] - C[0][1];
    var U = C[0][0] - C[1][0];
    C = S * C[0][0] + U * C[0][1];
    var V = H[1][1] - H[0][1];
    var aa = H[0][0] - H[1][0];
    H = V * H[0][0] + aa * H[0][1];
    var ma = S * aa - V * U;
    D(ma, 0, K || 0) ||
      ((P[0] = (aa * C - U * H) / ma), (P[1] = (S * H - V * C) / ma));
    return P;
  }
  function b(C, H, K, P) {
    var S = H[0] - C[0];
    H = H[1] - C[1];
    var U = P[0] - K[0],
      V = P[1] - K[1];
    if (0 === U * H - V * S) return !1;
    P = (S * (K[1] - C[1]) + H * (C[0] - K[0])) / (U * H - V * S);
    C = (U * (C[1] - K[1]) + V * (K[0] - C[0])) / (V * S - U * H);
    return 0 <= P && 1 >= P && 0 <= C && 1 >= C;
  }
  function a(C, H, K) {
    return (H[0] - C[0]) * (K[1] - C[1]) - (K[0] - C[0]) * (H[1] - C[1]);
  }
  function c(C, H, K) {
    return 0 < a(C, H, K);
  }
  function d(C, H, K) {
    return 0 <= a(C, H, K);
  }
  function f(C, H, K) {
    return 0 > a(C, H, K);
  }
  function h(C, H, K) {
    return 0 >= a(C, H, K);
  }
  var tmpPoint1$$module$str$c3runtime = [],
    tmpPoint2$$module$str$c3runtime = [];
  function g(C, H, K, P) {
    if (P) {
      var S = tmpPoint1$$module$str$c3runtime,
        U = tmpPoint2$$module$str$c3runtime;
      S[0] = H[0] - C[0];
      S[1] = H[1] - C[1];
      U[0] = K[0] - H[0];
      U[1] = K[1] - H[1];
      return (
        Math.acos(
          (S[0] * U[0] + S[1] * U[1]) /
            (Math.sqrt(S[0] * S[0] + S[1] * S[1]) *
              Math.sqrt(U[0] * U[0] + U[1] * U[1]))
        ) < P
      );
    }
    return 0 === a(C, H, K);
  }
  function k(C, H) {
    var K = H[0] - C[0];
    C = H[1] - C[1];
    return K * K + C * C;
  }
  function m(C, H) {
    var K = C.length;
    return C[0 > H ? (H % K) + K : H % K];
  }
  function q(C) {
    C.length = 0;
  }
  function v(C, H, K, P) {
    for (; K < P; K++) C.push(H[K]);
  }
  function r(C) {
    for (var H = [], K = C.length, P = 0; P !== K; P++) H.push(C.pop());
    for (P = 0; P !== K; P++) C[P] = H[P];
  }
  function n(C, H) {
    return f(m(C, H - 1), m(C, H), m(C, H + 1));
  }
  var tmpLine1$$module$str$c3runtime = [],
    tmpLine2$$module$str$c3runtime = [];
  function p(C, H, K) {
    var P = tmpLine1$$module$str$c3runtime,
      S = tmpLine2$$module$str$c3runtime;
    if (d(m(C, H + 1), m(C, H), m(C, K)) && h(m(C, H - 1), m(C, H), m(C, K)))
      return !1;
    var U = k(m(C, H), m(C, K));
    for (var V = 0; V !== C.length; ++V)
      if (
        (V + 1) % C.length !== H &&
        V !== H &&
        d(m(C, H), m(C, K), m(C, V + 1)) &&
        h(m(C, H), m(C, K), m(C, V))
      ) {
        P[0] = m(C, H);
        P[1] = m(C, K);
        S[0] = m(C, V);
        S[1] = m(C, V + 1);
        var aa = e(P, S);
        if (k(m(C, H), aa) < U) return !1;
      }
    return !0;
  }
  function u(C, H, K) {
    for (var P = 0; P !== C.length; ++P)
      if (
        P !== H &&
        P !== K &&
        (P + 1) % C.length !== H &&
        (P + 1) % C.length !== K &&
        b(m(C, H), m(C, K), m(C, P), m(C, P + 1))
      )
        return !1;
    return !0;
  }
  function w(C, H, K, P) {
    P = P || [];
    q(P);
    if (H < K) for (var S = H; S <= K; S++) P.push(C[S]);
    else {
      for (S = 0; S <= K; S++) P.push(C[S]);
      for (S = H; S < C.length; S++) P.push(C[S]);
    }
    return P;
  }
  function y(C) {
    for (
      var H = [], K, P, S = [], U = Number.MAX_VALUE, V = 0;
      V < C.length;
      ++V
    )
      if (n(C, V))
        for (var aa = 0; aa < C.length; ++aa)
          if (p(C, V, aa)) {
            K = y(w(C, V, aa, S));
            P = y(w(C, aa, V, S));
            for (var ma = 0; ma < P.length; ma++) K.push(P[ma]);
            K.length < U &&
              ((H = K), (U = K.length), H.push([m(C, V), m(C, aa)]));
          }
    return H;
  }
  function B(C, H) {
    if (0 === H.length) return [C];
    if (
      H instanceof Array &&
      H.length &&
      H[0] instanceof Array &&
      2 === H[0].length &&
      H[0][0] instanceof Array
    ) {
      C = [C];
      for (var K = 0; K < H.length; K++)
        for (var P = H[K], S = 0; S < C.length; S++) {
          var U = B(C[S], P);
          if (U) {
            C.splice(S, 1);
            C.push(U[0], U[1]);
            break;
          }
        }
      return C;
    }
    P = H;
    K = C.indexOf(P[0]);
    S = C.indexOf(P[1]);
    return -1 !== K && -1 !== S ? [w(C, K, S), w(C, S, K)] : !1;
  }
  function E(C, H, K, P, S) {
    var U = H[1] - C[1];
    H = C[0] - H[0];
    C = U * C[0] + H * C[1];
    var V = P[1] - K[1];
    P = K[0] - P[0];
    K = V * K[0] + P * K[1];
    var aa = U * P - V * H;
    return D(aa, 0, S || 0)
      ? [0, 0]
      : [(P * C - H * K) / aa, (U * K - V * C) / aa];
  }
  function z(C, H, K, P, S, U, V) {
    U = U || 100;
    V = V || 0;
    S = S || 25;
    H = "undefined" !== typeof H ? H : [];
    K = K || [];
    P = P || [];
    var aa = [0, 0],
      ma = [0, 0],
      va = [0, 0],
      Na,
      Ea = 0,
      Ia = 0,
      Ma = 0,
      Fa = [],
      ya = [];
    if (3 > C.length) return H;
    V++;
    if (V > U)
      return console.warn("quickDecomp: max level (" + U + ") reached."), H;
    for (var na = 0; na < C.length; ++na)
      if (n(C, na)) {
        K.push(C[na]);
        var Va = (Na = Number.MAX_VALUE);
        for (var xa = 0; xa < C.length; ++xa) {
          if (
            c(m(C, na - 1), m(C, na), m(C, xa)) &&
            h(m(C, na - 1), m(C, na), m(C, xa - 1)) &&
            ((va = E(m(C, na - 1), m(C, na), m(C, xa), m(C, xa - 1))),
            f(m(C, na + 1), m(C, na), va))
          ) {
            var Ga = k(C[na], va);
            Ga < Na && ((Na = Ga), (ma = va), (Ia = xa));
          }
          c(m(C, na + 1), m(C, na), m(C, xa + 1)) &&
            h(m(C, na + 1), m(C, na), m(C, xa)) &&
            ((va = E(m(C, na + 1), m(C, na), m(C, xa), m(C, xa + 1))),
            c(m(C, na - 1), m(C, na), va) &&
              ((Ga = k(C[na], va)),
              Ga < Va && ((Va = Ga), (aa = va), (Ea = xa))));
        }
        if (Ia === (Ea + 1) % C.length)
          (va[0] = (ma[0] + aa[0]) / 2),
            (va[1] = (ma[1] + aa[1]) / 2),
            P.push(va),
            na < Ea
              ? (v(Fa, C, na, Ea + 1),
                Fa.push(va),
                ya.push(va),
                0 !== Ia && v(ya, C, Ia, C.length),
                v(ya, C, 0, na + 1))
              : (0 !== na && v(Fa, C, na, C.length),
                v(Fa, C, 0, Ea + 1),
                Fa.push(va),
                ya.push(va),
                v(ya, C, Ia, na + 1));
        else {
          Ia > Ea && (Ea += C.length);
          aa = Number.MAX_VALUE;
          if (Ea < Ia) return H;
          for (xa = Ia; xa <= Ea; ++xa)
            d(m(C, na - 1), m(C, na), m(C, xa)) &&
              h(m(C, na + 1), m(C, na), m(C, xa)) &&
              ((Ga = k(m(C, na), m(C, xa))),
              Ga < aa && u(C, na, xa) && ((aa = Ga), (Ma = xa % C.length)));
          na < Ma
            ? (v(Fa, C, na, Ma + 1),
              0 !== Ma && v(ya, C, Ma, C.length),
              v(ya, C, 0, na + 1))
            : (0 !== na && v(Fa, C, na, C.length),
              v(Fa, C, 0, Ma + 1),
              v(ya, C, Ma, na + 1));
        }
        Fa.length < ya.length
          ? (z(Fa, H, K, P, S, U, V), z(ya, H, K, P, S, U, V))
          : (z(ya, H, K, P, S, U, V), z(Fa, H, K, P, S, U, V));
        return H;
      }
    H.push(C);
    return H;
  }
  function D(C, H, K) {
    return Math.abs(C - H) <= (K || 0);
  }
  function J(C, H, K) {
    return D(C[0], H[0], K) && D(C[1], H[1], K);
  }
  self.polyDecomp = {
    decomp: function (C) {
      var H = y(C);
      return 0 < H.length ? B(C, H) : [C];
    },
    quickDecomp: z,
    isSimple: function (C) {
      var H;
      for (H = 0; H < C.length - 1; H++)
        for (var K = 0; K < H - 1; K++)
          if (b(C[H], C[H + 1], C[K], C[K + 1])) return !1;
      for (H = 1; H < C.length - 2; H++)
        if (b(C[0], C[C.length - 1], C[H], C[H + 1])) return !1;
      return !0;
    },
    removeCollinearPoints: function (C, H) {
      for (var K = 0, P = C.length - 1; 3 < C.length && 0 <= P; --P)
        g(m(C, P - 1), m(C, P), m(C, P + 1), H) &&
          (C.splice(P % C.length, 1), K++);
      return K;
    },
    removeDuplicatePoints: function (C, H) {
      for (var K = C.length - 1; 1 <= K; --K)
        for (var P = C[K], S = K - 1; 0 <= S; --S)
          J(P, C[S], H) && C.splice(K, 1);
    },
    makeCCW: function (C) {
      for (var H = 0, K = 1; K < C.length; ++K)
        if (C[K][1] < C[H][1] || (C[K][1] === C[H][1] && C[K][0] > C[H][0]))
          H = K;
      if (c(m(C, H - 1), m(C, H), m(C, H + 1))) return !1;
      r(C);
      return !0;
    },
  };
}
{
  ("use strict");
  let e = !1,
    b = !1,
    a = "dev";
  const c = (self.C3 = class {
    constructor() {
      throw TypeError("static class can't be instantiated");
    }
    static SetReady() {
      e = !0;
    }
    static IsReady() {
      return e;
    }
    static SetAppStarted() {
      b = !0;
    }
    static HasAppStarted() {
      return b;
    }
    static SetBuildMode(d) {
      a = d;
    }
    static GetBuildMode() {
      return a;
    }
    static IsReleaseBuild() {
      return "final" === a;
    }
  });
  c.isDebug = !1;
  c.isDebugDefend = !1;
  c.hardwareConcurrency = navigator.hardwareConcurrency || 2;
  self.C3X = {};
}
{
  ("use strict");
  const e = self.C3;
  e.QueryParser = class {
    constructor(b) {
      this._queryString = b;
      this._parameters = new Map();
      this._Parse();
    }
    _Parse() {
      var b = this._queryString;
      if (b.startsWith("?") || b.startsWith("#")) b = b.substr(1);
      b = b.split("&");
      for (const a of b) this._ParseParameter(a);
    }
    _ParseParameter(b) {
      if (b)
        if (b.includes("=")) {
          var a = b.indexOf("="),
            c = decodeURIComponent(b.substring(0, a));
          b = decodeURIComponent(b.substring(a + 1));
          this._parameters.set(c, b);
        } else this._parameters.set(b, null);
    }
    LogAll() {
      for (const b of this._parameters)
        console.log(
          "[QueryParser] Parameter '" +
            b[0] +
            "' = " +
            (null === b[1] ? "null" : "'" + b[1] + "'")
        );
    }
    Has(b) {
      return this._parameters.has(b);
    }
    Get(b) {
      b = this._parameters.get(b);
      return "undefined" === typeof b ? null : b;
    }
    ClearHash() {
      history.replaceState(
        "",
        document.title,
        location.pathname + location.search
      );
    }
    Reparse(b) {
      this._queryString = b;
      this._parameters.clear();
      this._Parse();
    }
  };
  e.QueryString = new e.QueryParser(location.search);
  e.LocationHashString = new e.QueryParser(location.hash);
  e.QueryString.Has("perf") && (e.isPerformanceProfiling = !0);
  "dev" !== e.QueryString.Get("mode") && e.SetBuildMode("final");
}
{
  ("use strict");
  const e = self.C3,
    b = navigator.userAgent;
  let a = {
    linux: /linux|openbsd|freebsd|netbsd/i.test(b),
    chromeOS: /CrOS/.test(b),
    windowsTizen: /trident|iemobile|msie|tizen/i.test(b),
    genericMS: /trident|iemobile|msie|edge\//i.test(b),
    opera: /OPR\//.test(b),
    blackberry: /bb10/i.test(b),
    edge: /edge\//i.test(b),
    trident: /trident/i.test(b),
    webkit: /webkit/i.test(b),
    safari: /safari\//i.test(b),
    chrome: /chrome\//i.test(b),
    chromium: /chromium\//i.test(b),
    crosswalk: /crosswalk|xwalk/i.test(b),
    nwjs: /nwjs/i.test(b),
    amazonwebapp: /amazonwebappplatform/i.test(b),
    webview: /wv\)/.test(b),
    android: /android/i.test(b),
    nokia: /nokiabrowser\/[0-9.]+/i.test(b),
  };
  var JSCompiler_object_inline_windows_5 = /windows\s+nt\s+\d+\.\d+/i.exec(b),
    JSCompiler_object_inline_OSX_6 = /mac\s+os\s+x\s+[0-9_]+/i.exec(b),
    JSCompiler_object_inline_android_7 = /android\s+[0-9.]+/i.exec(b),
    JSCompiler_object_inline_opera_8 = /OPR\/[0-9.]+/.exec(b),
    JSCompiler_object_inline_tizen_9 = /tizen\s+[0-9.]+/i.exec(b),
    JSCompiler_object_inline_iphone_10 = /iphone\s+os\s+[0-9_]+/i.exec(b),
    JSCompiler_object_inline_ipad_11 = /ipad[^)]*os\s+[0-9_]+/i.exec(b),
    JSCompiler_object_inline_winPhone_12 = /windows\s+phone\s+[0-9.]+/i.exec(b),
    JSCompiler_object_inline_winPhoneOS_13 =
      /windows\s+phone\s+os\s+[0-9.]+/i.exec(b),
    JSCompiler_object_inline_chrome_14 = /chrome\/[0-9.]+/i.exec(b),
    JSCompiler_object_inline_chromium_15 = /chromium\/[0-9.]+/i.exec(b),
    JSCompiler_object_inline_nwjs_16 = /nwjs\/[0-9.]+/i.exec(b),
    JSCompiler_object_inline_firefox_17 = /firefox\/[0-9.]+/i.exec(b),
    JSCompiler_object_inline_ie_18 = /msie\s+[0-9.]+/i.exec(b),
    JSCompiler_object_inline_edge_19 = /edge\/[0-9.]+/i.exec(b),
    JSCompiler_object_inline_edgeChromium_20 = /edg\/[0-9.]+/i.exec(b),
    JSCompiler_object_inline_silk_21 = /silk\/[0-9.]+/i.exec(b);
  let c = "(unknown)",
    d = "(unknown)",
    f = "(unknown)",
    h = "(unknown)",
    g = "(unknown)",
    k = "browser",
    m = !1,
    q = !1,
    v = new Map();
  function r(p, u, w) {
    !0 === u ? (w(), v.set(p, !0)) : u && u.length && (w(u[0]), v.set(p, !0));
  }
  r("isWindows", JSCompiler_object_inline_windows_5, (p) => {
    c = "Windows";
    if ((p = p.split(" ")[2]))
      switch (p) {
        case "5.0":
          d = "2000";
          break;
        case "5.1":
          d = "XP";
          break;
        case "5.2":
          d = "XP";
          break;
        case "6.0":
          d = "Vista";
          break;
        case "6.1":
          d = "7";
          break;
        case "6.2":
          d = "8";
          break;
        case "6.3":
          d = "8.1";
          break;
        case "10.0":
          d = "10";
      }
  });
  r("isOSX", JSCompiler_object_inline_OSX_6, (p) => {
    c = "Mac OS X";
    (p = p.split(" ")[3]) && (d = p.replace("_", "."));
  });
  r("isLinux", a.linux, () => {
    c = "Linux";
  });
  r("isChromeOS", a.chromeOS, () => {
    c = "Chrome OS";
  });
  r("isAndroid", !a.windowsTizen && JSCompiler_object_inline_android_7, (p) => {
    c = "Android";
    (p = p.split(" ")[1]) && (d = p);
  });
  r("isTizen", JSCompiler_object_inline_tizen_9, (p) => {
    c = "Tizen";
    (p = p.split(" ")[1]) && (d = p);
  });
  r("isIPhone", !a.windowsTizen && JSCompiler_object_inline_iphone_10, (p) => {
    c = "iOS";
    (p = p.split(" ")[2]) && (d = p.replace("_", "."));
  });
  r("isIPad", !a.windowsTizen && JSCompiler_object_inline_ipad_11, (p) => {
    c = "iOS";
    (p = p.split(" ")[3]) && (d = p.replace("_", "."));
  });
  r("isWindowsPhone", JSCompiler_object_inline_winPhone_12, (p) => {
    c = "Windows Phone";
    (p = p.split(" ")[2]) && (d = p);
  });
  r("isWindowsPhoneOS", JSCompiler_object_inline_winPhoneOS_13, (p) => {
    c = "Windows Phone";
    (p = p.split(" ")[3]) && (d = p);
  });
  r("isBlackberry", a.blackberry, () => {
    c = "Blackberry";
    d = "10";
    f = "stock";
    g = "webkit";
  });
  r(
    "isChrome",
    !a.edge && !a.opera && JSCompiler_object_inline_chrome_14,
    (p) => {
      f = "Chrome";
      g = "Chromium";
      (p = p.split("/")[1]) && (h = p);
    }
  );
  r("isOpera", JSCompiler_object_inline_opera_8, (p) => {
    f = "Opera";
    g = "Chromium";
    (p = p.split("/")[1]) && (h = p);
  });
  r("isChromium", JSCompiler_object_inline_chromium_15, (p) => {
    g = f = "Chromium";
    (p = p.split("/")[1]) && (h = p);
  });
  r("isFirefox", JSCompiler_object_inline_firefox_17, (p) => {
    f = "Firefox";
    g = "Gecko";
    (p = p.split("/")[1]) && (h = p);
  });
  r("isInternetExplorer", JSCompiler_object_inline_ie_18, (p) => {
    f = "Internet Explorer";
    g = "Trident";
    (p = p.split(" ")[1]) && (h = p);
  });
  r("isTrident", "Internet Explorer" !== f && a.trident, () => {
    g = "Trident";
    var p = /rv:[0-9.]+/i.exec(b);
    p &&
      p.length &&
      ((f = "Internet Explorer"), (p = p[0].split(":")[1]) && (h = p));
  });
  r("isEdge", JSCompiler_object_inline_edge_19, (p) => {
    g = f = "Edge";
    (p = p.split("/")[1]) && (h = p);
  });
  r("isEdgeChromium", JSCompiler_object_inline_edgeChromium_20, (p) => {
    f = "Edge";
    g = "Chromium";
    (p = p.split("/")[1]) && (h = p);
  });
  r(
    "isSafari",
    a.safari &&
      !a.nokia &&
      !a.chrome &&
      !a.chromium &&
      !a.genericIE &&
      !a.blackberry,
    () => {
      f = "Safari";
      g = "WebKit";
      var p = /version\/[0-9.]+/i.exec(b),
        u = /crios\/[0-9.]+/i.exec(b),
        w = /fxios\/[0-9.]+/i.exec(b);
      p && p.length && (p = p[0].split("/")[1]) && (h = p);
      u &&
        u.length &&
        ((f = "Chrome for iOS"), (u = u[0].split("/")[1]) && (h = u));
      w &&
        w.length &&
        ((f = "Firefox for iOS"), (w = w[0].split("/")[1]) && (h = w));
    }
  );
  r("isSilk", JSCompiler_object_inline_silk_21, (p) => {
    f = "Silk";
    (p = p.split("/")[1]) && (h = p);
  });
  r("isCrosswalk", a.crosswalk, () => (k = "crosswalk"));
  r(
    "isCordova",
    self.device && (self.device.cordova || self.device.phonegap),
    () => (k = "cordova")
  );
  r("isNWJS", JSCompiler_object_inline_nwjs_16, (p) => {
    k = "nwjs";
    f = "NW.js";
    g = "Chromium";
    (p = p.split("/")[1]) && (h = p);
  });
  r("isAmazonWebApp", a.amazonwebapp, () => (k = "webapp"));
  r(
    "isHomeScreenWebApp",
    "nwjs" !== k &&
      "undefined" !== typeof window &&
      ((window.matchMedia &&
        window.matchMedia("(display-mode: standalone)").matches) ||
        navigator.standalone),
    () => (k = "webapp")
  );
  r(
    "isFalseSafari",
    "Safari" === f && ("Android" === c || "Tizen" === c || "Blackberry" === c),
    () => (f = "stock")
  );
  r(
    "isAndroidWebview",
    "Chrome" === f && "browser" === k && a.webview,
    () => (k = "webview")
  );
  r(
    "isFirefoxOS",
    "Firefox" === f && "(unknown)" === c,
    () => (c = "Firefox OS")
  );
  r(
    "isAndroidFallback",
    "(unknown)" === c && !a.windowsTizen && a.android,
    () => (c = "Android")
  );
  r("isTridentFallback", "(unknown)" === c && a.trident, () => (g = "Trident"));
  r("isWebkitFallback", "(unknown)" === c && a.webkit, () => (g = "WebKit"));
  r(
    "isDesktop",
    (() =>
      "Windows" === c ||
      "Mac OS X" === c ||
      "Linux" === c ||
      "Chrome OS" === c ||
      "nwjs" === k)(),
    () => (m = !0)
  );
  q = "nwjs" === k;
  const n =
    "Mac OS X" === c &&
    navigator.maxTouchPoints &&
    2 < navigator.maxTouchPoints;
  n && ((c = "iOS"), (d = h), (q = m = !1));
  e.Platform = {
    OS: c,
    OSVersion: d,
    Browser: f,
    BrowserVersion: h,
    BrowserVersionNumber: parseFloat(h),
    BrowserEngine: g,
    Context: k,
    IsDesktop: m,
    IsMobile: !m,
    IsDesktopApp: q,
    IsChromeWebStore: !!(
      self.chrome &&
      self.chrome.runtime &&
      self.chrome.runtime.id
    ),
    IsAppleOS: "Mac OS X" === c || "iOS" === c,
    IsIpadOS: n,
    IsLinux: "Linux" === c,
  };
}
("use strict");
{
  const e = new Map(),
    b =
      "undefined" !== typeof IDBObjectStore &&
      "function" === typeof IDBObjectStore.prototype.getAll,
    a =
      "undefined" !== typeof IDBObjectStore &&
      "function" === typeof IDBObjectStore.prototype.getAllKeys;
  function c(n) {
    return new Promise((p, u) => {
      n.onsuccess = () => p(n.result);
      n.onerror = () => u(n.error);
    });
  }
  function d(n) {
    return new Promise((p, u) => {
      n.oncomplete = () => p();
      n.onerror = () => u(n.error);
      n.onabort = () => u(n.error);
    });
  }
  function f(n, p) {
    return g(n, p);
  }
  function h(n, p) {
    return g(n, p, !0);
  }
  async function g(n, p, u = !1, w = !0) {
    const y = await k(n);
    try {
      const B = y.transaction(["keyvaluepairs"], u ? "readwrite" : "readonly");
      return p(B);
    } catch (B) {
      if (w && "InvalidStateError" === B.name)
        return e.delete(n), g(n, p, u, !1);
      throw B;
    }
  }
  function k(n) {
    q(n);
    let p = e.get(n);
    p instanceof Promise ||
      ((p = m(n)), e.set(n, p), p.catch((u) => e.delete(n)));
    return p;
  }
  async function m(n) {
    q(n);
    const p = indexedDB.open(n, 2);
    p.addEventListener("upgradeneeded", (u) => {
      try {
        u.target.result.createObjectStore("keyvaluepairs");
      } catch (w) {
        console.error(`Failed to create objectstore for database ${n}`, w);
      }
    });
    return c(p);
  }
  function q(n) {
    if ("string" !== typeof n) throw new TypeError("expected string");
  }
  function v(n, p) {
    const u = n.objectStore("keyvaluepairs").openCursor();
    return new Promise((w) => {
      const y = [];
      u.onsuccess = (B) => {
        if ((B = B.target.result)) {
          switch (p) {
            case "entries":
              y.push([B.key, B.value]);
              break;
            case "keys":
              y.push(B.key);
              break;
            case "values":
              y.push(B.value);
          }
          B.continue();
        } else w(y);
      };
    });
  }
  class r {
    constructor(n) {
      q(n);
      this.name = n;
    }
    async ready() {
      await k(this.name);
    }
    set(n, p) {
      q(n);
      return h(this.name, async (u) => {
        var w = u.objectStore("keyvaluepairs").put(p, n);
        w = c(w);
        u = d(u);
        await Promise.all([u, w]);
      });
    }
    get(n) {
      q(n);
      return f(this.name, async (p) => {
        var u = p.objectStore("keyvaluepairs").get(n);
        u = c(u);
        p = d(p);
        [, p] = await Promise.all([p, u]);
        return p;
      });
    }
    delete(n) {
      q(n);
      return h(this.name, async (p) => {
        var u = p.objectStore("keyvaluepairs").delete(n);
        u = c(u);
        p = d(p);
        await Promise.all([p, u]);
      });
    }
    clear() {
      return h(this.name, async (n) => {
        var p = n.objectStore("keyvaluepairs").clear();
        p = c(p);
        n = d(n);
        await Promise.all([n, p]);
      });
    }
    keys() {
      return f(this.name, async (n) => {
        if (a) {
          var p = n.objectStore("keyvaluepairs").getAllKeys();
          p = c(p);
        } else p = v(n, "keys");
        n = d(n);
        [, n] = await Promise.all([n, p]);
        return n;
      });
    }
    values() {
      return f(this.name, async (n) => {
        if (b) {
          var p = n.objectStore("keyvaluepairs").getAll();
          p = c(p);
        } else p = v(n, "values");
        n = d(n);
        [, n] = await Promise.all([n, p]);
        return n;
      });
    }
    entries() {
      return f(this.name, async (n) => {
        var p = v(n, "entries");
        n = d(n);
        [, p] = await Promise.all([n, p]);
        return p;
      });
    }
  }
  self.KVStorageContainer = r;
}
("use strict");
{
  const e = self.KVStorageContainer,
    b = [
      /no available storage method found/i,
      /an attempt was made to break through the security policy of the user agent/i,
      /the user denied permission to access the database/i,
      /a mutation operation was attempted on a database that did not allow mutations/i,
      /idbfactory\.open\(\) called in an invalid security context/i,
    ],
    a = new WeakMap();
  let c = !1;
  "undefined" === typeof indexedDB &&
    ((c = !0),
    console.warn(
      "Unable to use local storage because indexedDB is not defined"
    ));
  function d(k) {
    throw Error(`"${k}" is not implemented`);
  }
  function f(k) {
    if ("function" === typeof k)
      throw Error(
        "localforage callback API is not implemented; please use the promise API instead"
      );
  }
  function h(k) {
    return "object" === typeof k
      ? new Promise((m) => {
          const { port1: q, port2: v } = new MessageChannel();
          v.onmessage = (r) => m(r.data);
          q.postMessage(k);
        })
      : Promise.resolve(k);
  }
  class g {
    constructor(k) {
      this._inst = k;
      a.set(this, new Map());
    }
    _MaybeSwitchToMemoryFallback(k) {
      if (!c)
        for (const m of b)
          if (k && m.test(k.message)) {
            console.error(
              "Unable to use local storage, reverting to in-memory store: ",
              k,
              k.message
            );
            c = !0;
            break;
          }
    }
    async _getItemFallback(k) {
      k = a.get(this).get(k);
      k = await h(k);
      return "undefined" === typeof k ? null : k;
    }
    async _setItemFallback(k, m) {
      m = await h(m);
      a.get(this).set(k, m);
    }
    _removeItemFallback(k) {
      a.get(this).delete(k);
    }
    _clearFallback() {
      a.get(this).clear();
    }
    _keysFallback() {
      return Array.from(a.get(this).keys());
    }
    IsUsingFallback() {
      return c;
    }
    async getItem(k, m) {
      f(m);
      if (c) return await this._getItemFallback(k);
      let q;
      try {
        q = await this._inst.get(k);
      } catch (v) {
        this._MaybeSwitchToMemoryFallback(v);
        if (c) return await this._getItemFallback(k);
        console.error(`Error reading '${k}' from storage, returning null: `, v);
        return null;
      }
      return "undefined" === typeof q ? null : q;
    }
    async setItem(k, m, q) {
      f(q);
      "undefined" === typeof m && (m = null);
      if (c) await this._setItemFallback(k, m);
      else
        try {
          await this._inst.set(k, m);
        } catch (v) {
          if ((this._MaybeSwitchToMemoryFallback(v), c))
            await this._setItemFallback(k, m);
          else throw v;
        }
    }
    async removeItem(k, m) {
      f(m);
      if (c) this._removeItemFallback(k);
      else
        try {
          await this._inst.delete(k);
        } catch (q) {
          this._MaybeSwitchToMemoryFallback(q),
            c
              ? this._removeItemFallback(k)
              : console.error(`Error removing '${k}' from storage: `, q);
        }
    }
    async clear(k) {
      f(k);
      if (c) this._clearFallback();
      else
        try {
          await this._inst.clear();
        } catch (m) {
          this._MaybeSwitchToMemoryFallback(m),
            c
              ? this._clearFallback()
              : console.error("Error clearing storage: ", m);
        }
    }
    async keys(k) {
      f(k);
      if (c) return this._keysFallback();
      k = [];
      try {
        k = await this._inst.keys();
      } catch (m) {
        this._MaybeSwitchToMemoryFallback(m);
        if (c) return this._keysFallback();
        console.error("Error getting storage keys: ", m);
      }
      return k;
    }
    ready(k) {
      f(k);
      return c ? Promise.resolve(!0) : this._inst.ready();
    }
    createInstance(k) {
      if ("object" !== typeof k) throw new TypeError("invalid options object");
      k = k.name;
      if ("string" !== typeof k) throw new TypeError("invalid store name");
      k = new e(k);
      return new g(k);
    }
    length(k) {
      d("localforage.length()");
    }
    key(k, m) {
      d("localforage.key()");
    }
    iterate(k, m) {
      d("localforage.iterate()");
    }
    setDriver(k) {
      d("localforage.setDriver()");
    }
    config(k) {
      d("localforage.config()");
    }
    defineDriver(k) {
      d("localforage.defineDriver()");
    }
    driver() {
      d("localforage.driver()");
    }
    supports(k) {
      d("localforage.supports()");
    }
    dropInstance() {
      d("localforage.dropInstance()");
    }
    disableMemoryMode() {
      c = !1;
    }
  }
  self.localforage = new g(new e("localforage"));
}
{
  ("use strict");
  const e = self.C3;
  e.Supports = {};
  e.Supports.WebAnimations = (() => {
    try {
      if ("Safari" === e.Platform.Browser || "undefined" === typeof document)
        return !1;
      const b = document.createElement("div");
      return "undefined" === typeof b.animate
        ? !1
        : "undefined" !==
            typeof b.animate([{ opacity: "0" }, { opacity: "1" }], 1e3).reverse;
    } catch (b) {
      return !1;
    }
  })();
  e.Supports.DialogElement = "undefined" !== typeof HTMLDialogElement;
  e.Supports.RequestIdleCallback = !!self.requestIdleCallback;
  e.Supports.ImageBitmap = !!self.createImageBitmap;
  e.Supports.ImageBitmapOptions = !1;
  e.Supports.ImageBitmapOptionsResize = !1;
  if (e.Supports.ImageBitmap) {
    try {
      self
        .createImageBitmap(new ImageData(32, 32), { premultiplyAlpha: "none" })
        .then(() => {
          e.Supports.ImageBitmapOptions = !0;
        })
        .catch(() => {
          e.Supports.ImageBitmapOptions = !1;
        });
    } catch (b) {
      e.Supports.ImageBitmapOptions = !1;
    }
    try {
      self
        .createImageBitmap(new ImageData(32, 32), {
          resizeWidth: 10,
          resizeHeight: 10,
        })
        .then((b) => {
          e.Supports.ImageBitmapOptionsResize =
            10 === b.width && 10 === b.height;
        })
        .catch(() => {
          e.Supports.ImageBitmapOptionsResize = !1;
        });
    } catch (b) {
      e.Supports.ImageBitmapOptionsResize = !1;
    }
  }
  e.Supports.ClipboardReadText = !(
    !navigator.clipboard ||
    !navigator.clipboard.readText ||
    "Firefox" === e.Platform.Browser
  );
  e.Supports.PermissionsQuery = !(
    !navigator.permissions || !navigator.permissions.query
  );
  e.Supports.Proxies = "undefined" !== typeof Proxy;
  e.Supports.DownloadAttribute = (() =>
    "undefined" === typeof document
      ? !1
      : "undefined" !== typeof document.createElement("a").download)();
  e.Supports.CanvasToBlob = (() =>
    "undefined" !== typeof HTMLCanvasElement &&
    HTMLCanvasElement.prototype.toBlob)();
  e.Supports.Fetch = "function" === typeof fetch;
  e.Supports.PersistentStorage = !!(
    self.isSecureContext &&
    "Opera" !== e.Platform.Browser &&
    navigator.storage &&
    navigator.storage.persist
  );
  e.Supports.StorageQuotaEstimate = !!(
    self.isSecureContext &&
    navigator.storage &&
    navigator.storage.estimate
  );
  e.Supports.Fullscreen = (() => {
    if ("undefined" === typeof document || "iOS" === e.Platform.OS) return !1;
    const b = document.documentElement;
    return !!(
      b.requestFullscreen ||
      b.msRequestFullscreen ||
      b.mozRequestFullScreen ||
      b.webkitRequestFullscreen
    );
  })();
  e.Supports.ImageDecoder = "undefined" !== typeof self.ImageDecoder;
  e.Supports.WebCodecs = !!self.VideoEncoder;
  e.Supports.NativeFileSystemAPI = !!self.showOpenFilePicker;
  e.Supports.NavigatorFontsQuery = !(
    !navigator.fonts || !navigator.fonts.query
  );
  e.Supports.UserActivation = !!navigator.userActivation;
}
{
  ("use strict");
  const e = self.C3;
  if (!String.prototype.trimStart) {
    const b =
      /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
    String.prototype.trimStart = function () {
      return this.replace(b, "");
    };
  }
  if (!String.prototype.trimEnd) {
    const b =
      /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
    String.prototype.trimEnd = function () {
      return this.replace(b, "");
    };
  }
  String.prototype.replaceAll ||
    (String.prototype.replaceAll = function (b, a) {
      return this.replace(new RegExp(e.EscapeRegex(b), "g"), a);
    });
  Array.prototype.values ||
    (Array.prototype.values = function* () {
      for (const b of this) yield b;
    });
  if (!Array.prototype.flat) {
    function b(a, c) {
      return a.reduce((d, f) => {
        0 < c && Array.isArray(f)
          ? Array.prototype.push.apply(d, b(f, c - 1))
          : d.push(f);
        return d;
      }, []);
    }
    Array.prototype.flat = function (a = 1) {
      return b(this, a);
    };
  }
  Array.prototype.at ||
    (Array.prototype.at = function (b) {
      b = Math.trunc(b) || 0;
      0 > b && (b += this.length);
      if (!(0 > b || b >= this.length)) return this[b];
    });
  String.prototype.at ||
    (String.prototype.at = function (b) {
      b = Math.trunc(b) || 0;
      0 > b && (b += this.length);
      if (!(0 > b || b >= this.length)) return this[b];
    });
  RegExp.escape ||
    (RegExp.escape = function (b) {
      return String(b).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
    });
  navigator.storage &&
    !navigator.storage.estimate &&
    navigator.webkitTemporaryStorage &&
    navigator.webkitTemporaryStorage.queryUsageAndQuota &&
    (navigator.storage.estimate = function () {
      return new Promise((b, a) =>
        navigator.webkitTemporaryStorage.queryUsageAndQuota(
          (c, d) => b({ usage: c, quota: d }),
          a
        )
      );
    });
  "undefined" === typeof self.isSecureContext &&
    (self.isSecureContext = "https:" === location.protocol);
  "undefined" === typeof self.globalThis && (self.globalThis = self);
}
{
  ("use strict");
  const e = self.C3;
  function b(a) {
    let c = e.GetCallStack();
    console.error("Assertion failure: " + a + "\n\nStack trace:\n" + c);
  }
  self.assert = function (a, c) {
    a || b(c);
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.C3X;
  e.IsNumber = function (c) {
    return "number" === typeof c;
  };
  e.IsFiniteNumber = function (c) {
    return e.IsNumber(c) && isFinite(c);
  };
  e.RequireNumber = function (c) {
    if (!e.IsNumber(c)) throw new TypeError("expected number");
  };
  e.RequireOptionalNumber = function (c) {
    e.IsNullOrUndefined(c);
  };
  e.RequireNumberInRange = function (c, d, f) {
    if (!e.IsNumber(c) || isNaN(c) || d > c || f < c)
      throw new RangeError("number outside of range");
  };
  e.RequireAllNumber = function (...c) {
    for (let d of c);
  };
  e.RequireFiniteNumber = function (c) {
    if (!e.IsFiniteNumber(c)) throw new TypeError("expected finite number");
  };
  e.RequireOptionalFiniteNumber = function (c) {
    e.IsNullOrUndefined(c);
  };
  e.RequireAllFiniteNumber = function (...c) {
    for (let d of c);
  };
  e.IsString = function (c) {
    return "string" === typeof c;
  };
  e.RequireString = function (c) {
    if (!e.IsString(c)) throw new TypeError("expected string");
  };
  e.RequireOptionalString = function (c) {
    e.IsNullOrUndefined(c);
  };
  e.RequireAllString = function (...c) {
    for (let d of c);
  };
  e.IsSimpleObject = function (c) {
    return "object" !== typeof c || null === c
      ? !1
      : (c = Object.getPrototypeOf(c))
      ? c.constructor === Object
      : null === c;
  };
  e.RequireSimpleObject = function (c) {
    if (!e.IsSimpleObject(c)) throw new TypeError("expected simple object");
  };
  e.RequireOptionalSimpleObject = function (c) {
    if (!e.IsNullOrUndefined(c) && !e.IsSimpleObject(c))
      throw new TypeError("expected simple object");
  };
  e.IsObject = function (c) {
    return "object" === typeof c && null !== c && !Array.isArray(c);
  };
  e.RequireObject = function (c) {
    if (!e.IsObject(c)) throw new TypeError("expected object");
  };
  e.RequireOptionalObject = function (c) {
    e.IsNullOrUndefined(c);
  };
  e.RequireAllObject = function (...c) {
    for (let d of c);
  };
  e.IsFileLike = function (c) {
    return e.IsInstanceOf(c, Blob) && "string" === typeof c.name;
  };
  e.RequireFileLike = function (c) {
    if (!e.IsFileLike(c)) throw new TypeError("expected file");
  };
  e.RequireOptionalFileLike = function (c) {
    e.IsNullOrUndefined(c);
  };
  e.IsArray = function (c) {
    return Array.isArray(c);
  };
  e.RequireArray = function (c) {
    if (!e.IsArray(c)) throw new TypeError("expected array");
  };
  e.RequireOptionalArray = function (c) {
    e.IsNullOrUndefined(c);
  };
  e.RequireAllArray = function (...c) {
    for (let d of c);
  };
  e.Is2DArray = function (c) {
    return e.IsArray(c) ? (c.length ? (e.IsArray(c[0]) ? !0 : !1) : !0) : !1;
  };
  e.Require2DArray = function (c) {
    if (!e.Is2DArray(c)) throw new TypeError("expected 2d array");
    for (let d of c)
      if (!e.IsArray(d)) throw new TypeError("expected 2d array");
  };
  e.RequireOptional2DArray = function (c) {
    e.IsNullOrUndefined(c);
  };
  e.IsFunction = function (c) {
    return "function" === typeof c;
  };
  e.RequireFunction = function (c, d) {
    if (!e.IsFunction(c)) throw new TypeError("expected function");
    if (!e.IsNullOrUndefined(d) && c !== d)
      throw new TypeError("expected same function reference");
  };
  e.RequireOptionalFunction = function (c) {
    e.IsNullOrUndefined(c);
  };
  e.RequireAllFunction = function (...c) {
    for (let d of c);
  };
  e.RequireAnyFunction = function (c, ...d) {
    if (!e.IsFunction(c)) throw new TypeError("expected function");
    if (!d.length) throw Error("missing comparison functions");
    for (let f of d) if (!e.IsNullOrUndefined(f) && c === f) return;
    throw new TypeError("expected same function reference");
  };
  e.RequireOptionalAllFunction = function (...c) {
    if (!e.IsNullOrUndefined(c)) for (let d of c);
  };
  e.IsInstanceOf = function (c, d) {
    return c instanceof d;
  };
  e.IsInstanceOfAny = function (c, ...d) {
    for (let f of d) if (e.IsInstanceOf(c, f)) return !0;
    return !1;
  };
  e.RequireInstanceOf = function (c, d) {
    if (!e.IsInstanceOf(c, d)) throw new TypeError("unexpected type");
  };
  e.RequireOptionalInstanceOf = function (c, d) {
    e.IsNullOrUndefined(c);
  };
  e.RequireAllInstanceOf = function (c, ...d) {
    for (let f of d);
  };
  e.RequireAnyInstanceOf = function (c, ...d) {
    if (!e.IsInstanceOfAny(c, ...d)) throw new TypeError("unexpected type");
  };
  e.RequireAnyOptionalInstanceOf = function (c, ...d) {
    if (!e.IsNullOrUndefined(c) && !e.IsInstanceOfAny(c, ...d))
      throw new TypeError("unexpected type");
  };
  e.IsArrayOf = function (c, d) {
    for (let f of c) if (!e.IsInstanceOf(f, d)) return !1;
    return !0;
  };
  e.IsArrayOfFiniteNumbers = function (c) {
    for (let d of c) if (!e.IsFiniteNumber(d)) return !1;
    return !0;
  };
  e.RequireArrayOf = function (c, d) {
    for (let f of c);
  };
  e.RequireOptionalArrayOf = function (c, d) {
    if (!e.IsNullOrUndefined(c)) for (let f of c);
  };
  e.RequireArrayOfAny = function (c, ...d) {
    for (let f of c);
  };
  e.RequireOptionalArrayOfAny = function (c, ...d) {
    if (!e.IsNullOrUndefined(c)) for (let f of c);
  };
  e.IsDOMNode = function (c, d) {
    return e.IsNullOrUndefined(c) || !e.IsString(c.nodeName)
      ? !1
      : !d || e.equalsNoCase(c.nodeName, d);
  };
  e.RequireDOMNode = function (c, d) {
    if (e.IsNullOrUndefined(c) || !e.IsString(c.nodeName))
      throw new TypeError("expected DOM node");
    if (d && !e.equalsNoCase(c.nodeName, d))
      throw new TypeError(`expected DOM '${d}' node`);
  };
  e.RequireOptionalDOMNode = function (c, d) {
    e.IsNullOrUndefined(c);
  };
  e.IsHTMLElement = function (c, d) {
    return e.IsNullOrUndefined(c) || !e.IsString(c.tagName)
      ? !1
      : !d || e.equalsNoCase(c.tagName, d);
  };
  e.RequireHTMLElement = function (c, d) {
    if (e.IsNullOrUndefined(c) || !e.IsString(c.tagName))
      throw new TypeError("expected HTML element");
    if (d && !e.equalsNoCase(c.tagName, d))
      throw new TypeError(`expected HTML '${d}' element`);
  };
  e.RequireOptionalHTMLElement = function (c, d) {
    e.IsNullOrUndefined(c);
  };
  e.IsDrawable = function (c) {
    return (
      e.IsHTMLElement(c, "img") ||
      e.IsHTMLElement(c, "canvas") ||
      e.IsHTMLElement(c, "video") ||
      ("undefined" !== typeof OffscreenCanvas &&
        c instanceof OffscreenCanvas) ||
      ("undefined" !== typeof ImageBitmap && c instanceof ImageBitmap)
    );
  };
  e.RequireDrawable = function (c) {
    if (!e.IsDrawable(c)) throw new TypeError("expected drawable");
  };
  e.RequireOptionalDrawable = function (c) {
    e.IsNullOrUndefined(c);
  };
  e.IsDrawableOrImageData = function (c) {
    return c instanceof ImageData ? !0 : e.IsDrawable(c);
  };
  e.RequireDrawableOrImageData = function (c) {
    if (!e.IsDrawableOrImageData(c))
      throw new TypeError("expected drawable or image data");
  };
  e.RequireOptionalDrawableOrImageData = function (c) {
    if (!e.IsNullOrUndefined(c) && !e.IsDrawableOrImageData(c))
      throw new TypeError("expected drawable or image data");
  };
  e.IsStringLike = function (c) {
    return (
      "string" === typeof c ||
      (e.HtmlString && c instanceof e.HtmlString) ||
      c instanceof e.BBString
    );
  };
  e.RequireStringLike = function (c) {
    if (!e.IsStringLike(c)) throw new TypeError("expected string-like");
  };
  e.RequireOptionalStringLike = function (c) {
    e.IsNullOrUndefined(c);
  };
  e.RequireAllStringLike = function (...c) {
    for (let d of c);
  };
  e.RequireOverride = function () {
    throw Error("must be overridden");
  };
  e.NotYetImplemented = function () {
    throw Error("not yet implemented");
  };
  e.IsDefined = function (c, ...d) {
    if ("undefined" === typeof c) return !1;
    for (let f of d) {
      if ("undefined" === typeof c[f]) return !1;
      c = c[f];
    }
    return !0;
  };
  e.IsNullOrUndefined = function (c) {
    return "undefined" === typeof c || null === c;
  };
  e.AreArrayElementsOfSameType = function (c) {
    let d = c[0].constructor;
    for (let f of c) if (f.constructor !== d) return !1;
    return d;
  };
  e.AreArrayElementsOfType = function (c, d) {
    for (let f of c) if (!(f instanceof d)) return !1;
    return !0;
  };
  const a = Object.getPrototypeOf(Uint8Array);
  e.IsTypedArray = function (c) {
    return e.IsInstanceOf(c, a);
  };
  e.RequireTypedArray = function (c) {};
  e.WeakRequireTypedArray = function (c) {
    e.WeakRequireInstanceOf(c, a);
  };
  e.WeakRequireAnyInstanceOf = function (c, ...d) {
    if (!e.WeakIsAnyInstanceOf(c, ...d)) throw new TypeError("unexpected type");
  };
  e.WeakIsAnyInstanceOf = function (c, ...d) {
    for (const f of d) if (e.WeakIsInstanceOf(c, f)) return !0;
    return !1;
  };
  e.WeakRequireInstanceOf = function (c, d) {
    if (!e.WeakIsInstanceOf(c, d)) throw new TypeError("unexpected type");
  };
  e.WeakIsInstanceOf = function (c, d) {
    for (; (c = Object.getPrototypeOf(c)); )
      if (c.constructor.name === d.name) return !0;
    return !1;
  };
  b.RequireNumber = e.RequireNumber;
  b.RequireOptionalNumber = e.RequireOptionalNumber;
  b.RequireFiniteNumber = e.RequireFiniteNumber;
  b.RequireOptionalFiniteNumber = e.RequireOptionalFiniteNumber;
  b.RequireString = e.RequireString;
  b.RequireOptionalString = e.RequireOptionalString;
  b.RequireObject = e.RequireObject;
  b.RequireOptionalObject = e.RequireOptionalObject;
  b.RequireArray = e.RequireArray;
  b.RequireOptionalArray = e.RequireOptionalArray;
  b.RequireFunction = e.RequireFunction;
  b.RequireOptionalFunction = e.RequireOptionalFunction;
  b.RequireInstanceOf = e.RequireInstanceOf;
  b.RequireOptionalInstanceOf = e.RequireOptionalInstanceOf;
  b.IsNullOrUndefined = e.IsNullOrUndefined;
}
{
  ("use strict");
  const e = self.C3,
    b = new Map();
  e.ColorLog = function (u, w) {
    console.log(`%c${u}`, `font-weight: bold; color:${w}`);
  };
  e.RafLog = function (u, ...w) {
    b.has(u) || b.set(u, -1);
    -1 === b.get(u) &&
      b.set(
        u,
        requestAnimationFrame(() => {
          console.log(`%c${u}`, "font-weight: bold", ...w);
          b.set(u, -1);
        })
      );
  };
  let a;
  e.StartMeasure = function (u) {
    performance.mark(u);
    a || (a = new Map());
    a.has(u) ||
      a.set(u, {
        current: 0,
        total: 0,
        average: 0,
        calls: 1,
        toString: function () {
          return `current => ${this.current.toPrecision(
            3
          )} :: average => ${this.average.toPrecision(3)} :: calls => ${
            this.calls
          }`;
        },
      });
  };
  e.EndMeasure = function (u) {
    performance.measure("measure", u);
    const w = performance.getEntriesByName("measure")[0];
    u = a.get(u);
    u.current = w.duration;
    u.total += u.current;
    u.average = u.total / u.calls;
    u.calls++;
    console.log(u.toString());
    performance.clearMarks();
    performance.clearMeasures();
  };
  e.GetCallStack = function () {
    return Error().stack;
  };
  e.Debugger = function () {
    debugger;
  };
  e.cast = function (u, w) {
    return u && u instanceof w ? u : null;
  };
  e.getName = function (u) {
    return "undefined" === typeof u
      ? "undefined"
      : null === u
      ? "null"
      : "boolean" === typeof u
      ? "<boolean>"
      : e.IsNumber(u)
      ? "<number>"
      : e.IsString(u)
      ? "<string>"
      : e.IsArray(u)
      ? "<array>"
      : "symbol" === typeof u
      ? "<" + u.toString() + ">"
      : e.IsFunction(u)
      ? u.name && "Function" !== u.name
        ? u.name
        : "<anonymous function>"
      : "object" === typeof u
      ? u.constructor && u.constructor.name && "Object" !== u.constructor.name
        ? u.constructor.name
        : "<anonymous object>"
      : "<unknown>";
  };
  e.getType = function (u) {
    return null === u ? "null" : Array.isArray(u) ? "array" : typeof u;
  };
  e.range = function* (u, w) {
    if (!isFinite(Math.abs(u - w))) throw Error("Invalid parameters");
    if (u > w) for (--u; u >= w; u--) yield u;
    else for (; u < w; u++) yield u;
  };
  function c(u, w) {
    u = e.getType(u);
    w = e.getType(w);
    return "null" === u || "null" === w
      ? !0
      : "undefined" === u || "undefined" === w
      ? !1
      : u === w;
  }
  let d = new Map(),
    f = new Map(),
    h = new WeakMap(),
    g = new WeakMap();
  e.DefendHandler = {};
  const k = new Set(["then", "splice"]);
  function m(u) {
    console.warn("[Defence] " + u + " @", e.GetCallStack());
  }
  e.DefendHandler.get = function (u, w) {
    w in u ||
      "symbol" === typeof w ||
      k.has(w) ||
      m(
        `Accessed missing property '${w}' from defended object '${e.getName(
          u
        )}', returning undefined`
      );
    g.has(u) &&
      "symbol" !== typeof w &&
      !k.has(w) &&
      m(
        `Accessed property '${w}' on a released object '${e.getName(
          u
        )}'\nObject was originally released at: ${g.get(
          u
        )})\nCall stack at access: `
      );
    return u[w];
  };
  e.DefendHandler.set = function (u, w, y) {
    w in u ||
      d.has(u) ||
      m(
        `Set non-existent property '${w}' to '${y}' on defended object '${e.getName(
          u
        )}'`
      );
    c(u[w], y) ||
      d.has(u) ||
      m(
        `Set '${e.getType(u[w])}' property '${w}' to type '${e.getType(
          y
        )}' on defended object '${e.getName(u)}'`
      );
    g.has(u) &&
      m(
        `Set property '${w}' on a released object '${e.getName(
          u
        )}'\nObject was originally released at: ${g.get(
          u
        )})\nCall stack at access: `
      );
    u[w] = y;
    return !0;
  };
  e.DefendHandler.deleteProperty = function (u, w) {
    throw new ReferenceError(
      `Cannot delete property '${w}' from defended object '${e.getName(u)}'`
    );
  };
  e.DefendHandler.defineProperty = function (u, w, y) {
    throw new ReferenceError(
      `Cannot define property '${w}' on defended object '${e.getName(u)}'`
    );
  };
  e.DefendHandler.enumerate = function (u) {
    throw new ReferenceError(
      `Cannot enumerate defended object '${e.getName(u)}'`
    );
  };
  let q = -1;
  function v() {
    q = -1;
    if (0 < d.size || 0 < f.size) {
      let u = [...new Set([...d.keys()].map((w) => e.getName(w)))].join();
      console.warn(
        `An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${u}`
      );
      d.clear();
      f.clear();
    }
  }
  e.DefendedBase = class {
    constructor() {
      if (e.isDebugDefend && e.Supports.Proxies) {
        var u = new.target;
        u = Object.create(u.prototype);
        var w = new Proxy(u, e.DefendHandler);
        d.set(u, w);
        f.set(w, u);
        h.set(w, u);
        -1 === q && (q = requestAnimationFrame(v));
        return w;
      }
    }
  };
  e.debugDefend = function (u) {
    if (e.isDebugDefend && e.Supports.Proxies && u instanceof e.DefendedBase) {
      if (!f.has(u)) return u;
      let w = f.get(u);
      f.delete(u);
      d.delete(w);
      return u;
    }
    return e.isDebug ? Object.seal(u) : u;
  };
  e.New = function (u, ...w) {
    let y;
    try {
      y = new u(...w);
    } catch (B) {
      throw (f.clear(), d.clear(), B);
    }
    e.isDebugDefend && p(u, y);
    return e.debugDefend(y);
  };
  e.Release = function (u) {
    (u = h.get(u)) && g.set(u, e.GetCallStack());
  };
  e.WasReleased = function (u) {
    return (u = h.get(u)) ? !!g.get(u) : !1;
  };
  let r = new Map();
  function n(u) {
    let w = new Set();
    for (let y in u) w.add(y);
    return w;
  }
  function p(u, w) {
    w = n(w);
    let y = r.get(u);
    if (y) {
      let B = [];
      for (let E of y.values()) w.has(E) ? w.delete(E) : B.push(E);
      e.appendArray(B, [...w]);
      B.length &&
        console.warn(
          `[Defence] '${e.getName(
            u
          )}' constructor creates inconsistent properties: ${B.join(", ")}`
        );
    } else r.set(u, w);
  }
  e.PerfMark = class {
    constructor(u) {
      this._name = "";
      u && this.start(u);
    }
    start(u) {
      e.isPerformanceProfiling &&
        ((this._name = u), performance.mark(this._name + "-Start"));
    }
    end() {
      e.isPerformanceProfiling &&
        (performance.mark(this._name + "-End"),
        performance.measure(
          this._name,
          this._name + "-Start",
          this._name + "-End"
        ));
    }
    next(u) {
      e.isPerformanceProfiling &&
        (this.end(), (this._name = u), performance.mark(this._name + "-Start"));
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = 2 * Math.PI,
    a = Math.PI / 180,
    c = 180 / Math.PI;
  e.wrap = function (h, g, k) {
    h = Math.floor(h);
    g = Math.floor(g);
    k = Math.floor(k);
    return h < g
      ? ((h = k - ((g - h) % (k - g))), h === k ? 0 : h)
      : g + ((h - g) % (k - g));
  };
  e.mapToRange = function (h, g, k, m, q) {
    return ((h - g) * (q - m)) / (k - g) + m;
  };
  e.normalize = function (h, g, k) {
    return (h - g) / (k - g);
  };
  e.clamp = function (h, g, k) {
    return h < g ? g : h > k ? k : h;
  };
  e.clampAngle = function (h) {
    h %= b;
    0 > h && (h += b);
    return h;
  };
  e.toRadians = function (h) {
    return h * a;
  };
  e.toDegrees = function (h) {
    return h * c;
  };
  e.distanceTo = function (h, g, k, m) {
    return Math.hypot(k - h, m - g);
  };
  e.distanceSquared = function (h, g, k, m) {
    h = k - h;
    g = m - g;
    return h * h + g * g;
  };
  e.angleTo = function (h, g, k, m) {
    return Math.atan2(m - g, k - h);
  };
  e.angleDiff = function (h, g) {
    if (h === g) return 0;
    h = Math.sin(h) * Math.sin(g) + Math.cos(h) * Math.cos(g);
    return 1 <= h ? 0 : -1 >= h ? Math.PI : Math.acos(h);
  };
  e.angleRotate = function (h, g, k) {
    let m = Math.sin(h),
      q = Math.cos(h),
      v = Math.sin(g),
      r = Math.cos(g);
    return Math.acos(m * v + q * r) > k
      ? 0 < q * v - m * r
        ? e.clampAngle(h + k)
        : e.clampAngle(h - k)
      : e.clampAngle(g);
  };
  e.angleClockwise = function (h, g) {
    return 0 >= Math.cos(h) * Math.sin(g) - Math.sin(h) * Math.cos(g);
  };
  e.angleLerp = function (h, g, k, m = 0) {
    let q = e.angleDiff(h, g);
    m *= b;
    return e.angleClockwise(g, h)
      ? e.clampAngle(h + (q + m) * k)
      : e.clampAngle(h - (q + m) * k);
  };
  e.angleLerpClockwise = function (h, g, k, m = 0) {
    const q = e.angleDiff(h, g);
    m *= b;
    return e.angleClockwise(g, h)
      ? e.clampAngle(h + (q + m) * k)
      : e.clampAngle((b - q + m) * k);
  };
  e.angleLerpAntiClockwise = function (h, g, k, m = 0) {
    const q = e.angleDiff(h, g);
    m *= b;
    return e.angleClockwise(g, h)
      ? e.clampAngle((-b + q - m) * k)
      : e.clampAngle(h - (q + m) * k);
  };
  e.lerp = function (h, g, k) {
    return h + k * (g - h);
  };
  e.unlerp = function (h, g, k) {
    return h === g ? 0 : (k - h) / (g - h);
  };
  e.relerp = function (h, g, k, m, q) {
    return e.lerp(m, q, e.unlerp(h, g, k));
  };
  e.qarp = function (h, g, k, m) {
    return e.lerp(e.lerp(h, g, m), e.lerp(g, k, m), m);
  };
  e.cubic = function (h, g, k, m, q) {
    return e.lerp(e.qarp(h, g, k, q), e.qarp(g, k, m, q), q);
  };
  e.cosp = function (h, g, k) {
    return (h + g + (h - g) * Math.cos(k * Math.PI)) / 2;
  };
  e.isPOT = function (h) {
    return 0 < h && 0 === ((h - 1) & h);
  };
  e.nextHighestPowerOfTwo = function (h) {
    --h;
    for (let g = 1; 32 > g; g <<= 1) h |= h >> g;
    return h + 1;
  };
  e.roundToNearestFraction = function (h, g) {
    return Math.round(h * g) / g;
  };
  e.floorToNearestFraction = function (h, g) {
    return Math.floor(h * g) / g;
  };
  e.round6dp = function (h) {
    return Math.round(1e6 * h) / 1e6;
  };
  e.toFixed = function (h, g) {
    h = h.toFixed(g);
    for (g = h.length - 1; 0 <= g && "0" === h.charAt(g); --g);
    0 <= g && "." === h.charAt(g) && --g;
    return 0 > g ? h : h.substr(0, g + 1);
  };
  e.PackRGB = function (h, g, k) {
    return (
      e.clamp(h, 0, 255) |
      (e.clamp(g, 0, 255) << 8) |
      (e.clamp(k, 0, 255) << 16)
    );
  };
  e.PackRGBAEx = function (h, g, k, m) {
    h = e.clamp(Math.floor(1024 * h), -8192, 8191);
    g = e.clamp(Math.floor(1024 * g), -8192, 8191);
    k = e.clamp(Math.floor(1024 * k), -8192, 8191);
    m = e.clamp(Math.floor(1023 * m), 0, 1023);
    0 > h && (h += 16384);
    0 > g && (g += 16384);
    0 > k && (k += 16384);
    return -(274877906944 * h + 16777216 * g + 1024 * k + m);
  };
  e.PackRGBEx = function (h, g, k) {
    return e.PackRGBAEx(h, g, k, 1);
  };
  function d(h) {
    return 0 === h && 0 > 1 / h;
  }
  e.GetRValue = function (h) {
    if (0 <= h) return (h & 255) / 255;
    h = Math.floor(-h / 274877906944);
    8191 < h && (h -= 16384);
    return h / 1024;
  };
  e.GetGValue = function (h) {
    if (0 <= h) return ((h & 65280) >> 8) / 255;
    h = Math.floor((-h % 274877906944) / 16777216);
    8191 < h && (h -= 16384);
    return h / 1024;
  };
  e.GetBValue = function (h) {
    if (0 <= h) return ((h & 16711680) >> 16) / 255;
    h = Math.floor((-h % 16777216) / 1024);
    8191 < h && (h -= 16384);
    return h / 1024;
  };
  e.GetAValue = function (h) {
    return d(h) ? 0 : 0 <= h ? 1 : Math.floor(-h % 1024) / 1023;
  };
  e.greatestCommonDivisor = function (h, g) {
    h = Math.floor(h);
    for (g = Math.floor(g); 0 !== g; ) {
      let k = g;
      g = h % g;
      h = k;
    }
    return h;
  };
  const f = [
    [3, 2],
    [4, 3],
    [5, 4],
    [5, 3],
    [6, 5],
    [14, 9],
    [16, 9],
    [16, 10],
    [21, 9],
  ];
  e.getAspectRatio = function (h, g) {
    h = Math.floor(h);
    g = Math.floor(g);
    if (h === g) return [1, 1];
    for (var k of f) {
      let m = (h / k[0]) * k[1];
      if (1 > Math.abs(g - m)) return k.slice(0);
      m = (h / k[1]) * k[0];
      if (1 > Math.abs(g - m)) return [k[1], k[0]];
    }
    k = e.greatestCommonDivisor(h, g);
    return [h / k, g / k];
  };
  e.segmentsIntersect = function (h, g, k, m, q, v, r, n) {
    var p = Math.min(h, k),
      u = Math.max(q, r);
    if (Math.max(h, k) < Math.min(q, r) || p > u) return !1;
    p = Math.min(g, m);
    u = Math.max(v, n);
    if (Math.max(g, m) < Math.min(v, n) || p > u) return !1;
    p = q - h + r - k;
    u = v - g + n - m;
    h = k - h;
    g = m - g;
    q = r - q;
    v = n - v;
    n = Math.abs(g * q - v * h);
    return Math.abs(q * u - v * p) > n ? !1 : Math.abs(h * u - g * p) <= n;
  };
  e.segmentsIntersectPreCalc = function (h, g, k, m, q, v, r, n, p, u, w, y) {
    const B = Math.max(p, w);
    if (v < Math.min(p, w) || q > B) return !1;
    q = Math.max(u, y);
    if (n < Math.min(u, y) || r > q) return !1;
    r = p - h + w - k;
    n = u - g + y - m;
    h = k - h;
    g = m - g;
    p = w - p;
    u = y - u;
    y = Math.abs(g * p - u * h);
    return Math.abs(p * n - u * r) > y ? !1 : Math.abs(h * n - g * r) <= y;
  };
  e.segmentIntersectsQuad = function (h, g, k, m, q) {
    const v = Math.min(h, k),
      r = Math.max(h, k),
      n = Math.min(g, m),
      p = Math.max(g, m),
      u = q.getTlx(),
      w = q.getTly(),
      y = q.getTrx(),
      B = q.getTry(),
      E = q.getBrx(),
      z = q.getBry(),
      D = q.getBlx();
    q = q.getBly();
    return (
      e.segmentsIntersectPreCalc(h, g, k, m, v, r, n, p, u, w, y, B) ||
      e.segmentsIntersectPreCalc(h, g, k, m, v, r, n, p, y, B, E, z) ||
      e.segmentsIntersectPreCalc(h, g, k, m, v, r, n, p, E, z, D, q) ||
      e.segmentsIntersectPreCalc(h, g, k, m, v, r, n, p, D, q, u, w)
    );
  };
  e.segmentIntersectsAnyN = function (h, g, k, m, q) {
    const v = Math.min(h, k),
      r = Math.max(h, k),
      n = Math.min(g, m),
      p = Math.max(g, m);
    let u = 0;
    for (let w = q.length - 4; u <= w; u += 2)
      if (
        e.segmentsIntersectPreCalc(
          h,
          g,
          k,
          m,
          v,
          r,
          n,
          p,
          q[u],
          q[u + 1],
          q[u + 2],
          q[u + 3]
        )
      )
        return !0;
    return e.segmentsIntersectPreCalc(
      h,
      g,
      k,
      m,
      v,
      r,
      n,
      p,
      q[u],
      q[u + 1],
      q[0],
      q[1]
    );
  };
  e.rayIntersect = function (h, g, k, m, q, v, r, n) {
    k -= h;
    v = n - v;
    const p = k * v - (m - g) * (r - q);
    if (0 === p) return 2;
    m = ((g - m) * (r - h) + k * (n - g)) / p;
    return 0 < m && 1.000001 > m ? (v * (r - h) + (q - r) * (n - g)) / p : 2;
  };
  e.rayIntersectExtended = function (h, g, k, m, q, v, r, n, p) {
    const u = (r - q) * p;
    p *= n - v;
    return e.rayIntersect(h, g, k, m, q - u, v - p, r + u, n + p);
  };
  e.isPointInTriangleInclusive = function (h, g, k, m, q, v, r, n) {
    q -= k;
    v -= m;
    r -= k;
    n -= m;
    h -= k;
    k = g - m;
    g = q * q + v * v;
    m = q * r + v * n;
    q = q * h + v * k;
    v = r * r + n * n;
    r = r * h + n * k;
    n = 1 / (g * v - m * m);
    v = (v * q - m * r) * n;
    q = (g * r - m * q) * n;
    return 0 <= v && 0 <= q && 1 >= v + q;
  };
  e.triangleCartesianToBarycentric = function (h, g, k, m, q, v, r, n) {
    q -= k;
    v -= m;
    r -= k;
    n -= m;
    h -= k;
    const p = g - m;
    g = q * q + v * v;
    m = q * r + v * n;
    k = r * r + n * n;
    q = h * q + p * v;
    v = h * r + p * n;
    r = g * k - m * m;
    n = (k * q - m * v) / r;
    q = (g * v - m * q) / r;
    return [1 - n - q, n, q];
  };
  e.triangleBarycentricToCartesian = function (h, g, k, m, q, v, r, n, p) {
    return [h * m + g * v + k * n, h * q + g * r + k * p];
  };
}
{
  ("use strict");
  const e = self.C3;
  let b = null,
    a = "";
  if ("undefined" !== typeof document) {
    b = document;
    const k = document.querySelector("base");
    if ((a = k && k.hasAttribute("href") ? k.getAttribute("href") : ""))
      a.startsWith("/") && (a = a.substr(1)), a.endsWith("/") || (a += "/");
  }
  e.GetBaseHref = function () {
    return a;
  };
  e.GetBaseURL = function () {
    if (!b) return "";
    const k = b.location;
    return e.GetPathFromURL(k.origin + k.pathname) + a;
  };
  e.GetPathFromURL = function (k) {
    if (!k.length || k.endsWith("/") || k.endsWith("\\")) return k;
    const m = Math.max(k.lastIndexOf("/"), k.lastIndexOf("\\"));
    return -1 === m ? "" : k.substr(0, m + 1);
  };
  e.GetFilenameFromURL = function (k) {
    if (!k.length) return k;
    if (k.endsWith("/") || k.endsWith("\\")) return "";
    const m = Math.max(k.lastIndexOf("/"), k.lastIndexOf("\\"));
    return -1 === m ? k : k.substr(m + 1);
  };
  e.GetFileExtension = function (k) {
    let m = k.lastIndexOf(".");
    return 1 > m ? "" : k.substr(m);
  };
  e.GetFileNamePart = function (k) {
    let m = k.lastIndexOf(".");
    return 1 > m ? k : k.substr(0, m);
  };
  e.NormalizeFileSeparator = function (k) {
    return k.replace(/\\/g, "/");
  };
  e.IsFileExtension = function (k, m) {
    k = k ? e.GetFileExtension(k).slice(1) : "";
    return m === k;
  };
  e.FileNameEquals = function (k, m) {
    let q, v;
    e.IsFileLike(k) && (q = e.GetFileNamePart(k.name));
    e.IsString(k) && (q = e.GetFileNamePart(k));
    e.IsFileLike(m) && (v = e.GetFileNamePart(m.name));
    e.IsString(m) && (v = e.GetFileNamePart(m));
    return q === v;
  };
  e.ParseFilePath = function (k) {
    k = e.NormalizeFileSeparator(k);
    let m = /^\w:\//.exec(k);
    m
      ? ((m = m[0]), (k = k.slice(3)), "/" !== k[0] && (k = "/" + k))
      : (m = "");
    k = k.replace(/\/{2,}/g, "/");
    1 < k.length && "/" === k.slice(-1) && (k = k.slice(0, -1));
    var q = k.lastIndexOf("/") + 1;
    let v = "",
      r = k,
      n = "";
    0 < q && ((v = k.slice(0, q)), (r = k.slice(q)));
    k = r;
    q = r.lastIndexOf(".");
    0 < q && ((n = r.slice(q)), (k = r.slice(0, -n.length)));
    return { dir: v, base: r, name: k, root: m, ext: n, full: m + v + r };
  };
  e.Wait = function (k, m) {
    return new Promise((q, v) => {
      self.setTimeout(q, k, m);
    });
  };
  e.swallowException = function (k) {
    try {
      k();
    } catch (m) {
      e.isDebug && console.warn("Swallowed exception: ", m);
    }
  };
  e.noop = function () {};
  e.equalsNoCase = function (k, m) {
    return "string" !== typeof k || "string" !== typeof m
      ? !1
      : k === m || k.normalize().toLowerCase() === m.normalize().toLowerCase();
  };
  e.equalsCase = function (k, m) {
    return "string" !== typeof k || "string" !== typeof m
      ? !1
      : k === m
      ? !0
      : k.normalize() === m.normalize();
  };
  e.typedArraySet16 = function (k, m, q) {
    k[q++] = m[0];
    k[q++] = m[1];
    k[q++] = m[2];
    k[q++] = m[3];
    k[q++] = m[4];
    k[q++] = m[5];
    k[q++] = m[6];
    k[q++] = m[7];
    k[q++] = m[8];
    k[q++] = m[9];
    k[q++] = m[10];
    k[q++] = m[11];
    k[q++] = m[12];
    k[q++] = m[13];
    k[q++] = m[14];
    k[q] = m[15];
  };
  e.truncateArray = function (k, m) {
    k.length = m;
  };
  e.clearArray = function (k) {
    k && 0 !== k.length && e.truncateArray(k, 0);
  };
  e.clear2DArray = function (k) {
    if (k) {
      for (let m = 0; m < k.length; m++) e.truncateArray(k[m], 0);
      e.truncateArray(k, 0);
    }
  };
  e.extendArray = function (k, m, q) {
    m |= 0;
    var v = k.length;
    if (!(m <= v)) for (; v < m; ++v) k.push(q);
  };
  e.resizeArray = function (k, m, q) {
    m |= 0;
    const v = k.length;
    m < v ? e.truncateArray(k, m) : m > v && e.extendArray(k, m, q);
  };
  e.shallowAssignArray = function (k, m) {
    e.clearArray(k);
    e.appendArray(k, m);
  };
  e.appendArray = function (k, m) {
    if (1e4 > m.length) k.push(...m);
    else for (let q = 0, v = m.length; q < v; ++q) k.push(m[q]);
  };
  e.arrayRemove = function (k, m) {
    m = Math.floor(m);
    if (!(0 > m || m >= k.length)) {
      for (var q = k.length - 1; m < q; ++m) k[m] = k[m + 1];
      e.truncateArray(k, q);
    }
  };
  e.arrayFindRemove = function (k, m) {
    m = k.indexOf(m);
    0 <= m && k.splice(m, 1);
  };
  e.arraysEqual = function (k, m) {
    let q = k.length;
    if (m.length !== q) return !1;
    for (let v = 0; v < q; ++v) if (k[v] !== m[v]) return !1;
    return !0;
  };
  e.arrayFilterOut = function (k, m) {
    let q = [],
      v = 0;
    for (let r = 0, n = k.length; r < n; ++r) {
      let p = k[r];
      m(p) ? q.push(p) : ((k[v] = p), ++v);
    }
    e.truncateArray(k, v);
    return q;
  };
  e.arrayRemoveAllInSet = function (k, m) {
    const q = k.length;
    let v = 0;
    for (let r = 0, n = k.length; r < n; ++r) {
      let p = k[r];
      m.has(p) || (k[v++] = p);
    }
    e.truncateArray(k, v);
    return q - v;
  };
  e.isArrayIndexInBounds = function (k, m) {
    return k !== Math.floor(k) ? !1 : 0 <= k && k < m.length;
  };
  e.validateArrayIndex = function (k, m) {
    if (!e.isArrayIndexInBounds(k, m))
      throw new RangeError("array index out of bounds");
  };
  e.cloneArray = function (k) {
    return k.slice();
  };
  e.deepCloneArray = function (k, m) {
    let q = [];
    for (let v of k)
      if (e.IsObject(v)) {
        k = m(v);
        if (!k) throw Error("missing clone");
        if (k.constructor !== v.constructor)
          throw Error("object is not a clone");
        q.push(k);
      } else e.IsArray(v) ? q.push(e.deepCloneArray(v, m)) : q.push(v);
    return q;
  };
  e.clone2DArray = function (k) {
    let m = [];
    for (let q of k) m.push(q.slice());
    return m;
  };
  e.mergeSets = function (k, m) {
    return new Set([...k, ...m]);
  };
  e.mergeSetsInPlace = function (k, m) {
    for (const q of m) k.add(q);
    return k;
  };
  e.first = function (k) {
    for (let m of k) return m;
    return null;
  };
  e.xor = function (k, m) {
    return !k !== !m;
  };
  e.compare = function (k, m, q) {
    switch (m) {
      case 0:
        return k === q;
      case 1:
        return k !== q;
      case 2:
        return k < q;
      case 3:
        return k <= q;
      case 4:
        return k > q;
      case 5:
        return k >= q;
      default:
        return !1;
    }
  };
  e.hasAnyOwnProperty = function (k) {
    for (let m in k) if (k.hasOwnProperty(m)) return !0;
    return !1;
  };
  e.PromiseAllWithProgress = function (k, m) {
    return k.length
      ? new Promise((q, v) => {
          const r = [];
          let n = 0,
            p = !1;
          for (let u = 0, w = k.length; u < w; ++u)
            r.push(void 0),
              k[u]
                .then((y) => {
                  p ||
                    ((r[u] = y), ++n, n === k.length ? q(r) : m(n, k.length));
                })
                .catch((y) => {
                  p = !0;
                  v(y);
                });
        })
      : Promise.resolve([]);
  };
  let c = [];
  e.AddLibraryMemoryCallback = function (k) {
    c.push(k);
  };
  e.GetEstimatedLibraryMemoryUsage = function () {
    let k = 0;
    for (let m of c) {
      let q = m();
      k += q;
    }
    return Math.floor(k);
  };
  let d = 1;
  const f = new Map(),
    h = new MessageChannel();
  h.port2.onmessage = function (k) {
    k = k.data;
    const m = f.get(k);
    f.delete(k);
    m && m(performance.now());
  };
  e.RequestUnlimitedAnimationFrame = function (k) {
    const m = d++;
    f.set(m, k);
    h.port1.postMessage(m);
    return m;
  };
  e.CancelUnlimitedAnimationFrame = function (k) {
    f.delete(k);
  };
  e.PostTask = e.RequestUnlimitedAnimationFrame;
  e.WaitForNextTask = function () {
    return new Promise((k) => e.PostTask(k));
  };
  const g = new Set();
  e.RequestPostAnimationFrame = function (k) {
    const m = self.requestAnimationFrame(async (q) => {
      await e.WaitForNextTask();
      g.has(m) && (g.delete(m), k(q));
    });
    g.add(m);
    return m;
  };
  e.CancelPostAnimationFrame = function (k) {
    g.has(k) && (self.cancelAnimationFrame(k), g.delete(k));
  };
}
{
  ("use strict");
  const e = self.C3;
  e.IsAbsoluteURL = function (b) {
    return (
      /^(?:[a-z\-]+:)?\/\//.test(b) ||
      "data:" === b.substr(0, 5) ||
      "blob:" === b.substr(0, 5)
    );
  };
  e.IsRelativeURL = function (b) {
    return !e.IsAbsoluteURL(b);
  };
  e.ThrowIfNotOk = function (b) {
    if (!b.ok)
      throw Error(
        `fetch '${b.url}' response returned ${b.status} ${b.statusText}`
      );
  };
  e.FetchOk = function (b, a) {
    return fetch(b, a).then((c) => {
      e.ThrowIfNotOk(c);
      return c;
    });
  };
  e.FetchText = function (b) {
    return e.FetchOk(b).then((a) => a.text());
  };
  e.FetchJson = function (b) {
    return e.FetchOk(b).then((a) => a.json());
  };
  e.FetchBlob = function (b) {
    return e.FetchOk(b).then((a) => a.blob());
  };
  e.FetchArrayBuffer = function (b) {
    return e.FetchOk(b).then((a) => a.arrayBuffer());
  };
  e.FetchImage = function (b) {
    return new Promise((a, c) => {
      const d = new Image();
      d.onload = () => a(d);
      d.onerror = (f) => c(f);
      d.src = b;
    });
  };
  e.BlobToArrayBuffer = function (b) {
    return "function" === typeof b.arrayBuffer
      ? b.arrayBuffer()
      : new Promise((a, c) => {
          const d = new FileReader();
          d.onload = () => a(d.result);
          d.onerror = () => c(d.error);
          d.readAsArrayBuffer(b);
        });
  };
  e.BlobToString = function (b) {
    return "function" === typeof b.text
      ? b.text()
      : new Promise((a, c) => {
          const d = new FileReader();
          d.onload = () => a(d.result);
          d.onerror = () => c(d.error);
          d.readAsText(b);
        });
  };
  e.BlobToJson = function (b) {
    return e.BlobToString(b).then((a) => JSON.parse(a));
  };
  e.BlobToImage = async function (b, a) {
    b = URL.createObjectURL(b);
    try {
      const c = await e.FetchImage(b);
      URL.revokeObjectURL(b);
      b = "";
      a && "function" === typeof c.decode && (await c.decode());
      return c;
    } finally {
      b && URL.revokeObjectURL(b);
    }
  };
  e.CreateCanvas = function (b, a) {
    if (
      "undefined" !== typeof document &&
      "function" === typeof document.createElement
    ) {
      const c = document.createElement("canvas");
      c.width = b;
      c.height = a;
      return c;
    }
    return new OffscreenCanvas(b, a);
  };
  e.CanvasToBlob = function (b, a, c) {
    "number" !== typeof c && (c = 1);
    a = a || "image/png";
    c = e.clamp(c, 0, 1);
    return b.toBlob
      ? new Promise((d) => b.toBlob(d, a, c))
      : b.convertToBlob
      ? b.convertToBlob({ type: a, quality: c })
      : e.Asyncify(() => e.CanvasToBlobSync(b, a, c));
  };
  e.CanvasToBlobSync = function (b, a, c) {
    "number" !== typeof c && (c = 1);
    a = a || "image/png";
    c = e.clamp(c, 0, 1);
    return e.DataURIToBinaryBlobSync(b.toDataURL(a, c));
  };
  e.DataURIToBinaryBlobSync = function (b) {
    b = e.ParseDataURI(b);
    return e.BinaryStringToBlob(b.data, b.mime_type);
  };
  e.ParseDataURI = function (b) {
    if ("data:" !== b.substr(0, 5)) throw new URIError("expected data: uri");
    var a = b.indexOf(",");
    if (0 > a) throw new URIError("expected comma in data: uri");
    var c = b.substring(5, a);
    b = b.substring(a + 1);
    a = c.split(";");
    c = a[0] || "";
    let d = a[2];
    b = "base64" === a[1] || "base64" === d ? atob(b) : decodeURIComponent(b);
    return { mime_type: c, data: b };
  };
  e.BinaryStringToBlob = function (b, a) {
    var c = b.length;
    let d = c >> 2,
      f = new Uint8Array(c),
      h = new Uint32Array(f.buffer, 0, d),
      g,
      k;
    for (k = g = 0; g < d; ++g)
      h[g] =
        b.charCodeAt(k++) |
        (b.charCodeAt(k++) << 8) |
        (b.charCodeAt(k++) << 16) |
        (b.charCodeAt(k++) << 24);
    for (c &= 3; c--; ) (f[k] = b.charCodeAt(k)), ++k;
    return a ? new Blob([f], { type: a }) : new Blob([f]);
  };
  e.DrawableToBlob = function (b, a, c) {
    const d = e.CreateCanvas(b.width, b.height);
    d.getContext("2d").drawImage(b, 0, 0);
    return e.CanvasToBlob(d, a, c);
  };
  e.ImageDataToBlobSync = function (b, a, c) {
    const d = e.CreateCanvas(b.width, b.height);
    d.getContext("2d").putImageData(b, 0, 0);
    return e.CanvasToBlobSync(d, a, c);
  };
  e.ImageDataToBlob = function (b, a, c) {
    if (e.Supports.ImageBitmapOptions)
      return createImageBitmap(b, { premultiplyAlpha: "none" }).then((d) =>
        e.DrawableToBlob(d, a, c)
      );
    if (e.Supports.ImageBitmap)
      return createImageBitmap(b).then((d) => e.DrawableToBlob(d, a, c));
    {
      const d = e.CreateCanvas(b.width, b.height);
      d.getContext("2d").putImageData(b, 0, 0);
      return e.CanvasToBlob(d, a, c);
    }
  };
  e.CopySet = function (b, a) {
    b.clear();
    for (const c of a) b.add(c);
  };
  e.MapToObject = function (b) {
    const a = Object.create(null);
    for (const [c, d] of b.entries()) a[c] = d;
    return a;
  };
  e.ObjectToMap = function (b, a) {
    a.clear();
    for (const [c, d] of Object.entries(b)) a.set(c, d);
  };
  e.ToSuperJSON = function c(a) {
    if ("object" === typeof a && null !== a) {
      if (a instanceof Set)
        return { _c3type_: "set", data: [...a].map((d) => c(d)) };
      if (a instanceof Map)
        return { _c3type_: "map", data: [...a].map((d) => [d[0], c(d[1])]) };
      {
        const d = Object.create(null);
        for (const [f, h] of Object.entries(a)) d[f] = c(h);
        return d;
      }
    }
    return a;
  };
  e.FromSuperJSON = function d(c) {
    if (("object" === typeof c) & (null !== c)) {
      if ("set" === c._c3type_) return new Set(c.data.map((f) => d(f)));
      if ("map" === c._c3type_)
        return new Map(c.data.map((f) => [f[0], d(f[1])]));
      {
        const f = Object.create(null);
        for (const [h, g] of Object.entries(c)) f[h] = d(g);
        return f;
      }
    }
    return c;
  };
  e.CSSToCamelCase = function (c) {
    let d = "",
      f = !1;
    for (const h of c)
      "-" === h ? (f = !0) : f ? ((d += h.toUpperCase()), (f = !1)) : (d += h);
    return d;
  };
  e.IsIterator = function (c) {
    return "object" === typeof c && "function" === typeof c.next;
  };
  e.MakeFilledArray = function (c, d) {
    const f = [];
    if ("function" === typeof d) for (var h = 0; h < c; ++h) f.push(d());
    else for (h = 0; h < c; ++h) f.push(d);
    return f;
  };
}
{
  ("use strict");
  const e = self.C3,
    b = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?/i,
    a = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?,([0-9.])/i;
  function c(f) {
    return 0 === f.length ? "00" : 1 === f.length ? "0" + f : f;
  }
  function d(f, h, g) {
    0 > g && (g += 1);
    1 < g && --g;
    return g < 1 / 6
      ? f + 6 * (h - f) * g
      : 0.5 > g
      ? h
      : g < 2 / 3
      ? f + (h - f) * (2 / 3 - g) * 6
      : f;
  }
  e.Color = class {
    constructor(f, h, g, k) {
      this._a = this._b = this._g = this._r = 0;
      f instanceof e.Color
        ? this.set(f)
        : this.setRgba(f || 0, h || 0, g || 0, k || 0);
    }
    setRgb(f, h, g) {
      this._r = +f;
      this._g = +h;
      this._b = +g;
      this.clamp();
      return this;
    }
    setRgba(f, h, g, k) {
      this._r = +f;
      this._g = +h;
      this._b = +g;
      this._a = +k;
      this.clamp();
      return this;
    }
    set(f) {
      this._r = f._r;
      this._g = f._g;
      this._b = f._b;
      this._a = f._a;
      return this;
    }
    copy(f) {
      return this.set(f);
    }
    add(f) {
      this._r += f._r;
      this._g += f._g;
      this._b += f._b;
      this._a += f._a;
      this.clamp();
    }
    addRgb(f, h, g, k = 0) {
      this._r += +f;
      this._g += +h;
      this._b += +g;
      this._a += +k;
      this.clamp();
    }
    diff(f) {
      this.setR(Math.max(this._r, f._r) - Math.min(this._r, f._r));
      this.setG(Math.max(this._g, f._g) - Math.min(this._g, f._g));
      this.setB(Math.max(this._b, f._b) - Math.min(this._b, f._b));
      this.setA(Math.max(this._a, f._a) - Math.min(this._a, f._a));
      this.clamp();
    }
    copyRgb(f) {
      this._r = f._r;
      this._g = f._g;
      this._b = f._b;
    }
    setR(f) {
      this._r = e.clamp(+f, 0, 1);
    }
    getR() {
      return this._r;
    }
    setG(f) {
      this._g = e.clamp(+f, 0, 1);
    }
    getG() {
      return this._g;
    }
    setB(f) {
      this._b = e.clamp(+f, 0, 1);
    }
    getB() {
      return this._b;
    }
    setA(f) {
      this._a = e.clamp(+f, 0, 1);
    }
    getA() {
      return this._a;
    }
    clone() {
      return e.New(e.Color, this._r, this._g, this._b, this._a);
    }
    toArray() {
      return [this._r, this._g, this._b, this._a];
    }
    toTypedArray() {
      return new Float64Array(this.toArray());
    }
    writeToTypedArray(f, h) {
      f[h++] = this._r;
      f[h++] = this._g;
      f[h++] = this._b;
      f[h] = this._a;
    }
    writeRGBToTypedArray(f, h) {
      f[h++] = this._r;
      f[h++] = this._g;
      f[h] = this._b;
    }
    equals(f) {
      return (
        this._r === f._r &&
        this._g === f._g &&
        this._b === f._b &&
        this._a === f._a
      );
    }
    equalsIgnoringAlpha(f) {
      return this._r === f._r && this._g === f._g && this._b === f._b;
    }
    equalsRgb(f, h, g) {
      return this._r === f && this._g === h && this._b === g;
    }
    equalsRgba(f, h, g, k) {
      return this._r === f && this._g === h && this._b === g && this._a === k;
    }
    equalsF32Array(f, h) {
      return (
        f[h] === Math.fround(this._r) &&
        f[h + 1] === Math.fround(this._g) &&
        f[h + 2] === Math.fround(this._b) &&
        f[h + 3] === Math.fround(this._a)
      );
    }
    equalsRGBF32Array(f, h) {
      return (
        f[h] === Math.fround(this._r) &&
        f[h + 1] === Math.fround(this._g) &&
        f[h + 2] === Math.fround(this._b)
      );
    }
    multiply(f) {
      this._r *= f._r;
      this._g *= f._g;
      this._b *= f._b;
      this._a *= f._a;
    }
    multiplyAlpha(f) {
      this._r *= f;
      this._g *= f;
      this._b *= f;
      this._a *= f;
    }
    premultiply() {
      this._r *= this._a;
      this._g *= this._a;
      this._b *= this._a;
      return this;
    }
    unpremultiply() {
      this._r /= this._a;
      this._g /= this._a;
      this._b /= this._a;
      return this;
    }
    clamp() {
      this._r = e.clamp(this._r, 0, 1);
      this._g = e.clamp(this._g, 0, 1);
      this._b = e.clamp(this._b, 0, 1);
      this._a = e.clamp(this._a, 0, 1);
      return this;
    }
    setFromRgbValue(f) {
      this._r = e.GetRValue(f);
      this._g = e.GetGValue(f);
      this._b = e.GetBValue(f);
      this._a = e.GetAValue(f);
    }
    getCssRgb(f, h, g) {
      f = e.IsFiniteNumber(f) ? f : this.getR();
      h = e.IsFiniteNumber(h) ? h : this.getG();
      g = e.IsFiniteNumber(g) ? g : this.getB();
      return `rgb(${100 * f}%, ${100 * h}%, ${100 * g}%)`;
    }
    getCssRgba(f, h, g, k) {
      f = e.IsFiniteNumber(f) ? f : this.getR();
      h = e.IsFiniteNumber(h) ? h : this.getG();
      g = e.IsFiniteNumber(g) ? g : this.getB();
      k = e.IsFiniteNumber(k) ? k : this.getA();
      return `rgba(${100 * f}%, ${100 * h}%, ${100 * g}%, ${k})`;
    }
    toHexString() {
      const f = Math.round(255 * this.getR()),
        h = Math.round(255 * this.getG()),
        g = Math.round(255 * this.getB());
      return "#" + c(f.toString(16)) + c(h.toString(16)) + c(g.toString(16));
    }
    parseHexString(f) {
      if ("string" !== typeof f) return !1;
      f = f.trim();
      "#" === f.charAt(0) && (f = f.substr(1));
      let h, g;
      if (3 === f.length)
        (h = parseInt(f[0], 16) / 15),
          (g = parseInt(f[1], 16) / 15),
          (f = parseInt(f[2], 16) / 15);
      else if (6 === f.length)
        (h = parseInt(f.substr(0, 2), 16) / 255),
          (g = parseInt(f.substr(2, 2), 16) / 255),
          (f = parseInt(f.substr(4, 2), 16) / 255);
      else return !1;
      isFinite(h) && this.setR(h);
      isFinite(g) && this.setG(g);
      isFinite(f) && this.setB(f);
      this.setA(1);
      return !0;
    }
    toCommaSeparatedRgb() {
      const f = Math.round(255 * this.getR()),
        h = Math.round(255 * this.getG()),
        g = Math.round(255 * this.getB());
      return `${f}, ${h}, ${g}`;
    }
    toRgbArray() {
      const f = Math.round(255 * this.getR()),
        h = Math.round(255 * this.getG()),
        g = Math.round(255 * this.getB());
      return [f, h, g];
    }
    parseCommaSeparatedRgb(f) {
      if ("string" !== typeof f) return !1;
      f = f.replace(/^rgb\(|\)|%/, "");
      var h = f.split(",");
      if (3 > h.length) return !1;
      f = parseInt(h[0].trim(), 10) / 255;
      const g = parseInt(h[1].trim(), 10) / 255;
      h = parseInt(h[2].trim(), 10) / 255;
      isFinite(f) && this.setR(f);
      isFinite(g) && this.setG(g);
      isFinite(h) && this.setB(h);
      this.setA(1);
      return !0;
    }
    parseCommaSeparatedPercentageRgb(f) {
      if ("string" !== typeof f) return !1;
      f = f.replace(/^rgb\(|\)|%/, "");
      var h = f.split(",");
      if (3 > h.length) return !1;
      f = parseInt(h[0].trim(), 10) / 100;
      const g = parseInt(h[1].trim(), 10) / 100;
      h = parseInt(h[2].trim(), 10) / 100;
      isFinite(f) && this.setR(f);
      isFinite(g) && this.setG(g);
      isFinite(h) && this.setB(h);
      this.setA(1);
      return !0;
    }
    parseCommaSeparatedRgba(f) {
      if ("string" !== typeof f) return !1;
      f = f.replace(/^rgba\(|\)|%/, "");
      var h = f.split(",");
      if (4 > h.length) return !1;
      f = parseInt(h[0].trim(), 10) / 255;
      const g = parseInt(h[1].trim(), 10) / 255,
        k = parseInt(h[2].trim(), 10) / 255;
      h = parseFloat(h[3].trim());
      isFinite(f) && this.setR(f);
      isFinite(g) && this.setG(g);
      isFinite(k) && this.setB(k);
      isFinite(h) && this.setA(h);
      return !0;
    }
    parseCommaSeparatedPercentageRgba(f) {
      if ("string" !== typeof f) return !1;
      f = f.replace(/^rgba\(|\)|%/, "");
      var h = f.split(",");
      if (4 > h.length) return !1;
      f = parseInt(h[0].trim(), 10) / 100;
      const g = parseInt(h[1].trim(), 10) / 100,
        k = parseInt(h[2].trim(), 10) / 100;
      h = parseFloat(h[3].trim());
      isFinite(f) && this.setR(f);
      isFinite(g) && this.setG(g);
      isFinite(k) && this.setB(k);
      isFinite(h) && this.setA(h);
      return !0;
    }
    parseString(f) {
      if ("string" !== typeof f) return !1;
      f = f.replace(/\s+/, "");
      if (f.includes(",")) {
        if (f.startsWith("rgb("))
          return f.includes("%")
            ? this.parseCommaSeparatedPercentageRgb(f)
            : this.parseCommaSeparatedRgb(f);
        if (f.startsWith("rgba("))
          return f.includes("%")
            ? this.parseCommaSeparatedPercentageRgba(f)
            : this.parseCommaSeparatedRgba(f);
        if (f.startsWith("hsl(") || f.startsWith("hsla("))
          return this.parseHSLString(f);
        {
          const h = f.split(",");
          if (f.includes("%")) {
            if (3 === h.length) return this.parseCommaSeparatedPercentageRgb(f);
            if (4 === h.length)
              return this.parseCommaSeparatedPercentageRgba(f);
          } else {
            if (3 === h.length) return this.parseCommaSeparatedRgb(f);
            if (4 === h.length) return this.parseCommaSeparatedRgba(f);
          }
          return !1;
        }
      }
      return this.parseHexString(f);
    }
    toJSON() {
      return [this._r, this._g, this._b, this._a];
    }
    setFromHSLA(f, h, g, k) {
      f %= 360;
      h = e.clamp(h, 0, 100);
      g = e.clamp(g, 0, 100);
      k = e.clamp(k, 0, 1);
      f /= 360;
      h /= 100;
      g /= 100;
      if (0 === h) g = h = f = g;
      else {
        const m = 0.5 > g ? g * (1 + h) : g + h - g * h,
          q = 2 * g - m;
        g = d(q, m, f + 1 / 3);
        h = d(q, m, f);
        f = d(q, m, f - 1 / 3);
      }
      this.setR(g);
      this.setG(h);
      this.setB(f);
      this.setA(k);
      return this;
    }
    parseHSLString(f) {
      var h = f.replace(/ |hsl|hsla|\(|\)|;/gi, "");
      f = b.exec(h);
      h = a.exec(h);
      return f && 4 === f.length
        ? (this.setFromHSLA(+f[1], +f[2], +f[3], 1), !0)
        : h && 5 === h.length
        ? (this.setFromHSLA(+f[1], +f[2], +f[3], +f[4]), !0)
        : !1;
    }
    toHSLAString() {
      var f = this._r;
      const h = this._g,
        g = this._b,
        k = this._a,
        m = e.Color.GetHue(f, h, g),
        q = e.Color.GetSaturation(f, h, g);
      f = e.Color.GetLuminosity(f, h, g);
      return `hsla(${m}, ${q}%, ${f}%, ${k})`;
    }
    toHSLAArray() {
      const f = this._r,
        h = this._g,
        g = this._b;
      return [
        e.Color.GetHue(f, h, g),
        e.Color.GetSaturation(f, h, g),
        e.Color.GetLuminosity(f, h, g),
        this._a,
      ];
    }
    setFromJSON(f) {
      !Array.isArray(f) ||
        3 > f.length ||
        ((this._r = f[0]),
        (this._g = f[1]),
        (this._b = f[2]),
        (this._a = 4 <= f.length ? f[3] : 1));
    }
    set r(f) {
      this.setR(f);
    }
    get r() {
      return this.getR();
    }
    set g(f) {
      this.setG(f);
    }
    get g() {
      return this.getG();
    }
    set b(f) {
      this.setB(f);
    }
    get b() {
      return this.getB();
    }
    set a(f) {
      this.setA(f);
    }
    get a() {
      return this.getA();
    }
    setAtIndex(f, h) {
      switch (f) {
        case 0:
          this.setR(h);
          break;
        case 1:
          this.setG(h);
          break;
        case 2:
          this.setB(h);
          break;
        case 3:
          this.setA(h);
          break;
        default:
          throw new RangeError("invalid color index");
      }
    }
    getAtIndex(f) {
      switch (f) {
        case 0:
          return this.getR();
        case 1:
          return this.getG();
        case 2:
          return this.getB();
        case 3:
          return this.getA();
        default:
          throw new RangeError("invalid color index");
      }
    }
    static Equals(f, h) {
      let g;
      if (Array.isArray(f)) (g = new e.Color()), g.setFromJSON(f);
      else if (f instanceof e.Color) g = f;
      else throw Error("unexpected type");
      if (Array.isArray(h)) (f = new e.Color()), f.setFromJSON(h);
      else if (h instanceof e.Color) f = h;
      else throw Error("unexpected type");
      return g.equals(f);
    }
    static DiffChannel(f, h) {
      return e.clamp(Math.max(f, h) - Math.min(f, h), 0, 1);
    }
    static Diff(f, h) {
      const g = new e.Color();
      g.setR(Math.max(f._r, h._r) - Math.min(f._r, h._r));
      g.setG(Math.max(f._g, h._g) - Math.min(f._g, h._g));
      g.setB(Math.max(f._b, h._b) - Math.min(f._b, h._b));
      g.setA(Math.max(f._a, h._a) - Math.min(f._a, h._a));
      return g;
    }
    static DiffNoAlpha(f, h) {
      const g = new e.Color(0, 0, 0, 1);
      g.setR(Math.max(f._r, h._r) - Math.min(f._r, h._r));
      g.setG(Math.max(f._g, h._g) - Math.min(f._g, h._g));
      g.setB(Math.max(f._b, h._b) - Math.min(f._b, h._b));
      return g;
    }
    static GetHue(f, h, g) {
      const k = Math.max(f, h, g),
        m = Math.min(f, h, g);
      if (k === m) return 0;
      let q = 0;
      switch (k) {
        case f:
          q = (h - g) / (k - m) + (h < g ? 6 : 0);
          break;
        case h:
          q = (g - f) / (k - m) + 2;
          break;
        case g:
          q = (f - h) / (k - m) + 4;
      }
      return Math.round((q / 6) * 360);
    }
    static GetSaturation(f, h, g) {
      const k = Math.max(f, h, g);
      f = Math.min(f, h, g);
      if (k === f) return 0;
      h = k - f;
      return Math.round(
        100 * (0.5 < (k + f) / 2 ? h / (2 - k - f) : h / (k + f))
      );
    }
    static GetLuminosity(f, h, g) {
      const k = Math.max(f, h, g);
      return k ? Math.round(((k + Math.min(f, h, g)) / 2) * 100) : 0;
    }
  };
  e.Color.White = Object.freeze(e.New(e.Color, 1, 1, 1, 1));
  e.Color.Black = Object.freeze(e.New(e.Color, 0, 0, 0, 1));
  e.Color.TransparentBlack = Object.freeze(e.New(e.Color, 0, 0, 0, 0));
}
{
  ("use strict");
  const e = self.C3;
  e.Vector2 = class {
    constructor(b, a) {
      this._y = this._x = 0;
      b instanceof e.Vector2 ? this.copy(b) : this.set(b || 0, a || 0);
    }
    set(b, a) {
      this._x = +b;
      this._y = +a;
    }
    copy(b) {
      this._x = b._x;
      this._y = b._y;
    }
    equals(b) {
      return this._x === b._x && this._y === b._y;
    }
    equalsValues(b, a) {
      return this._x === b && this._y === a;
    }
    equalsF32Array(b, a) {
      return b[a] === Math.fround(this._x) && b[a + 1] === Math.fround(this._y);
    }
    setX(b) {
      this._x = +b;
    }
    getX() {
      return this._x;
    }
    setY(b) {
      this._y = +b;
    }
    getY() {
      return this._y;
    }
    toArray() {
      return [this._x, this._y];
    }
    toTypedArray() {
      return new Float64Array(this.toArray());
    }
    writeToTypedArray(b, a) {
      b[a++] = this._x;
      b[a] = this._y;
    }
    offset(b, a) {
      this._x += +b;
      this._y += +a;
    }
    scale(b, a) {
      this._x *= b;
      this._y *= a;
    }
    divide(b, a) {
      this._x /= b;
      this._y /= a;
    }
    round() {
      this._x = Math.round(this._x);
      this._y = Math.round(this._y);
    }
    floor() {
      this._x = Math.floor(this._x);
      this._y = Math.floor(this._y);
    }
    ceil() {
      this._x = Math.ceil(this._x);
      this._y = Math.ceil(this._y);
    }
    angle() {
      return e.angleTo(0, 0, this._x, this._y);
    }
    lengthSquared() {
      return this._x * this._x + this._y * this._y;
    }
    length() {
      return Math.sqrt(this.lengthSquared());
    }
    rotatePrecalc(b, a) {
      const c = this._x * a - this._y * b;
      this._y = this._y * a + this._x * b;
      this._x = c;
    }
    rotate(b) {
      0 !== b && this.rotatePrecalc(Math.sin(b), Math.cos(b));
    }
    rotateAbout(b, a, c) {
      0 === b ||
        (a === this._x && c === this._y) ||
        ((this._x -= a),
        (this._y -= c),
        this.rotatePrecalc(Math.sin(b), Math.cos(b)),
        (this._x += +a),
        (this._y += +c));
    }
    move(b, a) {
      0 !== a && ((this._x += Math.cos(b) * a), (this._y += Math.sin(b) * a));
    }
    normalize() {
      const b = this.length();
      0 !== b && 1 !== b && ((this._x /= b), (this._y /= b));
    }
    clamp(b, a) {
      this._x = e.clamp(this._x, b, a);
      this._y = e.clamp(this._y, b, a);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Rect = class {
    constructor(b, a, c, d) {
      this._bottom = this._right = this._top = this._left = 0;
      b instanceof e.Rect
        ? this.copy(b)
        : this.set(b || 0, a || 0, c || 0, d || 0);
    }
    set(b, a, c, d) {
      this._left = +b;
      this._top = +a;
      this._right = +c;
      this._bottom = +d;
    }
    setWH(b, a, c, d) {
      b = +b;
      a = +a;
      this._left = b;
      this._top = a;
      this._right = b + +c;
      this._bottom = a + +d;
    }
    copy(b) {
      this._left = +b._left;
      this._top = +b._top;
      this._right = +b._right;
      this._bottom = +b._bottom;
    }
    clone() {
      return new e.Rect(this._left, this._top, this._right, this._bottom);
    }
    static Merge(b, a) {
      const c = new e.Rect();
      c.setLeft(Math.min(b._left, a._left));
      c.setTop(Math.min(b._top, a._top));
      c.setRight(Math.max(b._right, a._right));
      c.setBottom(Math.max(b._bottom, a._bottom));
      return c;
    }
    static FromObject(b) {
      return new e.Rect(b.left, b.top, b.right, b.bottom);
    }
    equals(b) {
      return (
        this._left === b._left &&
        this._top === b._top &&
        this._right === b._right &&
        this._bottom === b._bottom
      );
    }
    equalsWH(b, a, c, d) {
      return (
        this._left === b &&
        this._top === a &&
        this.width() === c &&
        this.height() === d
      );
    }
    equalsF32Array(b, a) {
      return (
        b[a] === Math.fround(this._left) &&
        b[a + 1] === Math.fround(this._top) &&
        b[a + 2] === Math.fround(this._right) &&
        b[a + 3] === Math.fround(this._bottom)
      );
    }
    setLeft(b) {
      this._left = +b;
    }
    getLeft() {
      return this._left;
    }
    setTop(b) {
      this._top = +b;
    }
    getTop() {
      return this._top;
    }
    setRight(b) {
      this._right = +b;
    }
    getRight() {
      return this._right;
    }
    setBottom(b) {
      this._bottom = +b;
    }
    getBottom() {
      return this._bottom;
    }
    toArray() {
      return [this._left, this._top, this._right, this._bottom];
    }
    toTypedArray() {
      return new Float64Array(this.toArray());
    }
    toDOMRect() {
      return new DOMRect(this._left, this._top, this.width(), this.height());
    }
    writeToTypedArray(b, a) {
      b[a++] = this._left;
      b[a++] = this._top;
      b[a++] = this._right;
      b[a] = this._bottom;
    }
    writeAsQuadToTypedArray(b, a) {
      b[a++] = this._left;
      b[a++] = this._top;
      b[a++] = this._right;
      b[a++] = this._top;
      b[a++] = this._right;
      b[a++] = this._bottom;
      b[a++] = this._left;
      b[a] = this._bottom;
    }
    writeAsQuadToTypedArray3D(b, a, c) {
      b[a++] = this._left;
      b[a++] = this._top;
      b[a++] = c;
      b[a++] = this._right;
      b[a++] = this._top;
      b[a++] = c;
      b[a++] = this._right;
      b[a++] = this._bottom;
      b[a++] = c;
      b[a++] = this._left;
      b[a++] = this._bottom;
      b[a] = c;
    }
    width() {
      return this._right - this._left;
    }
    height() {
      return this._bottom - this._top;
    }
    midX() {
      return (this._left + this._right) / 2;
    }
    midY() {
      return (this._top + this._bottom) / 2;
    }
    offset(b, a) {
      b = +b;
      a = +a;
      this._left += b;
      this._top += a;
      this._right += b;
      this._bottom += a;
    }
    offsetLeft(b) {
      this._left += +b;
    }
    offsetTop(b) {
      this._top += +b;
    }
    offsetRight(b) {
      this._right += +b;
    }
    offsetBottom(b) {
      this._bottom += +b;
    }
    toSquare(b) {
      if ("x" !== b) throw Error("invalid axis, only 'x' supported");
      this._bottom =
        this._top < this._bottom
          ? this._left < this._right
            ? this._top + this.width()
            : this._top - this.width()
          : this._left < this._right
          ? this._top - this.width()
          : this._top + this.width();
    }
    inflate(b, a) {
      b = +b;
      a = +a;
      this._left -= b;
      this._top -= a;
      this._right += b;
      this._bottom += a;
    }
    deflate(b, a) {
      b = +b;
      a = +a;
      this._left += b;
      this._top += a;
      this._right -= b;
      this._bottom -= a;
    }
    multiply(b, a) {
      this._left *= b;
      this._top *= a;
      this._right *= b;
      this._bottom *= a;
    }
    divide(b, a) {
      this._left /= b;
      this._top /= a;
      this._right /= b;
      this._bottom /= a;
    }
    mirrorAround(b) {
      this._left = +b - this._left;
      this._right = +b - this._right;
    }
    flipAround(b) {
      this._top = +b - this._top;
      this._bottom = +b - this._bottom;
    }
    swapLeftRight() {
      const b = this._left;
      this._left = this._right;
      this._right = b;
    }
    swapTopBottom() {
      const b = this._top;
      this._top = this._bottom;
      this._bottom = b;
    }
    shuntY(b) {
      const a = this._top;
      this._top = +b - this._bottom;
      this._bottom = +b - a;
    }
    round() {
      this._left = Math.round(this._left);
      this._top = Math.round(this._top);
      this._right = Math.round(this._right);
      this._bottom = Math.round(this._bottom);
    }
    roundInner() {
      this._left = Math.ceil(this._left);
      this._top = Math.ceil(this._top);
      this._right = Math.floor(this._right);
      this._bottom = Math.floor(this._bottom);
    }
    roundOuter() {
      this._left = Math.floor(this._left);
      this._top = Math.floor(this._top);
      this._right = Math.ceil(this._right);
      this._bottom = Math.ceil(this._bottom);
    }
    floor() {
      this._left = Math.floor(this._left);
      this._top = Math.floor(this._top);
      this._right = Math.floor(this._right);
      this._bottom = Math.floor(this._bottom);
    }
    ceil() {
      this._left = Math.ceil(this._left);
      this._top = Math.ceil(this._top);
      this._right = Math.ceil(this._right);
      this._bottom = Math.ceil(this._bottom);
    }
    clamp(b, a, c, d) {
      this._left < b && (this._left = +b);
      this._top < a && (this._top = +a);
      this._right > c && (this._right = +c);
      this._bottom > d && (this._bottom = +d);
    }
    clampFlipped(b, a, c, d) {
      this._left < b && (this._left = +b);
      this._top > a && (this._top = +a);
      this._right > c && (this._right = +c);
      this._bottom < d && (this._bottom = +d);
    }
    normalize() {
      this._left > this._right && this.swapLeftRight();
      this._top > this._bottom && this.swapTopBottom();
    }
    intersectsRect(b) {
      return !(
        b._right < this._left ||
        b._bottom < this._top ||
        b._left > this._right ||
        b._top > this._bottom
      );
    }
    intersectsRectOffset(b, a, c) {
      return !(
        b._right + a < this._left ||
        b._bottom + c < this._top ||
        b._left + a > this._right ||
        b._top + c > this._bottom
      );
    }
    containsPoint(b, a) {
      return (
        b >= this._left &&
        b <= this._right &&
        a >= this._top &&
        a <= this._bottom
      );
    }
    containsRect(b) {
      return (
        b._left >= this._left &&
        b._top >= this._top &&
        b._right <= this._right &&
        b._bottom <= this._bottom
      );
    }
    expandToContain(b) {
      b._left < this._left && (this._left = +b._left);
      b._top < this._top && (this._top = +b._top);
      b._right > this._right && (this._right = +b._right);
      b._bottom > this._bottom && (this._bottom = +b._bottom);
    }
    lerpInto(b) {
      this._left = e.lerp(b._left, b._right, this._left);
      this._top = e.lerp(b._top, b._bottom, this._top);
      this._right = e.lerp(b._left, b._right, this._right);
      this._bottom = e.lerp(b._top, b._bottom, this._bottom);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Quad = class {
    constructor(b, a, c, d, f, h, g, k) {
      this._bly =
        this._blx =
        this._bry =
        this._brx =
        this._try =
        this._trx =
        this._tly =
        this._tlx =
          0;
      b instanceof e.Quad
        ? this.copy(b)
        : this.set(
            b || 0,
            a || 0,
            c || 0,
            d || 0,
            f || 0,
            h || 0,
            g || 0,
            k || 0
          );
    }
    set(b, a, c, d, f, h, g, k) {
      this._tlx = +b;
      this._tly = +a;
      this._trx = +c;
      this._try = +d;
      this._brx = +f;
      this._bry = +h;
      this._blx = +g;
      this._bly = +k;
    }
    setRect(b, a, c, d) {
      this.set(b, a, c, a, c, d, b, d);
    }
    copy(b) {
      this._tlx = b._tlx;
      this._tly = b._tly;
      this._trx = b._trx;
      this._try = b._try;
      this._brx = b._brx;
      this._bry = b._bry;
      this._blx = b._blx;
      this._bly = b._bly;
    }
    equals(b) {
      return (
        this._tlx === b._tlx &&
        this._tly === b._tly &&
        this._trx === b._trx &&
        this._try === b._try &&
        this._brx === b._brx &&
        this._bry === b._bry &&
        this._blx === b._blx &&
        this._bly === b._bly
      );
    }
    setTlx(b) {
      this._tlx = +b;
    }
    getTlx() {
      return this._tlx;
    }
    setTly(b) {
      this._tly = +b;
    }
    getTly() {
      return this._tly;
    }
    setTrx(b) {
      this._trx = +b;
    }
    getTrx() {
      return this._trx;
    }
    setTry(b) {
      this._try = +b;
    }
    getTry() {
      return this._try;
    }
    setBrx(b) {
      this._brx = +b;
    }
    getBrx() {
      return this._brx;
    }
    setBry(b) {
      this._bry = +b;
    }
    getBry() {
      return this._bry;
    }
    setBlx(b) {
      this._blx = +b;
    }
    getBlx() {
      return this._blx;
    }
    setBly(b) {
      this._bly = +b;
    }
    getBly() {
      return this._bly;
    }
    toDOMQuad() {
      return new DOMQuad(
        new DOMPoint(this._tlx, this._tly),
        new DOMPoint(this._trx, this._try),
        new DOMPoint(this._brx, this._bry),
        new DOMPoint(this._blx, this._bly)
      );
    }
    toArray() {
      return [
        this._tlx,
        this._tly,
        this._trx,
        this._try,
        this._brx,
        this._bry,
        this._blx,
        this._bly,
      ];
    }
    toTypedArray() {
      return new Float64Array(this.toArray());
    }
    writeToTypedArray(b, a) {
      b[a++] = this._tlx;
      b[a++] = this._tly;
      b[a++] = this._trx;
      b[a++] = this._try;
      b[a++] = this._brx;
      b[a++] = this._bry;
      b[a++] = this._blx;
      b[a] = this._bly;
    }
    writeToTypedArray3D(b, a, c) {
      b[a++] = this._tlx;
      b[a++] = this._tly;
      b[a++] = c;
      b[a++] = this._trx;
      b[a++] = this._try;
      b[a++] = c;
      b[a++] = this._brx;
      b[a++] = this._bry;
      b[a++] = c;
      b[a++] = this._blx;
      b[a++] = this._bly;
      b[a] = c;
    }
    offset(b, a) {
      b = +b;
      a = +a;
      this._tlx += b;
      this._tly += a;
      this._trx += b;
      this._try += a;
      this._brx += b;
      this._bry += a;
      this._blx += b;
      this._bly += a;
    }
    round() {
      this._tlx = Math.round(this._tlx);
      this._tly = Math.round(this._tly);
      this._trx = Math.round(this._trx);
      this._try = Math.round(this._try);
      this._brx = Math.round(this._brx);
      this._bry = Math.round(this._bry);
      this._blx = Math.round(this._blx);
      this._bly = Math.round(this._bly);
    }
    floor() {
      this._tlx = Math.floor(this._tlx);
      this._tly = Math.floor(this._tly);
      this._trx = Math.floor(this._trx);
      this._try = Math.floor(this._try);
      this._brx = Math.floor(this._brx);
      this._bry = Math.floor(this._bry);
      this._blx = Math.floor(this._blx);
      this._bly = Math.floor(this._bly);
    }
    ceil() {
      this._tlx = Math.ceil(this._tlx);
      this._tly = Math.ceil(this._tly);
      this._trx = Math.ceil(this._trx);
      this._try = Math.ceil(this._try);
      this._brx = Math.ceil(this._brx);
      this._bry = Math.ceil(this._bry);
      this._blx = Math.ceil(this._blx);
      this._bly = Math.ceil(this._bly);
    }
    setFromRect(b) {
      this._tlx = b._left;
      this._tly = b._top;
      this._trx = b._right;
      this._try = b._top;
      this._brx = b._right;
      this._bry = b._bottom;
      this._blx = b._left;
      this._bly = b._bottom;
    }
    setFromRotatedRect(b, a) {
      0 === a
        ? this.setFromRect(b)
        : this.setFromRotatedRectPrecalc(b, Math.sin(a), Math.cos(a));
    }
    setFromRotatedRectPrecalc(b, a, c) {
      const d = b._left * a,
        f = b._top * a,
        h = b._right * a;
      a *= b._bottom;
      const g = b._left * c,
        k = b._top * c,
        m = b._right * c;
      b = b._bottom * c;
      this._tlx = g - f;
      this._tly = k + d;
      this._trx = m - f;
      this._try = k + h;
      this._brx = m - a;
      this._bry = b + h;
      this._blx = g - a;
      this._bly = b + d;
    }
    getBoundingBox(b) {
      b.set(
        Math.min(this._tlx, this._trx, this._brx, this._blx),
        Math.min(this._tly, this._try, this._bry, this._bly),
        Math.max(this._tlx, this._trx, this._brx, this._blx),
        Math.max(this._tly, this._try, this._bry, this._bly)
      );
    }
    containsPoint(b, a) {
      var c = this._trx - this._tlx,
        d = this._try - this._tly;
      const f = this._brx - this._tlx,
        h = this._bry - this._tly;
      b -= this._tlx;
      a -= this._tly;
      var g = c * c + d * d;
      let k = c * f + d * h;
      d = c * b + d * a;
      const m = f * f + h * h,
        q = f * b + h * a;
      let v = 1 / (g * m - k * k);
      c = (m * d - k * q) * v;
      g = (g * q - k * d) * v;
      if (0 <= c && 0 < g && 1 > c + g) return !0;
      c = this._blx - this._tlx;
      d = this._bly - this._tly;
      g = c * c + d * d;
      k = c * f + d * h;
      d = c * b + d * a;
      v = 1 / (g * m - k * k);
      c = (m * d - k * q) * v;
      g = (g * q - k * d) * v;
      return 0 <= c && 0 < g && 1 > c + g;
    }
    midX() {
      return (this._tlx + this._trx + this._brx + this._blx) / 4;
    }
    midY() {
      return (this._tly + this._try + this._bry + this._bly) / 4;
    }
    intersectsSegment(b, a, c, d) {
      return this.containsPoint(b, a) || this.containsPoint(c, d)
        ? !0
        : e.segmentIntersectsQuad(b, a, c, d, this);
    }
    intersectsQuad(b) {
      var a = b.midX(),
        c = b.midY();
      if (this.containsPoint(a, c)) return !0;
      a = this.midX();
      c = this.midY();
      if (b.containsPoint(a, c)) return !0;
      a = this._tlx;
      c = this._tly;
      const d = this._trx,
        f = this._try,
        h = this._brx,
        g = this._bry,
        k = this._blx,
        m = this._bly;
      return (
        e.segmentIntersectsQuad(a, c, d, f, b) ||
        e.segmentIntersectsQuad(d, f, h, g, b) ||
        e.segmentIntersectsQuad(h, g, k, m, b) ||
        e.segmentIntersectsQuad(k, m, a, c, b)
      );
    }
    rotatePointsAnticlockwise() {
      const b = this._tlx,
        a = this._tly;
      this._tlx = this._trx;
      this._tly = this._try;
      this._trx = this._brx;
      this._try = this._bry;
      this._brx = this._blx;
      this._bry = this._bly;
      this._blx = b;
      this._bly = a;
    }
    mirror() {
      this._swap(0, 2);
      this._swap(1, 3);
      this._swap(6, 4);
      this._swap(7, 5);
    }
    flip() {
      this._swap(0, 6);
      this._swap(1, 7);
      this._swap(2, 4);
      this._swap(3, 5);
    }
    diag() {
      this._swap(2, 6);
      this._swap(3, 7);
    }
    _swap(b, a) {
      const c = this._getAtIndex(b);
      this._setAtIndex(b, this._getAtIndex(a));
      this._setAtIndex(a, c);
    }
    _getAtIndex(b) {
      switch (b) {
        case 0:
          return this._tlx;
        case 1:
          return this._tly;
        case 2:
          return this._trx;
        case 3:
          return this._try;
        case 4:
          return this._brx;
        case 5:
          return this._bry;
        case 6:
          return this._blx;
        case 7:
          return this._bly;
        default:
          throw new RangeError("invalid quad point index");
      }
    }
    _setAtIndex(b, a) {
      a = +a;
      switch (b) {
        case 0:
          this._tlx = a;
          break;
        case 1:
          this._tly = a;
          break;
        case 2:
          this._trx = a;
          break;
        case 3:
          this._try = a;
          break;
        case 4:
          this._brx = a;
          break;
        case 5:
          this._bry = a;
          break;
        case 6:
          this._blx = a;
          break;
        case 7:
          this._bly = a;
          break;
        default:
          throw new RangeError("invalid quad point index");
      }
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = [0, 0, 1, 0, 1, 1, 0, 1],
    a = e.New(e.Quad);
  e.CollisionPoly = class extends e.DefendedBase {
    constructor(c, d = !0) {
      super();
      c || (c = b);
      this._ptsArr = Float64Array.from(c);
      this._bbox = new e.Rect();
      this._isBboxChanged = !0;
      this._enabled = d;
    }
    Release() {}
    pointsArr() {
      return this._ptsArr;
    }
    pointCount() {
      return this._ptsArr.length / 2;
    }
    setPoints(c) {
      this._ptsArr.length === c.length
        ? this._ptsArr.set(c)
        : (this._ptsArr = Float64Array.from(c));
      this._isBboxChanged = !0;
    }
    setDefaultPoints() {
      this.setPoints(b);
    }
    copy(c) {
      this.setPoints(c._ptsArr);
    }
    setBboxChanged() {
      this._isBboxChanged = !0;
    }
    _updateBbox() {
      if (this._isBboxChanged) {
        var c = this._ptsArr,
          d = c[0],
          f = c[1],
          h = d,
          g = f;
        for (let k = 0, m = c.length; k < m; k += 2) {
          const q = c[k],
            v = c[k + 1];
          q < d && (d = q);
          q > h && (h = q);
          v < f && (f = v);
          v > g && (g = v);
        }
        this._bbox.set(d, f, h, g);
        this._isBboxChanged = !1;
      }
    }
    setFromRect(c, d, f) {
      let h = this._ptsArr;
      8 !== h.length && (this._ptsArr = h = new Float64Array(8));
      h[0] = c.getLeft() - d;
      h[1] = c.getTop() - f;
      h[2] = c.getRight() - d;
      h[3] = c.getTop() - f;
      h[4] = c.getRight() - d;
      h[5] = c.getBottom() - f;
      h[6] = c.getLeft() - d;
      h[7] = c.getBottom() - f;
      this._bbox.copy(c);
      (0 === d && 0 === f) || this._bbox.offset(-d, -f);
      this._isBboxChanged = !1;
    }
    setFromQuad(c, d, f) {
      a.copy(c);
      a.offset(d, f);
      this.setPoints(a.toArray());
      this._isBboxChanged = !0;
    }
    transform(c, d, f) {
      let h = 0,
        g = 1;
      0 !== f && ((h = Math.sin(f)), (g = Math.cos(f)));
      this.transformPrecalc(c, d, h, g);
    }
    transformPrecalc(c, d, f, h) {
      const g = this._ptsArr;
      for (let k = 0, m = g.length; k < m; k += 2) {
        const q = k + 1,
          v = g[k] * c,
          r = g[q] * d;
        g[k] = v * h - r * f;
        g[q] = r * h + v * f;
      }
      this._isBboxChanged = !0;
    }
    offset(c, d) {
      const f = this._ptsArr;
      for (let h = 0, g = f.length; h < g; h += 2) (f[h] += c), (f[h + 1] += d);
    }
    containsPoint(c, d) {
      const f = this._ptsArr;
      if (c === f[0] && d === f[1]) return !0;
      this._updateBbox();
      var h = this._bbox;
      const g = h.getLeft() - 110,
        k = h.getTop() - 101,
        m = h.getRight() + 131;
      h = h.getBottom() + 120;
      let q, v, r, n, p, u, w, y;
      g < c ? ((q = g), (r = c)) : ((q = c), (r = g));
      k < d ? ((v = k), (n = d)) : ((v = d), (n = k));
      m < c ? ((p = m), (w = c)) : ((p = c), (w = m));
      h < d ? ((u = h), (y = d)) : ((u = d), (y = h));
      let B = 0,
        E = 0;
      for (let D = 0, J = f.length; D < J; D += 2) {
        var z = (D + 2) % J;
        const C = f[D],
          H = f[D + 1],
          K = f[z];
        z = f[z + 1];
        e.segmentsIntersectPreCalc(g, k, c, d, q, r, v, n, C, H, K, z) && ++B;
        e.segmentsIntersectPreCalc(m, h, c, d, p, w, u, y, C, H, K, z) && ++E;
      }
      return 1 === B % 2 || 1 === E % 2;
    }
    intersectsPoly(c, d, f) {
      const h = c._ptsArr,
        g = this._ptsArr;
      if (
        this.containsPoint(h[0] + d, h[1] + f) ||
        c.containsPoint(g[0] - d, g[1] - f)
      )
        return !0;
      for (let m = 0, q = g.length; m < q; m += 2) {
        var k = (m + 2) % q;
        c = g[m];
        const v = g[m + 1],
          r = g[k];
        k = g[k + 1];
        let n, p, u, w;
        c < r ? ((n = c), (u = r)) : ((n = r), (u = c));
        v < k ? ((p = v), (w = k)) : ((p = k), (w = v));
        for (let y = 0, B = h.length; y < B; y += 2) {
          const E = (y + 2) % B;
          if (
            e.segmentsIntersectPreCalc(
              c,
              v,
              r,
              k,
              n,
              u,
              p,
              w,
              h[y] + d,
              h[y + 1] + f,
              h[E] + d,
              h[E + 1] + f
            )
          )
            return !0;
        }
      }
      return !1;
    }
    intersectsSegment(c, d, f, h, g, k) {
      if (this.containsPoint(f - c, h - d) || this.containsPoint(g - c, k - d))
        return !0;
      let m, q, v, r;
      f < g ? ((m = f), (v = g)) : ((m = g), (v = f));
      h < k ? ((q = h), (r = k)) : ((q = k), (r = h));
      const n = this._ptsArr;
      for (let p = 0, u = n.length; p < u; p += 2) {
        const w = (p + 2) % u;
        if (
          e.segmentsIntersectPreCalc(
            f,
            h,
            g,
            k,
            m,
            v,
            q,
            r,
            n[p] + c,
            n[p + 1] + d,
            n[w] + c,
            n[w + 1] + d
          )
        )
          return !0;
      }
      return !1;
    }
    mirror(c) {
      const d = this._ptsArr;
      for (let f = 0, h = d.length; f < h; f += 2) d[f] = 2 * c - d[f];
      this._isBboxChanged = !0;
    }
    flip(c) {
      const d = this._ptsArr;
      for (let f = 0, h = d.length; f < h; f += 2) {
        const g = f + 1;
        d[g] = 2 * c - d[g];
      }
      this._isBboxChanged = !0;
    }
    diag() {
      const c = this._ptsArr;
      for (let d = 0, f = c.length; d < f; d += 2) {
        const h = d + 1,
          g = c[d];
        c[d] = c[h];
        c[h] = g;
      }
      this._isBboxChanged = !0;
    }
    GetMidX() {
      const c = this._ptsArr;
      let d = 0;
      for (let f = 0, h = c.length; f < h; f += 2) d += c[f];
      return d / this.pointCount();
    }
    GetMidY() {
      const c = this._ptsArr;
      let d = 0;
      for (let f = 0, h = c.length; f < h; f += 2) d += c[f + 1];
      return d / this.pointCount();
    }
    GetPointsArray() {
      return this._ptsArr;
    }
    GetPointCount() {
      return this.pointCount();
    }
    IsEnabled() {
      return this._enabled;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.PairMap = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._firstMap = new Map();
      if (b) for (const [a, c, d] of b) this.Set(a, c, d);
    }
    Release() {
      this.Clear();
      this._firstMap = null;
    }
    Clear() {
      const b = this._firstMap;
      for (const a of b.values()) a.clear();
      b.clear();
    }
    Set(b, a, c) {
      const d = this._firstMap;
      let f = d.get(b);
      f || ((f = new Map()), d.set(b, f));
      f.set(a, c);
    }
    Get(b, a) {
      return (b = this._firstMap.get(b)) ? b.get(a) : b;
    }
    Has(b, a) {
      return (b = this._firstMap.get(b)) ? b.has(a) : !1;
    }
    Delete(b, a) {
      const c = this._firstMap,
        d = c.get(b);
      if (!d) return !1;
      (a = d.delete(a)) && 0 === d.size && c.delete(b);
      return a;
    }
    DeleteEither(b) {
      const a = this._firstMap,
        c = a.get(b);
      c && (c.clear(), a.delete(b));
      for (const [d, f] of a.entries())
        f.delete(b) && 0 === f.size && a.delete(d);
    }
    GetSize() {
      let b = 0;
      for (const a of this._firstMap.values()) b += a.size;
      return b;
    }
    *values() {
      for (const b of this._firstMap.values()) yield* b.values();
    }
    *keyPairs() {
      for (const [b, a] of this._firstMap.entries())
        for (const c of a.keys()) yield [b, c];
    }
    *entries() {
      for (const [b, a] of this._firstMap.entries())
        for (const [c, d] of a.entries()) yield [b, c, d];
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.ArraySet = class extends e.DefendedBase {
    constructor() {
      super();
      this._set = new Set();
      this._arr = [];
      this._needToRebuildArray = !1;
    }
    Release() {
      this.Clear();
    }
    Clear() {
      this._set.clear();
      e.clearArray(this._arr);
      this._needToRebuildArray = !1;
    }
    Add(b) {
      this._set.has(b) ||
        (this._set.add(b), this._needToRebuildArray || this._arr.push(b));
    }
    Has(b) {
      return this._set.has(b);
    }
    Delete(b) {
      this._set.delete(b) && (this._needToRebuildArray = !0);
    }
    GetSize() {
      return this._set.size;
    }
    IsEmpty() {
      return 0 === this._set.size;
    }
    GetArray() {
      this._needToRebuildArray &&
        (this._RebuildArray(), (this._needToRebuildArray = !1));
      return this._arr;
    }
    _RebuildArray() {
      const b = this._arr;
      e.clearArray(b);
      for (const a of this._set) b.push(a);
    }
  };
}
{
  ("use strict");
  const e = new Map(),
    b = new Map(),
    a = new Map(),
    c = new Map(),
    d = new Map(),
    f = new Map();
  f.set("linear", "noease");
  f.set("default", "noease");
  self.Ease = class r {
    constructor() {}
    static InheritEase() {
      return "default";
    }
    static DefaultEase() {
      return "noease";
    }
    static GetEditorEaseNames(n, ...p) {
      this._CreateEaseMap();
      a.has(n) || a.set(n, new Map());
      n = [...a.get(n).keys()];
      n.sort();
      return [...b.keys()].concat(n).filter((u) => !p.includes(u));
    }
    static GetRuntimeEaseNames() {
      this._CreateEaseMap();
      const n = [...c.keys()];
      n.sort();
      return [...b.keys()].concat(n);
    }
    static IsNamePredefined(n) {
      this._CreateEaseMap();
      return [...b.keys()].includes(n);
    }
    static _GetEase(n) {
      const p = f.get(n);
      if (p) return e.get(p);
      if (r.IsNamePredefined(n)) return e.get(n);
      if (d.has(n)) return d.get(n);
    }
    static GetEditorEase(n, p) {
      this._CreateEaseMap();
      const u = r._GetEase(n);
      return u ? u : a.get(p).get(n);
    }
    static GetRuntimeEase(n) {
      this._CreateEaseMap();
      const p = r._GetEase(n);
      return p ? p : c.get(n);
    }
    static GetEaseFromIndex(n) {
      this._CreateEaseMap();
      return this.GetRuntimeEaseNames()[n];
    }
    static GetIndexForEase(n, p) {
      this._CreateEaseMap();
      return this.GetEditorEaseNames(p).indexOf(n);
    }
    static _CreateEaseMap() {
      0 === e.size &&
        (this._AddPredifinedEase("default", () => {}),
        this._AddPredifinedEase("noease", this.NoEase),
        this._AddPredifinedEase("easeinsine", this.EaseInSine),
        this._AddPredifinedEase("easeoutsine", this.EaseOutSine),
        this._AddPredifinedEase("easeinoutsine", this.EaseInOutSine),
        this._AddPredifinedEase("easeinelastic", this.EaseInElastic),
        this._AddPredifinedEase("easeoutelastic", this.EaseOutElastic),
        this._AddPredifinedEase("easeinoutelastic", this.EaseInOutElastic),
        this._AddPredifinedEase("easeinback", this.EaseInBack),
        this._AddPredifinedEase("easeoutback", this.EaseOutBack),
        this._AddPredifinedEase("easeinoutback", this.EaseInOutBack),
        this._AddPredifinedEase("easeinbounce", this.EaseInBounce),
        this._AddPredifinedEase("easeoutbounce", this.EaseOutBounce),
        this._AddPredifinedEase("easeinoutbounce", this.EaseInOutBounce),
        this._AddPredifinedEase("easeincubic", this.EaseInCubic),
        this._AddPredifinedEase("easeoutcubic", this.EaseOutCubic),
        this._AddPredifinedEase("easeinoutcubic", this.EaseInOutCubic),
        this._AddPredifinedEase("easeinquad", this.EaseInQuad),
        this._AddPredifinedEase("easeoutquad", this.EaseOutQuad),
        this._AddPredifinedEase("easeinoutquad", this.EaseInOutQuad),
        this._AddPredifinedEase("easeinquart", this.EaseInQuart),
        this._AddPredifinedEase("easeoutquart", this.EaseOutQuart),
        this._AddPredifinedEase("easeinoutquart", this.EaseInOutQuart),
        this._AddPredifinedEase("easeinquint", this.EaseInQuint),
        this._AddPredifinedEase("easeoutquint", this.EaseOutQuint),
        this._AddPredifinedEase("easeinoutquint", this.EaseInOutQuint),
        this._AddPredifinedEase("easeincirc", this.EaseInCirc),
        this._AddPredifinedEase("easeoutcirc", this.EaseOutCirc),
        this._AddPredifinedEase("easeinoutcirc", this.EaseInOutCirc),
        this._AddPredifinedEase("easeinexpo", this.EaseInExpo),
        this._AddPredifinedEase("easeoutexpo", this.EaseOutExpo),
        this._AddPredifinedEase("easeinoutexpo", this.EaseInOutExpo),
        this._AddPrivateCustomEase("cubicbezier", this.EaseCubicBezier),
        this._AddPrivateCustomEase("spline", this.EaseSpline));
    }
    static _AddPredifinedEase(n, p) {
      r._AddEase(n, p, "predefined");
    }
    static _AddPrivateCustomEase(n, p) {
      r._AddEase(n, p, "private");
    }
    static AddCustomEase(n, p, u) {
      this._CreateEaseMap();
      r._AddEase(n, p, "custom", u);
    }
    static RemoveCustomEase(n, p) {
      this.IsNamePredefined(n) ||
        [...d.keys()].includes(n) ||
        ((p = a.get(p)) && p.delete(n));
    }
    static _AddEase(n, p, u, w) {
      switch (u) {
        case "predefined":
          e.set(n, p);
          b.set(n, p);
          break;
        case "custom":
          w
            ? (a.has(w) || a.set(w, new Map()), a.get(w).set(n, p))
            : c.set(n, p);
          break;
        case "private":
          e.set(n, p);
          d.set(n, p);
          break;
        default:
          throw Error("unexpected ease mode");
      }
    }
    static NoEase(n, p, u, w) {
      return (u * n) / w + p;
    }
    static EaseInQuad(n, p, u, w) {
      return u * (n /= w) * n + p;
    }
    static EaseOutQuad(n, p, u, w) {
      return -u * (n /= w) * (n - 2) + p;
    }
    static EaseInOutQuad(n, p, u, w) {
      return 1 > (n /= w / 2)
        ? (u / 2) * n * n + p
        : (-u / 2) * (--n * (n - 2) - 1) + p;
    }
    static EaseInCubic(n, p, u, w) {
      return u * (n /= w) * n * n + p;
    }
    static EaseOutCubic(n, p, u, w) {
      return u * ((n = n / w - 1) * n * n + 1) + p;
    }
    static EaseInOutCubic(n, p, u, w) {
      return 1 > (n /= w / 2)
        ? (u / 2) * n * n * n + p
        : (u / 2) * ((n -= 2) * n * n + 2) + p;
    }
    static EaseInQuart(n, p, u, w) {
      return u * (n /= w) * n * n * n + p;
    }
    static EaseOutQuart(n, p, u, w) {
      return -u * ((n = n / w - 1) * n * n * n - 1) + p;
    }
    static EaseInOutQuart(n, p, u, w) {
      return 1 > (n /= w / 2)
        ? (u / 2) * n * n * n * n + p
        : (-u / 2) * ((n -= 2) * n * n * n - 2) + p;
    }
    static EaseInQuint(n, p, u, w) {
      return u * (n /= w) * n * n * n * n + p;
    }
    static EaseOutQuint(n, p, u, w) {
      return u * ((n = n / w - 1) * n * n * n * n + 1) + p;
    }
    static EaseInOutQuint(n, p, u, w) {
      return 1 > (n /= w / 2)
        ? (u / 2) * n * n * n * n * n + p
        : (u / 2) * ((n -= 2) * n * n * n * n + 2) + p;
    }
    static EaseInSine(n, p, u, w) {
      return -u * Math.cos((n / w) * (Math.PI / 2)) + u + p;
    }
    static EaseOutSine(n, p, u, w) {
      return u * Math.sin((n / w) * (Math.PI / 2)) + p;
    }
    static EaseInOutSine(n, p, u, w) {
      return (-u / 2) * (Math.cos((Math.PI * n) / w) - 1) + p;
    }
    static EaseInExpo(n, p, u, w) {
      return 0 === n ? p : u * Math.pow(2, 10 * (n / w - 1)) + p;
    }
    static EaseOutExpo(n, p, u, w) {
      return n === w ? p + u : u * (-Math.pow(2, (-10 * n) / w) + 1) + p;
    }
    static EaseInOutExpo(n, p, u, w) {
      return 0 === n
        ? p
        : n === w
        ? p + u
        : 1 > (n /= w / 2)
        ? (u / 2) * Math.pow(2, 10 * (n - 1)) + p
        : (u / 2) * (-Math.pow(2, -10 * --n) + 2) + p;
    }
    static EaseInCirc(n, p, u, w) {
      return -u * (Math.sqrt(1 - (n /= w) * n) - 1) + p;
    }
    static EaseOutCirc(n, p, u, w) {
      return u * Math.sqrt(1 - (n = n / w - 1) * n) + p;
    }
    static EaseInOutCirc(n, p, u, w) {
      return 1 > (n /= w / 2)
        ? (-u / 2) * (Math.sqrt(1 - n * n) - 1) + p
        : (u / 2) * (Math.sqrt(1 - (n -= 2) * n) + 1) + p;
    }
    static EaseInElastic(n, p, u, w) {
      let y = 0,
        B = u;
      if (0 === n) return p;
      if (1 === (n /= w)) return p + u;
      y || (y = 0.3 * w);
      B < Math.abs(u)
        ? ((B = u), (u = y / 4))
        : (u = (y / (2 * Math.PI)) * Math.asin(u / B));
      return (
        -(
          B *
          Math.pow(2, 10 * --n) *
          Math.sin((2 * (n * w - u) * Math.PI) / y)
        ) + p
      );
    }
    static EaseOutElastic(n, p, u, w) {
      let y,
        B = 0,
        E = u;
      if (0 === n) return p;
      if (1 === (n /= w)) return p + u;
      B || (B = 0.3 * w);
      E < Math.abs(u)
        ? ((E = u), (y = B / 4))
        : (y = (B / (2 * Math.PI)) * Math.asin(u / E));
      return (
        E * Math.pow(2, -10 * n) * Math.sin((2 * (n * w - y) * Math.PI) / B) +
        u +
        p
      );
    }
    static EaseInOutElastic(n, p, u, w) {
      let y,
        B = 0,
        E = u;
      if (0 === n) return p;
      if (2 === (n /= w / 2)) return p + u;
      B || (B = 0.3 * w * 1.5);
      E < Math.abs(u)
        ? ((E = u), (y = B / 4))
        : (y = (B / (2 * Math.PI)) * Math.asin(u / E));
      return 1 > n
        ? -0.5 *
            E *
            Math.pow(2, 10 * --n) *
            Math.sin((2 * (n * w - y) * Math.PI) / B) +
            p
        : E *
            Math.pow(2, -10 * --n) *
            Math.sin((2 * (n * w - y) * Math.PI) / B) *
            0.5 +
            u +
            p;
    }
    static EaseInBack(n, p, u, w, y) {
      void 0 === y && (y = 1.70158);
      return u * (n /= w) * n * ((y + 1) * n - y) + p;
    }
    static EaseOutBack(n, p, u, w, y) {
      void 0 === y && (y = 1.70158);
      return u * ((n = n / w - 1) * n * ((y + 1) * n + y) + 1) + p;
    }
    static EaseInOutBack(n, p, u, w, y) {
      void 0 === y && (y = 1.70158);
      return 1 > (n /= w / 2)
        ? (u / 2) * n * n * (((y *= 1.525) + 1) * n - y) + p
        : (u / 2) * ((n -= 2) * n * (((y *= 1.525) + 1) * n + y) + 2) + p;
    }
    static EaseInBounce(n, p, u, w) {
      return u - r.EaseOutBounce(w - n, 0, u, w) + p;
    }
    static EaseOutBounce(n, p, u, w) {
      return (n /= w) < 1 / 2.75
        ? 7.5625 * u * n * n + p
        : n < 2 / 2.75
        ? u * (7.5625 * (n -= 1.5 / 2.75) * n + 0.75) + p
        : n < 2.5 / 2.75
        ? u * (7.5625 * (n -= 2.25 / 2.75) * n + 0.9375) + p
        : u * (7.5625 * (n -= 2.625 / 2.75) * n + 0.984375) + p;
    }
    static EaseInOutBounce(n, p, u, w) {
      return n < w / 2
        ? 0.5 * r.EaseInBounce(2 * n, 0, u, w) + p
        : 0.5 * r.EaseOutBounce(2 * n - w, 0, u, w) + 0.5 * u + p;
    }
    static EaseCubicBezier(n, p, u, w, y) {
      return (
        p +
        3 * n * (u - p) +
        3 * n ** 2 * (p + w - 2 * u) +
        n ** 3 * (y - p + 3 * u - 3 * w)
      );
    }
    static EaseSpline(n, p, u, w, y, B, E, z, D, J) {
      if (w === y && B === E) return n;
      n = v(n, p, w, B, z, J);
      p = h(u, y, E, D);
      w = g(u, y, E, D);
      u = k(u, y, E, D);
      return m(n, p, w, u);
    }
    static GetBezierSamples(n, p, u, w) {
      const y = [],
        B = h(n, p, u, w),
        E = g(n, p, u, w);
      n = k(n, p, u, w);
      for (p = 0; 11 > p; ++p) (u = m(0.1 * p, B, E, n)), y.push(u);
      return y;
    }
  };
  const h = (r, n, p, u) => u - 3 * p + 3 * n - r,
    g = (r, n, p, u) => 3 * p - 6 * n + 3 * r,
    k = (r, n, p, u) => 3 * (n - r),
    m = (r, n, p, u) => ((n * r + p) * r + u) * r,
    q = (r, n, p, u) => 3 * n * r * r + 2 * p * r + u,
    v = (r, n, p, u, w, y) => {
      if (1 == r) return 1;
      for (var B = 0, E = 1, z = y[E]; 10 != E && z <= r; )
        E++, (z = y[E]), (B += 0.1);
      E--;
      z = y[E];
      y = B + ((r - z) / (y[E + 1] - z)) * 0.1;
      E = h(n, p, u, w);
      z = g(n, p, u, w);
      n = k(n, p, u, w);
      p = q(y, E, z, n);
      if (0 !== p)
        if (0.02 <= p)
          for (B = 0; 4 > B; ++B)
            (p = m(y, E, z, n) - r), (u = q(y, E, z, n)), (y -= p / u);
        else {
          p = B;
          B += 0.1;
          u = 0;
          let D;
          do
            (y = p + (B - p) / 2),
              (w = m(y, E, z, n) - r),
              0 < w ? (B = y) : (p = y),
              (w = 1e-7 < Math.abs(w)),
              (D = 10 > ++u);
          while (w && D);
        }
      return y;
    };
}
{
  ("use strict");
  const e = self.C3;
  function b(a) {
    e.IsString(a);
  }
  e.ProbabilityTable = class {
    constructor() {
      this._items = [];
      this._totalWeight = 0;
    }
    Release() {
      this.Clear();
      this._items = null;
    }
    Clear() {
      e.clear2DArray(this._items);
      this._totalWeight = 0;
    }
    GetTotalWeight() {
      return this._totalWeight;
    }
    Sample(a = Math.random() * this.GetTotalWeight()) {
      let c = 0;
      for (const [d, f] of this._items) if (((c += d), a < c)) return f;
      return 0;
    }
    AddItem(a, c) {
      b(c);
      this._totalWeight += a;
      this._items.push([a, c]);
    }
    RemoveItem(a, c) {
      b(c);
      const d = 0 === a;
      for (let f = 0; f < this._items.length; f++) {
        const h = this._items[f],
          g = h[1] === c;
        if ((d || h[0] === a) && g) {
          this._items.splice(f, 1);
          this._totalWeight -= h[0];
          break;
        }
      }
    }
    asJSON() {
      return JSON.stringify(this._items);
    }
    static fromJSON(a) {
      const c = new e.ProbabilityTable();
      a = JSON.parse(a);
      for (const d of a) c.AddItem(d[0], d[1]);
      return c;
    }
  };
}
("use strict");
self.C3.Event = class {
  constructor(e, b) {
    this.type = e;
    this.cancelable = !!b;
    this.isAsync = this.propagationStopped = this.defaultPrevented = !1;
  }
  preventDefault() {
    if (!this.cancelable) throw Error(`event '${this.type}' is not cancelable`);
    this.defaultPrevented = !0;
  }
  stopPropagation() {
    if (!this.cancelable) throw Error(`event '${this.type}' cannot be stopped`);
    if (this.isAsync)
      throw Error(`cannot stop async event '${this.type}' propagation`);
    this.propagationStopped = !0;
  }
};
{
  ("use strict");
  const e = self.C3;
  e.Event.Handler = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._type = b;
      this._captureListeners = [];
      this._captureListenersSet = new Set();
      this._listeners = [];
      this._listenersSet = new Set();
      this._fireDepth = 0;
      this._queueModifyListeners = [];
    }
    Release() {
      0 < this._fireDepth ||
        (e.clearArray(this._captureListeners),
        this._captureListenersSet.clear(),
        e.clearArray(this._listeners),
        this._listenersSet.clear(),
        e.clearArray(this._queueModifyListeners),
        e.Release(this));
    }
    _AddListener(b, a) {
      this._IsFiring()
        ? this._queueModifyListeners.push({ op: "add", func: b, capture: a })
        : a
        ? this._captureListenersSet.has(b) ||
          (this._captureListeners.push(b), this._captureListenersSet.add(b))
        : this._listenersSet.has(b) ||
          (this._listeners.push(b), this._listenersSet.add(b));
    }
    _RemoveListener(b, a) {
      this._IsFiring()
        ? this._queueModifyListeners.push({ op: "remove", func: b, capture: a })
        : a
        ? this._captureListenersSet.has(b) &&
          (this._captureListenersSet.delete(b),
          e.arrayFindRemove(this._captureListeners, b))
        : this._listenersSet.has(b) &&
          (this._listenersSet.delete(b), e.arrayFindRemove(this._listeners, b));
    }
    _IsEmpty() {
      return !this._captureListeners.length && !this._listeners.length;
    }
    _IsFiring() {
      return 0 < this._fireDepth;
    }
    _ProcessQueuedListeners() {
      const b = new Set(),
        a = new Set();
      for (const c of this._queueModifyListeners)
        if ("add" === c.op)
          this._AddListener(c.func, c.capture),
            c.capture ? a.delete(c.func) : b.delete(c.func);
        else if ("remove" === c.op)
          c.capture
            ? (this._captureListenersSet.delete(c.func), a.add(c.func))
            : (this._listenersSet.delete(c.func), b.add(c.func));
        else throw Error("invalid op");
      e.arrayRemoveAllInSet(this._listeners, b);
      e.arrayRemoveAllInSet(this._captureListeners, a);
      e.clearArray(this._queueModifyListeners);
    }
    _FireCancellable(b) {
      this._IncreaseFireDepth();
      let a = !1;
      for (let c = 0, d = this._captureListeners.length; c < d; ++c)
        if ((this._captureListeners[c](b), b.propagationStopped)) {
          a = !0;
          break;
        }
      if (!a)
        for (
          let c = 0, d = this._listeners.length;
          c < d && (this._listeners[c](b), !b.propagationStopped);
          ++c
        );
      this._DecreaseFireDepth();
      return !b.defaultPrevented;
    }
    _FireNonCancellable(b) {
      this._IncreaseFireDepth();
      for (let a = 0, c = this._captureListeners.length; a < c; ++a)
        this._captureListeners[a](b);
      for (let a = 0, c = this._listeners.length; a < c; ++a)
        this._listeners[a](b);
      this._DecreaseFireDepth();
      return !0;
    }
    _IncreaseFireDepth() {
      this._fireDepth++;
    }
    _DecreaseFireDepth() {
      this._fireDepth--;
      0 === this._fireDepth &&
        0 < this._queueModifyListeners.length &&
        this._ProcessQueuedListeners();
    }
    SetDelayRemoveEventsEnabled(b) {
      b ? this._IncreaseFireDepth() : this._DecreaseFireDepth();
    }
    _FireAsync(b) {
      let a = [];
      for (let c = 0, d = this._captureListeners.length; c < d; ++c) {
        let f = this._captureListeners[c];
        a.push(e.Asyncify(() => f(b)));
      }
      for (let c = 0, d = this._listeners.length; c < d; ++c) {
        let f = this._listeners[c];
        a.push(e.Asyncify(() => f(b)));
      }
      return Promise.all(a).then(() => !b.defaultPrevented);
    }
    _FireAndWait_AsyncOptional(b) {
      const a = [];
      this._IncreaseFireDepth();
      for (let d = 0, f = this._captureListeners.length; d < f; ++d) {
        var c = this._captureListeners[d](b);
        c instanceof Promise && a.push(c);
      }
      for (let d = 0, f = this._listeners.length; d < f; ++d)
        (c = this._listeners[d](b)), c instanceof Promise && a.push(c);
      this._DecreaseFireDepth();
      return a.length
        ? Promise.all(a).then(() => !b.defaultPrevented)
        : !b.defaultPrevented;
    }
    async _FireAndWaitAsync(b) {
      return await this._FireAndWait_AsyncOptional(b);
    }
    async _FireAndWaitAsyncSequential(b) {
      this._IncreaseFireDepth();
      for (let c = 0, d = this._captureListeners.length; c < d; ++c) {
        var a = this._captureListeners[c](b);
        a instanceof Promise && (await a);
      }
      for (let c = 0, d = this._listeners.length; c < d; ++c)
        (a = this._listeners[c](b)), a instanceof Promise && (await a);
      this._DecreaseFireDepth();
      return !b.defaultPrevented;
    }
    *_FireAsGenerator(b) {
      this._IncreaseFireDepth();
      for (let c = 0, d = this._captureListeners.length; c < d; ++c) {
        var a = this._captureListeners[c](b);
        e.IsIterator(a) && (yield* a);
      }
      for (let c = 0, d = this._listeners.length; c < d; ++c)
        (a = this._listeners[c](b)), e.IsIterator(a) && (yield* a);
      this._DecreaseFireDepth();
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Event.Dispatcher = class extends e.DefendedBase {
    constructor() {
      super();
      this._eventHandlers = new Map();
      this._dispatcherWasReleased = !1;
    }
    Release() {
      if (this._dispatcherWasReleased) throw Error("already released");
      this.ClearEvents();
      this._dispatcherWasReleased = !0;
      e.Release(this);
    }
    WasReleased() {
      return this._dispatcherWasReleased;
    }
    ClearEvents() {
      for (let b of this._eventHandlers.values()) b.Release();
      this._eventHandlers.clear();
    }
    _GetHandlerByType(b, a) {
      let c = this._eventHandlers.get(b);
      return c
        ? c
        : a
        ? ((c = e.New(e.Event.Handler, b)), this._eventHandlers.set(b, c), c)
        : null;
    }
    HasAnyHandlerFor(b) {
      return this._eventHandlers.has(b);
    }
    addEventListener(b, a, c) {
      this._GetHandlerByType(b, !0)._AddListener(a, !!c);
    }
    removeEventListener(b, a, c) {
      let d = this._GetHandlerByType(b, !1);
      d &&
        (d._RemoveListener(a, !!c),
        d._IsEmpty() && this._eventHandlers.delete(b));
    }
    dispatchEvent(b) {
      const a = this._GetHandlerByType(b.type, !1);
      return a
        ? b.cancelable
          ? a._FireCancellable(b)
          : a._FireNonCancellable(b)
        : !0;
    }
    dispatchEventAsync(b) {
      const a = this._GetHandlerByType(b.type, !1);
      if (!a) return Promise.resolve(!0);
      b.isAsync = !0;
      return a._FireAsync(b);
    }
    async dispatchEventAndClearAsync(b) {
      const a = this._GetHandlerByType(b.type, !1);
      if (!a) return !0;
      this._eventHandlers.delete(b.type);
      b.isAsync = !0;
      b = await a._FireAsync(b);
      a.Release();
      return b;
    }
    async dispatchEventAndWaitAsync(b) {
      const a = this._GetHandlerByType(b.type, !1);
      return a ? await a._FireAndWaitAsync(b) : !0;
    }
    dispatchEventAndWait_AsyncOptional(b) {
      const a = this._GetHandlerByType(b.type, !1);
      return a ? a._FireAndWait_AsyncOptional(b) : !0;
    }
    async dispatchEventAndWaitAsyncSequential(b) {
      const a = this._GetHandlerByType(b.type, !1);
      return a ? await a._FireAndWaitAsyncSequential(b) : !0;
    }
    dispatchGeneratorEvent(b) {
      const a = this._GetHandlerByType(b.type, !1);
      if (!a) return null;
      if (b.cancelable) throw Error("not supported");
      return a._FireAsGenerator(b);
    }
    SetDelayRemoveEventsEnabled(b) {
      for (const a of this._eventHandlers.values())
        a.SetDelayRemoveEventsEnabled(b);
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = "undefined" !== typeof requestIdleCallback;
  let a = [],
    c = -1,
    d = 0;
  function f(m) {
    c =
      b && 0 === d
        ? requestIdleCallback(h, { timeout: 35 })
        : setTimeout(h, 0 < d ? 1 : m);
  }
  function h(m) {
    c = -1;
    if (a.length) {
      var q = performance.now(),
        v = 0;
      do {
        g(a.shift());
        var r = performance.now();
        ++v;
        var n = ((r - q) / v) * 1.1;
      } while (
        a.length &&
        (b && 0 === d && "undefined" !== typeof m
          ? n < m.timeRemaining()
          : 12 > r - q + n)
      );
      -1 === c && a.length && f(Math.max(16 - (r - q), 4));
    }
  }
  function g(m) {
    let q;
    try {
      q = m.func();
    } catch (v) {
      m.reject(v);
      return;
    }
    m.resolve(q);
  }
  let k = e.QueryString.Has("disable-asyncify");
  k &&
    console.warn(
      "[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously."
    );
  e.Asyncify = function (m) {
    let q = null;
    e.isDebug && (q = e.GetCallStack());
    return new Promise((v, r) => {
      a.push({ func: m, resolve: v, reject: r, stack: q });
      k ? g(a.pop()) : -1 === c && f(16);
    });
  };
  e.Asyncify.SetHighThroughputMode = function (m) {
    if (m) ++d;
    else if ((--d, 0 > d))
      throw Error("already turned off high throughput mode");
  };
}
{
  ("use strict");
  const e = self.C3;
  let b = -1;
  function a() {
    b = -1;
  }
  e.FastGetDateNow = function () {
    -1 === b && ((b = Date.now()), self.setTimeout(a, 16));
    return b;
  };
  let c = -1,
    d = -1,
    f = new Set();
  function h() {
    d = c = -1;
    let g = Date.now();
    for (let k of f)
      if (k._CheckTimeout(g)) {
        let m = k._GetDeadline();
        if (-1 === d || m < d) d = m;
      } else f.delete(k);
    -1 !== d && (c = self.setTimeout(h, Math.max(d - g + 100, 1e3)));
  }
  e.IdleTimeout = class {
    constructor(g, k) {
      this._callback = g;
      this._timeout = 1e3 * k;
      this._deadline = 0;
      this._isActive = !1;
    }
    Reset() {
      let g = e.FastGetDateNow();
      this._deadline = g + this._timeout;
      this._isActive || (f.add(this), (this._isActive = !0));
      -1 === c
        ? ((d = this._deadline), (c = self.setTimeout(h, this._timeout + 100)))
        : this._deadline < d &&
          d > g + 1e3 &&
          (self.clearTimeout(c),
          (d = this._deadline),
          (c = self.setTimeout(h, this._timeout + 100)));
    }
    _CheckTimeout(g) {
      return g >= this._deadline
        ? this._callback()
          ? ((this._deadline = g + this._timeout), !0)
          : (this._isActive = !1)
        : !0;
    }
    _GetDeadline() {
      return this._deadline;
    }
    Cancel() {
      this._isActive &&
        (f.delete(this),
        (this._isActive = !1),
        0 === f.size && -1 !== c && (self.clearTimeout(c), (d = c = -1)));
    }
    Release() {
      this.Cancel();
      this._callback = null;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Disposable = class b {
    constructor(a) {
      this._disposed = !1;
      this._disposeAction = a;
    }
    Dispose() {
      this._disposed ||
        ((this._disposed = !0),
        this._disposeAction &&
          (this._disposeAction(), (this._disposeAction = null)));
    }
    IsDisposed() {
      return this._disposed;
    }
    Release() {
      this.Dispose();
    }
    static Release(a) {
      return new b(() => a.Release());
    }
    static From(a, c, d, f, h) {
      if ("undefined" === typeof f || null === f) f = !1;
      else if ("boolean" !== typeof f && "object" !== typeof f)
        throw new TypeError("invalid event listener options");
      h && (d = d.bind(h));
      if (c.includes(" ")) {
        c = c.split(" ");
        h = new e.CompositeDisposable();
        for (let g of c)
          a.addEventListener(g, d, f),
            h.Add(e.New(e.Disposable, () => a.removeEventListener(g, d, f)));
        return h;
      }
      a.addEventListener(c, d, f);
      return e.New(e.Disposable, () => a.removeEventListener(c, d, f));
    }
  };
  e.StubDisposable = class extends e.Disposable {
    SetAction(b) {
      this._disposeAction = b;
    }
  };
  e.CompositeDisposable = class extends e.Disposable {
    constructor(...b) {
      super();
      this._disposables = new Set();
      for (let a of b) this.Add(a);
    }
    Add(...b) {
      if (this._disposed) throw Error("already disposed");
      for (let a of b) this._disposables.add(a);
    }
    Remove(b) {
      if (this._disposed) throw Error("already disposed");
      this._disposables.delete(b);
    }
    RemoveAll() {
      if (this._disposed) throw Error("already disposed");
      if (this._disposables) {
        for (let b of this._disposables) b.Dispose();
        this._disposables.clear();
      }
    }
    IsDisposed() {
      return this._disposed;
    }
    Dispose() {
      if (this._disposed) throw Error("already disposed");
      this._disposed = !0;
      for (let b of this._disposables) b.Dispose();
      this._disposables.clear();
      this._disposables = null;
    }
    Release() {
      this.Dispose();
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.KahanSum = class extends e.DefendedBase {
    constructor() {
      super();
      this._sum = this._t = this._y = this._c = 0;
    }
    Add(b) {
      this._y = +b - this._c;
      this._t = this._sum + this._y;
      this._c = this._t - this._sum - this._y;
      this._sum = this._t;
    }
    Subtract(b) {
      this._sum -= +b;
    }
    Get() {
      return this._sum;
    }
    Reset() {
      this._sum = this._t = this._y = this._c = 0;
    }
    Set(b) {
      this._t = this._y = this._c = 0;
      this._sum = +b;
    }
    Copy(b) {
      this._c = b._c;
      this._y = b._y;
      this._t = b._t;
      this._sum = b._sum;
    }
    Release() {}
  };
}
{
  ("use strict");
  const e = self.C3,
    b = {
      RBnode: function (a) {
        this.tree = a;
        this.left = this.right = this.tree.sentinel;
        this.parent = null;
        this.color = !1;
        this.key = null;
      },
      RedBlackSet: function (a) {
        this.size = 0;
        this.sentinel = new b.RBnode(this);
        this.sentinel.color = !1;
        this.root = this.sentinel;
        this.root.parent = this.sentinel;
        this.compare = a || this.default_compare;
      },
    };
  b.RedBlackSet.prototype.default_compare = function (a, c) {
    return a < c ? -1 : c < a ? 1 : 0;
  };
  b.RedBlackSet.prototype.clone = function () {
    var a = new b.RedBlackSet(this.compare);
    a.insertAll(this);
    return a;
  };
  b.RedBlackSet.prototype.clear = function () {
    this.size = 0;
    this.sentinel = new b.RBnode(this);
    this.sentinel.color = !1;
    this.root = this.sentinel;
    this.root.parent = this.sentinel;
  };
  b.RedBlackSet.prototype.leftRotate = function (a) {
    var c = a.right;
    a.right = c.left;
    c.left != this.sentinel && (c.left.parent = a);
    c.parent = a.parent;
    a.parent == this.sentinel
      ? (this.root = c)
      : a == a.parent.left
      ? (a.parent.left = c)
      : (a.parent.right = c);
    c.left = a;
    a.parent = c;
  };
  b.RedBlackSet.prototype.rightRotate = function (a) {
    var c = a.left;
    a.left = c.right;
    c.right != this.sentinel && (c.right.parent = a);
    c.parent = a.parent;
    a.parent == this.sentinel
      ? (this.root = c)
      : a == a.parent.right
      ? (a.parent.right = c)
      : (a.parent.left = c);
    c.right = a;
    a.parent = c;
  };
  b.RedBlackSet.prototype.insert = function (a) {
    if (this.contains(a)) this.get_(a).key = a;
    else {
      var c = new b.RBnode(this);
      c.key = a;
      a = this.sentinel;
      for (var d = this.root; d != this.sentinel; )
        (a = d), (d = 0 > this.compare(c.key, d.key) ? d.left : d.right);
      c.parent = a;
      a == this.sentinel
        ? (this.root = c)
        : 0 > this.compare(c.key, a.key)
        ? (a.left = c)
        : (a.right = c);
      c.left = this.sentinel;
      c.right = this.sentinel;
      c.color = !0;
      this.insertFixup(c);
      this.size++;
    }
  };
  b.RedBlackSet.prototype.insertFixup = function (a) {
    for (; a != this.sentinel && a != this.root && 1 == a.parent.color; )
      if (a.parent == a.parent.parent.left) {
        var c = a.parent.parent.right;
        1 == c.color
          ? ((a.parent.color = !1),
            (c.color = !1),
            (a.parent.parent.color = !0),
            (a = a.parent.parent))
          : (a == a.parent.right && ((a = a.parent), this.leftRotate(a)),
            (a.parent.color = !1),
            (a.parent.parent.color = !0),
            a.parent.parent != this.sentinel &&
              this.rightRotate(a.parent.parent));
      } else
        (c = a.parent.parent.left),
          1 == c.color
            ? ((a.parent.color = !1),
              (c.color = !1),
              (a.parent.parent.color = !0),
              (a = a.parent.parent))
            : (a == a.parent.left && ((a = a.parent), this.rightRotate(a)),
              (a.parent.color = !1),
              (a.parent.parent.color = !0),
              a.parent.parent != this.sentinel &&
                this.leftRotate(a.parent.parent));
    this.root.color = !1;
  };
  b.RedBlackSet.prototype.delete_ = function (a) {
    var c =
      a.left == this.sentinel || a.right == this.sentinel
        ? a
        : this.successor_(a);
    var d = c.left != this.sentinel ? c.left : c.right;
    d.parent = c.parent;
    c.parent == this.sentinel
      ? (this.root = d)
      : c == c.parent.left
      ? (c.parent.left = d)
      : (c.parent.right = d);
    c != a && (a.key = c.key);
    0 == c.color && this.deleteFixup(d);
    this.size--;
  };
  b.RedBlackSet.prototype.deleteFixup = function (a) {
    for (; a != this.root && 0 == a.color; )
      if (a == a.parent.left) {
        var c = a.parent.right;
        1 == c.color &&
          ((c.color = !1),
          (a.parent.color = !0),
          this.leftRotate(a.parent),
          (c = a.parent.right));
        0 == c.left.color && 0 == c.right.color
          ? ((c.color = !0), (a = a.parent))
          : (0 == c.right.color &&
              ((c.left.color = !1),
              (c.color = !0),
              this.rightRotate(c),
              (c = a.parent.right)),
            (c.color = a.parent.color),
            (a.parent.color = !1),
            (c.right.color = !1),
            this.leftRotate(a.parent),
            (a = this.root));
      } else
        (c = a.parent.left),
          1 == c.color &&
            ((c.color = !1),
            (a.parent.color = !0),
            this.rightRotate(a.parent),
            (c = a.parent.left)),
          0 == c.right.color && 0 == c.left.color
            ? ((c.color = !0), (a = a.parent))
            : (0 == c.left.color &&
                ((c.right.color = !1),
                (c.color = !0),
                this.leftRotate(c),
                (c = a.parent.left)),
              (c.color = a.parent.color),
              (a.parent.color = !1),
              (c.left.color = !1),
              this.rightRotate(a.parent),
              (a = this.root));
    a.color = !1;
  };
  b.RedBlackSet.prototype.remove = function (a) {
    a = this.get_(a);
    if (a != this.sentinel) {
      var c = a.key;
      this.delete_(a);
      return c;
    }
    return null;
  };
  b.RedBlackSet.prototype.removeSwapped = function (a, c) {
    this.remove(c);
  };
  b.RedBlackSet.prototype.min = function (a) {
    for (; a.left != this.sentinel; ) a = a.left;
    return a;
  };
  b.RedBlackSet.prototype.max = function (a) {
    for (; a.right != this.sentinel; ) a = a.right;
    return a;
  };
  b.RedBlackSet.prototype.successor_ = function (a) {
    if (a.right != this.sentinel) return this.min(a.right);
    for (var c = a.parent; c != this.sentinel && a == c.right; )
      (a = c), (c = c.parent);
    return c;
  };
  b.RedBlackSet.prototype.predeccessor_ = function (a) {
    if (a.left != this.sentinel) return this.max(a.left);
    for (var c = a.parent; c != this.sentinel && a == c.left; )
      (a = c), (c = c.parent);
    return c;
  };
  b.RedBlackSet.prototype.successor = function (a) {
    if (0 < this.size) {
      a = this.get_(a);
      if (a == this.sentinel) return null;
      if (a.right != this.sentinel) return this.min(a.right).key;
      for (var c = a.parent; c != this.sentinel && a == c.right; )
        (a = c), (c = c.parent);
      return c != this.sentinel ? c.key : null;
    }
    return null;
  };
  b.RedBlackSet.prototype.predecessor = function (a) {
    if (0 < this.size) {
      a = this.get_(a);
      if (a == this.sentinel) return null;
      if (a.left != this.sentinel) return this.max(a.left).key;
      for (var c = a.parent; c != this.sentinel && a == c.left; )
        (a = c), (c = c.parent);
      return c != this.sentinel ? c.key : null;
    }
    return null;
  };
  b.RedBlackSet.prototype.getMin = function () {
    return this.min(this.root).key;
  };
  b.RedBlackSet.prototype.getMax = function () {
    return this.max(this.root).key;
  };
  b.RedBlackSet.prototype.get_ = function (a) {
    for (var c = this.root; c != this.sentinel && 0 != this.compare(c.key, a); )
      c = 0 > this.compare(a, c.key) ? c.left : c.right;
    return c;
  };
  b.RedBlackSet.prototype.contains = function (a) {
    return null != this.get_(a).key;
  };
  b.RedBlackSet.prototype.getValues = function () {
    var a = [];
    this.forEach(function (c) {
      a.push(c);
    });
    return a;
  };
  b.RedBlackSet.prototype.insertAll = function (a) {
    if ("array" == b.typeOf(a))
      for (var c = 0; c < a.length; c++) this.insert(a[c]);
    else if ("function" == b.typeOf(a.forEach)) a.forEach(this.insert, this);
    else if ("function" == b.typeOf(a.getValues))
      for (a = a.getValues(), c = 0; c < a.length; c++) this.insert(a[c]);
    else if ("object" == b.typeOf(a)) for (c in a) this.insert(a[c]);
  };
  b.RedBlackSet.prototype.removeAll = function (a) {
    if ("array" == b.typeOf(a))
      for (var c = 0; c < a.length; c++) this.remove(a[c]);
    else if ("function" == b.typeOf(a.forEach))
      a.forEach(this.removeSwapped, this);
    else if ("function" == b.typeOf(a.getValues))
      for (a = a.getValues(), c = 0; c < a.length; c++) this.remove(a[c]);
    else if ("object" == b.typeOf(a)) for (c in a) this.remove(a[c]);
  };
  b.RedBlackSet.prototype.containsAll = function (a) {
    if ("array" == b.typeOf(a)) {
      for (var c = 0; c < a.length; c++) if (!this.contains(a[c])) return !1;
      return !0;
    }
    if ("function" == b.typeOf(a.forEach)) return a.every(this.contains, this);
    if ("function" == b.typeOf(a.getValues)) {
      a = a.getValues();
      for (c = 0; c < a.length; c++) if (!this.contains(a[c])) return !1;
      return !0;
    }
    if ("object" == b.typeOf(a)) {
      for (c in a) if (!this.contains(a[c])) return !1;
      return !0;
    }
  };
  b.RedBlackSet.prototype.range = function (a, c) {
    var d = [];
    this.traverseFromTo(
      function (f) {
        d.push(f);
      },
      a,
      c
    );
    return d;
  };
  b.RedBlackSet.prototype.traverse = function (a, c) {
    if (!this.isEmpty())
      for (
        var d = this.min(this.root);
        d != this.sentinel && !a.call(c, d.key, this);

      )
        d = this.successor_(d);
  };
  b.RedBlackSet.prototype.traverseFrom = function (a, c, d) {
    if (!this.isEmpty())
      for (c = this.get_(c); c != this.sentinel && !a.call(d, c.key, this); )
        c = this.successor_(c);
  };
  b.RedBlackSet.prototype.traverseTo = function (a, c, d) {
    if (!this.isEmpty()) {
      var f = this.min(this.root);
      for (c = this.get_(c); f != c && !a.call(d, f.key, this); )
        f = this.successor_(f);
    }
  };
  b.RedBlackSet.prototype.traverseFromTo = function (a, c, d, f) {
    if (!this.isEmpty())
      for (
        c = this.get_(c), d = this.get_(d);
        c != d && !a.call(f, c.key, this);

      )
        c = this.successor_(c);
  };
  b.RedBlackSet.prototype.traverseBackwards = function (a, c) {
    if (!this.isEmpty())
      for (
        var d = this.max(this.root);
        d != this.sentinel && !a.call(c, d.key, this);

      )
        d = this.predeccessor_(d);
  };
  b.RedBlackSet.prototype.forEach = function (a, c) {
    if (!this.isEmpty())
      for (
        var d = this.min(this.root);
        d != this.sentinel;
        d = this.successor_(d)
      )
        a.call(c, d.key, d.key, this);
  };
  b.RedBlackSet.prototype.some = function (a, c) {
    if (this.isEmpty()) return !1;
    for (
      var d = this.min(this.root);
      d != this.sentinel;
      d = this.successor_(d)
    )
      if (a.call(c, d.key, d.key, this)) return !0;
    return !1;
  };
  b.RedBlackSet.prototype.every = function (a, c) {
    if (this.isEmpty()) return !1;
    for (
      var d = this.min(this.root);
      d != this.sentinel;
      d = this.successor_(d)
    )
      if (!a.call(c, d.key, d.key, this)) return !1;
    return !0;
  };
  b.RedBlackSet.prototype.map = function (a, c) {
    var d = [];
    if (this.isEmpty()) return d;
    for (
      var f = this.min(this.root);
      f != this.sentinel;
      f = this.successor_(f)
    )
      d.push(a.call(c, f.key, f.key, this));
    return d;
  };
  b.RedBlackSet.prototype.filter = function (a, c) {
    var d = [];
    if (this.isEmpty()) return d;
    for (
      var f = this.min(this.root);
      f != this.sentinel;
      f = this.successor_(f)
    )
      a.call(c, f.key, f.key, this) && d.push(f.key);
    return d;
  };
  b.RedBlackSet.prototype.getCount = function () {
    return this.size;
  };
  b.RedBlackSet.prototype.isEmpty = function () {
    return 0 == this.size;
  };
  b.RedBlackSet.prototype.isSubsetOf = function (a) {
    var c = b.getCount(a);
    if (this.getCount() > c) return !1;
    c = 0;
    if (this.isEmpty()) return !0;
    for (
      var d = this.min(this.root);
      d != this.sentinel;
      d = this.successor_(d)
    )
      b.contains.call(a, a, d.key) && c++;
    return c == this.getCount();
  };
  b.RedBlackSet.prototype.intersection = function (a) {
    var c = new b.RedBlackSet(this.compare);
    if (this.isEmpty()) return c;
    for (
      var d = this.min(this.root);
      d != this.sentinel;
      d = this.successor_(d)
    )
      a.contains.call(a, d.key, d.key, this) && c.insert(d.key);
    return c;
  };
  e.RedBlackSet = class extends e.DefendedBase {
    constructor(a) {
      super();
      this._rbSet = new b.RedBlackSet(a);
      this._enableQueue = !1;
      this._queueInsert = new Set();
      this._queueRemove = new Set();
    }
    Add(a) {
      this._enableQueue
        ? this._rbSet.contains(a)
          ? this._queueRemove.delete(a)
          : this._queueInsert.add(a)
        : this._rbSet.insert(a);
    }
    Remove(a) {
      this._enableQueue
        ? this._rbSet.contains(a)
          ? this._queueRemove.add(a)
          : this._queueInsert.delete(a)
        : this._rbSet.remove(a);
    }
    Has(a) {
      return this._enableQueue
        ? this._queueInsert.has(a)
          ? !0
          : !this._queueRemove.has(a) && this._rbSet.contains(a)
        : this._rbSet.contains(a);
    }
    Clear() {
      this._rbSet.clear();
      this._queueInsert.clear();
      this._queueRemove.clear();
    }
    toArray() {
      if (this._enableQueue) throw Error("cannot be used in queueing mode");
      return this._rbSet.getValues();
    }
    GetSize() {
      return (
        this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size
      );
    }
    IsEmpty() {
      return 0 === this.GetSize();
    }
    Front() {
      if (this.IsEmpty()) throw Error("empty set");
      if (this._enableQueue) throw Error("cannot be used in queueing mode");
      const a = this._rbSet;
      return a.min(a.root).key;
    }
    Shift() {
      if (this.IsEmpty()) throw Error("empty set");
      if (this._enableQueue) throw Error("cannot be used in queueing mode");
      const a = this.Front();
      this.Remove(a);
      return a;
    }
    SetQueueingEnabled(a) {
      a = !!a;
      if (this._enableQueue !== a && ((this._enableQueue = a), !a)) {
        for (const c of this._queueRemove) this._rbSet.remove(c);
        this._queueRemove.clear();
        for (const c of this._queueInsert) this._rbSet.insert(c);
        this._queueInsert.clear();
      }
    }
    ForEach(a) {
      this._rbSet.forEach(a);
    }
    *values() {
      if (!this.IsEmpty()) {
        var a = this._rbSet;
        for (let c = a.min(a.root); c != a.sentinel; c = a.successor_(c))
          yield c.key;
      }
    }
    [Symbol.iterator]() {
      return this.values();
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.PromiseThrottle = class {
    constructor(b = e.hardwareConcurrency) {
      this._maxParallel = b;
      this._queue = [];
      this._activeCount = 0;
    }
    Add(b) {
      return new Promise((a, c) => {
        this._queue.push({ func: b, resolve: a, reject: c });
        this._MaybeStartNext();
      });
    }
    _FindInQueue(b) {
      for (let a = 0, c = this._queue.length; a < c; ++a)
        if (this._queue[a].func === b) return a;
      return -1;
    }
    RemoveAndResolve(b, a) {
      b = this._FindInQueue(b);
      if (-1 === b) throw Error("cannot find promise to resolve");
      this._queue[b].resolve(a);
      this._queue.splice(b, 1);
    }
    RemoveAndReject(b, a) {
      b = this._FindInQueue(b);
      if (-1 === b) throw Error("cannot find promise to reject");
      this._queue[b].reject(a);
      this._queue.splice(b, 1);
    }
    async _MaybeStartNext() {
      if (this._queue.length && !(this._activeCount >= this._maxParallel)) {
        this._activeCount++;
        var b = this._queue.shift();
        try {
          const a = await b.func();
          b.resolve(a);
        } catch (a) {
          b.reject(a);
        }
        this._activeCount--;
        this._MaybeStartNext();
      }
    }
    static async Batch(b, a) {
      const c = [];
      let d = !1;
      const f = async (g) => {
          for (; (g = a.pop()) && !d; )
            try {
              c.push(await g());
            } catch (k) {
              throw ((d = !0), k);
            }
        },
        h = [];
      for (; b--; ) h.push(f());
      await Promise.all(h);
      return c;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.RateLimiter = class {
    constructor(b, a, c) {
      this._callback = b;
      this._interval = a;
      this._intervalOnBattery = c || 2 * a;
      this._timerId = -1;
      this._lastCallTime = -Infinity;
      this._timerCallFunc = () => this._OnTimer();
      this._canRunImmediate = this._ignoreReset = !1;
      this._callbackArguments = null;
    }
    SetCanRunImmediate(b) {
      this._canRunImmediate = !!b;
    }
    _GetInterval() {
      return "undefined" !== typeof e.Battery && e.Battery.IsOnBatteryPower()
        ? this._intervalOnBattery
        : this._interval;
    }
    Call(...b) {
      if (-1 === this._timerId) {
        this._callbackArguments = b;
        b = e.FastGetDateNow();
        var a = b - this._lastCallTime,
          c = this._GetInterval();
        a >= c && this._canRunImmediate
          ? ((this._lastCallTime = b), this._RunCallback())
          : (this._timerId = self.setTimeout(
              this._timerCallFunc,
              Math.max(c - a, 4)
            ));
      }
    }
    _RunCallback() {
      this._ignoreReset = !0;
      const b = this._callbackArguments;
      this._callbackArguments = null;
      b ? this._callback(...b) : this._callback();
      this._ignoreReset = !1;
    }
    Reset() {
      this._ignoreReset ||
        (this._CancelTimer(),
        (this._callbackArguments = null),
        (this._lastCallTime = e.FastGetDateNow()));
    }
    _OnTimer() {
      this._timerId = -1;
      this._lastCallTime = e.FastGetDateNow();
      this._RunCallback();
    }
    _CancelTimer() {
      -1 !== this._timerId &&
        (self.clearTimeout(this._timerId), (this._timerId = -1));
    }
    Release() {
      this._CancelTimer();
      this._timerCallFunc = this._callbackArguments = this._callback = null;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.SVGRasterManager = class {
    constructor() {
      this._images = new Map();
      this._allowNpotSurfaces = !1;
      this._redrawCallback =
        this._releaseResultCallback =
        this._rasterAtSizeCallback =
        this._getBaseSizeCallback =
          null;
    }
    SetNpotSurfaceAllowed(b) {
      this._allowNpotSurfaces = !!b;
    }
    IsNpotSurfaceAllowed() {
      return this._allowNpotSurfaces;
    }
    SetGetBaseSizeCallback(b) {
      this._getBaseSizeCallback = b;
    }
    GetBaseSize(b) {
      if (!this._getBaseSizeCallback)
        throw Error("no get base size callback set");
      return this._getBaseSizeCallback(b);
    }
    SetRasterAtSizeCallback(b) {
      this._rasterAtSizeCallback = b;
    }
    RasterAtSize(b, a, c, d, f, h) {
      if (!this._rasterAtSizeCallback)
        throw Error("no raster at size callback set");
      return this._rasterAtSizeCallback(b, a, c, d, f, h);
    }
    SetReleaseResultCallback(b) {
      this._releaseResultCallback = b;
    }
    ReleaseResult(b) {
      if (!this._releaseResultCallback)
        throw Error("no release result callback set");
      this._releaseResultCallback(b);
    }
    SetRedrawCallback(b) {
      this._redrawCallback = b;
    }
    Redraw() {
      if (!this._redrawCallback) throw Error("no redraw callback set");
      this._redrawCallback();
    }
    AddImage(b) {
      let a = this._images.get(b);
      a || ((a = e.New(e.SVGRasterImage, this, b)), this._images.set(b, a));
      a.IncReference();
      return a;
    }
    _RemoveImage(b) {
      this._images.delete(b.GetDataSource());
    }
    OnTexturesChanged() {
      for (const b of this._images.values())
        b.ReleaseRasterizedResult(), b.ForceRasterAgain();
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.SVGRasterImage = class {
    constructor(b, a) {
      this._manager = b;
      this._dataSource = a;
      this._baseHeight = this._baseWidth = this._refCount = 0;
      this._getBaseSizePromise = this._manager
        .GetBaseSize(a)
        .then((c) => {
          this._baseWidth = c[0];
          this._baseHeight = c[1];
          this._manager.Redraw();
        })
        .catch((c) => {
          console.error("[SVG] Error loading SVG: ", c);
          this._hadError = !0;
          this._manager.Redraw();
        });
      this._rasterImageHeight =
        this._rasterImageWidth =
        this._rasterSurfaceHeight =
        this._rasterSurfaceWidth =
          0;
      this._isRasterizing = !1;
      this._rasterizedResult = null;
      this._hadError = this._forceRaster = !1;
    }
    Release() {
      if (0 >= this._refCount) throw Error("already released");
      this._refCount--;
      0 === this._refCount && this._Release();
    }
    ReleaseRasterizedResult() {
      this._rasterizedResult &&
        (this._manager.ReleaseResult(this._rasterizedResult),
        (this._rasterizedResult = null));
    }
    _Release() {
      this.ReleaseRasterizedResult();
      this._manager._RemoveImage(this);
      this._manager = null;
    }
    GetDataSource() {
      return this._dataSource;
    }
    IncReference() {
      this._refCount++;
    }
    HasReferences() {
      return 0 < this._refCount;
    }
    GetRasterizedResult() {
      return this._rasterizedResult;
    }
    ForceRasterAgain() {
      this._forceRaster = !0;
    }
    async StartRasterForSize(b, a, c) {
      if (0 !== a && 0 !== c && !this._hadError && !this._isRasterizing) {
        var d = e.nextHighestPowerOfTwo(Math.ceil(a)),
          f = e.nextHighestPowerOfTwo(Math.ceil(c)),
          h = Math.max(d, f);
        4096 < h &&
          ((h = 4096 / h),
          (a *= h),
          (c *= h),
          (d = Math.min(Math.ceil(d * h), 4096)),
          (f = Math.min(Math.ceil(f * h), 4096)));
        a < d &&
          c < f &&
          ((c = a / c),
          d / f > c ? ((a = f * c), (c = f)) : ((a = d), (c = d / c)));
        this._manager.IsNpotSurfaceAllowed() &&
          ((d = Math.ceil(a)), (f = Math.ceil(c)));
        (d <= this._rasterSurfaceWidth &&
          f <= this._rasterSurfaceHeight &&
          !this._forceRaster) ||
          ((this._isRasterizing = !0),
          (this._rasterSurfaceWidth = d),
          (this._rasterSurfaceHeight = f),
          (b = await this._manager.RasterAtSize(
            this._dataSource,
            b,
            this._rasterSurfaceWidth,
            this._rasterSurfaceHeight,
            a,
            c
          )),
          this._manager &&
            (this.ReleaseRasterizedResult(),
            (this._rasterizedResult = b),
            (this._rasterImageWidth = a),
            (this._rasterImageHeight = c),
            (this._forceRaster = this._isRasterizing = !1),
            this._manager.Redraw()));
      }
    }
    WhenBaseSizeReady() {
      return this._getBaseSizePromise;
    }
    GetBaseWidth() {
      return this._baseWidth;
    }
    GetBaseHeight() {
      return this._baseHeight;
    }
    GetRasterWidth() {
      return this._rasterImageWidth;
    }
    GetRasterHeight() {
      return this._rasterImageHeight;
    }
    HadError() {
      return this._hadError;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.UTF8_BOM = "\ufeff";
  const b = new Set([..."0123456789"]);
  e.IsNumericChar = function (m) {
    return b.has(m);
  };
  const a = new Set([
    ..." \t\n\r\u00a0\u0085\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000",
  ]);
  e.IsWhitespaceChar = function (m) {
    return a.has(m);
  };
  e.FilterWhitespace = function (m) {
    return [...m].filter((q) => !e.IsWhitespaceChar(q)).join("");
  };
  e.IsStringAllWhitespace = function (m) {
    for (const q of m) if (!e.IsWhitespaceChar(q)) return !1;
    return !0;
  };
  e.IsUnprintableChar = function (m) {
    return 1 === m.length && 32 > m.charCodeAt(0);
  };
  e.FilterUnprintableChars = function (m) {
    return [...m].filter((q) => !e.IsUnprintableChar(q)).join("");
  };
  const c = new Set([..."0123456789.+-e"]);
  e.IsStringNumber = function (m) {
    m = m.trim();
    if (!m.length) return !1;
    let q = m.charAt(0);
    if ("-" !== q && !b.has(q)) return !1;
    for (let v of m) if (!c.has(v)) return !1;
    return !0;
  };
  e.RemoveTrailingDigits = function (m) {
    let q = m.length;
    for (; 0 < q; ) {
      let v = m.charAt(q - 1);
      if (!e.IsNumericChar(v)) break;
      --q;
    }
    return m.substr(0, q);
  };
  e.IncrementNumberAtEndOf = function (m) {
    let q = e.RemoveTrailingDigits(m);
    m = (m = m.substr(q.length)) ? (parseInt(m, 10) + 1).toString() : "2";
    return q + m;
  };
  const d = new Map([
    ["&", "&amp;"],
    ["<", "&lt;"],
    [">", "&gt;"],
    ['"', "&quot;"],
    ["'", "&#39;"],
  ]);
  function f(m) {
    return d.get(m);
  }
  const h = /[&<>"']/g;
  e.EscapeHTML = function (m) {
    return m.replace(h, f);
  };
  e.EscapeJS = function (m) {
    m = e.ReplaceAll(m, "\\", "\\\\");
    m = e.ReplaceAll(m, '"', '\\"');
    m = e.ReplaceAll(m, "\t", "\\t");
    m = e.ReplaceAll(m, "\r", "");
    return e.ReplaceAll(m, "\n", "\\n");
  };
  e.EscapeXML = function (m) {
    m = e.ReplaceAll(m, "&", "&amp;");
    m = e.ReplaceAll(m, "<", "&lt;");
    m = e.ReplaceAll(m, ">", "&gt;");
    return e.ReplaceAll(m, '"', "&quot;");
  };
  const g = /[-[\]{}()*+?.,\\^$|#\s]/g;
  e.EscapeRegex = function (m) {
    return m.replace(g, "\\$&");
  };
  e.FindAll = function (m, q, v = !1) {
    if (!q) return [];
    v || ((m = m.toLowerCase()), (q = q.toLowerCase()));
    v = q.length;
    var r = 0;
    let n = [];
    for (; -1 < (r = m.indexOf(q, r)); ) n.push(r), (r += v);
    return n;
  };
  e.ReplaceAll = function (m, q, v) {
    return m.replaceAll(q, () => v);
  };
  e.ReplaceAllCaseInsensitive = function (m, q, v) {
    return m.replace(new RegExp(e.EscapeRegex(q), "gi"), () => v);
  };
  e.SetElementContent = function (m, q) {
    "string" === typeof q
      ? (m.textContent = q)
      : q.isPlainText()
      ? (m.textContent = q.toString())
      : ((m.innerHTML = q.toHTML()),
        q instanceof e.BBString && q.attachLinkHandlers(m));
  };
  e.StringLikeEquals = function (m, q) {
    return m instanceof e.HtmlString || m instanceof e.BBString
      ? m.equals(q)
      : q instanceof e.HtmlString || q instanceof e.BBString
      ? q.equals(m)
      : m === q;
  };
  e.StringSubstitute = function (m, ...q) {
    let v = m;
    for (let r = 0, n = q.length; r < n; ++r) {
      const p = `{${r}}`;
      if (!m.includes(p))
        throw Error(`missing placeholder '${p}' in string substitution`);
      v = v.replace(p, q[r].toString());
    }
    return v;
  };
  e.StringSubstituteAllowMissing = function (m, ...q) {
    let v = m,
      r = -1,
      n = -1;
    for (let p = 0, u = q.length; p < u; ++p) {
      const w = `{${p}}`;
      m.includes(w)
        ? ((n = p), (v = v.replace(w, q[p].toString())))
        : -1 === r && (r = p);
    }
    if (0 <= r && 0 <= n && r < n)
      throw Error(`missing placeholder '${r}' in string substitution`);
    return v;
  };
  e.StringSubstituteMap = function (m, q) {
    for (let [v, r] of Object.entries(q)) m = m.replaceAll(v, r.toString());
    return m;
  };
  e.SortAZ = function (m, q) {
    return m > q ? 1 : m < q ? -1 : 0;
  };
  e.SortAZCaseInsensitive = function (m, q) {
    m = m.toLowerCase();
    q = q.toLowerCase();
    return m > q ? 1 : m < q ? -1 : 0;
  };
  e.FormatDataSize = function (m, q) {
    q = "common." + (q ? "dataRates" : "dataSizes") + ".";
    const v = self.langSub;
    if (1024 > m) return v(q + "bytes", m);
    if (1048576 > m)
      return (
        (m /= 1024),
        (m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m)),
        v(q + "kilobytes", m)
      );
    if (1073741824 > m)
      return (
        (m /= 1048576),
        (m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m)),
        v(q + "megabytes", m)
      );
    if (1099511627776 > m)
      return (
        (m /= 1073741824),
        (m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m)),
        v(q + "gigabytes", m)
      );
    m /= 1099511627776;
    m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m);
    return v(q + "terabytes", m);
  };
  const k = { approximate: !1, days: !0, hours: !0, minutes: !0, seconds: !0 };
  e.FormatTime = function (m, q) {
    q = Object.assign({}, k, q);
    e.Lang.PushContext("common.time");
    const v = [],
      r = self.lang,
      n = self.langPluralSub;
    if (q.days) {
      var p = Math.floor(m / 86400);
      0 < p && ((m -= 86400 * p), v.push(n(".days", null, p)));
    }
    q.hours &&
      ((p = Math.floor(m / 3600)), 0 < p || v.length) &&
      ((m -= 3600 * p), v.push(n(".hours", null, p)));
    q.minutes &&
      ((p = Math.floor(m / 60)), 0 < p || v.length || !q.seconds) &&
      ((m -= 60 * p), v.push(n(".minutes", null, p)));
    q.seconds && v.push(n(".seconds", null, Math.floor(m % 60)));
    m = (q.approximate ? r(".approx-prefix") : "") + v.join(r(".separator"));
    e.Lang.PopContext();
    return m;
  };
  e.ZeroPad = function (m, q) {
    let v = 0 > m ? "-" : "";
    m = Math.abs(m);
    m = m.toString();
    q -= m.length;
    for (let r = 0; r < q; ++r) v += "0";
    return v + m;
  };
  e.StringToTitleCase = function (m) {
    return m.toLowerCase().replace(/\b\w/g, (q) => q.toUpperCase());
  };
  e.CompareVersionStrings = function (m, q) {
    m = m.split(".").map((v) => v.trim());
    q = q.split(".").map((v) => v.trim());
    e.resizeArray(m, 4, "0");
    e.resizeArray(q, 4, "0");
    m = m.map((v) => parseInt(v, 10));
    q = q.map((v) => parseInt(v, 10));
    for (let v = 0; 4 > v; ++v) {
      const r = m[v] - q[v];
      if (0 !== r) return 0 > r ? -1 : 1;
    }
    return 0;
  };
  e.CreateGUID = function () {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (m) => {
      const q = Math.floor(16 * Math.random());
      return ("x" === m ? q : (q & 3) | 8).toString(16);
    });
  };
  e.StringHammingDistance = function (m, q) {
    if (m.length !== q.length) throw Error("strings must be same length");
    let v = 0;
    for (let r = 0, n = m.length; r < n; ++r)
      m.charAt(r) !== q.charAt(r) && ++v;
    return v;
  };
  e.StringLevenshteinDistance = function (m, q) {
    if (0 === m.length) return q.length;
    if (0 === q.length) return m.length;
    let v, r, n, p;
    if (m.length > q.length) {
      var u = m;
      m = q;
      q = u;
    }
    p = Array(m.length + 1);
    for (u = 0; u <= m.length; u++) p[u] = u;
    for (u = 1; u <= q.length; u++) {
      r = u;
      for (v = 1; v <= m.length; v++)
        (n =
          q[u - 1] === m[v - 1]
            ? p[v - 1]
            : Math.min(p[v - 1] + 1, Math.min(r + 1, p[v] + 1))),
          (p[v - 1] = r),
          (r = n);
      p[m.length] = r;
    }
    return p[m.length];
  };
}
{
  ("use strict");
  const e = self.C3,
    b = new Map([
      ["b", "strong"],
      ["i", "em"],
      ["s", "s"],
      ["u", "u"],
      ["sub", "sub"],
      ["sup", "sup"],
      ["small", "small"],
      ["mark", "mark"],
      ["code", "code"],
      ["a1", "a"],
      ["a2", "a"],
      ["a3", "a"],
      ["a4", "a"],
      ["a5", "a"],
      ["a6", "a"],
      ["a7", "a"],
      ["a8", "a"],
      ["a9", "a"],
      ["tip1", "abbr"],
      ["tip2", "abbr"],
      ["tip3", "abbr"],
      ["tip4", "abbr"],
      ["tip5", "abbr"],
      ["tip6", "abbr"],
      ["tip7", "abbr"],
      ["tip8", "abbr"],
      ["tip9", "abbr"],
      ["bad", ["span", "bbCodeBad"]],
      ["good", ["span", "bbCodeGood"]],
      ["info", ["span", "bbCodeInfo"]],
      ["h1", ["span", "bbCodeH1"]],
      ["h2", ["span", "bbCodeH2"]],
      ["h3", ["span", "bbCodeH3"]],
      ["h4", ["span", "bbCodeH4"]],
      ["item", ["span", "bbCodeItem"]],
    ]),
    a = /\[(\/?)([a-zA-Z0-9]+)\]/g,
    c = /\[(\/?)([^\[\n]*?)\]/g;
  let d = null,
    f = null,
    h = 0;
  function g(m, q, v) {
    var r = b.get(v);
    if (r) {
      if ("string" === typeof r) {
        if (("a" === r && 0 === d.length) || ("abbr" === r && 0 === f.length))
          return m;
        if ("a" !== r || q) {
          if ("abbr" !== r || q) return "<" + q + r + ">";
          q = parseInt(v.substring(3), 10) - 1;
          if (0 > q || q >= f.length)
            throw Error("invalid bbcode tip substitution");
          q = f[q];
          r = "";
          "string" === typeof q
            ? (r = q)
            : "function" === typeof q && (r = q());
          if ("string" !== typeof r) throw new TypeError("invalid bbcode tip");
          return `<abbr title="${e.ReplaceAll(r, '"', "&quot;")}">`;
        }
        q = parseInt(v.substring(1), 10) - 1;
        if (0 > q || q >= d.length)
          throw Error("invalid bbcode link substitution");
        r = d[q];
        if ("string" === typeof r) return `<a href="${d[q]}">`;
        if ("function" === typeof r) return `<a class="bblink${q}">`;
        throw new TypeError("invalid bbcode link action");
      }
      if (Array.isArray(r))
        return (
          (m = r[0]), (r = r[1]), q ? "</" + m + ">" : `<${m} class="${r}">`
        );
    } else
      return "class" === v
        ? q
          ? "</span>"
          : `<span class="bbclass${h++}">`
        : m;
  }
  const k = /\n/g;
  e.BBString = class {
    constructor(m, q) {
      this._bbstr = q && q.noEscape ? m : e.EscapeHTML(m);
      this._htmlstr = "";
      this._convertLineBreaks = !1;
      this._linkActions = [];
      this._tipList = [];
      if (q) {
        this._convertLineBreaks = !!q.convertLineBreaks;
        if (q.links) {
          if (9 < q.links.length) throw Error("too many links");
          this._linkActions = q.links;
        }
        if (q.tips) {
          if (9 < q.tips.length) throw Error("too many tips");
          this._tipList = q.tips;
        }
      }
      this._hasAnyBBtags = this._bbstr.includes("[");
      this._needsLineBreakConversion =
        this._convertLineBreaks && this._bbstr.includes("\n");
      this._isPlain =
        !this._hasAnyBBtags &&
        !this._needsLineBreakConversion &&
        !this._bbstr.includes("&");
      this._hasParsedFragments = !1;
      this._fragments = [];
    }
    toString() {
      return this._bbstr;
    }
    valueOf() {
      return this._bbstr;
    }
    isPlainText() {
      return this._isPlain;
    }
    toPlainText() {
      return this._hasAnyBBtags ? this._bbstr.replace(a, "") : this._bbstr;
    }
    toHTML() {
      if (this._isPlain) return this._bbstr;
      if (!this._htmlstr && this._bbstr) {
        let m = this._bbstr;
        this._hasAnyBBtags &&
          ((h = 0),
          (d = this._linkActions),
          (f = this._tipList),
          (m = m.replace(a, g)),
          (f = d = null));
        this._needsLineBreakConversion && (m = m.replace(k, "<br>"));
        this._htmlstr = m;
      }
      return this._htmlstr;
    }
    attachLinkHandlers(m) {
      if (this._linkActions.length)
        for (let q = 0, v = this._linkActions.length; q < v; ++q) {
          const r = this._linkActions[q];
          if ("function" !== typeof r) continue;
          const n = m.querySelector(".bblink" + q);
          if (!n) throw Error("unable to attach BBString link handler");
          n.onclick = r;
        }
    }
    equals(m) {
      return m instanceof e.HtmlString
        ? this.toHTML() === m.toHTML()
        : m instanceof e.BBString
        ? this._bbstr === m._bbstr
        : this._bbstr === m;
    }
    toFragmentList() {
      if (this._hasParsedFragments) return this._fragments;
      const m = this._bbstr,
        q = [];
      let v = (c.lastIndex = 0);
      for (var r; null !== (r = c.exec(m)); ) {
        var n = r.index;
        if (0 < n && "\\" === m.charAt(n - 1)) continue;
        var p = r[0],
          u = r[1];
        r = r[2];
        const w = m.substring(v, n);
        v = n + p.length;
        w && this._fragments.push({ text: w, styles: q.slice(0) });
        if (r)
          if (u)
            for (r = r.toLowerCase(), n = q.length - 1; 0 <= n; --n) {
              if (q[n].tag === r) {
                q.splice(n, 1);
                break;
              }
            }
          else
            (n = r),
              (p = null),
              (u = r.indexOf("=")),
              -1 !== u
                ? ((n = r.substring(0, u).toLowerCase()),
                  (p = r.substring(u + 1)))
                : (n = n.toLowerCase()),
              q.push({ tag: n, param: p });
      }
      v < m.length &&
        this._fragments.push({ text: m.substring(v), styles: q.slice(0) });
      for (const w of this._fragments)
        w.text = this._ProcessBBCodeEscapeSequences(w.text);
      this._hasParsedFragments = !0;
      return this._fragments;
    }
    _ProcessBBCodeEscapeSequences(m) {
      m = e.ReplaceAll(m, "\\[", "[");
      return e.ReplaceAll(m, "\\\\", "\\");
    }
    static StripTags(m) {
      return e.New(e.BBString, m, { noEscape: !0 }).toPlainText();
    }
    static StripAnyTags(m) {
      return m.replace(c, "");
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  function b(d) {
    return "\u00a0" === d || "\u202f" === d ? !1 : e.IsWhitespaceChar(d);
  }
  const a =
    /[\x09\x0A\x0B\x0C\x0D\x20\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u205F\u3000\u2028\u2029\uFEFF]*$/;
  function c(d) {
    return d.replace(a, "");
  }
  e.WordWrap = class {
    constructor() {
      this._lines = [];
    }
    GetLines() {
      return this._lines;
    }
    GetLineCount() {
      return this._lines.length;
    }
    _MeasureLine(d, f) {
      let h = 0,
        g = 0,
        k = 0,
        m = 0,
        q = 0;
      for (const v of d)
        -1 === v.width &&
          ((d = f(v.text, v.styles)),
          (v.width = d.width),
          (v.height = d.height),
          (v.fontBoundingBoxAscent = d.fontBoundingBoxAscent || 0),
          (v.fontBoundingBoxDescent = d.fontBoundingBoxDescent || 0),
          (v.topToAlphabeticDistance = d.topToAlphabeticDistance || 0)),
          (h += v.width),
          (g = Math.max(g, v.height)),
          (k = Math.max(k, v.fontBoundingBoxAscent)),
          (m = Math.max(m, v.fontBoundingBoxDescent)),
          (q = Math.max(q, v.topToAlphabeticDistance));
      return {
        width: h,
        height: g,
        fontBoundingBoxAscent: k,
        fontBoundingBoxDescent: m,
        topToAlphabeticDistance: q,
      };
    }
    _AddLine(d, f, h, g, k, m) {
      this._lines.push({
        fragments: d,
        width: f,
        height: h,
        fontBoundingBoxAscent: g,
        fontBoundingBoxDescent: k,
        topToAlphabeticDistance: m,
      });
    }
    WordWrap(d, f, h, g, k) {
      "string" === typeof d && (d = [{ text: d, styles: [] }]);
      e.clearArray(this._lines);
      if (!(!d.length || (1 === d.length && !d[0].text.length) || 2 > h)) {
        if (1 === d.length) {
          var m = d[0];
          const q = m.text;
          m = m.styles;
          if (100 >= q.length && !q.includes("\n")) {
            let {
              width: v,
              height: r,
              fontBoundingBoxAscent: n,
              fontBoundingBoxDescent: p,
              topToAlphabeticDistance: u,
            } = f(q, m);
            v += k;
            n = n || 0;
            p = p || 0;
            u = u || 0;
            if (v <= h) {
              this._AddLine(
                [
                  {
                    text: q,
                    styles: m,
                    width: v,
                    height: r,
                    fontBoundingBoxAscent: n,
                    fontBoundingBoxDescent: p,
                    topToAlphabeticDistance: u,
                  },
                ],
                v,
                r,
                n,
                p,
                u
              );
              return;
            }
          }
        }
        if ("word" === g) g = this._TokeniseWords(d);
        else {
          g = [];
          for (const q of d)
            e.appendArray(
              g,
              [...q.text].map((v) => [{ text: v, styles: q.styles }])
            );
        }
        this._WrapText(g, f, h, k);
      }
    }
    _TokeniseWords(d) {
      const f = [];
      let h = [],
        g = !1;
      for (const m of d) {
        var k = m.text;
        d = m.styles;
        for (const q of k)
          "\n" === q
            ? (0 < h.length && f.push(h),
              f.push([{ text: "\n", styles: d }]),
              (h = []))
            : 0 === h.length
            ? (h.push({ text: q, styles: d }), (g = b(q)))
            : ((k = b(q)),
              k === g
                ? ((k = h.at(-1)),
                  k.styles === d
                    ? (k.text += q)
                    : h.push({ text: q, styles: d }))
                : (f.push(h),
                  (h = []),
                  h.push({ text: q, styles: d }),
                  (g = k)));
      }
      0 < h.length && f.push(h);
      return f;
    }
    _CopyLine(d) {
      return d.map((f) => ({
        text: f.text,
        styles: f.styles,
        width: f.width,
        height: f.height,
        fontBoundingBoxAscent: f.fontBoundingBoxAscent,
        fontBoundingBoxDescent: f.fontBoundingBoxDescent,
        topToAlphabeticDistance: f.topToAlphabeticDistance,
      }));
    }
    _AddWordToLine(d, f) {
      var h = d.length ? d.at(-1) : null;
      let g = 0;
      h &&
        f[0].styles === h.styles &&
        ((h.text += f[0].text),
        (h.width = -1),
        (h.height = -1),
        (h.fontBoundingBoxAscent = -1),
        (h.fontBoundingBoxDescent = -1),
        (h.topToAlphabeticDistance = -1),
        (g = 1));
      for (h = f.length; g < h; ++g) {
        const k = f[g];
        d.push({
          text: k.text,
          styles: k.styles,
          width: -1,
          height: -1,
          fontBoundingBoxAscent: -1,
          fontBoundingBoxDescent: -1,
          topToAlphabeticDistance: -1,
        });
      }
    }
    _WrapText(d, f, h, g) {
      let k = [],
        m = 0,
        q = 0,
        v = 0,
        r = 0;
      var n = 0;
      for (const p of d) {
        if (1 === p.length && "\n" === p[0].text) {
          0 === q &&
            ((n = f(" ", p[0].styles)),
            (q = n.height),
            (v = n.fontBoundingBoxAscent || 0),
            (r = n.fontBoundingBoxDescent || 0),
            (n = n.topToAlphabeticDistance || 0));
          this._AddLine(k, m, q, v, r, n);
          k = [];
          n = r = v = q = m = 0;
          continue;
        }
        d = this._CopyLine(k);
        this._AddWordToLine(d, p);
        const u = this._MeasureLine(d, f),
          w = u.width;
        w >= h
          ? (0 < k.length && this._AddLine(k, m, q, v, r, n),
            (k = []),
            e.IsStringAllWhitespace(p[0].text)
              ? (n = r = v = q = m = 0)
              : (this._AddWordToLine(k, p),
                (n = this._MeasureLine(k, f)),
                (m = n.width),
                (q = n.height),
                (v = n.fontBoundingBoxAscent),
                (r = n.fontBoundingBoxDescent),
                (n = n.topToAlphabeticDistance)))
          : ((k = d),
            (m = w),
            (q = u.height),
            (v = u.fontBoundingBoxAscent),
            (r = u.fontBoundingBoxDescent),
            (n = u.topToAlphabeticDistance));
      }
      0 < k.length && this._AddLine(k, m, q, v, r, n);
      this._TrimLinesTrailingWhitespace(f, g);
    }
    _TrimLinesTrailingWhitespace(d, f) {
      for (const g of this._lines) {
        const k = g.fragments;
        if (!k.length) continue;
        let m = k.at(-1);
        var h = m.text;
        const q = c(h);
        if (!q) (g.width -= m.width), k.pop();
        else if (q.length < h.length) {
          h = d(q, m.styles).width;
          const v = m.width - h;
          m.width = h;
          m.text = q;
          g.width -= v;
        }
        0 !== f &&
          0 < k.length &&
          ((m = k.at(-1)), (m.width += f), (g.width += f));
      }
    }
    Clear() {
      e.clearArray(this._lines);
    }
    GetMaxLineWidth() {
      return this._lines.reduce((d, f) => Math.max(d, f.width), 0);
    }
    GetTotalLineHeight() {
      return this._lines.reduce((d, f) => d + f.height, 0);
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.glMatrix,
    a = b.vec3,
    c = b.vec4,
    d = b.mat4,
    f = a.create(),
    h = a.create(),
    g = a.create(),
    k = c.create(),
    m = d.create(),
    q = a.create(),
    v = a.create(),
    r = a.create(),
    n = a.create(),
    p = a.create(),
    u = a.create(),
    w = a.create(),
    y = a.create(),
    B = c.fromValues(0, 0, 1, 1);
  e.Gfx = {
    Project(C, H, K, P, S, U, V) {
      const aa = P[0] * C + P[4] * H + P[8] * K + P[12],
        ma = P[1] * C + P[5] * H + P[9] * K + P[13],
        va = P[2] * C + P[6] * H + P[10] * K + P[14];
      P = P[3] * C + P[7] * H + P[11] * K + P[15];
      C = S[0] * aa + S[4] * ma + S[8] * va + S[12] * P;
      H = S[1] * aa + S[5] * ma + S[9] * va + S[13] * P;
      K = S[2] * aa + S[6] * ma + S[10] * va + S[14] * P;
      S = S[3] * aa + S[7] * ma + S[11] * va + S[15] * P;
      if (0 === S) return !1;
      S = 1 / S;
      V[0] = (C * S * 0.5 + 0.5) * U[2] + U[0];
      V[1] = (H * S * 0.5 + 0.5) * U[3] + U[1];
      V[2] = 0.5 * (1 + K * S);
      return !0;
    },
    Unproject(C, H, K, P, S, U, V) {
      d.multiply(m, S, P);
      if (null === d.invert(m, m)) return !1;
      k[0] = ((C - U[0]) / U[2]) * 2 - 1;
      k[1] = ((H - U[1]) / U[3]) * 2 - 1;
      k[2] = 2 * K - 1;
      k[3] = 1;
      c.transformMat4(k, k, m);
      if (0 === k[3]) return !1;
      k[3] = 1 / k[3];
      V[0] = k[0] * k[3];
      V[1] = k[1] * k[3];
      V[2] = k[2] * k[3];
      return !0;
    },
    UnprojectScreenToWorldZ(C, H, K, P, S, U, V) {
      if (
        !e.Gfx.Unproject(C, H, 0, P, S, U, f) ||
        !e.Gfx.Unproject(C, H, 1, P, S, U, h)
      )
        return !1;
      a.subtract(h, h, f);
      a.set(g, 0, 0, 1);
      C = -K;
      H = a.dot(g, h);
      K = 0;
      if (0 === H) {
        if (0 !== a.dot(g, f) + C) return !1;
      } else if (((K = -(a.dot(f, g) + C) / H), 0 > K)) return !1;
      a.scaleAndAdd(V, f, h, K);
      return !0;
    },
  };
  function E(C, H, K, P) {
    a.subtract(f, K, H);
    a.subtract(h, C, H);
    a.cross(g, f, h);
    a.normalize(g, g);
    P.set(g[0], g[1], g[2], a.dot(C, g));
  }
  function z(C, H, K, P, S, U, V) {
    const aa = V.x,
      ma = V.y,
      va = V.z,
      Na = V.w,
      Ea = V.xF,
      Ia = V.yF;
    V = V.zF;
    const Ma = 1 - Ea,
      Fa = 1 - Ia,
      ya = 1 - V;
    return aa * C * Ea +
      aa * P * Ma +
      ma * H * Ia +
      ma * S * Fa +
      va * K * V +
      va * U * ya >=
      Na
      ? !0
      : aa * P * Ea +
          aa * C * Ma +
          ma * S * Ia +
          ma * H * Fa +
          va * U * V +
          va * K * ya >
          Na;
  }
  function D(C, H, K, P) {
    return P.x * C + P.y * H + P.z * K >= P.w;
  }
  class J {
    constructor() {
      this.zF = this.yF = this.xF = this.w = this.z = this.y = this.x = NaN;
    }
    set(C, H, K, P) {
      this.x = C;
      this.y = H;
      this.z = K;
      this.w = P;
      this.xF = 0 < C ? 1 : 0;
      this.yF = 0 < H ? 1 : 0;
      this.zF = 0 < K ? 1 : 0;
    }
  }
  e.Gfx.ViewFrustum = class {
    constructor() {
      this._leftP = new J();
      this._topP = new J();
      this._rightP = new J();
      this._bottomP = new J();
      this._nearP = new J();
      this._farP = new J();
    }
    CalculatePlanes(C, H) {
      e.Gfx.Unproject(0, 1, 0, C, H, B, q);
      e.Gfx.Unproject(1, 1, 0, C, H, B, v);
      e.Gfx.Unproject(0, 0, 0, C, H, B, r);
      e.Gfx.Unproject(1, 0, 0, C, H, B, n);
      e.Gfx.Unproject(0, 1, 1, C, H, B, p);
      e.Gfx.Unproject(1, 1, 1, C, H, B, u);
      e.Gfx.Unproject(0, 0, 1, C, H, B, w);
      e.Gfx.Unproject(1, 0, 1, C, H, B, y);
      E(r, q, p, this._leftP);
      E(q, v, u, this._topP);
      E(v, n, y, this._rightP);
      E(n, r, w, this._bottomP);
      E(w, p, u, this._farP);
      E(n, v, q, this._nearP);
    }
    ContainsAABB(C, H, K, P, S, U) {
      return (
        z(C, H, K, P, S, U, this._leftP) &&
        z(C, H, K, P, S, U, this._topP) &&
        z(C, H, K, P, S, U, this._rightP) &&
        z(C, H, K, P, S, U, this._bottomP) &&
        z(C, H, K, P, S, U, this._nearP) &&
        z(C, H, K, P, S, U, this._farP)
      );
    }
    IsBehindNearPlane(C, H, K) {
      return !D(C, H, K, this._nearP);
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.glMatrix,
    a = b.vec3,
    c = b.vec4,
    d = b.mat4,
    f = d.create(),
    h = a.fromValues(0, 0, 0),
    g = a.fromValues(0, 0, 0),
    k = a.fromValues(0, 0, 0),
    m = a.fromValues(0, 1, 0);
  c.fromValues(0, 0, 0, 0);
  const q = new e.Quad(),
    v = new e.Rect(),
    r = new e.Quad(0, 0, 1, 0, 1, 1, 0, 1);
  e.Gfx.RendererBase = class {
    constructor() {
      this._height = this._width = 0;
      this._fovY = e.toRadians(45);
      this._tan_fovY_2 = Math.tan(this._fovY / 2);
      this._matP = d.create();
      this._matMV = d.create();
      this._zAxisScale = !1;
      this._allShaderPrograms = [];
      this._shaderProgramsByName = new Map();
      this._spSmoothLineFill =
        this._spSmoothEllipseOutline =
        this._spSmoothEllipseFill =
        this._spHardEllipseOutline =
        this._spHardEllipseFill =
        this._spLinearGradientFill =
        this._spColorFill =
        this._spTilemapFill =
        this._spPoints =
        this._spTextureFill =
          null;
      this._stateGroups = new Map();
      this._currentStateGroup = null;
      this._blendModeTable = [];
      this._namedBlendModeMap = new Map();
      this._currentZ = this._baseZ = 0;
      this._lineWidth = 1;
      this._lineWidthStack = [this._lineWidth];
      this._lineCap = 1;
      this._lineCapStack = [this._lineCap];
      this._lineOffset = 0.5;
      this._lineOffsetStack = [this._lineOffset];
      this._frameNumber = 0;
      this._enableMipmaps = !0;
      this._hasMajorPerformanceCaveat = !1;
    }
    FillIndexBufferData(n) {
      let p = 0,
        u = n.length,
        w = 0;
      for (; p < u; )
        (n[p++] = w),
          (n[p++] = w + 1),
          (n[p++] = w + 2),
          (n[p++] = w),
          (n[p++] = w + 2),
          (n[p++] = w + 3),
          (w += 4);
    }
    _ClearState() {
      this._currentZ = this._baseZ = 0;
      this._spSmoothLineFill =
        this._spSmoothEllipseOutline =
        this._spSmoothEllipseFill =
        this._spHardEllipseOutline =
        this._spHardEllipseFill =
        this._spLinearGradientFill =
        this._spColorFill =
        this._spTilemapFill =
        this._spPoints =
        this._spTextureFill =
          null;
      this._ClearAllShaderPrograms();
    }
    InitState() {
      this._ClearState();
      this._currentStateGroup = null;
    }
    OnDeviceOrContextLost() {
      for (const n of this._allShaderPrograms) n.Release();
      this._ClearState();
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    GetDefaultCameraZ(n) {
      return this.IsZAxisScaleNormalized()
        ? 100
        : n / (2 * this._GetTanFovYDiv2());
    }
    GetZAxisScaleFactor(n) {
      return this.IsZAxisScaleNormalized()
        ? n / (2 * this._GetTanFovYDiv2()) / this.GetDefaultCameraZ(n)
        : 1;
    }
    GetNearZ() {
      return 1;
    }
    GetFarZ() {
      return 1e4;
    }
    SetFovY(n) {
      this._fovY = n;
      this._tan_fovY_2 = Math.tan(this._fovY / 2);
    }
    GetFovY() {
      return this._fovY;
    }
    _GetTanFovYDiv2() {
      return this._tan_fovY_2;
    }
    SetZAxisScaleNormalized() {
      this._zAxisScale = !1;
    }
    SetZAxisScaleRegular() {
      this._zAxisScale = !0;
    }
    IsZAxisScaleNormalized() {
      return !this._zAxisScale;
    }
    IsZAxisScaleRegular() {
      return this._zAxisScale;
    }
    CalculatePerspectiveMatrix(n, p, u = 0.5, w = 0.5) {
      const y = this.GetNearZ(),
        B = this.GetFarZ();
      var E = this.GetFovY();
      if (0.5 === u && 0.5 === w)
        this.IsWebGPU()
          ? d.perspectiveZO(n, E, p, y, B)
          : d.perspective(n, E, p, y, B);
      else {
        u = 1 - u;
        E = 2 * u - 2;
        u *= 2;
        const z = 2 * w - 2;
        w *= 2;
        const D = this._GetTanFovYDiv2() * y;
        p *= D;
        d.frustum(n, E * p, u * p, z * D, w * D, y, B);
      }
    }
    CalculateOrthographicMatrix(n, p, u, w = 1) {
      var y = self.devicePixelRatio;
      const B =
        (2 * this.GetDefaultCameraZ(u) * y * this._GetTanFovYDiv2()) / u;
      p = (p * B) / (2 * y * w);
      u = (u * B) / (2 * y * w);
      w = -p;
      y = -u;
      this.IsWebGPU()
        ? d.orthoZO(n, w, p, y, u, this.GetNearZ(), this.GetFarZ())
        : d.ortho(n, w, p, y, u, this.GetNearZ(), this.GetFarZ());
    }
    CalculateLookAtModelView(n, p, u, w, y, B = 1) {
      let E = 1;
      this.IsZAxisScaleNormalized() && (E = (200 * this._GetTanFovYDiv2()) / y);
      a.set(k, E, -E, 1);
      a.multiply(h, p, k);
      a.multiply(g, u, k);
      d.lookAt(n, h, g, w || m);
      k[2] = B;
      d.scale(n, n, k);
    }
    CalculateLookAtModelView2(n, p, u, w, y, B, E, z) {
      a.set(h, n, p, u);
      a.set(g, w, y, B);
      this.CalculateLookAtModelView(f, h, g, m, E, z);
      return f;
    }
    _AddShaderProgram(n) {
      this._allShaderPrograms.push(n);
      this._shaderProgramsByName.set(n.GetName(), n);
    }
    _RemoveShaderProgram(n) {
      const p = this._allShaderPrograms.indexOf(n);
      -1 !== p && this._allShaderPrograms.splice(p, 1);
      this._shaderProgramsByName.delete(n.GetName());
    }
    _ClearAllShaderPrograms() {
      e.clearArray(this._allShaderPrograms);
      this._shaderProgramsByName.clear();
    }
    GetShaderProgramByName(n) {
      return this._shaderProgramsByName.get(n) || null;
    }
    GetTextureFillShaderProgram() {
      return this._spTextureFill;
    }
    SetTextureFillMode() {
      this.SetProgram(this._spTextureFill);
    }
    GetPointsRenderingProgram() {
      return this._spPoints;
    }
    SetPointsRenderingProgram() {
      this.SetProgram(this._spPoints);
    }
    SetTilemapFillMode() {
      this.SetProgram(this._spTilemapFill);
    }
    SetColorFillMode() {
      this.SetProgram(this._spColorFill);
    }
    SetLinearGradientFillMode() {
      this.SetProgram(this._spLinearGradientFill);
    }
    SetHardEllipseFillMode() {
      this.SetProgram(this._spHardEllipseFill);
    }
    SetHardEllipseOutlineMode() {
      this.SetProgram(this._spHardEllipseOutline);
    }
    SetSmoothEllipseFillMode() {
      this.SetProgram(this._spSmoothEllipseFill);
    }
    SetSmoothEllipseOutlineMode() {
      this.SetProgram(this._spSmoothEllipseOutline);
    }
    SetSmoothLineFillMode() {
      this.SetProgram(this._spSmoothLineFill);
    }
    _SetCurrentStateGroup(n) {
      this._currentStateGroup = n;
    }
    GetCurrentStateGroup() {
      return this._currentStateGroup;
    }
    AcquireStateGroup(n, p, u, w) {
      const y = e.Gfx.StateGroup.MakeKey(n, p, u, w);
      let B = this._stateGroups.get(y);
      B ||
        ((B = e.New(e.Gfx.StateGroup, this, n, p, u, w)),
        this._stateGroups.set(y, B));
      B.AddRef();
      return B;
    }
    ReleaseStateGroup(n) {
      n.DecRef();
      0 === n._GetRefCount() &&
        (this._currentStateGroup === n && (this._currentStateGroup = null),
        this._stateGroups.delete(n.GetKey()),
        n.Release());
    }
    _InitBlendModeData(n) {
      e.clearArray(this._blendModeTable);
      this._namedBlendModeMap.clear();
      let p = 0;
      for (const u of n) {
        n = u[0];
        const w = u[1],
          y = u[2];
        this._blendModeTable.push([w, y]);
        this._namedBlendModeMap.set(n, {
          number: p,
          srcBlend: w,
          destBlend: y,
        });
        p++;
      }
    }
    _GetBlendByIndex(n) {
      return this._blendModeTable[n];
    }
    GetSrcBlendByIndex(n) {
      return this._GetBlendByIndex(n)[0];
    }
    GetDestBlendByIndex(n) {
      return this._GetBlendByIndex(n)[1];
    }
    GetNamedBlend(n) {
      n = this._namedBlendModeMap.get(n);
      if ("undefined" === typeof n) throw Error("invalid blend name");
      return n;
    }
    NamedBlendToNumber(n) {
      n = this._namedBlendModeMap.get(n);
      if ("undefined" === typeof n) throw Error("invalid blend name");
      return n.number;
    }
    SetBaseZ(n) {
      this._baseZ = n;
    }
    GetBaseZ() {
      return this._baseZ;
    }
    SetCurrentZ(n) {
      this._currentZ = n;
      this._currentStateGroup = null;
    }
    GetCurrentZ() {
      return this._currentZ;
    }
    Line(n, p, u, w) {
      var y = e.angleTo(n, p, u, w),
        B = 0.5 * this._lineWidth;
      const E = Math.sin(y) * B;
      y = Math.cos(y) * B;
      B = this._lineCap;
      2 === B
        ? this.LinePreCalc_LineCap2(n, p, 0, u, w, 0, E, y)
        : 1 === B
        ? this.LinePreCalc_LineCap1(n, p, 0, u, w, 0, E, y)
        : this.LinePreCalc_LineCap0(n, p, 0, u, w, 0, E, y);
    }
    Line3D(n, p, u, w, y, B) {
      var E = e.angleTo(n, p, w, y),
        z = 0.5 * this._lineWidth;
      const D = Math.sin(E) * z;
      E = Math.cos(E) * z;
      z = this._lineCap;
      2 === z
        ? this.LinePreCalc_LineCap2(n, p, u, w, y, B, D, E)
        : 1 === z
        ? this.LinePreCalc_LineCap1(n, p, u, w, y, B, D, E)
        : this.LinePreCalc_LineCap0(n, p, u, w, y, B, D, E);
    }
    LinePreCalc_LineCap2(n, p, u, w, y, B, E, z) {
      var D = this._lineOffset;
      n = n + D - z;
      p = p + D - E;
      w = w + D + z;
      y = y + D + E;
      D = 2 * z;
      const J = 2 * E;
      this.Quad3D2(
        n + E,
        p - z,
        u,
        w + E,
        y - z,
        B,
        w - E - D,
        y + z - J,
        B,
        n - E + D,
        p + z + J,
        u,
        r
      );
    }
    LinePreCalc_LineCap1(n, p, u, w, y, B, E, z) {
      const D = this._lineOffset;
      n = n + D - z;
      p = p + D - E;
      w = w + D + z;
      y = y + D + E;
      this.Quad3D2(
        n + E,
        p - z,
        u,
        w + E,
        y - z,
        B,
        w - E,
        y + z,
        B,
        n - E,
        p + z,
        u,
        r
      );
    }
    LinePreCalc_LineCap0(n, p, u, w, y, B, E, z) {
      const D = this._lineOffset;
      n += D;
      p += D;
      w += D;
      y += D;
      this.Quad3D2(
        n + E,
        p - z,
        u,
        w + E,
        y - z,
        B,
        w - E,
        y + z,
        B,
        n - E,
        p + z,
        u,
        r
      );
    }
    TexturedLine(n, p, u, w, y, B) {
      var E = e.angleTo(n, p, u, w),
        z = 0.5 * this._lineWidth;
      const D = Math.sin(E) * z;
      E = Math.cos(E) * z;
      z = this._lineCap;
      2 === z
        ? this.TexturedLinePreCalc_LineCap2(n, p, u, w, D, E, y, B)
        : 1 === z
        ? this.TexturedLinePreCalc_LineCap1(n, p, u, w, D, E, y, B)
        : this.TexturedLinePreCalc_LineCap0(n, p, u, w, D, E, y, B);
    }
    TexturedLinePreCalc_LineCap2(n, p, u, w, y, B, E, z) {
      var D = this._lineOffset;
      n = n + D - B;
      p = p + D - y;
      u = u + D + B;
      w = w + D + y;
      D = 2 * B;
      const J = 2 * y;
      q.set(
        n + y,
        p - B,
        u + y,
        w - B,
        u - y - D,
        w + B - J,
        n - y + D,
        p + B + J
      );
      v.set(E, 0, z, 0);
      this.Quad3(q, v);
    }
    TexturedLinePreCalc_LineCap1(n, p, u, w, y, B, E, z) {
      const D = this._lineOffset;
      n = n + D - B;
      p = p + D - y;
      u = u + D + B;
      w = w + D + y;
      q.set(n + y, p - B, u + y, w - B, u - y, w + B, n - y, p + B);
      v.set(E, 0, z, 0);
      this.Quad3(q, v);
    }
    TexturedLinePreCalc_LineCap0(n, p, u, w, y, B, E, z) {
      const D = this._lineOffset;
      n += D;
      p += D;
      u += D;
      w += D;
      q.set(n + y, p - B, u + y, w - B, u - y, w + B, n - y, p + B);
      v.set(E, 0, z, 0);
      this.Quad3(q, v);
    }
    LineRect(n, p, u, w) {
      const y = 0.5 * this._lineWidth,
        B = this._lineCap;
      2 === B
        ? this._LineRectPreCalc_LineCap2(n, p, u, w, y)
        : 1 === B
        ? this._LineRectPreCalc_LineCap1(n, p, u, w, y)
        : this._LineRectPreCalc_LineCap0(n, p, u, w, y);
    }
    _LineRectPreCalc_LineCap2(n, p, u, w, y) {
      this.LinePreCalc_LineCap2(n, p, 0, u, p, 0, 0, y);
      this.LinePreCalc_LineCap2(u, p, 0, u, w, 0, y, 0);
      this.LinePreCalc_LineCap2(u, w, 0, n, w, 0, 0, -y);
      this.LinePreCalc_LineCap2(n, w, 0, n, p, 0, -y, 0);
    }
    _LineRectPreCalc_LineCap1(n, p, u, w, y) {
      this.LinePreCalc_LineCap1(n, p, 0, u, p, 0, 0, y);
      this.LinePreCalc_LineCap1(u, p, 0, u, w, 0, y, 0);
      this.LinePreCalc_LineCap1(u, w, 0, n, w, 0, 0, -y);
      this.LinePreCalc_LineCap1(n, w, 0, n, p, 0, -y, 0);
    }
    _LineRectPreCalc_LineCap0(n, p, u, w, y) {
      this.LinePreCalc_LineCap0(n, p, 0, u, p, 0, 0, y);
      this.LinePreCalc_LineCap0(u, p, 0, u, w, 0, y, 0);
      this.LinePreCalc_LineCap0(u, w, 0, n, w, 0, 0, -y);
      this.LinePreCalc_LineCap0(n, w, 0, n, p, 0, -y, 0);
    }
    LineRect2(n) {
      this.LineRect(n.getLeft(), n.getTop(), n.getRight(), n.getBottom());
    }
    LineQuad(n) {
      var p = e.angleTo(n.getTlx(), n.getTly(), n.getTrx(), n.getTry()),
        u = 0.5 * this._lineWidth;
      const w = Math.sin(p) * u;
      p = Math.cos(p) * u;
      u = this._lineCap;
      2 === u
        ? this._LineQuadPreCalc_LineCap2(n, w, p)
        : 1 === u
        ? this._LineQuadPreCalc_LineCap1(n, w, p)
        : this._LineQuadPreCalc_LineCap0(n, w, p);
    }
    _LineQuadPreCalc_LineCap2(n, p, u) {
      this.LinePreCalc_LineCap2(
        n.getTlx(),
        n.getTly(),
        0,
        n.getTrx(),
        n.getTry(),
        0,
        p,
        u
      );
      this.LinePreCalc_LineCap2(
        n.getTrx(),
        n.getTry(),
        0,
        n.getBrx(),
        n.getBry(),
        0,
        u,
        -p
      );
      this.LinePreCalc_LineCap2(
        n.getBrx(),
        n.getBry(),
        0,
        n.getBlx(),
        n.getBly(),
        0,
        -p,
        -u
      );
      this.LinePreCalc_LineCap2(
        n.getBlx(),
        n.getBly(),
        0,
        n.getTlx(),
        n.getTly(),
        0,
        -u,
        p
      );
    }
    _LineQuadPreCalc_LineCap1(n, p, u) {
      this.LinePreCalc_LineCap1(
        n.getTlx(),
        n.getTly(),
        0,
        n.getTrx(),
        n.getTry(),
        0,
        p,
        u
      );
      this.LinePreCalc_LineCap1(
        n.getTrx(),
        n.getTry(),
        0,
        n.getBrx(),
        n.getBry(),
        0,
        u,
        -p
      );
      this.LinePreCalc_LineCap1(
        n.getBrx(),
        n.getBry(),
        0,
        n.getBlx(),
        n.getBly(),
        0,
        -p,
        -u
      );
      this.LinePreCalc_LineCap1(
        n.getBlx(),
        n.getBly(),
        0,
        n.getTlx(),
        n.getTly(),
        0,
        -u,
        p
      );
    }
    _LineQuadPreCalc_LineCap0(n, p, u) {
      this.LinePreCalc_LineCap0(
        n.getTlx(),
        n.getTly(),
        0,
        n.getTrx(),
        n.getTry(),
        0,
        p,
        u
      );
      this.LinePreCalc_LineCap0(
        n.getTrx(),
        n.getTry(),
        0,
        n.getBrx(),
        n.getBry(),
        0,
        u,
        -p
      );
      this.LinePreCalc_LineCap0(
        n.getBrx(),
        n.getBry(),
        0,
        n.getBlx(),
        n.getBly(),
        0,
        -p,
        -u
      );
      this.LinePreCalc_LineCap0(
        n.getBlx(),
        n.getBly(),
        0,
        n.getTlx(),
        n.getTly(),
        0,
        -u,
        p
      );
    }
    SetLineWidth(n) {
      this._lineWidth = n;
      this._lineWidthStack[this._lineWidthStack.length - 1] = n;
    }
    GetLineWidth() {
      return this._lineWidth;
    }
    PushLineWidth(n) {
      if (100 <= this._lineWidthStack.length)
        throw Error("pushed too many line widths - check push/pop pairs");
      this._lineWidthStack.push(n);
      this._lineWidth = n;
    }
    PopLineWidth() {
      if (1 >= this._lineWidthStack.length)
        throw Error("cannot pop last line width - check push/pop pairs");
      this._lineWidthStack.pop();
      this._lineWidth = this._lineWidthStack.at(-1);
    }
    SetLineCapButt() {
      this._lineCap = 0;
      this._lineCapStack[this._lineCapStack.length - 1] = 0;
    }
    SetLineCapSquare() {
      this._lineCap = 1;
      this._lineCapStack[this._lineCapStack.length - 1] = 0;
    }
    SetLineCapZag() {
      this._lineCap = 2;
      this._lineCapStack[this._lineCapStack.length - 1] = 0;
    }
    PushLineCap(n) {
      if ("butt" === n) this.PushLineCapButt();
      else if ("square" === n) this.PushLineCapSquare();
      else if ("zag" === n) this.PushLineCapZag();
      else throw Error("invalid line cap");
    }
    PushLineCapButt() {
      if (100 <= this._lineCapStack.length)
        throw Error("pushed too many line caps - check push/pop pairs");
      this._lineCapStack.push(0);
      this._lineCap = 0;
    }
    PushLineCapSquare() {
      if (100 <= this._lineCapStack.length)
        throw Error("pushed too many line caps - check push/pop pairs");
      this._lineCapStack.push(1);
      this._lineCap = 1;
    }
    PushLineCapZag() {
      if (100 <= this._lineCapStack.length)
        throw Error("pushed too many line caps - check push/pop pairs");
      this._lineCapStack.push(2);
      this._lineCap = 2;
    }
    PopLineCap() {
      if (1 >= this._lineCapStack.length)
        throw Error("cannot pop last line cap - check push/pop pairs");
      this._lineCapStack.pop();
      this._lineCap = this._lineCapStack.at(-1);
    }
    SetLineOffset(n) {
      this._lineOffset = n;
      this._lineOffsetStack[this._lineOffsetStack.length - 1] = n;
    }
    GetLineOffset() {
      return this._lineOffset;
    }
    PushLineOffset(n) {
      if (100 <= this._lineOffsetStack.length)
        throw Error("pushed too many line offsets - check push/pop pairs");
      this._lineOffsetStack.push(n);
      this._lineOffset = n;
    }
    PopLineOffset() {
      if (1 >= this._lineOffsetStack.length)
        throw Error("cannot pop last line offset - check push/pop pairs");
      this._lineOffsetStack.pop();
      this._lineOffset = this._lineOffsetStack.at(-1);
    }
    ConvexPoly(n) {
      var p = n.length / 2;
      if (3 > p) throw Error("need at least 3 points");
      p -= 2;
      const u = p - 1,
        w = n[0],
        y = n[1];
      for (let B = 0; B < p; B += 2) {
        const E = 2 * B,
          z = n[E + 2],
          D = n[E + 3],
          J = n[E + 4],
          C = n[E + 5];
        B === u
          ? this.Quad2(w, y, z, D, J, C, J, C)
          : this.Quad2(w, y, z, D, J, C, n[E + 6], n[E + 7]);
      }
    }
    GetNumVertexComponents() {
      return 3;
    }
    Finish() {
      this.EndBatch(!0);
      this._frameNumber++;
    }
    GetFrameNumber() {
      return this._frameNumber;
    }
    IncrementFrameNumber() {
      this._frameNumber++;
    }
    SetMipmapsEnabled(n) {
      this._enableMipmaps = !!n;
    }
    AreMipmapsEnabled() {
      return this._enableMipmaps;
    }
    SetHasMajorPerformanceCaveat(n) {
      this._hasMajorPerformanceCaveat = !!n;
    }
    HasMajorPerformanceCaveat() {
      return this._hasMajorPerformanceCaveat;
    }
    IsWebGL() {
      return !1;
    }
    IsWebGPU() {
      return !1;
    }
  };
}
("use strict");
self.C3.Gfx.ShaderProgramBase = class {
  constructor(e, b, a) {
    this._name = b;
    this._renderer = e;
    this._extendBoxHorizontal = a.extendBoxHorizontal || 0;
    this._extendBoxVertical = a.extendBoxVertical || 0;
    this._crossSampling = !!a.crossSampling;
    this._mustPreDraw = !!a.mustPreDraw;
    this._preservesOpaqueness = !!a.preservesOpaqueness;
    this._animated = !!a.animated;
    this._blendsBackground = !!a.blendsBackground;
    this._usesDepth = !!a.usesDepth;
    this._usesAnySrcRectOrPixelSize = !1;
    this._needsPostDrawOrExtendBox =
      this._crossSampling ||
      this._blendsBackground ||
      0 !== this._extendBoxHorizontal ||
      0 !== this._extendBoxVertical;
  }
  Release() {
    this._renderer = null;
  }
  GetRenderer() {
    return this._renderer;
  }
  GetName() {
    return this._name;
  }
  ExtendsBox() {
    return 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;
  }
  GetBoxExtendHorizontal() {
    return this._extendBoxHorizontal;
  }
  GetBoxExtendVertical() {
    return this._extendBoxVertical;
  }
  UsesCrossSampling() {
    return this._crossSampling;
  }
  MustPreDraw() {
    return this._mustPreDraw;
  }
  PreservesOpaqueness() {
    return this._preservesOpaqueness;
  }
  IsAnimated() {
    return this._animated;
  }
  BlendsBackground() {
    return this._blendsBackground;
  }
  UsesDepth() {
    return this._usesDepth;
  }
  UsesAnySrcRectOrPixelSize() {
    return this._usesAnySrcRectOrPixelSize;
  }
  NeedsPostDrawOrExtendsBox() {
    return this._needsPostDrawOrExtendBox;
  }
  UsesIsSrcTexRotated() {
    return !1;
  }
};
{
  ("use strict");
  const e = self.C3;
  e.Gfx.StateGroup = class {
    constructor(b, a, c, d, f) {
      this._renderer = b;
      this._refCount = 0;
      this._shaderProgram = null;
      this._shaderProgramName = "";
      this._blendMode = c;
      this._color = e.New(e.Color);
      this._color.set(d);
      this._zElevation = f;
      "string" === typeof a
        ? (this._shaderProgramName = a)
        : ((this._shaderProgram = a),
          (this._shaderProgramName = this._shaderProgram.GetName()));
    }
    Release() {
      if (0 < this._refCount) throw Error("releasing state group still in use");
      this._shaderProgram = this._renderer = null;
      this._shaderProgramName = "";
    }
    Apply() {
      const b = this._renderer;
      b.SetProgram(this._shaderProgram);
      b.SetBlendMode(this._blendMode);
      b.SetColor(this._color);
      b.SetCurrentZ(this._zElevation);
      b._SetCurrentStateGroup(this);
    }
    GetKey() {
      return e.Gfx.StateGroup.MakeKey(
        this._shaderProgramName,
        this._blendMode,
        this._color,
        this._zElevation
      );
    }
    AddRef() {
      ++this._refCount;
    }
    DecRef() {
      --this._refCount;
    }
    _GetRefCount() {
      return this._refCount;
    }
    OnContextLost() {
      this._shaderProgram = null;
    }
    OnContextRestored(b) {
      this._shaderProgram = b.GetShaderProgramByName(this._shaderProgramName);
      if (!this._shaderProgram) throw Error("failed to restore shader program");
    }
    static MakeKey(b, a, c, d) {
      return (
        ("string" === typeof b ? b : b.GetName()) +
        "," +
        a +
        "," +
        c.getR() +
        "," +
        c.getG() +
        "," +
        c.getB() +
        "," +
        c.getA() +
        "," +
        d
      );
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = e.New(e.Quad);
  function a(c, d, f) {
    const h = f.getTlx(),
      g = f.getTly(),
      k = f.getTrx() - h,
      m = f.getTry() - g,
      q = f.getBlx() - h;
    f = f.getBly() - g;
    return [h + k * c + q * d, g + m * c + f * d];
  }
  e.Gfx.MeshPoint = class {
    constructor(c, d, f) {
      this._mesh = c;
      this._col = d;
      this._row = f;
      this._v = this._u = this._zElevation = this._y = this._x = 0;
    }
    _Init(c, d, f, h) {
      this._x = c;
      this._y = d;
      this._u = f;
      this._v = h;
    }
    GetX() {
      return this._x;
    }
    SetX(c) {
      this._x !== c && ((this._x = c), this._mesh._SetPointsChanged());
    }
    GetY() {
      return this._y;
    }
    SetY(c) {
      this._y !== c && ((this._y = c), this._mesh._SetPointsChanged());
    }
    GetZElevation() {
      return this._zElevation;
    }
    SetZElevation(c) {
      this._zElevation !== c &&
        ((this._zElevation = Math.max(c, 0)), this._mesh._SetPointsChanged());
    }
    GetU() {
      return this._u;
    }
    SetU(c) {
      this._u = c;
    }
    GetV() {
      return this._v;
    }
    SetV(c) {
      this._v = c;
    }
    _Interpolate_TexRect(c, d, f) {
      [this._x, this._y] = a(c._x, c._y, d);
      this._zElevation = c._zElevation;
      this._u = e.lerp(f.getLeft(), f.getRight(), c._u);
      this._v = e.lerp(f.getTop(), f.getBottom(), c._v);
    }
    _Interpolate_TexQuad(c, d, f) {
      [this._x, this._y] = a(c._x, c._y, d);
      this._zElevation = c._zElevation;
      [this._u, this._v] = a(c._u, c._v, f);
    }
    SaveToJson() {
      return {
        x: this.GetX(),
        y: this.GetY(),
        z: this.GetZElevation(),
        u: this.GetU(),
        v: this.GetV(),
      };
    }
    LoadFromJson(c) {
      this.SetX(c.x);
      this.SetY(c.y);
      c.hasOwnProperty("z") && this.SetZElevation(c.z);
      this.SetU(c.u);
      this.SetV(c.v);
    }
    GetMesh() {
      return this._mesh;
    }
    GetColumn() {
      return this._col;
    }
    GetRow() {
      return this._row;
    }
  };
  e.Gfx.Mesh = class {
    constructor(c, d, f) {
      if (2 > c || 2 > d) throw Error("invalid mesh size");
      this._hsize = c;
      this._vsize = d;
      this._owner = f || null;
      this._pts = [];
      this._minY = this._minX = 0;
      this._maxY = this._maxX = 1;
      this._maxZ = 0;
      this._pointsChanged = !1;
      f = c - 1;
      const h = d - 1;
      for (let g = 0; g < d; ++g) {
        const k = [];
        for (let m = 0; m < c; ++m) {
          const q = e.New(e.Gfx.MeshPoint, this, m, g),
            v = m / f,
            r = g / h;
          q._Init(v, r, v, r);
          k.push(q);
        }
        this._pts.push(k);
      }
    }
    Release() {
      e.clearArray(this._pts);
    }
    GetHSize() {
      return this._hsize;
    }
    GetVSize() {
      return this._vsize;
    }
    GetOwner() {
      return this._owner;
    }
    _GetPoints() {
      return this._pts;
    }
    _SetPointsChanged() {
      this._pointsChanged = !0;
    }
    _MaybeComputeBounds() {
      if (this._pointsChanged) {
        var c = Infinity,
          d = Infinity,
          f = -Infinity,
          h = -Infinity,
          g = 0;
        for (const k of this._pts)
          for (const m of k) {
            const q = m.GetX(),
              v = m.GetY();
            c = Math.min(c, q);
            d = Math.min(d, v);
            f = Math.max(f, q);
            h = Math.max(h, v);
            g = Math.max(g, m.GetZElevation());
          }
        this._minX = c;
        this._minY = d;
        this._maxX = f;
        this._maxY = h;
        this._maxZ = g;
        this._pointsChanged = !1;
      }
    }
    GetMinX() {
      this._MaybeComputeBounds();
      return this._minX;
    }
    GetMinY() {
      this._MaybeComputeBounds();
      return this._minY;
    }
    GetMaxX() {
      this._MaybeComputeBounds();
      return this._maxX;
    }
    GetMaxY() {
      this._MaybeComputeBounds();
      return this._maxY;
    }
    GetMaxZ() {
      this._MaybeComputeBounds();
      return this._maxZ;
    }
    HasAnyZElevation() {
      return 0 < this.GetMaxZ();
    }
    GetMeshPointAt(c, d) {
      c = Math.floor(c);
      d = Math.floor(d);
      return 0 > c || c >= this._hsize || 0 > d || d >= this._vsize
        ? null
        : this._pts[d][c];
    }
    CalculateTransformedMesh(c, d, f) {
      const h = f instanceof e.Rect;
      if (c.GetHSize() !== this.GetHSize() || c.GetVSize() !== this.GetVSize())
        throw Error("source mesh wrong size");
      c = c._pts;
      const g = this._pts;
      for (let k = 0, m = g.length; k < m; ++k) {
        const q = c[k],
          v = g[k];
        for (let r = 0, n = v.length; r < n; ++r) {
          const p = q[r],
            u = v[r];
          h ? u._Interpolate_TexRect(p, d, f) : u._Interpolate_TexQuad(p, d, f);
        }
      }
    }
    Draw(c) {
      const d = this._pts;
      let f = d[0];
      for (let h = 1, g = d.length; h < g; ++h) {
        const k = d[h];
        let m = f[0],
          q = k[0];
        for (let v = 1, r = k.length; v < r; ++v) {
          const n = f[v],
            p = k[v];
          b.set(
            m.GetU(),
            m.GetV(),
            n.GetU(),
            n.GetV(),
            p.GetU(),
            p.GetV(),
            q.GetU(),
            q.GetV()
          );
          c.Quad3D2(
            m.GetX(),
            m.GetY(),
            m.GetZElevation(),
            n.GetX(),
            n.GetY(),
            n.GetZElevation(),
            p.GetX(),
            p.GetY(),
            p.GetZElevation(),
            q.GetX(),
            q.GetY(),
            q.GetZElevation(),
            b
          );
          m = n;
          q = p;
        }
        f = k;
      }
    }
    Outline(c, d) {
      d || (d = (g, k, m) => [g, k, m]);
      const f = this._pts;
      let h = f[0];
      for (let g = 1, k = f.length; g < k; ++g) {
        const m = f[g];
        let q = h[0],
          v = m[0];
        for (let r = 1, n = m.length; r < n; ++r) {
          const p = h[r],
            u = m[r],
            [w, y, B] = d(q.GetX(), q.GetY(), q.GetZElevation()),
            [E, z, D] = d(p.GetX(), p.GetY(), p.GetZElevation()),
            [J, C, H] = d(u.GetX(), u.GetY(), u.GetZElevation()),
            [K, P, S] = d(v.GetX(), v.GetY(), v.GetZElevation());
          c.Line3D(w, y, B, E, z, D);
          c.Line3D(w, y, B, J, C, H);
          c.Line3D(w, y, B, K, P, S);
          r === n - 1 && c.Line3D(E, z, D, J, C, H);
          g === k - 1 && c.Line3D(K, P, S, J, C, H);
          q = p;
          v = u;
        }
        h = m;
      }
    }
    InsertPolyMeshVertices(c) {
      c = c.pointsArr();
      const d = [],
        f = this.GetHSize() - 1,
        h = this.GetVSize() - 1,
        g = 1 / f,
        k = 1 / h,
        m = f - 1,
        q = h - 1;
      let v = c[0],
        r = c[1],
        n = e.clamp(Math.floor(v * f), 0, m),
        p = e.clamp(Math.floor(r * h), 0, q),
        u = 0,
        w = 0,
        y = 0;
      var B = -1;
      const E = () => {
        v = e.clamp(e.lerp(v, u, y), 0, 1);
        r = e.clamp(e.lerp(r, w, y), 0, 1);
        d.push(v, r);
      };
      for (let z = 0, D = c.length; z < D; z += 2)
        for (
          v = c[z],
            r = c[z + 1],
            d.push(v, r),
            n = e.clamp(Math.floor(v * f), 0, m),
            p = e.clamp(Math.floor(r * h), 0, q),
            B = (z + 2) % D,
            u = c[B],
            w = c[B + 1],
            B = -1;
          ;

        ) {
          if (1e6 < d.length) throw Error("Too many mesh poly points");
          const J = n * g,
            C = p * k,
            H = (n + 1) * g,
            K = (p + 1) * k;
          e.isPointInTriangleInclusive(v, r, J, C, H, C, H, K);
          if (
            0 !== B &&
            ((y = e.rayIntersectExtended(v, r, u, w, J, C, H, K, -0.001)),
            0 <= y && 0.99999999 >= y)
          ) {
            E();
            B = 0;
            continue;
          }
          if (
            0 < p &&
            2 !== B &&
            ((y = e.rayIntersectExtended(v, r, u, w, J, C, H, C, 0.001)),
            0 <= y && 0.99999999 >= y)
          ) {
            E();
            p--;
            B = 4;
            continue;
          }
          if (
            n < m &&
            3 !== B &&
            ((y = e.rayIntersectExtended(v, r, u, w, H, C, H, K, 0.001)),
            0 <= y && 0.99999999 >= y)
          ) {
            E();
            n++;
            B = 1;
            continue;
          }
          if (
            0 < n &&
            1 !== B &&
            ((y = e.rayIntersectExtended(v, r, u, w, J, C, J, K, 0.001)),
            0 <= y && 0.99999999 >= y)
          ) {
            E();
            n--;
            B = 3;
            continue;
          }
          if (
            p < q &&
            4 !== B &&
            ((y = e.rayIntersectExtended(v, r, u, w, J, K, H, K, 0.001)),
            0 <= y && 0.99999999 >= y)
          ) {
            E();
            p++;
            B = 2;
            continue;
          }
          break;
        }
      return e.New(e.CollisionPoly, d);
    }
    TransformCollisionPoly(c, d) {
      c = this._TransformPolyPoints(c);
      this._SimplifyPoly(c);
      d.setPoints(c);
    }
    _TransformPolyPoints(c) {
      const d = [];
      c = c.pointsArr();
      for (let f = 0, h = c.length; f < h; f += 2) {
        const [g, k] = this.TransformPoint(c[f], c[f + 1]);
        d.push(g, k);
      }
      return d;
    }
    TransformPoint(c, d) {
      var f = this.GetHSize() - 1,
        h = this.GetVSize() - 1,
        g = 1 / f,
        k = 1 / h;
      f = e.clamp(Math.floor(c * f), 0, f - 1);
      const m = e.clamp(Math.floor(d * h), 0, h - 1);
      h = f * g;
      const q = m * k,
        v = (f + 1) * g,
        r = (m + 1) * k,
        n = this.GetMeshPointAt(f, m),
        p = this.GetMeshPointAt(f + 1, m + 1),
        u = e.isPointInTriangleInclusive(c, d, h, q, v, q, v, r);
      g = u ? h + g : h;
      k = u ? q : q + k;
      f = this.GetMeshPointAt(f + (u ? 1 : 0), m + (u ? 0 : 1));
      const [w, y, B] = e.triangleCartesianToBarycentric(
        c,
        d,
        h,
        q,
        g,
        k,
        v,
        r
      );
      return e.triangleBarycentricToCartesian(
        w,
        y,
        B,
        n.GetX(),
        n.GetY(),
        f.GetX(),
        f.GetY(),
        p.GetX(),
        p.GetY()
      );
    }
    _SimplifyPoly(c) {
      const d = [];
      let f = c[0],
        h = c[1],
        g = f - c.at(-2),
        k = h - c.at(-1);
      for (let q = 0, v = c.length; q < v; q += 2) {
        var m = (q + 2) % v;
        const r = c[m];
        m = c[m + 1];
        const n = r - f,
          p = m - h,
          u =
            1e-7 > Math.abs(p) &&
            1e-7 > Math.abs(k) &&
            Math.sign(n) === Math.sign(g);
        ((!(
          (1e-7 > Math.abs(n) &&
            1e-7 > Math.abs(g) &&
            Math.sign(p) === Math.sign(k)) ||
          u
        ) &&
          1e-7 < Math.abs(n / g - p / k)) ||
          (0 == n && 0 === p)) &&
          d.push(f, h);
        f = r;
        h = m;
        g = n;
        k = p;
      }
      6 <= d.length && d.length < c.length && e.shallowAssignArray(c, d);
    }
    SaveToJson() {
      return {
        cols: this.GetHSize(),
        rows: this.GetVSize(),
        points: this._pts.map((c) => c.map((d) => d.SaveToJson())),
      };
    }
    LoadFromJson(c) {
      const d = this.GetHSize(),
        f = this.GetVSize();
      if (c.cols !== d || c.rows !== f) throw Error("mesh data wrong size");
      c = c.points;
      for (let h = 0; h < f; ++h) {
        const g = c[h];
        for (let k = 0; k < d; ++k)
          this.GetMeshPointAt(k, h).LoadFromJson(g[k]);
      }
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"]),
    a = new Set(["nearest", "bilinear", "trilinear"]),
    c = new Set(["default", "low", "high"]),
    d = new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);
  function f(m, q) {
    let v, r;
    switch (m) {
      case "rgba8":
        m = q.RGBA8;
        r = v = q.RGBA;
        q = q.UNSIGNED_BYTE;
        break;
      case "rgb8":
        m = q.RGB8;
        r = v = q.RGB;
        q = q.UNSIGNED_BYTE;
        break;
      case "rgba4":
        m = q.RGBA4;
        r = v = q.RGBA;
        q = q.UNSIGNED_SHORT_4_4_4_4;
        break;
      case "rgb5_a1":
        m = q.RGB5_A1;
        r = v = q.RGBA;
        q = q.UNSIGNED_SHORT_5_5_5_1;
        break;
      case "rgb565":
        m = q.RGB565;
        r = v = q.RGB;
        q = q.UNSIGNED_SHORT_5_6_5;
        break;
      default:
        throw Error("invalid pixel format");
    }
    return { sizedinternalformat: m, internalformat: v, format: r, type: q };
  }
  const h = {
      wrapX: "clamp-to-edge",
      wrapY: "clamp-to-edge",
      sampling: "trilinear",
      anisotropy: 0,
      pixelFormat: "rgba8",
      mipMap: !0,
      mipMapQuality: "default",
      premultiplyAlpha: !0,
      isSvg: !1,
      width: -1,
      height: -1,
    },
    g = { premultiplyAlpha: !0, flipY: !1 },
    k = new Set();
  e.Gfx.WebGLRendererTexture = class {
    constructor(m) {
      this._renderer = m;
      this._texture = null;
      this._height = this._width = 0;
      this._isStatic = !0;
      this._wrapY = this._wrapX = "clamp-to-edge";
      this._sampling = "trilinear";
      this._anisotropy = 0;
      this._pixelFormat = "rgba8";
      this._isMipMapped = !1;
      this._mipMapQuality = "default";
      this._refCount = 0;
    }
    _CreateStatic(m, q) {
      if (
        !(
          ("undefined" !== typeof HTMLImageElement &&
            m instanceof HTMLImageElement) ||
          ("undefined" !== typeof HTMLCanvasElement &&
            m instanceof HTMLCanvasElement) ||
          ("undefined" !== typeof ImageBitmap && m instanceof ImageBitmap) ||
          ("undefined" !== typeof OffscreenCanvas &&
            m instanceof OffscreenCanvas) ||
          m instanceof ImageData ||
          m instanceof ArrayBuffer
        ) &&
        null !== m
      )
        throw Error("invalid texture source");
      q = Object.assign({}, h, q);
      if (this._texture) throw Error("already created texture");
      this._wrapX = q.wrapX;
      this._wrapY = q.wrapY;
      this._sampling = q.sampling;
      this._anisotropy = q.anisotropy;
      this._pixelFormat = q.pixelFormat;
      this._isMipMapped = !!q.mipMap && this._renderer.AreMipmapsEnabled();
      this._mipMapQuality = q.mipMapQuality;
      if (!d.has(this._wrapX) || !d.has(this._wrapY))
        throw Error("invalid wrap mode");
      if (!a.has(this._sampling)) throw Error("invalid sampling");
      if (!b.has(this._pixelFormat)) throw Error("invalid pixel format");
      if (!c.has(this._mipMapQuality)) throw Error("invalid mipmap quality");
      this._isStatic = !0;
      if (m instanceof ArrayBuffer || null === m || q.isSvg) {
        if (
          ((this._width = q.width),
          (this._height = q.height),
          m instanceof ArrayBuffer &&
            m.byteLength !== this._width * this._height * 4)
        )
          throw Error("ArrayBuffer wrong size");
      } else (this._width = m.width), (this._height = m.height);
      if (0 >= this._width || 0 >= this._height)
        throw Error("invalid texture data size");
      if (q.isSvg) {
        var v = e.CreateCanvas(this._width, this._height);
        v.getContext("2d").drawImage(m, 0, 0, this._width, this._height);
        m = v;
      }
      var r = e.isPOT(this._width) && e.isPOT(this._height);
      v = this._renderer.GetMaxTextureSize();
      if (this._width > v || this._height > v)
        throw Error("texture data exceeds maximum texture size");
      v = this._renderer.GetContext();
      var n = this._renderer.GetWebGLVersionNumber();
      this._texture = v.createTexture();
      v.bindTexture(v.TEXTURE_2D, this._texture);
      v.pixelStorei(v.UNPACK_PREMULTIPLY_ALPHA_WEBGL, q.premultiplyAlpha);
      v.pixelStorei(v.UNPACK_FLIP_Y_WEBGL, !1);
      q = f(this._pixelFormat, v);
      if (this._renderer.SupportsNPOTTextures() || r || !this._IsTiled())
        2 <= n
          ? (v.texStorage2D(
              v.TEXTURE_2D,
              this._isMipMapped
                ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1)
                : 1,
              q.sizedinternalformat,
              this._width,
              this._height
            ),
            m instanceof ArrayBuffer
              ? v.texSubImage2D(
                  v.TEXTURE_2D,
                  0,
                  0,
                  0,
                  this._width,
                  this._height,
                  q.format,
                  q.type,
                  new Uint8Array(m)
                )
              : null !== m &&
                v.texSubImage2D(v.TEXTURE_2D, 0, 0, 0, q.format, q.type, m))
          : m instanceof ArrayBuffer
          ? v.texImage2D(
              v.TEXTURE_2D,
              0,
              q.internalformat,
              this._width,
              this._height,
              0,
              q.format,
              q.type,
              new Uint8Array(m)
            )
          : null === m
          ? v.texImage2D(
              v.TEXTURE_2D,
              0,
              q.internalformat,
              this._width,
              this._height,
              0,
              q.format,
              q.type,
              null
            )
          : v.texImage2D(
              v.TEXTURE_2D,
              0,
              q.internalformat,
              q.format,
              q.type,
              m
            );
      else {
        if (null === m)
          throw Error(
            "cannot pass null data when creating a NPOT tiled texture without NPOT support"
          );
        m instanceof ArrayBuffer &&
          (m = new ImageData(
            new Uint8ClampedArray(m),
            this._width,
            this._height
          ));
        m instanceof ImageData &&
          ((r = e.CreateCanvas(this._width, this._height)),
          r.getContext("2d").putImageData(m, 0, 0),
          (m = r));
        r = e.CreateCanvas(
          e.nextHighestPowerOfTwo(this._width),
          e.nextHighestPowerOfTwo(this._height)
        );
        n = r.getContext("2d");
        n.imageSmoothingEnabled = "nearest" !== this._sampling;
        n.drawImage(
          m,
          0,
          0,
          this._width,
          this._height,
          0,
          0,
          r.width,
          r.height
        );
        v.texImage2D(v.TEXTURE_2D, 0, q.internalformat, q.format, q.type, r);
      }
      null !== m && this._SetTextureParameters(v);
      v.bindTexture(v.TEXTURE_2D, null);
      this._renderer._ResetLastTexture();
      this._refCount = 1;
      k.add(this);
    }
    _CreateDynamic(m, q, v) {
      v = Object.assign({}, h, v);
      if (this._texture) throw Error("already created texture");
      this._wrapX = v.wrapX;
      this._wrapY = v.wrapY;
      this._sampling = v.sampling;
      this._pixelFormat = v.pixelFormat;
      this._isMipMapped = !!v.mipMap && this._renderer.AreMipmapsEnabled();
      this._mipMapQuality = v.mipMapQuality;
      if (!d.has(this._wrapX) || !d.has(this._wrapY))
        throw Error("invalid wrap mode");
      if (!a.has(this._sampling)) throw Error("invalid sampling");
      if (!b.has(this._pixelFormat)) throw Error("invalid pixel format");
      if (!c.has(this._mipMapQuality)) throw Error("invalid mipmap quality");
      this._isStatic = !1;
      this._width = Math.floor(m);
      this._height = Math.floor(q);
      m = e.isPOT(this._width) && e.isPOT(this._height);
      q = this._renderer.GetMaxTextureSize();
      if (0 >= this._width || 0 >= this._height)
        throw Error("invalid texture size");
      if (this._width > q || this._height > q)
        throw Error("texture exceeds maximum texture size");
      if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !m)
        throw Error("non-power-of-two tiled textures not supported");
      m = this._renderer.GetContext();
      q = this._renderer.GetWebGLVersionNumber();
      this._texture = m.createTexture();
      m.bindTexture(m.TEXTURE_2D, this._texture);
      m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL, v.premultiplyAlpha);
      m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, !1);
      v = f(this._pixelFormat, m);
      m.texImage2D(
        m.TEXTURE_2D,
        0,
        2 <= q ? v.sizedinternalformat : v.internalformat,
        this._width,
        this._height,
        0,
        v.format,
        v.type,
        null
      );
      this._SetTextureParameters(m);
      m.bindTexture(m.TEXTURE_2D, null);
      this._renderer._ResetLastTexture();
      this._refCount = 1;
      k.add(this);
    }
    _GetMipMapHint(m) {
      if ("default" === this._mipMapQuality)
        return this._isStatic ? m.NICEST : m.FASTEST;
      if ("low" === this._mipMapQuality) return m.FASTEST;
      if ("high" === this._mipMapQuality) return m.NICEST;
      throw Error("invalid mipmap quality");
    }
    _IsTiled() {
      return "clamp-to-edge" !== this._wrapX || "clamp-to-edge" !== this._wrapY;
    }
    _GetTextureWrapMode(m, q) {
      if ("clamp-to-edge" === q) return m.CLAMP_TO_EDGE;
      if ("repeat" === q) return m.REPEAT;
      if ("mirror-repeat" === q) return m.MIRRORED_REPEAT;
      throw Error("invalid wrap mode");
    }
    _SetTextureParameters(m) {
      var q = e.isPOT(this._width) && e.isPOT(this._height);
      m.texParameteri(
        m.TEXTURE_2D,
        m.TEXTURE_WRAP_S,
        this._GetTextureWrapMode(m, this._wrapX)
      );
      m.texParameteri(
        m.TEXTURE_2D,
        m.TEXTURE_WRAP_T,
        this._GetTextureWrapMode(m, this._wrapY)
      );
      "nearest" === this._sampling
        ? (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST),
          m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST),
          (this._isMipMapped = !1))
        : (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.LINEAR),
          (q || this._renderer.SupportsNPOTTextures()) && this._isMipMapped
            ? (m.hint(m.GENERATE_MIPMAP_HINT, this._GetMipMapHint(m)),
              m.generateMipmap(m.TEXTURE_2D),
              (q =
                "trilinear" === this._sampling &&
                !this._renderer.HasMajorPerformanceCaveat()),
              m.texParameteri(
                m.TEXTURE_2D,
                m.TEXTURE_MIN_FILTER,
                q ? m.LINEAR_MIPMAP_LINEAR : m.LINEAR_MIPMAP_NEAREST
              ))
            : (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.LINEAR),
              (this._isMipMapped = !1)));
      (q = this._renderer._GetAnisotropicExtension()) &&
        0 < this._anisotropy &&
        "nearest" !== this._sampling &&
        m.texParameterf(
          m.TEXTURE_2D,
          q.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(this._anisotropy, this._renderer._GetMaxAnisotropy())
        );
    }
    _Update(m, q) {
      if (
        !(
          ("undefined" !== typeof HTMLImageElement &&
            m instanceof HTMLImageElement) ||
          ("undefined" !== typeof HTMLVideoElement &&
            m instanceof HTMLVideoElement) ||
          ("undefined" !== typeof HTMLCanvasElement &&
            m instanceof HTMLCanvasElement) ||
          ("undefined" !== typeof ImageBitmap && m instanceof ImageBitmap) ||
          ("undefined" !== typeof OffscreenCanvas &&
            m instanceof OffscreenCanvas) ||
          m instanceof ImageData
        )
      )
        throw Error("invalid texture source");
      if (!this._texture || 0 >= this._refCount)
        throw Error("texture not created");
      if (this._isStatic) throw Error("cannot update static texture");
      q = Object.assign({}, g, q);
      const v = m.width || m.videoWidth,
        r = m.height || m.videoHeight;
      var n = this._renderer.GetWebGLVersionNumber();
      const p = this._renderer.GetContext();
      p.bindTexture(p.TEXTURE_2D, this._texture);
      p.pixelStorei(p.UNPACK_PREMULTIPLY_ALPHA_WEBGL, q.premultiplyAlpha);
      p.pixelStorei(p.UNPACK_FLIP_Y_WEBGL, !!q.flipY);
      q = f(this._pixelFormat, p);
      n = 2 <= n ? q.sizedinternalformat : q.internalformat;
      try {
        if (this._width === v && this._height === r) {
          const u = e.isPOT(this._width) && e.isPOT(this._height);
          p.texSubImage2D(p.TEXTURE_2D, 0, 0, 0, q.format, q.type, m);
          (u || this._renderer.SupportsNPOTTextures()) &&
            this._isMipMapped &&
            (p.hint(p.GENERATE_MIPMAP_HINT, this._GetMipMapHint(p)),
            p.generateMipmap(p.TEXTURE_2D));
        } else {
          this._width = v;
          this._height = r;
          const u = e.isPOT(this._width) && e.isPOT(this._height);
          if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !u)
            throw Error("non-power-of-two tiled textures not supported");
          p.texImage2D(p.TEXTURE_2D, 0, n, q.format, q.type, m);
          (u || this._renderer.SupportsNPOTTextures()) &&
            this._isMipMapped &&
            (p.hint(p.GENERATE_MIPMAP_HINT, this._GetMipMapHint(p)),
            p.generateMipmap(p.TEXTURE_2D));
        }
      } catch (u) {
        console.error("Error updating WebGL texture: ", u);
      }
      p.bindTexture(p.TEXTURE_2D, null);
      this._renderer._ResetLastTexture();
    }
    _Delete() {
      if (0 < this._refCount) throw Error("texture still has references");
      if (!this._texture) throw Error("already deleted texture");
      k.delete(this);
      this._renderer.GetContext().deleteTexture(this._texture);
      this._texture = null;
    }
    IsValid() {
      return !!this._texture;
    }
    _GetTexture() {
      return this._texture;
    }
    GetRenderer() {
      return this._renderer;
    }
    AddReference() {
      this._refCount++;
    }
    SubtractReference() {
      if (0 >= this._refCount) throw Error("no more references");
      this._refCount--;
    }
    GetReferenceCount() {
      return this._refCount;
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    IsStatic() {
      return this._isStatic;
    }
    GetEstimatedMemoryUsage() {
      let m = this._width * this._height;
      switch (this._pixelFormat) {
        case "rgba8":
          m *= 4;
          break;
        case "rgb8":
          m *= 3;
          break;
        case "rgba4":
        case "rgb5_a1":
        case "rgb565":
          m *= 2;
      }
      this._isMipMapped && (m += Math.floor(m / 3));
      return m;
    }
    static OnContextLost() {
      k.clear();
    }
    static allTextures() {
      return k.values();
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.glMatrix.mat4,
    a = new Set(["nearest", "bilinear", "trilinear"]),
    c = {
      sampling: "trilinear",
      alpha: !0,
      depth: !1,
      isSampled: !0,
      isDefaultSize: !0,
      multisampling: 0,
    },
    d = new Set();
  e.Gfx.WebGLRenderTarget = class {
    constructor(f) {
      this._renderer = f;
      this._renderBuffer =
        this._texture =
        this._frameBufferNoDepth =
        this._frameBuffer =
          null;
      this._height = this._width = 0;
      this._isDefaultSize = !0;
      this._sampling = "trilinear";
      this._alpha = !0;
      this._depth = !1;
      this._isSampled = !0;
      this._multisampling = 0;
      this._projectionMatrix = b.create();
      this._lastFov = 0;
    }
    _Create(f, h, g) {
      g = Object.assign({}, c, g);
      const k = this._renderer.GetWebGLVersionNumber();
      if (this._texture || this._renderBuffer)
        throw Error("already created render target");
      this._sampling = g.sampling;
      this._alpha = !!g.alpha;
      this._depth = !!g.depth;
      this._isSampled = !!g.isSampled;
      this._isDefaultSize = !!g.isDefaultSize;
      this._multisampling = g.multisampling;
      if (!a.has(this._sampling)) throw Error("invalid sampling");
      if (0 < this._multisampling && (2 > k || this._isSampled))
        throw Error("invalid use of multisampling");
      2 > k && (this._isSampled = !0);
      this._width = f;
      this._height = h;
      if (0 >= this._width || 0 >= this._height)
        throw Error("invalid render target size");
      this._CalculateProjection();
      f = this._renderer.GetContext();
      this._frameBuffer = f.createFramebuffer();
      this._depth && (this._frameBufferNoDepth = f.createFramebuffer());
      this._isSampled
        ? ((this._texture = this._renderer.CreateDynamicTexture(
            this._width,
            this._height,
            {
              sampling: this._sampling,
              pixelFormat: this._alpha ? "rgba8" : "rgb8",
              mipMap: !1,
            }
          )),
          (h = this._texture._GetTexture()),
          f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer),
          f.framebufferTexture2D(
            f.FRAMEBUFFER,
            f.COLOR_ATTACHMENT0,
            f.TEXTURE_2D,
            h,
            0
          ),
          this._depth &&
            (f.bindFramebuffer(f.FRAMEBUFFER, this._frameBufferNoDepth),
            f.framebufferTexture2D(
              f.FRAMEBUFFER,
              f.COLOR_ATTACHMENT0,
              f.TEXTURE_2D,
              h,
              0
            )))
        : ((this._renderBuffer = f.createRenderbuffer()),
          f.bindRenderbuffer(f.RENDERBUFFER, this._renderBuffer),
          (h = this._alpha ? f.RGBA8 : f.RGB8),
          0 < this._multisampling &&
            ((g = f.getInternalformatParameter(f.RENDERBUFFER, h, f.SAMPLES)) &&
            g[0]
              ? ((g = g[0]),
                this._multisampling > g && (this._multisampling = g))
              : (this._multisampling = 0)),
          0 === this._multisampling
            ? f.renderbufferStorage(
                f.RENDERBUFFER,
                h,
                this._width,
                this._height
              )
            : f.renderbufferStorageMultisample(
                f.RENDERBUFFER,
                this._multisampling,
                h,
                this._width,
                this._height
              ),
          f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer),
          f.framebufferRenderbuffer(
            f.FRAMEBUFFER,
            f.COLOR_ATTACHMENT0,
            f.RENDERBUFFER,
            this._renderBuffer
          ),
          this._depth &&
            (f.bindFramebuffer(f.FRAMEBUFFER, this._frameBufferNoDepth),
            f.framebufferRenderbuffer(
              f.FRAMEBUFFER,
              f.COLOR_ATTACHMENT0,
              f.RENDERBUFFER,
              this._renderBuffer
            )),
          f.bindRenderbuffer(f.RENDERBUFFER, null));
      h = this._renderer._GetDepthBuffer();
      this._depth &&
        h &&
        (f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer),
        this._renderer._CanSampleDepth()
          ? f.framebufferTexture2D(
              f.FRAMEBUFFER,
              f.DEPTH_STENCIL_ATTACHMENT,
              f.TEXTURE_2D,
              h,
              0
            )
          : f.framebufferRenderbuffer(
              f.FRAMEBUFFER,
              f.DEPTH_STENCIL_ATTACHMENT,
              f.RENDERBUFFER,
              h
            ));
      f.bindFramebuffer(f.FRAMEBUFFER, null);
      d.add(this);
    }
    _Resize(f, h) {
      if (this._width !== f || this._height !== h)
        (this._width = f),
          (this._height = h),
          this._CalculateProjection(),
          (f = this._renderer.GetContext()),
          f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer),
          this._texture
            ? this._texture._Update(new ImageData(this._width, this._height))
            : (f.bindRenderbuffer(f.RENDERBUFFER, this._renderBuffer),
              f.renderbufferStorage(
                f.RENDERBUFFER,
                this._alpha ? f.RGBA8 : f.RGB8,
                this._width,
                this._height
              ),
              f.bindRenderbuffer(f.RENDERBUFFER, null)),
          (h = this._renderer._GetDepthBuffer()),
          this._depth &&
            h &&
            (this._renderer._CanSampleDepth()
              ? f.framebufferTexture2D(
                  f.FRAMEBUFFER,
                  f.DEPTH_STENCIL_ATTACHMENT,
                  f.TEXTURE_2D,
                  h,
                  0
                )
              : f.framebufferRenderbuffer(
                  f.FRAMEBUFFER,
                  f.DEPTH_STENCIL_ATTACHMENT,
                  f.RENDERBUFFER,
                  h
                )),
          f.bindFramebuffer(f.FRAMEBUFFER, null);
    }
    _Delete() {
      if (!this._texture && !this._renderBuffer)
        throw Error("already deleted render target");
      d.delete(this);
      var f = this._renderer.GetContext();
      this._texture
        ? (f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer),
          f.framebufferTexture2D(
            f.FRAMEBUFFER,
            f.COLOR_ATTACHMENT0,
            f.TEXTURE_2D,
            null,
            0
          ),
          this._depth &&
            (f.bindFramebuffer(f.FRAMEBUFFER, this._frameBufferNoDepth),
            f.framebufferTexture2D(
              f.FRAMEBUFFER,
              f.COLOR_ATTACHMENT0,
              f.TEXTURE_2D,
              null,
              0
            )),
          this._renderer.DeleteTexture(this._texture),
          (this._texture = null))
        : this._renderBuffer &&
          (f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer),
          f.framebufferRenderbuffer(
            f.FRAMEBUFFER,
            f.COLOR_ATTACHMENT0,
            f.RENDERBUFFER,
            null
          ),
          this._depth &&
            (f.bindFramebuffer(f.FRAMEBUFFER, this._frameBufferNoDepth),
            f.framebufferRenderbuffer(
              f.FRAMEBUFFER,
              f.COLOR_ATTACHMENT0,
              f.RENDERBUFFER,
              null
            )),
          f.deleteRenderbuffer(this._renderBuffer),
          (this._renderBuffer = null));
      f.bindFramebuffer(f.FRAMEBUFFER, null);
      2 <= this._renderer.GetWebGLVersionNumber() &&
        (f.bindFramebuffer(f.READ_FRAMEBUFFER, null),
        f.bindFramebuffer(f.DRAW_FRAMEBUFFER, null));
      f.deleteFramebuffer(this._frameBuffer);
      this._depth && f.deleteFramebuffer(this._frameBufferNoDepth);
      f = this._renderer.GetBatchState();
      f.currentFramebuffer = null;
      this._frameBuffer = f.currentFramebufferNoDepth = null;
    }
    _CalculateProjection() {
      this._renderer.CalculatePerspectiveMatrix(
        this._projectionMatrix,
        this._width / this._height
      );
      this._lastFov = this._renderer.GetFovY();
    }
    _GetFramebuffer() {
      return this._frameBuffer;
    }
    _GetFramebufferNoDepth() {
      return this._frameBufferNoDepth;
    }
    GetRenderer() {
      return this._renderer;
    }
    GetTexture() {
      return this._texture;
    }
    GetProjectionMatrix() {
      this._renderer.GetFovY() !== this._lastFov && this._CalculateProjection();
      return this._projectionMatrix;
    }
    IsLinearSampling() {
      return "nearest" !== this._sampling;
    }
    HasAlpha() {
      return this._alpha;
    }
    IsSampled() {
      return this._isSampled;
    }
    HasDepthBuffer() {
      return this._depth;
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    IsDefaultSize() {
      return this._isDefaultSize;
    }
    GetMultisampling() {
      return this._multisampling;
    }
    GetOptions() {
      const f = {
        sampling: this._sampling,
        alpha: this._alpha,
        isSampled: this._isSampled,
      };
      this._isDefaultSize ||
        ((f.width = this._width), (f.height = this._height));
      return f;
    }
    IsCompatibleWithOptions(f) {
      f = Object.assign({}, c, f);
      return ("nearest" !== f.sampling) !== this.IsLinearSampling() ||
        !!f.alpha !== this.HasAlpha() ||
        !!f.depth !== this.HasDepthBuffer() ||
        (2 <= this._renderer.GetWebGLVersionNumber() &&
          !!f.isSampled !== this.IsSampled())
        ? !1
        : "number" === typeof f.width || "number" === typeof f.height
        ? !this.IsDefaultSize() &&
          this.GetWidth() === f.width &&
          this.GetHeight() === f.height
        : this.IsDefaultSize();
    }
    _GetWebGLTexture() {
      return this._texture ? this._texture._GetTexture() : null;
    }
    GetEstimatedMemoryUsage() {
      return this._texture
        ? this._texture.GetEstimatedMemoryUsage()
        : this._width * this._height * (this._alpha ? 4 : 3);
    }
    static async DebugReadPixelsToBlob(f, h) {
      f = await f.ReadBackRenderTargetToImageData(h, !0);
      return await e.ImageDataToBlob(f);
    }
    static OnContextLost() {
      d.clear();
    }
    static allRenderTargets() {
      return d.values();
    }
    static ResizeAll(f, h) {
      for (const g of d) g.IsDefaultSize() && g._Resize(f, h);
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = new Set(
      "aPos aTex aPoints matP matMV samplerFront samplerBack samplerDepth destStart destEnd srcStart srcEnd srcOriginStart srcOriginEnd pixelSize seconds devicePixelRatio layerScale layerAngle layoutStart layoutEnd color color2_ pointTexStart pointTexEnd zElevation tileSize tileSpacing outlineThickness".split(
        " "
      )
    );
  e.Gfx.WebGLShaderProgram = class extends e.Gfx.ShaderProgramBase {
    static async Compile(a, c, d, f) {
      const h = a.GetContext(),
        g = h.createShader(h.FRAGMENT_SHADER);
      h.shaderSource(g, c);
      h.compileShader(g);
      c = h.createShader(h.VERTEX_SHADER);
      h.shaderSource(c, d);
      h.compileShader(c);
      const k = h.createProgram();
      h.attachShader(k, g);
      h.attachShader(k, c);
      h.bindAttribLocation(k, 0, "aPos");
      h.bindAttribLocation(k, 1, "aTex");
      h.bindAttribLocation(k, 2, "aPoints");
      h.linkProgram(k);
      const m = a._GetParallelShaderCompileExtension();
      m
        ? await a._WaitForObjectReady(() =>
            h.getProgramParameter(k, m.COMPLETION_STATUS_KHR)
          )
        : await e.Wait(5);
      if (!h.getShaderParameter(g, h.COMPILE_STATUS))
        throw (
          ((f = h.getShaderInfoLog(g)),
          h.deleteShader(g),
          h.deleteShader(c),
          h.deleteProgram(k),
          Error("Error compiling fragment shader: " + f))
        );
      if (!h.getShaderParameter(c, h.COMPILE_STATUS))
        throw (
          ((f = h.getShaderInfoLog(c)),
          h.deleteShader(g),
          h.deleteShader(c),
          h.deleteProgram(k),
          Error("Error compiling vertex shader: " + f))
        );
      if (!h.getProgramParameter(k, h.LINK_STATUS))
        throw (
          ((f = h.getProgramInfoLog(k)),
          h.deleteShader(g),
          h.deleteShader(c),
          h.deleteProgram(k),
          Error("Error linking shader program: " + f))
        );
      (a = e.FilterUnprintableChars(h.getProgramInfoLog(k) || "").trim()) &&
        !e.IsStringAllWhitespace(a) &&
        console.info(`[WebGL] Shader program '${f}' compilation log: `, a);
      h.deleteShader(g);
      h.deleteShader(c);
      return k;
    }
    static async Create(a, c, d, f) {
      d = await e.Gfx.WebGLShaderProgram.Compile(a, c.src, d, f);
      return new e.Gfx.WebGLShaderProgram(a, d, c, f);
    }
    constructor(a, c, d, f) {
      super(a, f, d);
      const h = a.GetContext();
      var g = a.GetBatchState();
      a.EndBatch();
      h.useProgram(c);
      this._gl = h;
      this._shaderProgram = c;
      this._isDeviceTransform = "<default-device-transform>" === f;
      f = h.getAttribLocation(c, "aPos");
      const k = h.getAttribLocation(c, "aTex");
      this._locAPoints = h.getAttribLocation(c, "aPoints");
      -1 !== f &&
        (h.bindBuffer(h.ARRAY_BUFFER, a._vertexBuffer),
        h.vertexAttribPointer(f, a.GetNumVertexComponents(), h.FLOAT, !1, 0, 0),
        h.enableVertexAttribArray(f));
      -1 !== k &&
        (h.bindBuffer(h.ARRAY_BUFFER, a._texcoordBuffer),
        h.vertexAttribPointer(k, 2, h.FLOAT, !1, 0, 0),
        h.enableVertexAttribArray(k));
      -1 !== this._locAPoints &&
        (h.bindBuffer(h.ARRAY_BUFFER, a._pointBuffer),
        h.vertexAttribPointer(this._locAPoints, 4, h.FLOAT, !1, 0, 0),
        h.enableVertexAttribArray(this._locAPoints));
      h.bindBuffer(h.ARRAY_BUFFER, null);
      this._uMatP = new e.Gfx.WebGLShaderUniform(this, "matP", "mat4");
      this._uMatMV = new e.Gfx.WebGLShaderUniform(this, "matMV", "mat4");
      this._uColor = new e.Gfx.WebGLShaderUniform(this, "color", "vec4");
      this._uSamplerFront = new e.Gfx.WebGLShaderUniform(
        this,
        "samplerFront",
        "sampler"
      );
      this._uPointTexStart = new e.Gfx.WebGLShaderUniform(
        this,
        "pointTexStart",
        "vec2"
      );
      this._uPointTexEnd = new e.Gfx.WebGLShaderUniform(
        this,
        "pointTexEnd",
        "vec2"
      );
      this._uZElevation = new e.Gfx.WebGLShaderUniform(
        this,
        "zElevation",
        "float"
      );
      this._uTileSize = new e.Gfx.WebGLShaderUniform(this, "tileSize", "vec2");
      this._uTileSpacing = new e.Gfx.WebGLShaderUniform(
        this,
        "tileSpacing",
        "vec2"
      );
      this._uColor2 = new e.Gfx.WebGLShaderUniform(this, "color2_", "vec4");
      this._uOutlineThickness = new e.Gfx.WebGLShaderUniform(
        this,
        "outlineThickness",
        "float"
      );
      this._uSamplerBack = new e.Gfx.WebGLShaderUniform(
        this,
        "samplerBack",
        "sampler"
      );
      this._uSamplerDepth = new e.Gfx.WebGLShaderUniform(
        this,
        "samplerDepth",
        "sampler"
      );
      this._uDestStart = new e.Gfx.WebGLShaderUniform(
        this,
        "destStart",
        "vec2"
      );
      this._uDestEnd = new e.Gfx.WebGLShaderUniform(this, "destEnd", "vec2");
      this._uSrcStart = new e.Gfx.WebGLShaderUniform(this, "srcStart", "vec2");
      this._uSrcEnd = new e.Gfx.WebGLShaderUniform(this, "srcEnd", "vec2");
      this._uSrcOriginStart = new e.Gfx.WebGLShaderUniform(
        this,
        "srcOriginStart",
        "vec2"
      );
      this._uSrcOriginEnd = new e.Gfx.WebGLShaderUniform(
        this,
        "srcOriginEnd",
        "vec2"
      );
      this._uPixelSize = new e.Gfx.WebGLShaderUniform(
        this,
        "pixelSize",
        "vec2"
      );
      this._uSeconds = new e.Gfx.WebGLShaderUniform(this, "seconds", "float");
      this._uDevicePixelRatio = new e.Gfx.WebGLShaderUniform(
        this,
        "devicePixelRatio",
        "float"
      );
      this._uLayerScale = new e.Gfx.WebGLShaderUniform(
        this,
        "layerScale",
        "float"
      );
      this._uLayerAngle = new e.Gfx.WebGLShaderUniform(
        this,
        "layerAngle",
        "float"
      );
      this._uLayoutStart = new e.Gfx.WebGLShaderUniform(
        this,
        "layoutStart",
        "vec2"
      );
      this._uLayoutEnd = new e.Gfx.WebGLShaderUniform(
        this,
        "layoutEnd",
        "vec2"
      );
      this._hasAnyOptionalUniforms = !!(
        this._uPixelSize.IsUsed() ||
        this._uSeconds.IsUsed() ||
        this._uSamplerBack.IsUsed() ||
        this._uDestStart.IsUsed() ||
        this._uDestEnd.IsUsed() ||
        this._uSrcStart.IsUsed() ||
        this._uSrcEnd.IsUsed() ||
        this._uSrcOriginStart.IsUsed() ||
        this._uSrcOriginEnd.IsUsed() ||
        this._uDevicePixelRatio.IsUsed() ||
        this._uLayerScale.IsUsed() ||
        this._uLayerAngle.IsUsed() ||
        this._uLayoutStart.IsUsed() ||
        this._uLayoutEnd.IsUsed()
      );
      a = d.parameters || [];
      this._uCustomParameters = [];
      this._usesAnySrcRectOrPixelSize =
        this._uPixelSize.IsUsed() ||
        this._uSrcStart.IsUsed() ||
        this._uSrcEnd.IsUsed() ||
        this._uSrcOriginStart.IsUsed() ||
        this._uSrcOriginEnd.IsUsed();
      this._hasCurrentMatMV = this._hasCurrentMatP = !1;
      this._uColor.Init4f(1, 1, 1, 1);
      this._uColor2.Init4f(1, 1, 1, 1);
      this._uSamplerFront.Init1i(0);
      this._uSamplerBack.Init1i(1);
      this._uSamplerDepth.Init1i(2);
      this._uPointTexStart.Init2f(0, 0);
      this._uPointTexEnd.Init2f(1, 1);
      this._uZElevation.Init1f(0);
      this._uTileSize.Init2f(0, 0);
      this._uTileSpacing.Init2f(0, 0);
      this._uDestStart.Init2f(0, 0);
      this._uDestEnd.Init2f(1, 1);
      this._uSrcStart.Init2f(0, 0);
      this._uSrcEnd.Init2f(0, 0);
      this._uSrcOriginStart.Init2f(0, 0);
      this._uSrcOriginEnd.Init2f(0, 0);
      this._uPixelSize.Init2f(0, 0);
      this._uDevicePixelRatio.Init1f(1);
      this._uLayerScale.Init1f(1);
      this._uLayerAngle.Init1f(0);
      this._uSeconds.Init1f(0);
      this._uLayoutStart.Init2f(0, 0);
      this._uLayoutEnd.Init2f(0, 0);
      this._uOutlineThickness.Init1f(1);
      for (const m of a)
        (a = m[2]),
          (c = new e.Gfx.WebGLShaderUniform(this, m[0], a)),
          "color" === a ? c.Init3f(0, 0, 0) : c.Init1f(0),
          this._uCustomParameters.push(c);
      this._isDeviceTransform
        ? this._UpdateDeviceTransformUniforms(g.currentMatP)
        : (this.UpdateMatP(g.currentMatP, !0),
          this.UpdateMatMV(g.currentMV, !0));
      g = g.currentShader;
      h.useProgram(g ? g._shaderProgram : null);
    }
    Release() {
      this._gl.deleteProgram(this._shaderProgram);
      this._shaderProgram = null;
      this._renderer._RemoveShaderProgram(this);
      this._gl = null;
      super.Release();
    }
    GetWebGLContext() {
      return this._gl;
    }
    GetShaderProgram() {
      return this._shaderProgram;
    }
    GetParameterCount() {
      return this._uCustomParameters.length;
    }
    GetParameterType(a) {
      return 0 > a || a >= this._uCustomParameters.length
        ? null
        : this._uCustomParameters[a].GetType();
    }
    AreCustomParametersAlreadySetInBatch(a) {
      for (let c = 0, d = a.length; c < d; ++c)
        if (!this._uCustomParameters[c].IsSetToCustomInBatch(a[c])) return !1;
      return !0;
    }
    SetCustomParametersInBatch(a) {
      for (let c = 0, d = a.length; c < d; ++c)
        this._uCustomParameters[c].SetBatchValueCustom(a[c]);
    }
    AreOptionalUniformsAlreadySetInBatch(a, c, d, f, h, g, k, m, q, v) {
      return this._uSamplerBack.IsUsed() ||
        (this._uPixelSize.IsUsed() &&
          !this._uPixelSize.IsSetTo2InBatch(h, g)) ||
        (this._uDestStart.IsUsed() &&
          !this._uDestStart.IsSetTo2InBatch(a.getLeft(), a.getTop())) ||
        (this._uDestEnd.IsUsed() &&
          !this._uDestEnd.IsSetTo2InBatch(a.getRight(), a.getBottom())) ||
        (this._uDevicePixelRatio.IsUsed() &&
          !this._uDevicePixelRatio.IsSetTo1InBatch(k)) ||
        (this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(m)) ||
        (this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(q)) ||
        (this._uSrcStart.IsUsed() &&
          !this._uSrcStart.IsSetTo2InBatch(c.getLeft(), c.getTop())) ||
        (this._uSrcEnd.IsUsed() &&
          !this._uSrcEnd.IsSetTo2InBatch(c.getRight(), c.getBottom())) ||
        (this._uSrcOriginStart.IsUsed() &&
          !this._uSrcOriginStart.IsSetTo2InBatch(d.getLeft(), d.getTop())) ||
        (this._uSrcOriginEnd.IsUsed() &&
          !this._uSrcOriginEnd.IsSetTo2InBatch(d.getRight(), d.getBottom())) ||
        (this._uLayoutStart.IsUsed() &&
          !this._uLayoutStart.IsSetTo2InBatch(f.getLeft(), f.getTop())) ||
        (this._uLayoutEnd.IsUsed() &&
          !this._uLayoutEnd.IsSetTo2InBatch(f.getTop(), f.getBottom())) ||
        (this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(v))
        ? !1
        : !0;
    }
    SetOptionalUniformsInBatch(a, c, d, f, h, g, k, m, q, v) {
      this._uSamplerBack.IsUsed() ||
        (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(h, g),
        this._uDestStart.IsUsed() &&
          this._uDestStart.SetBatch2(a.getLeft(), a.getTop()),
        this._uDestEnd.IsUsed() &&
          this._uDestEnd.SetBatch2(a.getRight(), a.getBottom()),
        this._uDevicePixelRatio.IsUsed() &&
          this._uDevicePixelRatio.SetBatch1(k),
        this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(m),
        this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(q),
        this._uSrcStart.IsUsed() &&
          this._uSrcStart.SetBatch2(c.getLeft(), c.getTop()),
        this._uSrcEnd.IsUsed() &&
          this._uSrcEnd.SetBatch2(c.getRight(), c.getBottom()),
        this._uSrcOriginStart.IsUsed() &&
          this._uSrcOriginStart.SetBatch2(d.getLeft(), d.getTop()),
        this._uSrcOriginEnd.IsUsed() &&
          this._uSrcOriginEnd.SetBatch2(d.getRight(), d.getBottom()),
        this._uLayoutStart.IsUsed() &&
          this._uLayoutStart.SetBatch2(f.getLeft(), f.getTop()),
        this._uLayoutEnd.IsUsed() &&
          this._uLayoutEnd.SetBatch2(f.getTop(), f.getBottom()),
        this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(v));
    }
    UpdateMatP(a, c) {
      (this._hasCurrentMatP && !c) ||
        this._isDeviceTransform ||
        (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(a),
        (this._hasCurrentMatP = !0));
    }
    SetMatPStale() {
      this._hasCurrentMatP = !1;
    }
    UpdateMatMV(a, c) {
      (this._hasCurrentMatMV && !c) ||
        this._isDeviceTransform ||
        (this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(a),
        (this._hasCurrentMatMV = !0));
    }
    SetMatMVStale() {
      this._hasCurrentMatMV = !1;
    }
    _UpdateDeviceTransformUniforms(a) {
      if (!this._isDeviceTransform) throw Error("not device transform shader");
      this._uMatP.UpdateMatrix4fv(a);
      a = this._renderer;
      const c = a.GetWidth() / 2,
        d = a.GetHeight() / 2;
      a = a.CalculateLookAtModelView2(
        c,
        d,
        a.GetDefaultCameraZ(a.GetHeight()),
        c,
        d,
        0,
        a.GetHeight()
      );
      this._uMatMV.UpdateMatrix4fv(a);
    }
    UpdateColor(a) {
      this._uColor.IsUsed() && this._uColor.Update4f(a[0], a[1], a[2], a[3]);
    }
    static GetReservedUniformNames() {
      return b;
    }
    static GetDefaultVertexShaderSource(a) {
      a = a ? "highmedp" : "mediump";
      return [
        "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nattribute highp vec3 aPos;",
        `attribute ${a} vec2 aTex;`,
        `varying ${a} vec2 vTex;`,
        "uniform highp mat4 matP;\nuniform highp mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPos, 1.0);\n\tvTex = aTex;\n}",
      ].join("\n");
    }
    static GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth() {
      return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, vTex) * color;\n}";
    }
    static GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT() {
      return "#extension GL_EXT_frag_depth : enable\nvarying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, vTex) * color;\n\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}";
    }
    static GetDefaultVertexShaderSource_WebGL2() {
      return "#version 300 es\nin highp vec3 aPos;\nin mediump vec2 aTex;\nout mediump vec2 vTex;\nuniform highp mat4 matP;\nuniform highp mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPos, 1.0);\n\tvTex = aTex;\n}";
    }
    static GetTextureFillFragmentShaderSource_WebGL2() {
      return "#version 300 es\nin mediump vec2 vTex;\nout lowp vec4 outColor;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\toutColor = texture(samplerFront, vTex) * color;\n\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}";
    }
    static GetTilemapFragmentShaderSource() {
      return "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying highmedp vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highmedp vec2 srcStart;\nuniform highmedp vec2 pixelSize;\nuniform highmedp vec2 tileSize;\nuniform highmedp vec2 tileSpacing;\nvoid main(void) {\n\thighmedp vec2 tile = floor(vTex);\n\thighmedp vec2 tex = fract(vTex);\n\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n}";
    }
    static GetPointVertexShaderSource(a) {
      return e.Gfx.WebGLShaderProgram.GetPointVertexShaderSource_WebGL1();
    }
    static GetPointFragmentShaderSource(a) {
      return e.Gfx.WebGLShaderProgram.GetPointFragmentShaderSource_WebGL1();
    }
    static GetPointVertexShaderSource_WebGL1() {
      return "attribute vec4 aPoints;\nvarying float pointOpacity;\nuniform float zElevation;\nuniform mat4 matP;\nuniform mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\n\tgl_PointSize = aPoints.z;\n\tpointOpacity = aPoints.w;\n}";
    }
    static GetPointFragmentShaderSource_WebGL1() {
      return "uniform lowp sampler2D samplerFront;\nvarying lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, mix(pointTexStart, pointTexEnd, gl_PointCoord)) * color * pointOpacity;\n}";
    }
    static GetColorFillFragmentShaderSource() {
      return "uniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = color;\n}";
    }
    static GetLinearGradientFillFragmentShaderSource() {
      return "precision lowp float;\nvarying mediump vec2 vTex;\nuniform vec4 color;\nuniform vec4 color2_;\nvec3 fromLinear(vec3 linearRGB)\n{\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvec3 toLinear(vec3 sRGB)\n{\n\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));\n\tvec3 lower = sRGB/vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvoid main(void) {\n\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);\n\tfloat a = mix(color.a, color2_.a, vTex.x);\n\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);\n}";
    }
    static GetSmoothLineFillFragmentShaderSource() {
      return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;\n\tgl_FragColor = color * f;\n}";
    }
    static GetHardEllipseFillFragmentShaderSource() {
      return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float f = step(diffSq.x + diffSq.y, 0.25);\n\tgl_FragColor = color * f;\n}";
    }
    static GetHardEllipseOutlineFragmentShaderSource() {
      return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump float innerF = step(distSq, 0.25);\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}";
    }
    static GetSmoothEllipseFillFragmentShaderSource() {
      return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);\n\tgl_FragColor = color * f;\n}";
    }
    static GetSmoothEllipseOutlineFragmentShaderSource() {
      return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 pxNorm = pixelSize * norm;\n\tmediump vec2 innerEdge1 = halfNorm - pxNorm;\n\tmediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;\n\tmediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);\n\tmediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;\n\tmediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;\n\tmediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);\n\tmediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;\n\tmediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}";
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.glMatrix.mat4,
    a = new Map([
      ["float", 1],
      ["percent", 1],
      ["sampler", 1],
      ["vec2", 2],
      ["vec3", 3],
      ["color", 3],
      ["vec4", 4],
      ["mat4", 16],
    ]);
  e.Gfx.WebGLShaderUniform = class {
    constructor(c, d, f) {
      if (!a.has(f)) throw Error("invalid uniform type");
      this._owner = c;
      this._gl = this._owner.GetWebGLContext();
      this._name = d;
      this._type = f;
      this._isColorType = "color" === this._type;
      this._location = this._gl.getUniformLocation(
        this._owner.GetShaderProgram(),
        d
      );
      this._isUsed = !!this._location;
      c = a.get(f);
      this._lastValue = new Float32Array(c);
      this._lastBatchValue = new Float32Array(c);
    }
    Release() {
      this._location = this._gl = this._owner = null;
    }
    IsUsed() {
      return this._isUsed;
    }
    GetType() {
      return this._type;
    }
    IsColorType() {
      return this._isColorType;
    }
    Init1f(c) {
      this.IsUsed() &&
        ((this._lastValue[0] = c),
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform1f(this._location, c));
    }
    Init1i(c) {
      this.IsUsed() &&
        ((this._lastValue[0] = c),
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform1i(this._location, c));
    }
    Init2f(c, d) {
      this.IsUsed() &&
        ((this._lastValue[0] = c),
        (this._lastValue[1] = d),
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform2f(this._location, c, d));
    }
    Init3f(c, d, f) {
      this.IsUsed() &&
        ((this._lastValue[0] = c),
        (this._lastValue[1] = d),
        (this._lastValue[2] = f),
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform3f(this._location, c, d, f));
    }
    Init4f(c, d, f, h) {
      this.IsUsed() &&
        ((this._lastValue[0] = c),
        (this._lastValue[1] = d),
        (this._lastValue[2] = f),
        (this._lastValue[3] = h),
        this._lastBatchValue.set(this._lastValue),
        this._gl.uniform4f(this._location, c, d, f, h));
    }
    Update1f(c) {
      c = Math.fround(c);
      const d = this._lastValue;
      d[0] !== c && ((d[0] = c), this._gl.uniform1f(this._location, c));
    }
    Update1i(c) {
      const d = this._lastValue;
      d[0] !== c && ((d[0] = c), this._gl.uniform1i(this._location, c));
    }
    Update2f(c, d) {
      c = Math.fround(c);
      d = Math.fround(d);
      const f = this._lastValue;
      if (f[0] !== c || f[1] !== d)
        (f[0] = c), (f[1] = d), this._gl.uniform2f(this._location, c, d);
    }
    Update3f(c, d, f) {
      c = Math.fround(c);
      d = Math.fround(d);
      f = Math.fround(f);
      const h = this._lastValue;
      if (h[0] !== c || h[1] !== d || h[2] !== f)
        (h[0] = c),
          (h[1] = d),
          (h[2] = f),
          this._gl.uniform3f(this._location, c, d, f);
    }
    Update4f(c, d, f, h) {
      c = Math.fround(c);
      d = Math.fround(d);
      f = Math.fround(f);
      h = Math.fround(h);
      const g = this._lastValue;
      if (g[0] !== c || g[1] !== d || g[2] !== f || g[3] !== h)
        (g[0] = c),
          (g[1] = d),
          (g[2] = f),
          (g[3] = h),
          this._gl.uniform4f(this._location, c, d, f, h);
    }
    UpdateMatrix4fv(c) {
      const d = this._lastValue;
      b.exactEquals(d, c) ||
        (e.typedArraySet16(d, c, 0),
        this._gl.uniformMatrix4fv(this._location, !1, c));
    }
    IsSetToCustomInBatch(c) {
      const d = this._lastBatchValue;
      return this.IsColorType()
        ? d[0] === Math.fround(c.getR()) &&
            d[1] === Math.fround(c.getG()) &&
            d[2] === Math.fround(c.getB())
        : d[0] === Math.fround(c);
    }
    SetBatchValueCustom(c) {
      const d = this._lastBatchValue;
      this.IsColorType()
        ? ((d[0] = c.getR()), (d[1] = c.getG()), (d[2] = c.getB()))
        : (d[0] = c);
    }
    IsSetTo1InBatch(c) {
      return this._lastBatchValue[0] === Math.fround(c);
    }
    IsSetTo2InBatch(c, d) {
      const f = this._lastBatchValue;
      return f[0] === Math.fround(c) && f[1] === Math.fround(d);
    }
    SetBatch1(c) {
      this._lastBatchValue[0] = c;
    }
    SetBatch2(c, d) {
      const f = this._lastBatchValue;
      f[0] = c;
      f[1] = d;
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.glMatrix,
    a = b.vec4,
    c = b.mat4;
  e.Gfx.BatchState = class {
    constructor(d) {
      this.renderer = d;
      this.currentMV = c.create();
      this.currentMatP = c.create();
      this.currentFramebufferNoDepth = this.currentFramebuffer = null;
      this.isDepthSamplingEnabled = !1;
      this.currentColor = a.fromValues(1, 1, 1, 1);
      this.currentShader = null;
      this.pointTexCoords = new e.Rect();
      this.clearColor = e.New(e.Color, 0, 0, 0, 0);
    }
  };
  e.Gfx.WebGLBatchJob = class {
    constructor(d) {
      const f = new ArrayBuffer(96);
      this._type = 0;
      this._batchState = d;
      this._gl = d.renderer.GetContext();
      this._indexCount = this._startIndex = 0;
      this._texParam = null;
      this._mat4param = new Float32Array(f, 0, 16);
      this._colorParam = new Float32Array(f, 64, 4);
      this._srcOriginRect = new Float32Array(f, 80, 4);
      this._shaderParams = [];
    }
    InitQuad(d, f) {
      this._type = 1;
      this._startIndex = d;
      this._indexCount = f;
    }
    DoQuad() {
      const d = this._gl;
      d.drawElements(
        d.TRIANGLES,
        this._indexCount,
        d.UNSIGNED_SHORT,
        this._startIndex
      );
    }
    InitSetTexture(d) {
      this._type = 2;
      this._texParam = d;
    }
    DoSetTexture() {
      const d = this._gl,
        f = this._texParam;
      d.bindTexture(d.TEXTURE_2D, f ? f._GetTexture() : null);
    }
    InitSetColor(d) {
      this._type = 3;
      d.writeToTypedArray(this._colorParam, 0);
    }
    DoSetColor() {
      const d = this._colorParam,
        f = this._batchState;
      a.copy(f.currentColor, d);
      f.currentShader.UpdateColor(d);
    }
    InitSetGradientColor(d) {
      this._type = 21;
      d.writeToTypedArray(this._colorParam, 0);
    }
    DoSetGradientColor() {
      const d = this._colorParam,
        f = this._batchState.currentShader;
      f._uColor2.IsUsed() && f._uColor2.Update4f(d[0], d[1], d[2], d[3]);
    }
    InitSetBlend(d, f) {
      this._type = 4;
      this._startIndex = d;
      this._indexCount = f;
    }
    DoSetBlend() {
      this._gl.blendFunc(this._startIndex, this._indexCount);
    }
    InitSetViewport(d, f, h, g) {
      this._type = 5;
      const k = this._colorParam;
      k[0] = d;
      k[1] = f;
      k[2] = h;
      k[3] = g;
    }
    DoSetViewport() {
      const d = this._colorParam;
      this._gl.viewport(d[0], d[1], d[2], d[3]);
    }
    InitSetProjection(d) {
      this._type = 6;
      c.copy(this._mat4param, d);
    }
    DoSetProjection() {
      const d = this._batchState,
        f = d.renderer._allShaderPrograms,
        h = d.currentShader,
        g = this._mat4param;
      for (let k = 0, m = f.length; k < m; ++k) {
        const q = f[k];
        q === h ? q.UpdateMatP(g, !0) : q.SetMatPStale();
      }
      c.copy(d.currentMatP, g);
    }
    InitSetModelView(d) {
      this._type = 7;
      c.copy(this._mat4param, d);
    }
    DoSetModelView() {
      const d = this._batchState,
        f = d.renderer._allShaderPrograms,
        h = d.currentShader,
        g = this._mat4param;
      for (let k = 0, m = f.length; k < m; ++k) {
        const q = f[k];
        q === h ? q.UpdateMatMV(g, !0) : q.SetMatMVStale();
      }
      c.copy(d.currentMV, g);
    }
    InitSetRenderTarget(d) {
      this._type = 8;
      this._texParam = d;
    }
    DoSetRenderTarget() {
      const d = this._gl,
        f = this._texParam,
        h = this._batchState;
      f
        ? ((h.currentFramebuffer = f._GetFramebuffer()),
          (h.currentFramebufferNoDepth = f._GetFramebufferNoDepth()),
          h.isDepthSamplingEnabled && h.currentFramebufferNoDepth
            ? d.bindFramebuffer(d.FRAMEBUFFER, h.currentFramebufferNoDepth)
            : d.bindFramebuffer(d.FRAMEBUFFER, h.currentFramebuffer))
        : ((h.currentFramebuffer = null),
          (h.currentFramebufferNoDepth = null),
          d.bindFramebuffer(d.FRAMEBUFFER, null));
    }
    InitClearSurface(d) {
      this._type = 9;
      d.writeToTypedArray(this._mat4param, 0);
    }
    InitClearSurface2(d, f, h, g) {
      this._type = 9;
      const k = this._mat4param;
      k[0] = d;
      k[1] = f;
      k[2] = h;
      k[3] = g;
    }
    DoClearSurface() {
      const d = this._gl;
      var f = this._mat4param;
      const h = this._batchState.clearColor,
        g = f[0],
        k = f[1],
        m = f[2];
      f = f[3];
      h.equalsRgba(g, k, m, f) ||
        (d.clearColor(g, k, m, f), h.setRgba(g, k, m, f));
      d.clear(d.COLOR_BUFFER_BIT);
    }
    InitSetPointTexCoords(d) {
      this._type = 15;
      d.writeToTypedArray(this._mat4param, 0);
    }
    DoSetPointTextureCoords() {
      const d = this._mat4param;
      this._batchState.pointTexCoords.set(d[0], d[1], d[2], d[3]);
    }
    InitPoints(d, f) {
      this._type = 10;
      this._startIndex = d;
      this._indexCount = 1;
      this._mat4param[0] = f;
    }
    DoPoints() {
      const d = this._gl,
        f = this._batchState,
        h = f.renderer._spPoints;
      d.useProgram(h._shaderProgram);
      h.UpdateMatP(f.currentMatP, !1);
      h.UpdateMatMV(f.currentMV, !1);
      var g = f.pointTexCoords;
      h._uPointTexStart.IsUsed() &&
        h._uPointTexStart.Update2f(g.getLeft(), g.getTop());
      h._uPointTexEnd.IsUsed() &&
        h._uPointTexEnd.Update2f(g.getRight(), g.getBottom());
      g = this._mat4param[0];
      h._uZElevation.IsUsed() && h._uZElevation.Update1f(g);
      h._uColor.IsUsed() &&
        ((g = f.currentColor), h._uColor.Update4f(g[0], g[1], g[2], g[3]));
      d.drawArrays(d.POINTS, this._startIndex / 4, this._indexCount);
      d.useProgram(f.currentShader._shaderProgram);
    }
    InitSetProgram(d) {
      this._type = 11;
      this._texParam = d;
    }
    DoSetProgram() {
      var d = this._gl;
      const f = this._batchState,
        h = this._texParam;
      f.currentShader = h;
      d.useProgram(h._shaderProgram);
      h.UpdateMatP(f.currentMatP, !1);
      h.UpdateMatMV(f.currentMV, !1);
      h._uColor.IsUsed() &&
        ((d = f.currentColor), h._uColor.Update4f(d[0], d[1], d[2], d[3]));
    }
    InitSetProgramParameters() {
      this._type = 12;
    }
    DoSetProgramParameters() {
      const d = this._batchState.currentShader,
        f = this._gl,
        h = this._mat4param,
        g = this._colorParam,
        k = this._srcOriginRect;
      if (d._uSamplerBack.IsUsed()) {
        const m = this._batchState.renderer,
          q = this._texParam;
        m._lastTexture1 !== q &&
          (f.activeTexture(f.TEXTURE1),
          f.bindTexture(f.TEXTURE_2D, q ? q._GetTexture() : null),
          (m._lastTexture1 = q),
          f.activeTexture(f.TEXTURE0));
      }
      d._uPixelSize.IsUsed() && d._uPixelSize.Update2f(h[0], h[1]);
      d._uDestStart.IsUsed() && d._uDestStart.Update2f(h[2], h[3]);
      d._uDestEnd.IsUsed() && d._uDestEnd.Update2f(h[4], h[5]);
      d._uDevicePixelRatio.IsUsed() &&
        d._uDevicePixelRatio.Update1f(this._indexCount);
      d._uLayerScale.IsUsed() && d._uLayerScale.Update1f(h[6]);
      d._uLayerAngle.IsUsed() && d._uLayerAngle.Update1f(h[7]);
      d._uSrcStart.IsUsed() && d._uSrcStart.Update2f(h[12], h[13]);
      d._uSrcEnd.IsUsed() && d._uSrcEnd.Update2f(h[14], h[15]);
      d._uSrcOriginStart.IsUsed() && d._uSrcOriginStart.Update2f(k[0], k[1]);
      d._uSrcOriginEnd.IsUsed() && d._uSrcOriginEnd.Update2f(k[2], k[3]);
      d._uLayoutStart.IsUsed() && d._uLayoutStart.Update2f(g[0], g[1]);
      d._uLayoutEnd.IsUsed() && d._uLayoutEnd.Update2f(g[2], g[3]);
      d._uSeconds.IsUsed() && d._uSeconds.Update1f(this._startIndex);
    }
    InitSetProgramCustomParameters() {
      this._type = 13;
    }
    DoSetProgramCustomParameters() {
      const d = this._batchState.currentShader._uCustomParameters,
        f = this._shaderParams;
      for (let h = 0, g = d.length; h < g; ++h) {
        const k = d[h],
          m = f[h];
        k.IsColorType()
          ? k.Update3f(m.getR(), m.getG(), m.getB())
          : k.Update1f(m);
      }
    }
    InitInvalidateFramebuffer(d) {
      this._type = 14;
      this._texParam = d;
    }
    DoInvalidateFramebuffer() {
      const d = this._gl,
        f = this._texParam,
        h = this._batchState.currentFramebuffer;
      f !== h && d.bindFramebuffer(d.FRAMEBUFFER, f);
      d.invalidateFramebuffer(d.FRAMEBUFFER, [d.COLOR_ATTACHMENT0]);
      f !== h && d.bindFramebuffer(d.FRAMEBUFFER, h);
    }
    InitBlitFramebuffer(d, f, h) {
      this._type = 17;
      const g = this._mat4param,
        k = this._batchState.renderer;
      g[0] = d.GetWidth();
      g[1] = d.GetHeight();
      g[2] = f ? f.GetWidth() : k.GetWidth();
      g[3] = f ? f.GetHeight() : k.GetHeight();
      g[4] = d.IsLinearSampling() ? 1 : 0;
      g[5] = "stretch" === h;
      h = this._shaderParams;
      e.clearArray(h);
      h.push(d._GetFramebuffer());
      h.push(f ? f._GetFramebuffer() : null);
    }
    DoBlitFramebuffer() {
      var d = this._mat4param,
        f = this._shaderParams;
      const h = this._gl;
      var g = d[0],
        k = d[1],
        m = d[2];
      const q = d[3],
        v = 0 !== d[4];
      d = 0 !== d[5];
      const r = f[1];
      h.bindFramebuffer(h.READ_FRAMEBUFFER, f[0]);
      h.bindFramebuffer(h.DRAW_FRAMEBUFFER, r);
      d
        ? h.blitFramebuffer(
            0,
            0,
            g,
            k,
            0,
            0,
            m,
            q,
            h.COLOR_BUFFER_BIT,
            v ? h.LINEAR : h.NEAREST
          )
        : ((f = Math.min(g, m)),
          (g = Math.min(k, q)),
          (m = Math.max(k - q, 0)),
          (k = Math.max(q - k, 0)),
          h.blitFramebuffer(
            0,
            m,
            f,
            g + m,
            0,
            k,
            f,
            g + k,
            h.COLOR_BUFFER_BIT,
            h.NEAREST
          ));
    }
    InitStartQuery(d) {
      this._type = 18;
      this._texParam = d;
    }
    DoStartQuery() {
      this._texParam.BeginTimeElapsed();
      this._texParam = null;
    }
    InitEndQuery(d) {
      this._type = 19;
      this._texParam = d;
    }
    DoEndQuery() {
      this._texParam.EndTimeElapsed();
      this._texParam = null;
    }
    InitSetEllipseParams(d, f, h) {
      this._type = 20;
      const g = this._mat4param;
      g[0] = d;
      g[1] = f;
      g[2] = h;
    }
    DoSetEllipseParams() {
      const d = this._batchState.currentShader,
        f = this._mat4param;
      d._uPixelSize.IsUsed() && d._uPixelSize.Update2f(f[0], f[1]);
      d._uOutlineThickness.IsUsed() && d._uOutlineThickness.Update1f(f[2]);
    }
    InitSetTilemapInfo(d, f, h, g, k, m, q) {
      this._type = 16;
      const v = this._mat4param;
      d.writeToTypedArray(v, 0);
      v[4] = 1 / f;
      v[5] = 1 / h;
      v[6] = g / f;
      v[7] = k / h;
      v[8] = m / f;
      v[9] = q / h;
    }
    DoSetTilemapInfo() {
      const d = this._batchState.currentShader,
        f = this._mat4param;
      d._uSrcStart.IsUsed() && d._uSrcStart.Update2f(f[0], f[1]);
      d._uPixelSize.IsUsed() && d._uPixelSize.Update2f(f[4], f[5]);
      d._uTileSize.IsUsed() && d._uTileSize.Update2f(f[6], f[7]);
      d._uTileSpacing.IsUsed() && d._uTileSpacing.Update2f(f[8], f[9]);
    }
    InitClearDepth(d) {
      this._type = 22;
      this._startIndex = d ? 1 : 0;
    }
    DoClearDepth() {
      const d = this._gl,
        f = 0 !== this._startIndex;
      f || d.depthMask(!0);
      d.clear(d.DEPTH_BUFFER_BIT);
      f || d.depthMask(!1);
    }
    InitSetDepthEnabled(d) {
      this._type = 23;
      this._startIndex = d ? 1 : 0;
    }
    DoSetDepthEnabled() {
      const d = this._gl;
      0 === this._startIndex
        ? (d.disable(d.DEPTH_TEST), d.depthMask(!1))
        : (d.enable(d.DEPTH_TEST), d.depthMask(!0));
    }
    InitSetDepthSamplingEnabled(d) {
      this._type = 24;
      this._startIndex = d ? 1 : 0;
    }
    DoSetDepthSamplingEnabled() {
      const d = this._gl,
        f = this._batchState,
        h = f.renderer,
        g = 0 !== this._startIndex;
      f.isDepthSamplingEnabled = g;
      d.activeTexture(d.TEXTURE2);
      g
        ? (f.currentFramebufferNoDepth &&
            d.bindFramebuffer(d.FRAMEBUFFER, f.currentFramebufferNoDepth),
          d.bindTexture(d.TEXTURE_2D, h._GetDepthBuffer()))
        : (d.bindTexture(d.TEXTURE_2D, null),
          f.currentFramebufferNoDepth &&
            d.bindFramebuffer(d.FRAMEBUFFER, f.currentFramebuffer));
      d.activeTexture(d.TEXTURE0);
    }
    InitCoplanarStartStencilPass() {
      this._type = 25;
    }
    DoCoplanarStartStencilPass() {
      const d = this._gl;
      d.clear(d.STENCIL_BUFFER_BIT);
      d.enable(d.STENCIL_TEST);
      d.stencilFunc(d.ALWAYS, 1, 1);
      d.stencilOp(d.KEEP, d.KEEP, d.REPLACE);
      d.colorMask(!1, !1, !1, !1);
    }
    InitCoplanarStartColorPass() {
      this._type = 26;
    }
    DoCoplanarStartColorPass() {
      const d = this._gl;
      d.colorMask(!0, !0, !0, !0);
      d.stencilFunc(d.EQUAL, 1, 1);
      d.stencilOp(d.KEEP, d.KEEP, d.KEEP);
    }
    InitCoplanarRestore() {
      this._type = 27;
    }
    DoCoplanarRestore() {
      const d = this._gl;
      d.disable(d.STENCIL_TEST);
    }
    InitSetScissor(d, f, h, g, k) {
      this._type = 28;
      this._startIndex = d ? 1 : 0;
      d = this._mat4param;
      d[0] = f;
      d[1] = h;
      d[2] = g;
      d[3] = k;
    }
    DoSetScissor() {
      const d = this._gl,
        f = this._mat4param;
      1 === this._startIndex
        ? (d.enable(d.SCISSOR_TEST), d.scissor(f[0], f[1], f[2], f[3]))
        : d.disable(d.SCISSOR_TEST);
    }
    Run() {
      switch (this._type) {
        case 1:
          this.DoQuad();
          break;
        case 2:
          this.DoSetTexture();
          break;
        case 3:
          this.DoSetColor();
          break;
        case 4:
          this.DoSetBlend();
          break;
        case 5:
          this.DoSetViewport();
          break;
        case 6:
          this.DoSetProjection();
          break;
        case 7:
          this.DoSetModelView();
          break;
        case 8:
          this.DoSetRenderTarget();
          break;
        case 9:
          this.DoClearSurface();
          break;
        case 10:
          this.DoPoints();
          break;
        case 11:
          this.DoSetProgram();
          break;
        case 12:
          this.DoSetProgramParameters();
          break;
        case 13:
          this.DoSetProgramCustomParameters();
          break;
        case 14:
          this.DoInvalidateFramebuffer();
          break;
        case 15:
          this.DoSetPointTextureCoords();
          break;
        case 16:
          this.DoSetTilemapInfo();
          break;
        case 17:
          this.DoBlitFramebuffer();
          break;
        case 18:
          this.DoStartQuery();
          break;
        case 19:
          this.DoEndQuery();
          break;
        case 20:
          this.DoSetEllipseParams();
          break;
        case 21:
          this.DoSetGradientColor();
          break;
        case 22:
          this.DoClearDepth();
          break;
        case 23:
          this.DoSetDepthEnabled();
          break;
        case 24:
          this.DoSetDepthSamplingEnabled();
          break;
        case 25:
          this.DoCoplanarStartStencilPass();
          break;
        case 26:
          this.DoCoplanarStartColorPass();
          break;
        case 27:
          this.DoCoplanarRestore();
          break;
        case 28:
          this.DoSetScissor();
      }
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = new Set(
      "serif sans-serif monospace cursive fantasy system-ui ui-serif ui-sans-serif ui-monospace ui-rounded math emoji fangsong".split(
        " "
      )
    ),
    a = { timeout: 60 },
    c = new e.Color(0, 0, 0, 1),
    d = new Set(["left", "center", "right"]),
    f = new Set(["top", "center", "bottom"]),
    h = new Set(["word", "character"]),
    g = new Set();
  e.FontManager &&
    e.FontManager.addEventListener("fontload", (n) => {
      n = n.font.GetName();
      for (const p of g)
        (p.IsBBCodeEnabled() || e.equalsNoCase(p.GetFontName(), n)) &&
          p._SetTextChanged();
    });
  function k(n, p, u, w, y, B) {
    p
      ? "Gecko" === e.Platform.BrowserEngine
        ? n.strokeText(u, w, y, B)
        : n.strokeText(u, w, y)
      : "Gecko" === e.Platform.BrowserEngine
      ? n.fillText(u, w, y, B)
      : n.fillText(u, w, y);
  }
  function m(n, p, u, w, y, B) {
    p ? n.strokeRect(u, w, y, B) : n.fillRect(u, w, y, B);
  }
  function q(n) {
    return (4 / 3) * n;
  }
  let v = !1,
    r = !1;
  e.Gfx.RendererText = class {
    constructor(n, p) {
      p = Object.assign({}, a, p);
      this._renderer = n;
      this._fontName = "Arial";
      this._fontSize = 16;
      this._fontSizeScale = 1;
      this._lineHeight = 0;
      this._isItalic = this._isBold = !1;
      this._colorStr = "black";
      this._isBBcodeEnabled = !1;
      this.onloadfont = null;
      this._alreadyLoadedFonts = new Set();
      this._horizontalAlign = "left";
      this._verticalAlign = "top";
      this._text = "";
      this._bbString = null;
      this._wrappedText = e.New(e.WordWrap);
      this._wrapMode = "word";
      this._isUpdating = this._textChanged = !1;
      this._isAsync = !0;
      this._drawMaxCharCount = -1;
      this._height =
        this._width =
        this._cssHeight =
        this._cssWidth =
        this._drawCharCount =
          0;
      this._zoom = 1;
      this._changed = !1;
      this._measureContextTop =
        this._measureContext =
        this._textContext =
        this._textCanvas =
          null;
      this._lastCanvasHeight = this._lastCanvasWidth = -1;
      this._lastTextCanvasFillStyle =
        this._lastMeasureCanvasFont =
        this._lastTextCanvasFont =
          "";
      this._lastTextCanvasLineWidth = this._lastTextCanvasOpacity = 1;
      this._measureTextCallback = (u, w) => this._MeasureText(u, w);
      this._texture = null;
      this._textureHeight = this._textureWidth = 0;
      this._rcTex = new e.Rect();
      this._scaleFactor = 1;
      this._needToRecreateTexture = !1;
      this._textureTimeout = new e.IdleTimeout(() => {
        this.ReleaseTexture();
        this._SetTextCanvasSize(8, 8);
      }, p.timeout);
      this.ontextureupdate = null;
      this._wasReleased = !1;
      g.add(this);
    }
    Release() {
      this.onloadfont = null;
      this._alreadyLoadedFonts.clear();
      this._measureTextCallback =
        this._measureContextTop =
        this._measureContext =
        this._textContext =
        this._textCanvas =
        this._bbString =
          null;
      this._textureTimeout.Release();
      this.ontextureupdate = null;
      this.ReleaseTexture();
      this._wrappedText.Clear();
      this._renderer = this._wrappedText = null;
      this._wasReleased = !0;
      g.delete(this);
    }
    _SetChanged() {
      this._changed = !0;
    }
    _SetTextChanged() {
      this._SetChanged();
      this._wrappedText.Clear();
      this._textChanged = !0;
    }
    SetIsAsync(n) {
      this._isAsync = !!n;
    }
    IsAsync() {
      return this._isAsync;
    }
    SetBBCodeEnabled(n) {
      n = !!n;
      this._isBBcodeEnabled !== n &&
        ((n = (this._isBBcodeEnabled = n) ? "alphabetic" : "top"),
        this._textContext && (this._textContext.textBaseline = n),
        this._measureContext && (this._measureContext.textBaseline = n),
        this._SetTextChanged());
    }
    IsBBCodeEnabled() {
      return this._isBBcodeEnabled;
    }
    SetFontName(n) {
      n || (n = "serif");
      this._fontName !== n && ((this._fontName = n), this._SetTextChanged());
    }
    GetFontName() {
      return this._fontName;
    }
    SetFontSize(n) {
      0.1 > n && (n = 0.1);
      this._fontSize !== n && ((this._fontSize = n), this._SetTextChanged());
    }
    SetFontSizeScale(n) {
      this._fontSizeScale !== n &&
        ((this._fontSizeScale = n), this._SetTextChanged());
    }
    SetLineHeight(n) {
      this._lineHeight !== n && ((this._lineHeight = n), this._SetChanged());
    }
    SetBold(n) {
      n = !!n;
      this._isBold !== n && ((this._isBold = n), this._SetTextChanged());
    }
    SetItalic(n) {
      n = !!n;
      this._isItalic !== n && ((this._isItalic = n), this._SetTextChanged());
    }
    SetDrawMaxCharacterCount(n) {
      n = Math.floor(n);
      this._drawMaxCharCount !== n &&
        ((this._drawMaxCharCount = n), this._SetChanged());
    }
    GetDrawMaxCharacterCount() {
      return this._drawMaxCharCount;
    }
    _GetStyleTag(n, p) {
      for (let u = n.length - 1; 0 <= u; --u) {
        const w = n[u];
        if (w.tag === p) return w;
      }
      return null;
    }
    _HasStyleTag(n, p) {
      return !!this._GetStyleTag(n, p);
    }
    _GetFontString(n, p) {
      let u = [];
      (this._isBold || this._HasStyleTag(p, "b")) && u.push("bold");
      (this._isItalic || this._HasStyleTag(p, "i")) && u.push("italic");
      var w = this._GetStyleTag(p, "size");
      w = (w ? parseFloat(w.param) : this._fontSize) * this._fontSizeScale;
      n
        ? u.push(w + "pt")
        : u.push(
            w * this._scaleFactor * this._zoom * self.devicePixelRatio + "pt"
          );
      n = this._fontName;
      (p = this._GetStyleTag(p, "font")) &&
        p.param &&
        ((n = p.param),
        this.onloadfont &&
          !this._alreadyLoadedFonts.has(n) &&
          (this.onloadfont(n), this._alreadyLoadedFonts.add(n)));
      n && (b.has(n) ? u.push(n) : u.push('"' + n + '"'));
      return u.join(" ");
    }
    SetColor(n) {
      n instanceof e.Color && (n = n.getCssRgb());
      this._colorStr !== n && ((this._colorStr = n), this._SetChanged());
    }
    SetColorRgb(n, p, u) {
      c.setRgb(n, p, u);
      this.SetColor(c);
    }
    SetHorizontalAlignment(n) {
      if (!d.has(n)) throw Error("invalid horizontal alignment");
      this._horizontalAlign !== n &&
        ((this._horizontalAlign = n), this._SetChanged());
    }
    SetVerticalAlignment(n) {
      if (!f.has(n)) throw Error("invalid vertical alignment");
      this._verticalAlign !== n &&
        ((this._verticalAlign = n), this._SetChanged());
    }
    SetWordWrapMode(n) {
      if (!h.has(n)) throw Error("invalid word wrap mode");
      this._wrapMode !== n && ((this._wrapMode = n), this._SetTextChanged());
    }
    SetText(n) {
      this._text !== n && ((this._text = n), this._SetTextChanged());
    }
    SetSize(n, p, u) {
      "undefined" === typeof u && (u = 1);
      if (
        !(
          0 >= n ||
          0 >= n ||
          (this._cssWidth === n && this._cssHeight === p && this._zoom === u)
        )
      ) {
        (1 === this._zoom) !== (1 === u) && (this._needToRecreateTexture = !0);
        var w = this._cssWidth,
          y = this._zoom;
        this._cssWidth = n;
        this._cssHeight = p;
        this._zoom = u;
        n = self.devicePixelRatio;
        this._width = this._cssWidth * this._zoom * n;
        this._height = this._cssHeight * this._zoom * n;
        n = Math.max(this._width, this._height);
        p = Math.min(this._renderer.GetMaxTextureSize(), 4096);
        u = 1;
        n > p &&
          ((u = p / n),
          (this._width = Math.min(this._width * u, p)),
          (this._height = Math.min(this._height * u, p)));
        this._scaleFactor = u;
        0 < this._textureWidth &&
          0 < this._textureHeight &&
          this._zoom === y &&
          this._rcTex.set(
            0,
            0,
            this._width / this._textureWidth,
            this._height / this._textureHeight
          );
        this._cssWidth !== w ? this._SetTextChanged() : this._SetChanged();
      }
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    GetTextWidth() {
      this._MaybeWrapText();
      return this._wrappedText.GetMaxLineWidth();
    }
    GetTextHeight() {
      this._MaybeWrapText();
      return (
        this._wrappedText.GetTotalLineHeight() +
        this._wrappedText.GetLineCount() * (this._lineHeight + 4) -
        this._lineHeight
      );
    }
    GetTexture() {
      this._textureTimeout.Reset();
      this._MaybeUpdate();
      return this._texture;
    }
    _MaybeUpdate() {
      (this._texture && !this._changed && !this._textChanged) ||
        this._isUpdating ||
        0 >= this._width ||
        0 >= this._height ||
        ((this._changed = !1),
        (this._isUpdating = !0),
        this._isAsync ? e.Asyncify(() => this._DoUpdate()) : this._DoUpdate());
    }
    _DoUpdate() {
      this._wasReleased ||
        (this._SetTextCanvasSize(
          Math.ceil(this._width),
          Math.ceil(this._height)
        ),
        this._MaybeWrapText(),
        this._DrawTextToCanvas(),
        this._UpdateTexture(),
        this._textureTimeout.Reset(),
        (this._isUpdating = !1));
    }
    _SetTextCanvasSize(n, p) {
      this._textCanvas || (this._textCanvas = e.CreateCanvas(16, 16));
      let u = !1;
      if (this._lastCanvasWidth !== n || this._lastCanvasHeight !== p)
        (this._lastCanvasWidth = n),
          (this._lastCanvasHeight = p),
          (this._textCanvas.width = n),
          (this._textCanvas.height = p),
          (u = !0);
      this._textContext ||
        ((this._textContext = this._textCanvas.getContext("2d")), (u = !0));
      u
        ? ((this._textContext.textBaseline = this._isBBcodeEnabled
            ? "alphabetic"
            : "top"),
          (this._textContext.font = this._lastTextCanvasFont),
          (this._textContext.fillStyle = this._lastTextCanvasFillStyle),
          (this._textContext.strokeStyle = this._lastTextCanvasFillStyle),
          (this._textContext.globalAlpha = this._lastTextCanvasOpacity),
          (this._textContext.lineWidth = this._lastTextCanvasLineWidth))
        : this._textContext.clearRect(0, 0, n, p);
    }
    _MaybeCreateMeasureContext() {
      this._measureContext ||
        ((this._measureContext = e.CreateCanvas(16, 16).getContext("2d")),
        (this._measureContextTop = e.CreateCanvas(16, 16).getContext("2d")),
        (this._measureContext.textBaseline = this._isBBcodeEnabled
          ? "alphabetic"
          : "top"),
        (this._measureContextTop.textBaseline = "top"));
    }
    _SetMeasureFontString(n) {
      this._lastMeasureCanvasFont !== n &&
        ((this._lastMeasureCanvasFont = n),
        (this._measureContext.font = n),
        (this._measureContextTop.font = n));
    }
    _SupportsFontBoundingBoxMeasurements() {
      if (!v) {
        v = !0;
        this._MaybeCreateMeasureContext();
        const n = this._measureContext.measureText("test");
        r =
          "number" === typeof n.fontBoundingBoxAscent &&
          "number" === typeof n.fontBoundingBoxDescent;
      }
      return r;
    }
    _MaybeWrapText() {
      this._textChanged &&
        (this._MaybeCreateMeasureContext(),
        !this._isBBcodeEnabled ||
          (this._bbString && this._bbString.toString() === this._text) ||
          (this._bbString = new e.BBString(this._text, { noEscape: !0 })),
        this._wrappedText.WordWrap(
          this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text,
          this._measureTextCallback,
          this._cssWidth,
          this._wrapMode,
          0
        ),
        (this._textChanged = !1));
    }
    _MeasureText(n, p) {
      this._SetMeasureFontString(this._GetFontString(!0, p));
      p = this._GetStyleTag(p, "size");
      p = (p ? parseFloat(p.param) : this._fontSize) * this._fontSizeScale;
      const u = this._measureContext.measureText(n);
      let w = 0;
      this._isBBcodeEnabled &&
        this._SupportsFontBoundingBoxMeasurements() &&
        ((n = this._measureContextTop.measureText(n)),
        (w = u.fontBoundingBoxAscent - n.fontBoundingBoxAscent));
      return {
        width: u.width,
        height: q(p),
        fontBoundingBoxAscent: u.fontBoundingBoxAscent || 0,
        fontBoundingBoxDescent: u.fontBoundingBoxDescent || 0,
        topToAlphabeticDistance: w,
      };
    }
    _SetDrawFontString(n) {
      this._lastTextCanvasFont !== n &&
        ((this._lastTextCanvasFont = n), (this._textContext.font = n));
    }
    _SetDrawCanvasColor(n) {
      this._lastTextCanvasFillStyle !== n &&
        ((this._lastTextCanvasFillStyle = n),
        (this._textContext.fillStyle = n),
        (this._textContext.strokeStyle = n));
    }
    _SetDrawCanvasOpacity(n) {
      this._lastTextCanvasOpacity !== n &&
        ((this._lastTextCanvasOpacity = n),
        (this._textContext.globalAlpha = n));
    }
    _SetDrawCanvasLineWith(n) {
      this._lastTextCanvasLineWidth !== n &&
        ((this._lastTextCanvasLineWidth = n),
        (this._textContext.lineWidth = n));
    }
    _DrawTextToCanvas() {
      this._drawCharCount = 0;
      const n = this._scaleFactor * this._zoom * self.devicePixelRatio,
        p = (4 + this._lineHeight) * n;
      var u = 0;
      const w = this._wrappedText.GetLines();
      if (0 !== w.length) {
        var y =
            this._isBBcodeEnabled &&
            this._SupportsFontBoundingBoxMeasurements(),
          B = w[0].height * n;
        "center" === this._verticalAlign
          ? ((u = w.reduce((E, z) => E + z.height * n + p, 0) - p),
            (u = Math.max(this._height / 2 - u / 2, 0)),
            y && (B = w[0].topToAlphabeticDistance * n))
          : "bottom" === this._verticalAlign &&
            ((u =
              w.reduce((E, z) => E + z.height * n + p, 0) -
              this._lineHeight * n),
            (y = y ? w.at(-1).fontBoundingBoxDescent * n : 0),
            (u = this._height - u - y - 2));
        for (let E = 0, z = w.length; E < z; ++E) {
          y = w[E];
          const D = y.height * n,
            J = u;
          if (this._isBBcodeEnabled) {
            if (((u += 0 === E ? B : D), 0 < E && u > this._height - 4 * n))
              break;
          } else if (0 < E && u >= this._height - D) break;
          0 <= J && this._DrawTextLine(y, u, n);
          this._isBBcodeEnabled || (u += D);
          u += p;
        }
      }
    }
    _DrawTextLine(n, p, u) {
      let w = 0;
      "center" === this._horizontalAlign
        ? (w = (this._width - n.width * u) / 2)
        : "right" === this._horizontalAlign && (w = this._width - n.width * u);
      for (const y of n.fragments)
        this._DrawTextFragment(y, w, p, u, n.height), (w += y.width * u);
    }
    _DrawTextFragment(n, p, u, w, y) {
      const B = this._textContext,
        E = y / 16;
      y = n.width * w;
      const z = n.height * w,
        D = n.height / 16;
      var J = (4 + this._lineHeight) * w,
        C = n.styles;
      n = n.text;
      if (-1 !== this._drawMaxCharCount) {
        if (this._drawCharCount >= this._drawMaxCharCount) return;
        this._drawCharCount + n.length > this._drawMaxCharCount &&
          ((n = n.substr(0, this._drawMaxCharCount - this._drawCharCount)),
          (y = this._MeasureText(n, C).width * w));
        this._drawCharCount += n.length;
      }
      var H = this._GetStyleTag(C, "background");
      const K = this._HasStyleTag(C, "u"),
        P = this._HasStyleTag(C, "s");
      if (
        (!e.IsStringAllWhitespace(n) || H || K || P) &&
        !this._HasStyleTag(C, "hide")
      ) {
        var S = this._GetStyleTag(C, "offsetx");
        p += S ? parseFloat(S.param) * w : 0;
        S = this._GetStyleTag(C, "offsety");
        u += S ? parseFloat(S.param) * w : 0;
        H &&
          (this._SetDrawCanvasColor(H.param), B.fillRect(p, u - z, y, z + J));
        J = this._GetStyleTag(C, "color");
        this._SetDrawCanvasColor(J ? J.param : this._colorStr);
        H = this._GetStyleTag(C, "opacity");
        this._SetDrawCanvasOpacity(H ? parseFloat(H.param) / 100 : 1);
        H = (H = this._GetStyleTag(C, "linethickness"))
          ? parseFloat(H.param)
          : 1;
        (S = this._HasStyleTag(C, "stroke")) &&
          this._SetDrawCanvasLineWith(
            0.5 * D * H * this._scaleFactor * this._zoom * self.devicePixelRatio
          );
        this._SetDrawFontString(this._GetFontString(!1, C));
        k(B, S, n, p, u, y);
        !S &&
          (this._SetDrawCanvasLineWith(
            0.5 * D * H * this._scaleFactor * this._zoom * self.devicePixelRatio
          ),
          (C = this._GetStyleTag(C, "outline"))) &&
          (this._SetDrawCanvasColor(C.param), k(B, !0, n, p, u, y));
        this._SetDrawCanvasColor(J ? J.param : this._colorStr);
        K && m(B, S, p, u + w * E, y, w * E * H);
        P &&
          ((w *= D), B.fillRect(p, u - z / 4 + w / 2 - (w * H) / 2, y, w * H));
      }
    }
    _UpdateTexture() {
      if (
        !this._renderer.IsContextLost() &&
        ((this._textureWidth = Math.ceil(this._width)),
        (this._textureHeight = Math.ceil(this._height)),
        this._rcTex.set(
          0,
          0,
          this._width / this._textureWidth,
          this._height / this._textureHeight
        ),
        this._needToRecreateTexture &&
          (this.ReleaseTexture(), (this._needToRecreateTexture = !1)),
        this._texture ||
          (this._texture = this._renderer.CreateDynamicTexture(
            this._textureWidth,
            this._textureHeight,
            { mipMap: 1 === this._zoom, mipMapQuality: "high" }
          )),
        this._renderer.UpdateTexture(this._textCanvas, this._texture),
        this.ontextureupdate)
      )
        this.ontextureupdate();
    }
    GetTexRect() {
      return this._rcTex;
    }
    ReleaseTexture() {
      this._texture &&
        (this._renderer.IsContextLost() ||
          this._renderer.DeleteTexture(this._texture),
        (this._texture = null));
    }
    static OnContextLost() {
      for (const n of g) n.ReleaseTexture();
    }
    static GetAll() {
      return g.values();
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  class b {
    constructor(a) {
      this._gl = a.GetContext();
      this._version = a.GetWebGLVersionNumber();
      this._timerExt = a._GetDisjointTimerQueryExtension();
      this._query = null;
      this._hasResult = this._isActive = !1;
      this._result = 0;
      this._query =
        1 === this._version
          ? this._timerExt.createQueryEXT()
          : this._gl.createQuery();
    }
    Release() {
      this._DeleteQueryObject();
      this._timerExt = this._gl = null;
      this._hasResult = !1;
    }
    _DeleteQueryObject() {
      this._query &&
        (1 === this._version
          ? this._timerExt.deleteQueryEXT(this._query)
          : this._gl.deleteQuery(this._query),
        (this._query = null));
    }
    BeginTimeElapsed() {
      if (this._isActive) throw Error("query already active");
      1 === this._version
        ? this._timerExt.beginQueryEXT(
            this._timerExt.TIME_ELAPSED_EXT,
            this._query
          )
        : this._gl.beginQuery(this._timerExt.TIME_ELAPSED_EXT, this._query);
      this._isActive = !0;
    }
    EndTimeElapsed() {
      if (!this._isActive) throw Error("query not active");
      1 === this._version
        ? this._timerExt.endQueryEXT(this._timerExt.TIME_ELAPSED_EXT)
        : this._gl.endQuery(this._timerExt.TIME_ELAPSED_EXT);
      this._isActive = !1;
    }
    CheckForResult() {
      if (this._query && !this._hasResult && !this._isActive) {
        var a =
          1 === this._version
            ? this._timerExt.getQueryObjectEXT(
                this._query,
                this._timerExt.QUERY_RESULT_AVAILABLE_EXT
              )
            : this._gl.getQueryParameter(
                this._query,
                this._gl.QUERY_RESULT_AVAILABLE
              );
        var c = this._gl.getParameter(this._timerExt.GPU_DISJOINT_EXT);
        a &&
          !c &&
          ((this._result =
            1 === this._version
              ? this._timerExt.getQueryObjectEXT(
                  this._query,
                  this._timerExt.QUERY_RESULT_EXT
                )
              : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT)),
          (this._result /= 1e9),
          (this._hasResult = !0));
        (a || c) && this._DeleteQueryObject();
      }
    }
    HasResult() {
      return this._hasResult;
    }
    GetResult() {
      if (!this._hasResult) throw Error("no result available");
      return this._result;
    }
  }
  e.Gfx.WebGLTimeElapsedQuery = class {
    constructor(a) {
      this._renderer = a;
      this._frameNumber = a.GetFrameNumber();
      this._isActive = !1;
      this._parentQuery = null;
      this._isNested = !1;
      this._realQuery = null;
      this._queries = [];
    }
    Release() {
      for (const a of this._queries) a instanceof b && a.Release();
      e.clearArray(this._queries);
      this._renderer = this._realQuery = this._parentQuery = null;
    }
    BeginTimeElapsed() {
      if (this._isActive) throw Error("query already active");
      const a = this._renderer._GetTimeQueryStack();
      0 < a.length
        ? ((this._isNested = !0),
          (this._parentQuery = a.at(-1)),
          this._parentQuery._EndReal(),
          this._parentQuery._queries.push(this))
        : ((this._isNested = !1), (this._parentQuery = null));
      this._isActive = !0;
      a.push(this);
      this._StartReal();
    }
    EndTimeElapsed() {
      if (!this._isActive) throw Error("query not active");
      if (this._renderer._GetTimeQueryStack().pop() !== this)
        throw Error("can only end most nested query");
      this._isActive = !1;
      this._EndReal();
      this._parentQuery &&
        (this._parentQuery._StartReal(), (this._parentQuery = null));
    }
    _StartReal() {
      this._realQuery = e.New(b, this._renderer);
      this._queries.push(this._realQuery);
      this._realQuery.BeginTimeElapsed();
    }
    _EndReal() {
      this._realQuery.EndTimeElapsed();
      this._realQuery = null;
    }
    CheckForResult() {
      for (const a of this._queries) a.CheckForResult();
    }
    IsNested() {
      return this._isNested;
    }
    HasResult() {
      return this._queries.every((a) => a.HasResult());
    }
    GetResult() {
      return this._queries.reduce((a, c) => a + c.GetResult(), 0);
    }
    GetFrameNumber() {
      return this._frameNumber;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Gfx.WebGLQueryResultBuffer = class {
    constructor(b, a = 1e3) {
      this._renderer = b;
      this._maxQueries = a;
      this._buffer = [];
      this._renderer._AddQueryResultBuffer(this);
    }
    Release() {
      this.Clear();
      this._renderer._RemoveQueryResultBuffer(this);
      this._renderer = null;
    }
    Clear() {
      for (const b of this._buffer) b.Release();
      e.clearArray(this._buffer);
    }
    AddTimeElapsedQuery() {
      const b = new e.Gfx.WebGLTimeElapsedQuery(this._renderer);
      this._buffer.push(b);
      this._buffer.length > this._maxQueries && this._buffer.shift().Release();
      return b;
    }
    CheckForResults(b) {
      for (const a of this._buffer) {
        if (a.GetFrameNumber() >= b) break;
        if (a.IsNested()) break;
        a.CheckForResult();
      }
    }
    GetFrameRangeResultSum(b, a) {
      if (a <= b) return NaN;
      let c = 0;
      for (const d of this._buffer) {
        if (d.GetFrameNumber() >= a) break;
        if (!(d.GetFrameNumber() < b))
          if (d.HasResult()) c += d.GetResult();
          else return NaN;
      }
      return c;
    }
    DeleteAllBeforeFrameNumber(b) {
      for (let a = 0, c = this._buffer.length; a < c; ++a) {
        const d = this._buffer[a];
        if (d.GetFrameNumber() < b) d.Release();
        else {
          0 < a && this._buffer.splice(0, a);
          break;
        }
      }
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.glMatrix,
    a = b.vec4,
    c = b.mat4,
    d = {
      powerPreference: "default",
      enableGpuProfiling: !0,
      alpha: !1,
      lowLatency: !1,
      depth: !1,
      canSampleDepth: !1,
      maxWebGLVersion: 2,
      failIfMajorPerformanceCaveat: !1,
    },
    f = new Set(["default", "low-power", "high-performance"]),
    h = new e.Quad(0, 0, 1, 0, 1, 1, 0, 1),
    g = c.create(),
    k = c.create(),
    m = new e.Quad(),
    q = new e.Rect();
  let v = null;
  e.isDebug &&
    ((self.debug_lose_context = function () {
      v ? v.loseContext() : console.warn("WEBGL_lose_context not supported");
    }),
    (self.debug_restore_context = function () {
      v ? v.restoreContext() : console.warn("WEBGL_lose_context not supported");
    }));
  const r = new Set();
  let n = -1;
  function p() {
    n = -1;
    for (const u of r) u.checkFunc() && (u.resolve(), r.delete(u));
    0 < r.size && (n = self.requestAnimationFrame(p));
  }
  e.Gfx.WebGLRenderer = class extends e.Gfx.RendererBase {
    constructor(u, w) {
      super();
      w = Object.assign({}, d, w);
      if (!f.has(w.powerPreference)) throw Error("invalid power preference");
      const y = {
        alpha: !!w.alpha,
        depth: !1,
        antialias: !1,
        powerPreference: w.powerPreference,
        failIfMajorPerformanceCaveat: !!w.failIfMajorPerformanceCaveat,
      };
      w.lowLatency && ((y.desynchronized = !0), (y.preserveDrawingBuffer = !0));
      let B = null,
        E = 0;
      2 <= w.maxWebGLVersion && ((B = u.getContext("webgl2", y)), (E = 2));
      B || ((B = u.getContext("webgl", y)), (E = 1));
      if (!B) throw Error("failed to initialise WebGL context");
      this._gl = B;
      this._attribs = B.getContextAttributes();
      w.lowLatency &&
        !this._attribs.desynchronized &&
        console.info(
          "[WebGLRenderer] Low-latency mode specified but is not supported here"
        );
      this._versionString = B.getParameter(B.VERSION);
      this._version = E;
      this._viewport = a.create();
      this._didChangeTransform = !1;
      this._bbProjectionMatrix = c.create();
      this._usesDepthBuffer = !!w.depth;
      this._canSampleDepth = !(!w.depth || !w.canSampleDepth);
      this._isDepthEnabled = this._usesDepthBuffer;
      this._isDepthSamplingEnabled = !1;
      this._depthBuffer = null;
      this._isAutoSizeDepthBuffer = !0;
      this._depthBufferHeight = this._depthBufferWidth = 0;
      this._pointBuffer =
        this._indexBuffer =
        this._texcoordBuffer =
        this._vertexBuffer =
          null;
      this._vertexData = new Float32Array(8e3 * this.GetNumVertexComponents());
      this._indexData = new Uint16Array(12e3);
      this._texcoordData = new Float32Array(16e3);
      this._pointData = new Float32Array(32e3);
      this._lastVertexPtr = this._pointPtr = this._texPtr = this._vertexPtr = 0;
      this._spDeviceTransformTextureFill = this._lastProgram = null;
      this._batch = [];
      this._topOfBatch = this._batchPtr = 0;
      this._currentRenderTarget = null;
      this._lastPointZ = 0;
      this._batchState = e.New(e.Gfx.BatchState, this);
      this._lastColor = e.New(e.Color, 1, 1, 1, 1);
      this._lastTexture1 = this._lastTexture0 = null;
      this._lastDestBlend = this._lastSrcBlend = 0;
      this._lastPointTexCoords = new e.Rect();
      this._lastScissorRect = e.New(e.Rect, 0, 0, -1, -1);
      this._maxTextureSize = -1;
      this._highpPrecision = this._maxPointSize = this._minPointSize = 0;
      this._unmaskedRenderer = this._unmaskedVendor = "(unavailable)";
      this._extensions = [];
      this._isInitialisingAfterContextRestored = !1;
      this._fragDepthExt =
        this._depthTextureExt =
        this._anisotropicExt =
        this._parallelShaderCompileExt =
          null;
      this._maxAnisotropy = 0;
      this._isGpuProfilingEnabled = !!w.enableGpuProfiling;
      this._timerExt = null;
      this._allQueryResultBuffers = new Set();
      this._timeQueryStack = [];
      this.FillIndexBufferData(this._indexData);
    }
    IsWebGL() {
      return !0;
    }
    async InitState() {
      super.InitState();
      var u = this._gl,
        w = this.GetNumVertexComponents();
      this._lastColor.setRgba(1, 1, 1, 1);
      this._lastTexture1 = this._lastTexture0 = null;
      this._pointPtr = this._vertexPtr = 0;
      this._lastVertexPtr = 8e3 * w - 4 * w;
      e.clearArray(this._batch);
      this._topOfBatch = this._batchPtr = 0;
      this._currentRenderTarget = this._lastProgram = null;
      this._lastPointTexCoords.set(0, 0, 1, 1);
      this._lastPointZ = 0;
      w = this._batchState;
      w.currentShader = null;
      w.currentFramebuffer = null;
      w.currentFramebufferNoDepth = null;
      a.set(w.currentColor, 1, 1, 1, 1);
      w.clearColor.setRgba(0, 0, 0, 0);
      w.pointTexCoords.set(0, 0, 1, 1);
      u.clearColor(0, 0, 0, 0);
      u.clear(u.COLOR_BUFFER_BIT);
      u.enable(u.BLEND);
      u.blendFunc(u.ONE, u.ONE_MINUS_SRC_ALPHA);
      this._lastSrcBlend = u.ONE;
      this._lastDestBlend = u.ONE_MINUS_SRC_ALPHA;
      this._InitBlendModes(u);
      u.disable(u.CULL_FACE);
      u.disable(u.STENCIL_TEST);
      u.disable(u.DITHER);
      this._usesDepthBuffer
        ? (u.enable(u.DEPTH_TEST), u.depthMask(!0), u.depthFunc(u.LEQUAL))
        : (u.disable(u.DEPTH_TEST), u.depthMask(!1));
      this._isDepthEnabled = this._usesDepthBuffer;
      this._isDepthSamplingEnabled = !1;
      this._pointBuffer = u.createBuffer();
      u.bindBuffer(u.ARRAY_BUFFER, this._pointBuffer);
      u.bufferData(u.ARRAY_BUFFER, this._pointData.byteLength, u.DYNAMIC_DRAW);
      this._vertexBuffer = u.createBuffer();
      u.bindBuffer(u.ARRAY_BUFFER, this._vertexBuffer);
      u.bufferData(u.ARRAY_BUFFER, this._vertexData.byteLength, u.DYNAMIC_DRAW);
      this._texcoordBuffer = u.createBuffer();
      u.bindBuffer(u.ARRAY_BUFFER, this._texcoordBuffer);
      u.bufferData(
        u.ARRAY_BUFFER,
        this._texcoordData.byteLength,
        u.DYNAMIC_DRAW
      );
      this._indexBuffer = u.createBuffer();
      u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      u.bufferData(u.ELEMENT_ARRAY_BUFFER, this._indexData, u.STATIC_DRAW);
      u.activeTexture(u.TEXTURE0);
      u.bindTexture(u.TEXTURE_2D, null);
      this._maxTextureSize = u.getParameter(u.MAX_TEXTURE_SIZE);
      w = u.getParameter(u.ALIASED_POINT_SIZE_RANGE);
      this._minPointSize = w[0];
      this._maxPointSize = w[1];
      w = u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_FLOAT);
      var y = u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_FLOAT);
      this._highpPrecision = w && y ? Math.min(w.precision, y.precision) : 0;
      2048 < this._maxPointSize && (this._maxPointSize = 2048);
      this._extensions = u.getSupportedExtensions();
      if ((w = u.getExtension("WEBGL_debug_renderer_info")))
        (this._unmaskedVendor = u.getParameter(w.UNMASKED_VENDOR_WEBGL)),
          (this._unmaskedRenderer = u.getParameter(w.UNMASKED_RENDERER_WEBGL));
      this._parallelShaderCompileExt = u.getExtension(
        "KHR_parallel_shader_compile"
      );
      e.isDebug && (v = u.getExtension("WEBGL_lose_context"));
      if (this._isGpuProfilingEnabled)
        if (1 === this.GetWebGLVersionNumber()) {
          if (
            "Chromium" !== e.Platform.BrowserEngine ||
            81 <= e.Platform.BrowserVersionNumber ||
            "undefined" !== typeof document
          )
            this._timerExt = u.getExtension("EXT_disjoint_timer_query");
        } else
          this._timerExt =
            u.getExtension("EXT_disjoint_timer_query_webgl2") ||
            u.getExtension("EXT_disjoint_timer_query");
      this._maxAnisotropy = (this._anisotropicExt = u.getExtension(
        "EXT_texture_filter_anisotropic"
      ))
        ? u.getParameter(this._anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        : 0;
      if (
        2 > this.GetWebGLVersionNumber() &&
        this._usesDepthBuffer &&
        this._canSampleDepth &&
        ((this._depthTextureExt = u.getExtension("WEBGL_depth_texture")),
        !this._depthTextureExt)
      )
        throw Error("no depth texture support");
      2 > this.GetWebGLVersionNumber() &&
        (this._fragDepthExt = u.getExtension("EXT_frag_depth"));
      u = e.Gfx.WebGLShaderProgram;
      w = u.GetDefaultVertexShaderSource(!1);
      y = u.GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth();
      u = [
        [y, w, "<default>"],
        [y, w, "<default-device-transform>"],
        [
          u.GetPointFragmentShaderSource(this._version),
          u.GetPointVertexShaderSource(this._version),
          "<point>",
        ],
        [u.GetColorFillFragmentShaderSource(), w, "<fill>"],
        [u.GetLinearGradientFillFragmentShaderSource(), w, "<lineargradient>"],
        [u.GetHardEllipseFillFragmentShaderSource(), w, "<hardellipse>"],
        [
          u.GetHardEllipseOutlineFragmentShaderSource(),
          w,
          "<hardellipseoutline>",
        ],
        [u.GetSmoothEllipseFillFragmentShaderSource(), w, "<smoothellipse>"],
        [
          u.GetSmoothEllipseOutlineFragmentShaderSource(),
          w,
          "<smoothellipseoutline>",
        ],
        [u.GetSmoothLineFillFragmentShaderSource(), w, "<smoothline>"],
        [
          u.GetTilemapFragmentShaderSource(),
          u.GetDefaultVertexShaderSource(!0),
          "<tilemap>",
        ],
      ];
      u = await Promise.all(
        u.map((B) => this.CreateShaderProgram({ src: B[0] }, B[1], B[2]))
      );
      this._spTextureFill = u[0];
      this._spDeviceTransformTextureFill = u[1];
      this._spPoints = u[2];
      this._spColorFill = u[3];
      this._spLinearGradientFill = u[4];
      this._spHardEllipseFill = u[5];
      this._spHardEllipseOutline = u[6];
      this._spSmoothEllipseFill = u[7];
      this._spSmoothEllipseOutline = u[8];
      this._spSmoothLineFill = u[9];
      this._spTilemapFill = u[10];
      this.SetTextureFillMode();
    }
    async CreateShaderProgram(u, w, y) {
      u = await e.Gfx.WebGLShaderProgram.Create(this, u, w, y);
      this._AddShaderProgram(u);
      return u;
    }
    ResetLastProgram() {
      this._lastProgram = null;
    }
    SetSize(u, w, y) {
      if (this._width !== u || this._height !== w || y) {
        this.EndBatch();
        y = this._gl;
        var B = this._batchState;
        this._width = u;
        this._height = w;
        this._SetViewport(0, 0, u, w);
        this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, u / w);
        this.SetProjectionMatrix(this._bbProjectionMatrix);
        this._spDeviceTransformTextureFill &&
          (y.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()),
          this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(
            this._matP
          ),
          (this._lastProgram = this._spDeviceTransformTextureFill),
          (this._batchState.currentShader =
            this._spDeviceTransformTextureFill));
        y.bindTexture(y.TEXTURE_2D, null);
        y.activeTexture(y.TEXTURE1);
        y.bindTexture(y.TEXTURE_2D, null);
        y.activeTexture(y.TEXTURE0);
        this._lastTexture1 = this._lastTexture0 = null;
        this._usesDepthBuffer &&
          this._isAutoSizeDepthBuffer &&
          this._SetDepthBufferSize(this._width, this._height);
        this._currentRenderTarget &&
          this._currentRenderTarget._Resize(this._width, this._height);
        y.bindFramebuffer(y.FRAMEBUFFER, null);
        this._currentRenderTarget = null;
        B.currentFramebuffer = null;
        B.currentFramebufferNoDepth = null;
      }
    }
    _SetDepthBufferSize(u, w) {
      const y = this._gl;
      (this._depthBuffer &&
        this._depthBufferWidth === u &&
        this._depthBufferHeight === w) ||
        (this._canSampleDepth
          ? (this._depthBuffer && y.deleteTexture(this._depthBuffer),
            (this._depthBuffer = y.createTexture()),
            y.bindTexture(y.TEXTURE_2D, this._depthBuffer),
            y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MAG_FILTER, y.NEAREST),
            y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MIN_FILTER, y.NEAREST),
            y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_S, y.CLAMP_TO_EDGE),
            y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_T, y.CLAMP_TO_EDGE),
            2 <= this.GetWebGLVersionNumber()
              ? y.texImage2D(
                  y.TEXTURE_2D,
                  0,
                  y.DEPTH24_STENCIL8,
                  u,
                  w,
                  0,
                  y.DEPTH_STENCIL,
                  y.UNSIGNED_INT_24_8,
                  null
                )
              : this._depthTextureExt &&
                y.texImage2D(
                  y.TEXTURE_2D,
                  0,
                  y.DEPTH_STENCIL,
                  u,
                  w,
                  0,
                  y.DEPTH_STENCIL,
                  this._depthTextureExt.UNSIGNED_INT_24_8_WEBGL,
                  null
                ),
            y.bindTexture(y.TEXTURE_2D, null))
          : (this._depthBuffer && y.deleteRenderbuffer(this._depthBuffer),
            (this._depthBuffer = y.createRenderbuffer()),
            y.bindRenderbuffer(y.RENDERBUFFER, this._depthBuffer),
            y.renderbufferStorage(
              y.RENDERBUFFER,
              2 <= this._version ? y.DEPTH24_STENCIL8 : y.DEPTH_STENCIL,
              u,
              w
            ),
            y.bindRenderbuffer(y.RENDERBUFFER, null)),
        (this._depthBufferWidth = u),
        (this._depthBufferHeight = w));
    }
    SetFixedSizeDepthBuffer(u, w) {
      this._usesDepthBuffer &&
        ((this._isAutoSizeDepthBuffer = !1), this._SetDepthBufferSize(u, w));
    }
    SetAutoSizeDepthBuffer() {
      this._usesDepthBuffer &&
        ((this._isAutoSizeDepthBuffer = !0),
        this._SetDepthBufferSize(this._width, this._height));
    }
    _SetViewport(u, w, y, B) {
      const E = this._viewport;
      if (E[0] !== u || E[1] !== w || E[2] !== y || E[3] !== B)
        this.PushBatch().InitSetViewport(u, w, y, B),
          a.set(E, u, w, y, B),
          (this._topOfBatch = 0);
    }
    SetFovY(u) {
      super.SetFovY(u);
      this.CalculatePerspectiveMatrix(
        this._bbProjectionMatrix,
        this._width / this._height
      );
    }
    SetProjectionMatrix(u) {
      c.exactEquals(this._matP, u) ||
        (this.PushBatch().InitSetProjection(u),
        c.copy(this._matP, u),
        (this._topOfBatch = 0),
        (this._didChangeTransform = !0));
    }
    SetDefaultRenderTargetProjectionState() {
      let u, w;
      var y = this._currentRenderTarget;
      null === y
        ? ((u = this._bbProjectionMatrix),
          (w = this.GetWidth()),
          (y = this.GetHeight()))
        : ((u = y.GetProjectionMatrix()),
          (w = y.GetWidth()),
          (y = y.GetHeight()));
      this.SetProjectionMatrix(u);
      this._SetViewport(0, 0, w, y);
    }
    SetModelViewMatrix(u) {
      c.exactEquals(this._matMV, u) ||
        (this.PushBatch().InitSetModelView(u),
        c.copy(this._matMV, u),
        (this._topOfBatch = 0),
        (this._didChangeTransform = !0));
    }
    ResetDidChangeTransformFlag() {
      this._didChangeTransform = !1;
    }
    DidChangeTransform() {
      return this._didChangeTransform;
    }
    GetBatchState() {
      return this._batchState;
    }
    PushBatch() {
      const u = this._batch;
      this._batchPtr === u.length &&
        u.push(new e.Gfx.WebGLBatchJob(this._batchState));
      return u[this._batchPtr++];
    }
    EndBatch() {
      0 === this._batchPtr ||
        this.IsContextLost() ||
        (this._WriteBuffers(),
        this._ExecuteBatch(),
        (this._topOfBatch =
          this._pointPtr =
          this._texPtr =
          this._vertexPtr =
          this._batchPtr =
            0));
    }
    _WriteBuffers() {
      const u = this._gl;
      0 < this._pointPtr &&
        (u.bindBuffer(u.ARRAY_BUFFER, this._pointBuffer),
        u.bufferSubData(
          u.ARRAY_BUFFER,
          0,
          this._pointData.subarray(0, this._pointPtr)
        ));
      0 < this._vertexPtr &&
        (u.bindBuffer(u.ARRAY_BUFFER, this._vertexBuffer),
        u.bufferSubData(
          u.ARRAY_BUFFER,
          0,
          this._vertexData.subarray(0, this._vertexPtr)
        ),
        u.bindBuffer(u.ARRAY_BUFFER, this._texcoordBuffer),
        u.bufferSubData(
          u.ARRAY_BUFFER,
          0,
          this._texcoordData.subarray(0, this._texPtr)
        ));
    }
    _ExecuteBatch() {
      const u = this._batch;
      for (let w = 0, y = this._batchPtr; w < y; ++w) u[w].Run();
    }
    GetOpacity() {
      return this._lastColor.getA();
    }
    SetColorRgba(u, w, y, B) {
      const E = this._lastColor;
      E.equalsRgba(u, w, y, B) ||
        (E.setRgba(u, w, y, B),
        this.PushBatch().InitSetColor(E),
        (this._topOfBatch = 0),
        (this._currentStateGroup = null));
    }
    SetOpacity(u) {
      const w = this._lastColor;
      w.getA() !== u &&
        (w.setA(u),
        this.PushBatch().InitSetColor(w),
        (this._topOfBatch = 0),
        (this._currentStateGroup = null));
    }
    SetColor(u) {
      const w = this._lastColor;
      w.equals(u) ||
        (w.set(u),
        this.PushBatch().InitSetColor(w),
        (this._topOfBatch = 0),
        (this._currentStateGroup = null));
    }
    ResetColor() {
      this.SetColorRgba(1, 1, 1, 1);
    }
    GetColor() {
      return this._lastColor;
    }
    SetTexture(u) {
      u !== this._lastTexture0 &&
        (this.PushBatch().InitSetTexture(u),
        (this._lastTexture0 = u),
        (this._topOfBatch = 0));
    }
    _ResetLastTexture() {
      this._lastTexture0 = null;
    }
    SetBlendMode(u) {
      u = this._GetBlendByIndex(u);
      this._SetBlend(u[0], u[1]);
    }
    SetNamedBlendMode(u) {
      u = this.GetNamedBlend(u);
      this._SetBlend(u.srcBlend, u.destBlend);
    }
    _SetBlend(u, w) {
      if (u !== this._lastSrcBlend || w !== this._lastDestBlend)
        this.PushBatch().InitSetBlend(u, w),
          (this._lastSrcBlend = u),
          (this._lastDestBlend = w),
          (this._topOfBatch = 0),
          (this._currentStateGroup = null);
    }
    IsPremultipliedAlphaBlend() {
      return (
        this._lastSrcBlend === this._gl.ONE &&
        this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA
      );
    }
    SetAlphaBlend() {
      this._SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
    }
    SetNoPremultiplyAlphaBlend() {
      this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
    }
    SetCopyBlend() {
      this._SetBlend(this._gl.ONE, this._gl.ZERO);
    }
    Rect(u) {
      this.Rect2(u.getLeft(), u.getTop(), u.getRight(), u.getBottom());
    }
    Rect2(u, w, y, B) {
      this.Quad2(u, w, y, w, y, B, u, B);
    }
    _ExtendQuadBatch() {
      let u = this._vertexPtr;
      u >= this._lastVertexPtr && (this.EndBatch(), (u = 0));
      1 === this._topOfBatch
        ? (this._batch[this._batchPtr - 1]._indexCount += 6)
        : (this.PushBatch().InitQuad(u, 6), (this._topOfBatch = 1));
    }
    _WriteQuadToVertexBuffer(u) {
      u.writeToTypedArray3D(
        this._vertexData,
        this._vertexPtr,
        this._baseZ + this._currentZ
      );
      this._vertexPtr += 12;
    }
    Quad(u) {
      this._ExtendQuadBatch();
      this._WriteQuadToVertexBuffer(u);
      h.writeToTypedArray(this._texcoordData, this._texPtr);
      this._texPtr += 8;
    }
    Quad2(u, w, y, B, E, z, D, J) {
      this._ExtendQuadBatch();
      const C = this._vertexData;
      let H = this._vertexPtr;
      const K = this._baseZ + this._currentZ;
      C[H++] = u;
      C[H++] = w;
      C[H++] = K;
      C[H++] = y;
      C[H++] = B;
      C[H++] = K;
      C[H++] = E;
      C[H++] = z;
      C[H++] = K;
      C[H++] = D;
      C[H++] = J;
      C[H++] = K;
      this._vertexPtr = H;
      h.writeToTypedArray(this._texcoordData, this._texPtr);
      this._texPtr += 8;
    }
    Quad3(u, w) {
      this._ExtendQuadBatch();
      this._WriteQuadToVertexBuffer(u);
      w.writeAsQuadToTypedArray(this._texcoordData, this._texPtr);
      this._texPtr += 8;
    }
    Quad4(u, w) {
      this._ExtendQuadBatch();
      this._WriteQuadToVertexBuffer(u);
      w.writeToTypedArray(this._texcoordData, this._texPtr);
      this._texPtr += 8;
    }
    Quad3D(u, w, y, B, E, z, D, J, C, H, K, P, S) {
      this._ExtendQuadBatch();
      const U = this._vertexData;
      let V = this._vertexPtr;
      const aa = this._baseZ + this._currentZ;
      U[V++] = u;
      U[V++] = w;
      U[V++] = aa + y;
      U[V++] = B;
      U[V++] = E;
      U[V++] = aa + z;
      U[V++] = D;
      U[V++] = J;
      U[V++] = aa + C;
      U[V++] = H;
      U[V++] = K;
      U[V++] = aa + P;
      this._vertexPtr = V;
      S.writeAsQuadToTypedArray(this._texcoordData, this._texPtr);
      this._texPtr += 8;
    }
    Quad3D2(u, w, y, B, E, z, D, J, C, H, K, P, S) {
      this._ExtendQuadBatch();
      const U = this._vertexData;
      let V = this._vertexPtr;
      const aa = this._baseZ + this._currentZ;
      U[V++] = u;
      U[V++] = w;
      U[V++] = aa + y;
      U[V++] = B;
      U[V++] = E;
      U[V++] = aa + z;
      U[V++] = D;
      U[V++] = J;
      U[V++] = aa + C;
      U[V++] = H;
      U[V++] = K;
      U[V++] = aa + P;
      this._vertexPtr = V;
      S.writeToTypedArray(this._texcoordData, this._texPtr);
      this._texPtr += 8;
    }
    FullscreenQuad(u, w) {
      c.copy(g, this._matP);
      c.copy(k, this._matMV);
      this.SetDefaultRenderTargetProjectionState();
      const [y, B] = this.GetRenderTargetSize(this._currentRenderTarget);
      var E = this.CalculateLookAtModelView2(
        0,
        0,
        this.GetDefaultCameraZ(B),
        0,
        0,
        0,
        B
      );
      this.SetModelViewMatrix(E);
      if ("crop" === u && this._currentRenderTarget && w) {
        u = this._width / 2;
        E = this._height / 2;
        const J = w.GetWidth();
        w = w.GetHeight();
        var z = this._currentRenderTarget.GetWidth(),
          D = this._currentRenderTarget.GetHeight();
        z = Math.min(z, J);
        const C = Math.min(D, w),
          H = Math.max(w - D, 0);
        D = Math.max(D - w, 0);
        q.set(-u, E - D, -u + z, E - C - D);
        m.setFromRect(q);
        q.set(0, H, z, C + H);
        q.divide(J, w);
        this.Quad3(m, q);
      } else (u = y / 2), (E = B / 2), this.Rect2(-u, E, u, -E);
      this.SetProjectionMatrix(g);
      this.SetModelViewMatrix(k);
    }
    StartRenderingPoints(u) {
      this._lastPointTexCoords.equals(u) ||
        (this._lastPointTexCoords.copy(u),
        this.PushBatch().InitSetPointTexCoords(u),
        (this._topOfBatch = 0));
    }
    FinishRenderingPoints() {}
    Point(u, w, y, B) {
      7996 <= this._pointPtr && this.EndBatch();
      let E = this._pointPtr;
      var z = this._baseZ + this._currentZ;
      2 === this._topOfBatch && this._lastPointZ === z
        ? this._batch[this._batchPtr - 1]._indexCount++
        : (this.PushBatch().InitPoints(E, z),
          (this._topOfBatch = 2),
          (this._lastPointZ = z));
      z = this._pointData;
      z[E++] = u;
      z[E++] = w;
      z[E++] = y;
      z[E++] = B;
      this._pointPtr = E;
    }
    SetProgram(u) {
      this._lastProgram !== u &&
        (this.PushBatch().InitSetProgram(u),
        (this._lastProgram = u),
        (this._topOfBatch = 0),
        (this._currentStateGroup = null));
    }
    SetDeviceTransformTextureFillMode() {
      this.SetProgram(this._spDeviceTransformTextureFill);
    }
    SetGradientColor(u) {
      this.PushBatch().InitSetGradientColor(u);
      this._topOfBatch = 0;
    }
    SetEllipseParams(u, w, y = 1) {
      this.PushBatch().InitSetEllipseParams(u, w, y);
      this._topOfBatch = 0;
    }
    SetTilemapInfo(u, w, y, B, E, z, D) {
      if (this._lastProgram !== this._spTilemapFill)
        throw Error("must set tilemap fill mode first");
      this.PushBatch().InitSetTilemapInfo(u, w, y, B, E, z, D);
      this._topOfBatch = 0;
    }
    SetProgramParameters(u, w, y, B, E, z, D, J, C, H, K) {
      const P = this._lastProgram;
      if (
        P._hasAnyOptionalUniforms &&
        !P.AreOptionalUniformsAlreadySetInBatch(w, y, B, E, z, D, J, C, H, K)
      ) {
        var S = this.PushBatch();
        S.InitSetProgramParameters();
        P.SetOptionalUniformsInBatch(w, y, B, E, z, D, J, C, H, K);
        var U = S._mat4param;
        U[0] = z;
        U[1] = D;
        w.writeToTypedArray(U, 2);
        U[6] = C;
        U[7] = H;
        y.writeToTypedArray(U, 12);
        w = S._colorParam;
        E.writeToTypedArray(w, 0);
        E = w[1];
        w[1] = w[3];
        w[3] = E;
        B.writeToTypedArray(S._srcOriginRect, 0);
        S._startIndex = K;
        S._indexCount = J;
        P._uSamplerBack.IsUsed()
          ? (S._texParam = u ? u.GetTexture() : null)
          : (S._texParam = null);
        this._topOfBatch = 0;
      }
    }
    SetProgramCustomParameters(u) {
      const w = this._lastProgram;
      if (0 !== u.length && !w.AreCustomParametersAlreadySetInBatch(u)) {
        var y = this.PushBatch();
        y.InitSetProgramCustomParameters();
        w.SetCustomParametersInBatch(u);
        e.shallowAssignArray(y._shaderParams, u);
        this._topOfBatch = 0;
      }
    }
    ClearRgba(u, w, y, B) {
      this.PushBatch().InitClearSurface2(u, w, y, B);
      this._topOfBatch = 0;
    }
    Clear(u) {
      this.PushBatch().InitClearSurface(u);
      this._topOfBatch = 0;
    }
    Start() {}
    Finish() {
      super.Finish();
      this._gl.flush();
    }
    ClearDepth() {
      this._usesDepthBuffer &&
        this._currentRenderTarget &&
        this._currentRenderTarget.HasDepthBuffer() &&
        (this.PushBatch().InitClearDepth(this._isDepthEnabled),
        (this._topOfBatch = 0));
    }
    SetDepthEnabled(u) {
      u = !!u;
      this._isDepthEnabled !== u &&
        this._usesDepthBuffer &&
        ((this._isDepthEnabled = u),
        this.PushBatch().InitSetDepthEnabled(u),
        (this._topOfBatch = 0));
    }
    IsDepthEnabled() {
      return this._isDepthEnabled;
    }
    _GetDepthBuffer() {
      return this._depthBuffer;
    }
    _CanSampleDepth() {
      return this._canSampleDepth;
    }
    SetDepthSamplingEnabled(u) {
      u = !!u;
      if (this._canSampleDepth && this._isDepthSamplingEnabled !== u) {
        if (u && this.IsDepthEnabled()) throw Error("depth still enabled");
        this._isDepthSamplingEnabled = u;
        this.PushBatch().InitSetDepthSamplingEnabled(u);
        this._topOfBatch = 0;
      }
    }
    SetScissorRect(u, w, y, B, E = 0) {
      u = Math.floor(u);
      w = Math.floor(w);
      y = Math.floor(y);
      B = Math.floor(B);
      this._lastScissorRect.equalsWH(u, w, y, B) ||
        (this._lastScissorRect.setWH(u, w, y, B),
        (w =
          (E || this.GetRenderTargetSize(this.GetRenderTarget())[1]) - w - B),
        this.PushBatch().InitSetScissor(!0, u, w, y, B),
        (this._topOfBatch = 0));
    }
    RemoveScissorRect() {
      -1 !== this._lastScissorRect.getRight() &&
        (this._lastScissorRect.set(0, 0, -1, -1),
        this.PushBatch().InitSetScissor(!1, 0, 0, 0, 0),
        (this._topOfBatch = 0));
    }
    CheckForQueryResults() {
      for (const u of this._allQueryResultBuffers)
        u.CheckForResults(this._frameNumber);
    }
    IsContextLost() {
      return (
        !this._gl ||
        this._gl.isContextLost() ||
        this._isInitialisingAfterContextRestored
      );
    }
    OnContextLost() {
      super.OnDeviceOrContextLost();
      e.Gfx.WebGLRendererTexture.OnContextLost();
      e.Gfx.WebGLRenderTarget.OnContextLost();
      e.Gfx.RendererText.OnContextLost();
      for (const u of this._allQueryResultBuffers) u.Clear();
      this._extensions = [];
      this._fragDepthExt =
        this._depthTextureExt =
        this._anisotropicExt =
        this._parallelShaderCompileExt =
        this._timerExt =
          null;
      this._maxAnisotropy = 0;
      this._unmaskedRenderer = this._unmaskedVendor = "(unavailable)";
      this._depthBuffer =
        this._spDeviceTransformTextureFill =
        this._lastProgram =
          null;
      for (const u of this._stateGroups.values()) u.OnContextLost();
    }
    async OnContextRestored() {
      this._isInitialisingAfterContextRestored = !0;
      await this.InitState();
      this._isInitialisingAfterContextRestored = !1;
      for (const u of this._stateGroups.values()) u.OnContextRestored(this);
      this.SetSize(this._width, this._height, !0);
    }
    CreateStaticTexture(u, w) {
      if (this.IsContextLost()) throw Error("context lost");
      this.EndBatch();
      const y = e.New(e.Gfx.WebGLRendererTexture, this);
      y._CreateStatic(u, w);
      return y;
    }
    async CreateStaticTextureAsync(u, w) {
      if (this.IsContextLost()) throw Error("context lost");
      w = Object.assign({}, w);
      if (
        !e.Supports.ImageBitmapOptions ||
        ("Safari" === e.Platform.Browser &&
          u instanceof ImageData &&
          "undefined" !== typeof Image)
      ) {
        if (u instanceof Blob) {
          if ("undefined" === typeof Image)
            throw Error("texture upload variant not supported in worker");
          u = await e.BlobToImage(u);
        }
        return await e.Asyncify(() => this.CreateStaticTexture(u, w));
      }
      {
        let y = await createImageBitmap(u, { premultiplyAlpha: "premultiply" });
        const B =
            (w.wrapX && "clamp-to-edge" !== w.wrapX) ||
            (w.wrapY && "clamp-to-edge" !== w.wrapY),
          E = e.isPOT(y.width) && e.isPOT(y.height);
        this.SupportsNPOTTextures() || E || !B
          ? (w.premultiplyAlpha = !1)
          : e.Supports.ImageBitmapOptionsResize
          ? ((y = await createImageBitmap(u, {
              premultiplyAlpha: "premultiply",
              resizeWidth: e.nextHighestPowerOfTwo(y.width),
              resizeHeight: e.nextHighestPowerOfTwo(y.height),
            })),
            (w.premultiplyAlpha = !1))
          : (y = await createImageBitmap(u, { premultiplyAlpha: "none" }));
        return await e.Asyncify(() => this.CreateStaticTexture(y, w));
      }
    }
    CreateDynamicTexture(u, w, y) {
      this.EndBatch();
      const B = e.New(e.Gfx.WebGLRendererTexture, this);
      B._CreateDynamic(u, w, y);
      return B;
    }
    UpdateTexture(u, w, y) {
      this.EndBatch();
      w._Update(u, y);
    }
    DeleteTexture(u) {
      u &&
        (u.SubtractReference(),
        0 < u.GetReferenceCount() ||
          (this.EndBatch(),
          u === this._lastTexture0 &&
            (this._gl.bindTexture(this._gl.TEXTURE_2D, null),
            (this._lastTexture0 = null)),
          u === this._lastTexture1 &&
            (this._gl.activeTexture(this._gl.TEXTURE1),
            this._gl.bindTexture(this._gl.TEXTURE_2D, null),
            this._gl.activeTexture(this._gl.TEXTURE0),
            (this._lastTexture1 = null)),
          u._Delete()));
    }
    CreateRenderTarget(u) {
      let w = this._width,
        y = this._height,
        B = !0;
      u &&
        ("number" === typeof u.width && ((w = u.width), (B = !1)),
        "number" === typeof u.height && ((y = u.height), (B = !1)));
      if (0 >= w || 0 >= y) throw Error("invalid size");
      this.EndBatch();
      const E = e.New(e.Gfx.WebGLRenderTarget, this);
      E._Create(w, y, Object.assign({ isDefaultSize: B }, u));
      this._currentRenderTarget = null;
      this._batchState.currentFramebuffer = null;
      this._batchState.currentFramebufferNoDepth = null;
      return E;
    }
    SetRenderTarget(u, w = !0) {
      u !== this._currentRenderTarget &&
        (u && u.IsDefaultSize() && u._Resize(this._width, this._height),
        this.PushBatch().InitSetRenderTarget(u),
        (this._currentRenderTarget = u),
        (this._topOfBatch = 0),
        w && this.SetDefaultRenderTargetProjectionState());
    }
    GetRenderTarget() {
      return this._currentRenderTarget;
    }
    GetRenderTargetSize(u) {
      return u ? [u.GetWidth(), u.GetHeight()] : [this._width, this._height];
    }
    CopyRenderTarget(u, w = "stretch") {
      2 > this._version ||
      (this._currentRenderTarget &&
        0 < this._currentRenderTarget.GetMultisampling())
        ? (this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(u, w))
        : (this.PushBatch().InitBlitFramebuffer(
            u,
            this._currentRenderTarget,
            w
          ),
          (this._topOfBatch = 0));
    }
    DrawRenderTarget(u, w = "stretch") {
      u = u.GetTexture();
      if (!u) throw Error("not a texture-backed render target");
      this.SetTexture(u);
      this.FullscreenQuad(w, u);
    }
    InvalidateRenderTarget(u) {
      2 > this._version ||
        (this.PushBatch().InitInvalidateFramebuffer(u._GetFramebuffer()),
        (this._topOfBatch = 0));
    }
    DeleteRenderTarget(u) {
      this.SetRenderTarget(null);
      this.EndBatch();
      const w = u.GetTexture();
      w === this._lastTexture0 &&
        (this._gl.bindTexture(this._gl.TEXTURE_2D, null),
        (this._lastTexture0 = null));
      w === this._lastTexture1 &&
        (this._gl.activeTexture(this._gl.TEXTURE1),
        this._gl.bindTexture(this._gl.TEXTURE_2D, null),
        this._gl.activeTexture(this._gl.TEXTURE0),
        (this._lastTexture1 = null));
      u._Delete();
    }
    async ReadBackRenderTargetToImageData(u, w, y) {
      this.EndBatch();
      const B = this._currentRenderTarget;
      if (u) {
        var E = u.GetWidth();
        var z = u.GetHeight();
        var D = u._GetFramebuffer();
      } else (E = this.GetWidth()), (z = this.GetHeight()), (D = null);
      let J = (u = 0);
      var C = E,
        H = z;
      y &&
        ((u = e.clamp(Math.floor(y.getLeft()), 0, E - 1)),
        (J = e.clamp(Math.floor(y.getTop()), 0, z - 1)),
        (C = y.width()),
        (C = 0 === C ? E - u : e.clamp(Math.floor(C), 0, E - u)),
        (H = y.height()),
        (H = 0 === H ? z - J : e.clamp(Math.floor(H), 0, z - J)),
        (J = z - (J + H)));
      const K = this._gl;
      K.bindFramebuffer(K.FRAMEBUFFER, D);
      z = () => {
        K.bindFramebuffer(K.FRAMEBUFFER, null);
        this._currentRenderTarget = null;
        this._batchState.currentFramebuffer = null;
        this._batchState.currentFramebufferNoDepth = null;
        this.SetRenderTarget(B);
      };
      if (!w && 2 <= this.GetWebGLVersionNumber()) {
        K.bindFramebuffer(K.READ_FRAMEBUFFER, D);
        D = K.createBuffer();
        y = C * H * 4;
        E = K.PIXEL_PACK_BUFFER;
        K.bindBuffer(E, D);
        K.bufferData(E, y, K.STREAM_READ);
        K.readPixels(u, J, C, H, K.RGBA, K.UNSIGNED_BYTE, 0);
        K.bindFramebuffer(K.READ_FRAMEBUFFER, null);
        K.bindBuffer(E, null);
        z();
        const P = K.fenceSync(K.SYNC_GPU_COMMANDS_COMPLETE, 0);
        await this._WaitForObjectReady(
          () => K.getSyncParameter(P, K.SYNC_STATUS) === K.SIGNALED
        );
        K.deleteSync(P);
        w = new ImageData(C, H);
        K.bindBuffer(E, D);
        K.getBufferSubData(E, 0, new Uint8Array(w.data.buffer), 0, y);
        K.bindBuffer(E, null);
        K.deleteBuffer(D);
      } else
        (w = new ImageData(C, H)),
          K.readPixels(
            u,
            J,
            C,
            H,
            K.RGBA,
            K.UNSIGNED_BYTE,
            new Uint8Array(w.data.buffer)
          ),
          z();
      return w;
    }
    CoplanarStartStencilPass() {
      this.SetDepthEnabled(!0);
      this.PushBatch().InitCoplanarStartStencilPass();
      this._topOfBatch = 0;
    }
    CoplanarStartColorPass() {
      this.SetDepthEnabled(!1);
      this.PushBatch().InitCoplanarStartColorPass();
      this._topOfBatch = 0;
    }
    CoplanarRestoreStandardRendering() {
      this.SetDepthEnabled(!0);
      this.PushBatch().InitCoplanarRestore();
      this._topOfBatch = 0;
    }
    StartQuery(u) {
      this.SupportsGPUProfiling() &&
        (this.PushBatch().InitStartQuery(u), (this._topOfBatch = 0));
    }
    EndQuery(u) {
      this.SupportsGPUProfiling() &&
        (this.PushBatch().InitEndQuery(u), (this._topOfBatch = 0));
    }
    _WaitForObjectReady(u) {
      const w = new Promise((y) => r.add({ resolve: y, checkFunc: u }));
      -1 === n && (n = self.requestAnimationFrame(p));
      return w;
    }
    IsDesynchronized() {
      return !!this._attribs.desynchronized;
    }
    GetEstimatedBackBufferMemoryUsage() {
      return this._width * this._height * (this._attribs.alpha ? 4 : 3);
    }
    GetEstimatedRenderBufferMemoryUsage() {
      let u = 0;
      for (const w of e.Gfx.WebGLRenderTarget.allRenderTargets())
        w.GetTexture() || (u += w.GetEstimatedMemoryUsage());
      return u;
    }
    GetEstimatedTextureMemoryUsage() {
      let u = 0;
      for (const w of e.Gfx.WebGLRendererTexture.allTextures())
        u += w.GetEstimatedMemoryUsage();
      return u;
    }
    GetEstimatedTotalMemoryUsage() {
      return (
        this.GetEstimatedBackBufferMemoryUsage() +
        this.GetEstimatedRenderBufferMemoryUsage() +
        this.GetEstimatedTextureMemoryUsage()
      );
    }
    GetWebGLVersionString() {
      return this._versionString;
    }
    GetWebGLVersionNumber() {
      return this._version;
    }
    GetDisplayName() {
      return "webgl" + this.GetWebGLVersionNumber();
    }
    SupportsNPOTTextures() {
      return 2 <= this.GetWebGLVersionNumber();
    }
    GetMaxTextureSize() {
      return this._maxTextureSize;
    }
    GetMinPointSize() {
      return this._minPointSize;
    }
    GetMaxPointSize() {
      return this._maxPointSize;
    }
    SupportsHighP() {
      return 0 !== this._highpPrecision;
    }
    GetHighPPrecision() {
      return this._highpPrecision;
    }
    GetUnmaskedVendor() {
      return this._unmaskedVendor;
    }
    GetUnmaskedRenderer() {
      return this._unmaskedRenderer;
    }
    GetExtensions() {
      return this._extensions;
    }
    SupportsGPUProfiling() {
      return !!this._timerExt;
    }
    _GetDisjointTimerQueryExtension() {
      return this._timerExt;
    }
    _GetParallelShaderCompileExtension() {
      return this._parallelShaderCompileExt;
    }
    _GetAnisotropicExtension() {
      return this._anisotropicExt;
    }
    _GetMaxAnisotropy() {
      return this._maxAnisotropy;
    }
    _AddQueryResultBuffer(u) {
      this._allQueryResultBuffers.add(u);
    }
    _RemoveQueryResultBuffer(u) {
      this._allQueryResultBuffers.delete(u);
    }
    _GetTimeQueryStack() {
      return this._timeQueryStack;
    }
    GetContext() {
      return this._gl;
    }
    _InitBlendModes(u) {
      this._InitBlendModeData([
        ["normal", u.ONE, u.ONE_MINUS_SRC_ALPHA],
        ["additive", u.ONE, u.ONE],
        ["xor", u.ONE, u.ONE_MINUS_SRC_ALPHA],
        ["copy", u.ONE, u.ZERO],
        ["destination-over", u.ONE_MINUS_DST_ALPHA, u.ONE],
        ["source-in", u.DST_ALPHA, u.ZERO],
        ["destination-in", u.ZERO, u.SRC_ALPHA],
        ["source-out", u.ONE_MINUS_DST_ALPHA, u.ZERO],
        ["destination-out", u.ZERO, u.ONE_MINUS_SRC_ALPHA],
        ["source-atop", u.DST_ALPHA, u.ONE_MINUS_SRC_ALPHA],
        ["destination-atop", u.ONE_MINUS_DST_ALPHA, u.SRC_ALPHA],
      ]);
    }
    CreateRendererText() {
      return e.New(e.Gfx.RendererText, this);
    }
    CreateWebGLText() {
      return this.CreateRendererText();
    }
  };
}
{
  ("use strict");
  const e = {
    getDrawSize: null,
    getRenderTarget: null,
    releaseRenderTarget: null,
    getTime: null,
    redraw: null,
  };
  self.C3.Gfx.EffectChainManager = class {
    constructor(b) {
      b = Object.assign({}, e, b);
      this._cbGetDrawSize = b.getDrawSize;
      this._cbGetRenderTarget = b.getRenderTarget;
      this._cbReleaseRenderTarget = b.releaseRenderTarget;
      this._cbGetTime = b.getTime;
      this._cbRedraw = b.redraw;
      this._webgpuBackTexture = null;
    }
    GetDrawSize(b) {
      return this._cbGetDrawSize
        ? this._cbGetDrawSize(b)
        : [b.GetWidth(), b.GetHeight()];
    }
    GetRenderTarget(b) {
      return this._cbGetRenderTarget(b);
    }
    ReleaseRenderTarget(b, a) {
      this._cbReleaseRenderTarget(b, a);
    }
    GetTime() {
      return this._cbGetTime();
    }
    Redraw(b) {
      this._cbRedraw(b);
    }
    _GetWebGPUBackTexture(b, a, c) {
      !this._webgpuBackTexture ||
        (this._webgpuBackTexture.GetWidth() === a &&
          this._webgpuBackTexture.GetHeight() === c) ||
        (b.DeleteTexture(this._webgpuBackTexture),
        (this._webgpuBackTexture = null));
      null === this._webgpuBackTexture &&
        (this._webgpuBackTexture = b.CreateStaticTexture(null, {
          width: a,
          height: c,
          sampling: "nearest",
          mipMap: !1,
        }));
      return this._webgpuBackTexture;
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.glMatrix.mat4,
    a = e.New(e.Rect),
    c = e.New(e.Rect),
    d = e.New(e.Rect),
    f = e.New(e.Rect),
    h = b.create(),
    g = b.create(),
    k = {
      drawContent: null,
      getSourceTextureInfo: null,
      getShaderParameters: null,
      invalidateRenderTargets: !1,
    },
    m = {
      indexMap: null,
      forcePreDraw: !1,
      forcePostDraw: !1,
      is3D: !1,
      isSourceTextureRotated: !1,
      isRotatedOrNegativeSizeInstance: !1,
      useFullSurface: !1,
    };
  e.Gfx.EffectChain = class {
    constructor(q, v) {
      v = Object.assign({}, k, v);
      this._manager = q;
      this._cbDrawContent = v.drawContent;
      this._cbGetSourceTextureInfo = v.getSourceTextureInfo;
      this._cbGetShaderParameters = v.getShaderParameters;
      this._cbDrawContentHook = null;
      this._shaderProgramList = [];
      this._shaderProgramIndices = [];
      this._steps = [];
      this._blendMode = 0;
      this._isSourceTextureRotated =
        this._useFullSurface =
        this._canUseFastPath =
        this._depthEnabledAtStart =
        this._didChangeTransform =
        this._useCopyTextureBackgroundSampling =
        this._isAnyIsSrcTexRotated =
        this._isAnyShaderCrossSampling =
        this._isAnyShaderBackgroundBlending =
        this._isAnyShaderDepthSampling =
        this._isAnyShaderAnimated =
          !1;
      this._numTempSurfacesRequired = 0;
      this._renderTargets = [null, null, null];
      this._invalidateRenderTargets = !!v.invalidateRenderTargets;
      this._drawHeight =
        this._drawWidth =
        this._boxExtendVertical =
        this._boxExtendHorizontal =
          0;
      this._contextObject = this._contentObject = null;
      this._layoutRect = e.New(e.Rect);
      this._drawSurfaceRect = e.New(e.Rect);
      this._rcTexOriginal = e.New(e.Rect);
      this._rcTexBounce = e.New(e.Rect);
      this._rcTexDest = e.New(e.Rect);
      this._layerScale = this._devicePixelRatio = 1;
      this._time = this._layerAngle = 0;
      this._backTex = this._destRenderTarget = null;
      this._compositOffY = this._compositOffX = 0;
      this._updateOwnProjection = !1;
      this._projectionMatrix = b.create();
      this._modelViewMatrix = b.create();
    }
    Release() {
      e.clearArray(this._steps);
      e.clearArray(this._shaderProgramList);
      e.clearArray(this._shaderProgramIndices);
      this._cbGetShaderParameters =
        this._cbGetSourceTextureInfo =
        this._cbDrawContent =
        this._contextObject =
        this._contentObject =
          null;
    }
    BuildSteps(q, v) {
      v = Object.assign({}, m, v);
      e.clearArray(this._steps);
      this._boxExtendVertical = this._boxExtendHorizontal = 0;
      this._useCopyTextureBackgroundSampling =
        this._isAnyIsSrcTexRotated =
        this._isAnyShaderCrossSampling =
        this._isAnyShaderBackgroundBlending =
        this._isAnyShaderDepthSampling =
        this._isAnyShaderAnimated =
          !1;
      this._numTempSurfacesRequired = 0;
      this._isSourceTextureRotated = !!v.isSourceTextureRotated;
      this._useFullSurface = !!v.useFullSurface;
      e.shallowAssignArray(this._shaderProgramList, q);
      if (0 !== q.length) {
        if (v.indexMap) {
          if (v.indexMap.length !== q.length)
            throw Error("incorrect indexMap length");
          e.shallowAssignArray(this._shaderProgramIndices, v.indexMap);
        } else {
          e.clearArray(this._shaderProgramIndices);
          for (let p = 0, u = q.length; p < u; ++p)
            this._shaderProgramIndices.push(p);
        }
        for (var r of q)
          (this._boxExtendHorizontal += r.GetBoxExtendHorizontal()),
            (this._boxExtendVertical += r.GetBoxExtendVertical()),
            r.IsAnimated() && (this._isAnyShaderAnimated = !0),
            r.UsesDepth() && (this._isAnyShaderDepthSampling = !0),
            r.BlendsBackground() && (this._isAnyShaderBackgroundBlending = !0),
            r.UsesCrossSampling() && (this._isAnyShaderCrossSampling = !0),
            r.UsesIsSrcTexRotated() && (this._isAnyIsSrcTexRotated = !0);
        this._useCopyTextureBackgroundSampling =
          this._ShouldUseCopyTextureBackgroundSampling(q[0].GetRenderer());
        r = this._ShouldPreDraw(q[0], v);
        v = this._ShouldPostDraw(q.at(-1), v);
        if (1 !== q.length || r || v) {
          this._canUseFastPath = !1;
          var n = 0;
          r &&
            ((this._numTempSurfacesRequired = 1),
            this._steps.push(
              e.New(e.Gfx.EffectChain.Step.PreDraw, this, -1, 1)
            ),
            (n = 1));
          for (let p = 0, u = q.length; p < u; ++p)
            0 !== p || r
              ? ((q = 1 === n ? 2 : 1),
                p !== u - 1 || v || (q = 0),
                (this._numTempSurfacesRequired = Math.max(
                  this._numTempSurfacesRequired,
                  q
                )),
                this._steps.push(
                  e.New(e.Gfx.EffectChain.Step.Bounce, this, n, q, p)
                ),
                (n = q))
              : ((this._numTempSurfacesRequired = 1),
                this._steps.push(
                  e.New(e.Gfx.EffectChain.Step.FirstBounce, this, -1, 1, p)
                ),
                (n = 1));
          v &&
            this._steps.push(
              e.New(e.Gfx.EffectChain.Step.PostDraw, this, n, 0)
            );
        } else this._canUseFastPath = !0;
      }
    }
    _ShouldPreDraw(q, v) {
      return v.forcePreDraw ||
        q.MustPreDraw() ||
        v.is3D ||
        (q.UsesDepth() && !this._useFullSurface) ||
        ((0 !== this._boxExtendHorizontal || 0 !== this._boxExtendVertical) &&
          !this._useFullSurface)
        ? !0
        : q.GetRenderer().IsWebGL()
        ? (q.BlendsBackground() &&
            (v.isRotatedOrNegativeSizeInstance || v.isSourceTextureRotated)) ||
          (q.UsesAnySrcRectOrPixelSize() && v.isSourceTextureRotated)
        : !1;
    }
    _ShouldPostDraw(q, v) {
      return v.forcePostDraw
        ? !0
        : q.GetRenderer().IsWebGL()
        ? q.BlendsBackground() || q.UsesCrossSampling()
        : (q.BlendsBackground() || q.UsesCrossSampling()) &&
          this._UseRenderTargetBackgroundSampling();
    }
    _ShouldUseCopyTextureBackgroundSampling(q) {
      return (
        q.IsWebGPU() &&
        this._isAnyShaderBackgroundBlending &&
        !this._isAnyShaderCrossSampling
      );
    }
    Render(q, v, r) {
      q.IsWebGPU() && null === v && (v = q.GetBackbufferRenderTarget());
      this._destRenderTarget = v;
      this._contentObject = r.contentObject || null;
      this._contextObject = r.contextObject || null;
      this._blendMode = r.blendMode || 0;
      this._devicePixelRatio = r.devicePixelRatio || 1;
      this._layerScale = r.layerScale || 1;
      this._layerAngle = r.layerAngle || 0;
      this._time =
        "number" === typeof r.time ? r.time : this._manager.GetTime();
      this._didChangeTransform = !1;
      q.ResetDidChangeTransformFlag();
      this._isAnyShaderAnimated && this._Redraw();
      let n = !1;
      this._UseCopyTextureBackgroundSampling() &&
        (this._CalculateDrawSizeAndRectangles(q, r),
        (n = !0),
        (this._backTex = this._manager._GetWebGPUBackTexture(
          q,
          this._drawWidth,
          this._drawHeight
        )),
        a.copy(this._drawSurfaceRect),
        a.roundOuter(),
        q.CopyTextureToTexture(
          this._destRenderTarget.GetTexture(),
          this._backTex,
          a.getLeft(),
          a.getTop(),
          a.width(),
          a.height()
        ));
      if (this._canUseFastPath) this._Render_FastPath(q, r);
      else {
        n || this._CalculateDrawSizeAndRectangles(q, r);
        q.ResetColor();
        q.SetBaseZ(0);
        q.SetCurrentZ(0);
        this._cbDrawContentHook = r.drawContentHook || null;
        this._compositOffX = r.compositOffX || 0;
        this._compositOffY = r.compositOffY || 0;
        this._updateOwnProjection = !!r.updateOwnProjection;
        this._OnBeforeStartEffectChain(q);
        this._renderTargets[0] = v;
        this._renderTargets[1] =
          1 <= this._numTempSurfacesRequired ? this._GetRenderTarget() : null;
        this._renderTargets[2] =
          2 === this._numTempSurfacesRequired ? this._GetRenderTarget() : null;
        for (const p of this._steps)
          (v = this._GetRenderTargetForId(p.GetSrcTargetId())),
            (r = this._GetRenderTargetForId(p.GetDestTargetId())),
            q.IsWebGPU() ? p.Run_WebGPU(q, v, r) : p.Run_WebGL(q, v, r);
        this._renderTargets[1] &&
          this._ReleaseRenderTarget(this._renderTargets[1]);
        this._renderTargets[2] &&
          this._ReleaseRenderTarget(this._renderTargets[2]);
        this._renderTargets.fill(null);
        this._OnAfterEndEffectChain(q);
        this._cbDrawContentHook =
          this._contextObject =
          this._contentObject =
          this._backTex =
          this._destRenderTarget =
            null;
      }
    }
    _CalculateDrawSizeAndRectangles(q, v) {
      const [r, n] = this._manager.GetDrawSize(q);
      this._SetDrawSize(q, r, n);
      this._CalculateRectangles(v);
    }
    _SetDrawSize(q, v, r) {
      if (0 >= v || 0 >= r) throw Error("invalid draw size");
      (this._drawWidth === v && this._drawHeight === r) ||
        this._CalculateDeviceTransformMatrices(
          q,
          v,
          r,
          0,
          0,
          this._projectionMatrix,
          this._modelViewMatrix
        );
      this._drawWidth = v;
      this._drawHeight = r;
    }
    _CalculateDeviceTransformMatrices(q, v, r, n, p, u, w) {
      n = v / 2 + n;
      p = r / 2 + p;
      q.CalculatePerspectiveMatrix(u, v / r);
      q = q.CalculateLookAtModelView2(n, p, q.GetDefaultCameraZ(r), n, p, 0, r);
      b.copy(w, q);
    }
    _CalculateRectangles(q) {
      this._layoutRect.copy(q.layoutRect);
      q.drawSurfaceRect
        ? this._drawSurfaceRect.copy(q.drawSurfaceRect)
        : this._drawSurfaceRect.set(0, 0, this._drawWidth, this._drawHeight);
      this._rcTexOriginal.copy(this._drawSurfaceRect);
      this._rcTexOriginal.divide(this._drawWidth, this._drawHeight);
      q = this._layerScale * this._devicePixelRatio;
      this._drawSurfaceRect.inflate(
        this._boxExtendHorizontal * q,
        this._boxExtendVertical * q
      );
      this._rcTexDest.copy(this._drawSurfaceRect);
      this._rcTexDest.divide(this._drawWidth, this._drawHeight);
      this._drawSurfaceRect.clamp(0, 0, this._drawWidth, this._drawHeight);
      this._rcTexBounce.copy(this._drawSurfaceRect);
      this._rcTexBounce.divide(this._drawWidth, this._drawHeight);
    }
    _OnBeforeStartEffectChain(q) {
      this._depthEnabledAtStart = q.IsDepthEnabled();
      if (this._useFullSurface)
        q.SetDepthEnabled(!1),
          this._isAnyShaderDepthSampling && q.SetDepthSamplingEnabled(!0);
      else {
        a.copy(this._drawSurfaceRect);
        if (q.IsWebGL()) {
          const v = this._layerScale * this._devicePixelRatio;
          a.inflate(
            Math.max(this._boxExtendHorizontal, 1) * v,
            Math.max(this._boxExtendVertical, 1) * v
          );
          a.roundOuter();
          a.clamp(0, 0, this._drawWidth, this._drawHeight);
        } else a.roundOuter();
        q.SetScissorRect(
          a.getLeft(),
          a.getTop(),
          a.width(),
          a.height(),
          this._drawHeight
        );
      }
    }
    _OnAfterEffectChainDrawContent(q) {
      q.ResetColor();
      this._useFullSurface ||
        (q.SetDepthEnabled(!1),
        this._isAnyShaderDepthSampling && q.SetDepthSamplingEnabled(!0));
      q.IsWebGPU() && q.SetNormalizedCoordsProgramVariant(!0);
    }
    _OnAfterEndEffectChain(q) {
      q.SetDepthSamplingEnabled(!1);
      q.SetDepthEnabled(this._depthEnabledAtStart);
      this._useFullSurface || q.RemoveScissorRect();
      q.IsWebGPU() && q.SetNormalizedCoordsProgramVariant(!1);
      this._didChangeTransform = q.DidChangeTransform();
    }
    _ClampRcTexDest() {
      this._rcTexDest.clamp(0, 0, 1, 1);
    }
    _GetRenderTargetForId(q) {
      return 0 > q ? null : this._renderTargets[q];
    }
    _GetRenderTarget() {
      return this._manager.GetRenderTarget(this);
    }
    _GetDestRenderTarget() {
      return this._destRenderTarget;
    }
    _ReleaseRenderTarget(q) {
      this._manager.ReleaseRenderTarget(q, this);
    }
    _GetShaderProgramAt(q) {
      return this._shaderProgramList[q];
    }
    _DrawContent(q) {
      this._cbDrawContentHook
        ? this._cbDrawContentHook(this, q, () => this._cbDrawContent(q, this))
        : this._cbDrawContent(q, this);
      this._canUseFastPath || this._OnAfterEffectChainDrawContent(q);
    }
    _IsRenderTargetSameSizeAndOffset(q) {
      if (this._useFullSurface) return !0;
      if (0 !== this._compositOffX || 0 !== this._compositOffY) return !1;
      const [v, r] = q.GetRenderTargetSize(q.GetRenderTarget());
      return v !== this._drawWidth || r !== this._drawHeight ? !1 : !0;
    }
    _SetDeviceTransform(q, v) {
      let r = this._projectionMatrix,
        n = this._modelViewMatrix;
      if (v && !this._IsRenderTargetSameSizeAndOffset(q)) {
        r = h;
        n = g;
        const [p, u] = q.GetRenderTargetSize(q.GetRenderTarget());
        this._CalculateDeviceTransformMatrices(
          q,
          p,
          u,
          this._compositOffX,
          this._compositOffY,
          r,
          n
        );
        this._useFullSurface || q.RemoveScissorRect();
      }
      q.SetProjectionMatrix(r);
      q.SetModelViewMatrix(n);
    }
    _Redraw() {
      this._manager.Redraw(this);
    }
    _GetShaderParameters(q) {
      return this._cbGetShaderParameters(this._shaderProgramIndices[q]);
    }
    _SetProgramParameters(q, v) {
      let r = this._rcTexDest,
        n = this._rcTexBounce,
        p = this._rcTexOriginal;
      q.IsWebGL() &&
        (c.copy(r),
        c.flipAround(1),
        (r = c),
        d.copy(n),
        d.flipAround(1),
        (n = d),
        f.copy(p),
        f.flipAround(1),
        (p = f));
      this._DoSetProgramParameters(
        q,
        v,
        n,
        p,
        r,
        1 / this._drawWidth,
        1 / this._drawHeight
      );
    }
    _SetFirstBounceProgramParameters(q, v) {
      let r = this._rcTexBounce,
        n = this._rcTexOriginal,
        p = 1 / this._drawWidth,
        u = 1 / this._drawHeight;
      if (this._cbGetSourceTextureInfo) {
        let {
          srcTexRect: y,
          srcWidth: B,
          srcHeight: E,
        } = this._cbGetSourceTextureInfo(this._contentObject);
        y || (a.set(0, 0, 0, 0), (y = a));
        B || (B = this._drawWidth);
        E || (E = this._drawHeight);
        n = r = y;
        p = 1 / B;
        u = 1 / E;
      } else
        q.IsWebGL() &&
          (d.copy(r),
          d.flipAround(1),
          (r = d),
          f.copy(n),
          f.flipAround(1),
          (n = f));
      let w = this._rcTexDest;
      q.IsWebGL() && ((w = c), w.copy(this._rcTexDest), w.flipAround(1));
      this._DoSetProgramParameters(q, v, r, n, w, p, u);
      q.IsWebGPU() &&
        this._isAnyIsSrcTexRotated &&
        q.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated);
    }
    _GetBackTex(q) {
      return this._isAnyShaderBackgroundBlending
        ? q.IsWebGPU()
          ? this._UseCopyTextureBackgroundSampling()
            ? this._backTex
            : this._destRenderTarget.GetTexture()
          : this._destRenderTarget
        : null;
    }
    _DoSetProgramParameters(q, v, r, n, p, u, w) {
      q.SetProgramParameters(
        this._GetBackTex(q),
        p,
        r,
        n,
        this._layoutRect,
        u,
        w,
        this._devicePixelRatio,
        this._layerScale,
        this._layerAngle,
        this._time
      );
      q.SetProgramCustomParameters(this._GetShaderParameters(v));
    }
    _Render_FastPath(q, v) {
      var r = this._shaderProgramList[0];
      const n = q.IsDepthEnabled(),
        p = r.UsesDepth();
      p &&
        (q.SetDepthEnabled(!1),
        q.SetDepthSamplingEnabled(!0),
        this._rcTexDest.set(0, 0, 1, 1),
        this._rcTexOriginal.set(0, 0, 1, 1));
      q.SetProgram(r);
      q.SetBlendMode(this._blendMode);
      q.SetRenderTarget(this._destRenderTarget);
      let u;
      this._rcTexOriginal.set(0, 0, 1, 1);
      if (r.UsesAnySrcRectOrPixelSize() && this._cbGetSourceTextureInfo) {
        const {
          srcTexRect: w,
          srcWidth: y,
          srcHeight: B,
        } = this._cbGetSourceTextureInfo(this._contentObject);
        w && this._rcTexOriginal.copy(w);
        r = Number.isFinite(y) ? 1 / y : 0;
        u = Number.isFinite(B) ? 1 / B : 0;
      } else {
        const [w, y] = this._manager.GetDrawSize(q);
        r = 1 / w;
        u = 1 / y;
      }
      v.layoutRect
        ? this._layoutRect.copy(v.layoutRect)
        : this._layoutRect.set(0, 0, 0, 0);
      q.SetProgramParameters(
        this._GetBackTex(q),
        this._rcTexDest,
        this._rcTexOriginal,
        this._rcTexOriginal,
        this._layoutRect,
        r,
        u,
        this._devicePixelRatio,
        this._layerScale,
        this._layerAngle,
        this._time
      );
      q.SetProgramCustomParameters(this._GetShaderParameters(0));
      q.IsWebGPU() &&
        this._isAnyIsSrcTexRotated &&
        q.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated);
      q.SetBaseZ(0);
      this._DrawContent(q);
      p && (q.SetDepthSamplingEnabled(!1), q.SetDepthEnabled(n));
    }
    _UseCopyTextureBackgroundSampling() {
      return this._useCopyTextureBackgroundSampling;
    }
    _UseRenderTargetBackgroundSampling() {
      return !this._useCopyTextureBackgroundSampling;
    }
    IsAnyShaderBackgroundBlending() {
      return this._isAnyShaderBackgroundBlending;
    }
    CanSkipCalculatingDrawSurfaceRect() {
      return !this._canUseFastPath || this._UseCopyTextureBackgroundSampling()
        ? !1
        : !0;
    }
    UseFullSurface() {
      return this._useFullSurface;
    }
    GetContentObject() {
      return this._contentObject;
    }
    GetContextObject() {
      return this._contextObject;
    }
    _GetBlendMode() {
      return this._blendMode;
    }
    _UpdateOwnProjection() {
      return this._updateOwnProjection;
    }
    DidChangeTransform() {
      return this._didChangeTransform;
    }
    _GetDrawSurfaceRect() {
      return this._drawSurfaceRect;
    }
    _GetRcTexBounce() {
      return this._rcTexBounce;
    }
    _ShouldInvalidateRenderTargets() {
      return this._invalidateRenderTargets;
    }
    async DebugLogRenderTargetContents(q, v, r) {}
  };
}
("use strict");
self.C3.Gfx.EffectChain.Step = class {
  constructor(e, b, a, c = -1) {
    this._effectChain = e;
    this._srcTargetId = b;
    this._destTargetId = a;
    this._index = c;
  }
  GetEffectChain() {
    return this._effectChain;
  }
  GetSrcTargetId() {
    return this._srcTargetId;
  }
  GetDestTargetId() {
    return this._destTargetId;
  }
  GetIndex() {
    return this._index;
  }
  GetShaderProgram() {
    return this.GetEffectChain()._GetShaderProgramAt(this.GetIndex());
  }
  Run_WebGL(e, b, a) {}
  Run_WebGPU(e, b, a) {}
};
{
  ("use strict");
  const e = self.C3;
  e.Gfx.EffectChain.Step.PreDraw = class extends e.Gfx.EffectChain.Step {
    constructor(b, a, c, d) {
      super(b, a, c, d);
    }
    Run_WebGL(b, a, c) {
      a = this.GetEffectChain();
      b.SetAlphaBlend();
      b.SetTextureFillMode();
      b.SetRenderTarget(c, a._UpdateOwnProjection());
      b.ClearRgba(0, 0, 0, 0);
      a._DrawContent(b);
      a._ClampRcTexDest();
    }
    Run_WebGPU(b, a, c) {
      a = this.GetEffectChain();
      b.SetAlphaBlend();
      b.SetTextureFillMode();
      b.SetRenderTarget(c, !1);
      b.ClearRgba(0, 0, 0, 0);
      a._DrawContent(b);
      a._ClampRcTexDest();
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = e.New(e.Rect),
    a = e.New(e.Quad);
  e.Gfx.EffectChain.Step.PostDraw = class extends e.Gfx.EffectChain.Step {
    constructor(c, d, f, h) {
      super(c, d, f, h);
    }
    Run_WebGL(c, d, f) {
      const h = this.GetEffectChain();
      c.SetTextureFillMode();
      c.SetRenderTarget(f);
      h._SetDeviceTransform(c, !0);
      c.SetBlendMode(h._GetBlendMode());
      c.SetTexture(d.GetTexture());
      a.setFromRect(h._GetDrawSurfaceRect());
      b.copy(h._GetRcTexBounce());
      b.flipAround(1);
      c.Quad3(a, b);
      h._ShouldInvalidateRenderTargets() && c.InvalidateRenderTarget(d);
    }
    Run_WebGPU(c, d, f) {
      const h = this.GetEffectChain();
      c.SetTextureFillMode();
      c.SetRenderTarget(f, !1);
      h._IsRenderTargetSameSizeAndOffset(c)
        ? a.setFromRect(h._GetRcTexBounce())
        : (c.SetNormalizedCoordsProgramVariant(!1),
          h._SetDeviceTransform(c, !0),
          a.setFromRect(h._GetDrawSurfaceRect()));
      c.SetBackTexture(null);
      c.SetBlendMode(h._GetBlendMode());
      c.SetTexture(d.GetTexture());
      h.UseFullSurface() ? c.FullscreenQuad() : c.Quad3(a, h._GetRcTexBounce());
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Gfx.EffectChain.Step.FirstBounce = class extends e.Gfx.EffectChain.Step {
    constructor(b, a, c, d) {
      super(b, a, c, d);
    }
    Run_WebGL(b, a, c) {
      a = this.GetEffectChain();
      b.SetRenderTarget(c, a._UpdateOwnProjection());
      b.ClearRgba(0, 0, 0, 0);
      b.SetCopyBlend();
      b.SetProgram(this.GetShaderProgram());
      a._SetFirstBounceProgramParameters(b, this.GetIndex());
      a._DrawContent(b);
      a._ClampRcTexDest();
    }
    Run_WebGPU(b, a, c) {
      a = this.GetEffectChain();
      b.SetRenderTarget(c, !1);
      b.ClearRgba(0, 0, 0, 0);
      b.SetCopyBlend();
      b.SetProgram(this.GetShaderProgram());
      a._SetFirstBounceProgramParameters(b, this.GetIndex());
      a._DrawContent(b);
      a._ClampRcTexDest();
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = e.New(e.Rect),
    a = e.New(e.Quad);
  e.Gfx.EffectChain.Step.Bounce = class extends e.Gfx.EffectChain.Step {
    constructor(c, d, f, h) {
      super(c, d, f, h);
    }
    Run_WebGL(c, d, f) {
      const h = this.GetEffectChain();
      c.SetRenderTarget(f);
      (f = 0 === this.GetDestTargetId())
        ? c.SetBlendMode(h._GetBlendMode())
        : (c.ClearRgba(0, 0, 0, 0), c.SetCopyBlend());
      c.SetProgram(this.GetShaderProgram());
      h._SetProgramParameters(c, this.GetIndex());
      c.SetTexture(d.GetTexture());
      h._SetDeviceTransform(c, f);
      a.setFromRect(h._GetDrawSurfaceRect());
      b.copy(h._GetRcTexBounce());
      b.flipAround(1);
      c.Quad3(a, b);
      h._ShouldInvalidateRenderTargets() && c.InvalidateRenderTarget(d);
    }
    Run_WebGPU(c, d, f) {
      const h = this.GetEffectChain();
      c.SetRenderTarget(f, !1);
      0 === this.GetDestTargetId()
        ? (c.SetBlendMode(h._GetBlendMode()),
          c.SetBackTexture(null),
          h._IsRenderTargetSameSizeAndOffset(c)
            ? a.setFromRect(h._GetRcTexBounce())
            : (c.SetNormalizedCoordsProgramVariant(!1),
              h._SetDeviceTransform(c, !0),
              a.setFromRect(h._GetDrawSurfaceRect())))
        : (c.ClearRgba(0, 0, 0, 0),
          c.SetCopyBlend(),
          a.setFromRect(h._GetRcTexBounce()));
      c.SetProgram(this.GetShaderProgram());
      h._SetProgramParameters(c, this.GetIndex());
      c.SetTexture(d.GetTexture());
      h.UseFullSurface() ? c.FullscreenQuad() : c.Quad3(a, h._GetRcTexBounce());
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.C3X;
  let a = null;
  const c = new Set();
  function d(k, m) {
    const q = k[0] - m[0];
    return 0 !== q ? q : k[1] - m[1];
  }
  const f = [],
    h = [];
  let g = !1;
  self.IRuntime = class {
    constructor(k, m) {
      a = k;
      Object.defineProperties(this, {
        assets: { value: a.GetAssetManager().GetIAssetManager(), writable: !1 },
        objects: { value: m, writable: !1 },
        globalVars: { value: {}, writable: !1 },
        projectName: { value: a.GetProjectName(), writable: !1 },
        projectVersion: { value: a.GetProjectVersion(), writable: !1 },
        storage: { value: new self.IStorage(a), writable: !1 },
        isInWorker: { value: a.IsInWorker(), writable: !1 },
      });
      a.UserScriptDispatcher().addEventListener("keydown", (q) => {
        c.has(q.key) ? q.stopPropagation() : c.add(q.key);
      });
      a.UserScriptDispatcher().addEventListener("keyup", (q) =>
        c.delete(q.key)
      );
      a.Dispatcher().addEventListener("window-blur", () => c.clear());
      a.IsInWorker() &&
        (self.alert = (q) => {
          g ||
            ((g = !0),
            console.warn(
              "[Construct 3] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual."
            ));
          return this.alert(q);
        });
    }
    _InitGlobalVars(k) {
      Object.defineProperties(this.globalVars, k);
    }
    addEventListener(k, m) {
      a.UserScriptDispatcher().addEventListener(k, m);
    }
    removeEventListener(k, m) {
      a.UserScriptDispatcher().removeEventListener(k, m);
    }
    callFunction(k, ...m) {
      b.RequireString(k);
      const q = a.GetEventSheetManager(),
        v = q.GetFunctionBlockByName(k);
      if (!v) throw Error(`cannot find function name '${k}'`);
      if (!v.IsEnabled()) return v.GetDefaultReturnValue();
      if (m.length < v.GetFunctionParameterCount())
        throw Error(
          `not enough function parameters passed for '${k}' (${
            m.length
          } passed, ${v.GetFunctionParameterCount()} expected)`
        );
      const r = v.GetEventBlock();
      k = null;
      var n = q.GetCurrentEvent();
      n &&
        ((n = n.GetSolModifiersIncludingParents()),
        0 < n.length && ((k = n), q.PushCleanSol(n)));
      m = r.RunAsExpressionFunctionCall(
        r.GetSolModifiersIncludingParents(),
        v.GetReturnType(),
        v.GetDefaultReturnValue(),
        ...m
      );
      k && q.PopSol(k);
      return m;
    }
    setReturnValue(k) {
      const m = a.GetEventStack().GetCurrentExpFuncStackFrame();
      if (!m) throw Error("not in a function which returns a value");
      switch (m.GetFunctionReturnType()) {
        case 1:
          "number" === typeof k && m.SetFunctionReturnValue(k);
          break;
        case 2:
          "string" === typeof k && m.SetFunctionReturnValue(k);
          break;
        case 3:
          ("number" !== typeof k && "string" !== typeof k) ||
            m.SetFunctionReturnValue(k);
      }
    }
    get dt() {
      return a.GetDt();
    }
    get gameTime() {
      return a.GetGameTime();
    }
    get wallTime() {
      return a.GetWallTime();
    }
    random() {
      return a.Random();
    }
    get layout() {
      return a.GetMainRunningLayout().GetILayout();
    }
    getLayout(k) {
      const m = a.GetLayoutManager();
      if ("number" === typeof k || "string" === typeof k) k = m.GetLayout(k);
      else throw new TypeError("expected string or number");
      if (!k) throw Error("invalid layout");
      return k.GetILayout();
    }
    getAllLayouts() {
      return a
        .GetLayoutManager()
        .GetAllLayouts()
        .map((k) => k.GetILayout());
    }
    goToLayout(k) {
      const m = a.GetLayoutManager();
      if ("number" === typeof k || "string" === typeof k) k = m.GetLayout(k);
      else throw new TypeError("expected string or number");
      if (!k) throw Error("invalid layout");
      m.IsPendingChangeMainLayout() || m.ChangeMainLayout(k);
    }
    get keyboard() {
      const k = a._GetCommonScriptInterfaces().keyboard;
      if (!k)
        throw Error(
          "runtime.keyboard used but Keyboard object missing - add it to your project first"
        );
      return k;
    }
    get mouse() {
      const k = a._GetCommonScriptInterfaces().mouse;
      if (!k)
        throw Error(
          "runtime.mouse used but Mouse object missing - add it to your project first"
        );
      return k;
    }
    get touch() {
      const k = a._GetCommonScriptInterfaces().touch;
      if (!k)
        throw Error(
          "runtime.touch used but Touch object missing - add it to your project first"
        );
      return k;
    }
    invokeDownload(k, m) {
      b.RequireString(k);
      b.RequireString(m);
      a.InvokeDownload(k, m);
    }
    getInstanceByUid(k) {
      b.RequireFiniteNumber(k);
      return (k = a.GetInstanceByUID(k)) ? k.GetInterfaceClass() : null;
    }
    sortZOrder(k, m) {
      b.RequireFunction(m);
      const q = a.GetCurrentLayout();
      for (var v of k) {
        k = a._UnwrapIWorldInstance(v);
        var r = k.GetWorldInfo();
        f.push([r.GetLayer().GetIndex(), r.GetZIndex()]);
        h.push(k);
      }
      if (0 !== f.length) {
        f.sort(d);
        h.sort((n, p) => m(n.GetInterfaceClass(), p.GetInterfaceClass()));
        v = !1;
        for (let n = 0, p = f.length; n < p; ++n) {
          k = h[n];
          r = q.GetLayerByIndex(f[n][0]);
          const u = f[n][1],
            w = r._GetInstances();
          w[u] !== k &&
            ((w[u] = k),
            k.GetWorldInfo()._SetLayer(r),
            r.SetZIndicesChanged(),
            (v = !0));
        }
        v && a.UpdateRender();
        e.clearArray(f);
        e.clearArray(h);
      }
    }
    alert(k) {
      return a.PostComponentMessageToDOMAsync("runtime", "alert", {
        message: k + (a.IsInWorker() ? " [via Web Worker]" : ""),
      });
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  let b = null;
  self.IAssetManager = class {
    constructor(a) {
      b = a;
      Object.defineProperties(this, {
        isWebMOpusSupported: {
          value: b.IsAudioFormatSupported("audio/webm; codecs=opus"),
          writable: !1,
        },
      });
    }
    fetchText(a) {
      return b.FetchText(a);
    }
    fetchJson(a) {
      return b.FetchJson(a);
    }
    fetchBlob(a) {
      return b.FetchBlob(a);
    }
    fetchArrayBuffer(a) {
      return b.FetchArrayBuffer(a);
    }
    getProjectFileUrl(a) {
      return b.GetProjectFileUrl(a);
    }
    getMediaFileUrl(a) {
      e.IsRelativeURL(a) && (a = a.toLowerCase());
      return b.GetMediaFileUrl(a, b.GetMediaSubfolder());
    }
    get mediaFolder() {
      return b.GetMediaSubfolder();
    }
    async decodeWebMOpus(a, c) {
      if (this.isWebMOpusSupported)
        throw Error(
          "decodeWebMOpus(): not supported because WebM Opus is supported by the platform"
        );
      c = await b.GetRuntime()._WasmDecodeWebMOpus(c);
      c = new Float32Array(c);
      a = a.createBuffer(1, c.length, 48e3);
      a.getChannelData(0).set(c);
      return a;
    }
    loadScripts(...a) {
      return b.LoadScripts(...a);
    }
    compileWebAssembly(a) {
      return b.CompileWebAssembly(a);
    }
    loadStyleSheet(a) {
      return b.LoadStyleSheet(a);
    }
  };
}
{
  ("use strict");
  const e = self.C3X;
  self.IStorage = class {
    constructor(b) {
      this._storage = b._GetProjectStorage();
    }
    getItem(b) {
      e.RequireString(b);
      return this._storage.getItem(b);
    }
    setItem(b, a) {
      e.RequireString(b);
      return this._storage.setItem(b, a);
    }
    removeItem(b) {
      e.RequireString(b);
      return this._storage.removeItem(b);
    }
    clear() {
      return this._storage.clear();
    }
    keys() {
      return this._storage.keys();
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.C3X,
    a = new WeakMap();
  self.IObjectClass = class {
    constructor(c) {
      a.set(this, c);
      Object.defineProperties(this, {
        name: { value: c.GetName(), writable: !1 },
      });
      c.GetRuntime()._MapScriptInterface(this, c);
    }
    addEventListener(c, d) {
      b.RequireString(c);
      b.RequireFunction(d);
      a.get(this).UserScriptDispatcher().addEventListener(c, d);
    }
    removeEventListener(c, d) {
      b.RequireString(c);
      b.RequireFunction(d);
      a.get(this).UserScriptDispatcher().removeEventListener(c, d);
    }
    getAllInstances() {
      return [...this.instances()];
    }
    getFirstInstance() {
      return e.first(this.instances());
    }
    getPickedInstances() {
      return [...this.pickedInstances()];
    }
    getFirstPickedInstance() {
      return e.first(this.pickedInstances());
    }
    *instances() {
      for (const c of a.get(this).instancesIncludingPendingCreate())
        yield c.GetInterfaceClass();
    }
    *pickedInstances() {
      for (const c of a.get(this).GetCurrentSol().GetInstances())
        yield c.GetInterfaceClass();
    }
    setInstanceClass(c) {
      b.RequireFunction(c);
      if (0 < a.get(this).GetInstanceCount())
        throw Error(
          "setInstanceClass() called too late, because instances have already been created - call in runOnStartup"
        );
      a.get(this)._SetUserScriptInstanceClass(c);
    }
    createInstance(c, d, f, h, g) {
      b.RequireNumber(d);
      b.RequireNumber(f);
      if ("number" !== typeof c && "string" !== typeof c)
        throw new TypeError("invalid layer parameter");
      const k = a.get(this),
        m = k.GetRuntime();
      c = m.GetMainRunningLayout().GetLayer(c);
      if (!c) throw Error("invalid layer");
      d = m.CreateInstance(k, c, d, f, h, g);
      h && c.SortAndAddInstancesByZIndex(d);
      h = m.GetEventSheetManager();
      h.BlockFlushingInstances(!0);
      d._TriggerOnCreatedOnSelfAndRelated();
      h.BlockFlushingInstances(!1);
      h.IsInEventEngine() || m.FlushPendingInstances();
      return d.GetInterfaceClass();
    }
  };
}
{
  ("use strict");
  const e = self.C3X,
    b = new WeakMap();
  self.ILayout = class {
    constructor(a) {
      b.set(this, a);
      const c = [],
        d = a.GetEffectList(),
        f = d.GetAllEffectTypes().length;
      for (let h = 0; h < f; ++h) c.push(new self.IEffectInstance(d, h));
      Object.defineProperties(this, {
        name: { value: a.GetName(), writable: !1 },
        index: { value: a.GetIndex(), writable: !1 },
        effects: { value: c, writable: !1 },
      });
    }
    addEventListener(a, c) {
      e.RequireString(a);
      e.RequireFunction(c);
      b.get(this).UserScriptDispatcher().addEventListener(a, c);
    }
    removeEventListener(a, c) {
      e.RequireString(a);
      e.RequireFunction(c);
      b.get(this).UserScriptDispatcher().removeEventListener(a, c);
    }
    get width() {
      return b.get(this).GetWidth();
    }
    set width(a) {
      b.get(this).SetWidth(a);
    }
    get height() {
      return b.get(this).GetHeight();
    }
    set height(a) {
      b.get(this).SetHeight(a);
    }
    set scale(a) {
      e.RequireFiniteNumber(a);
      b.get(this).SetScale(a);
    }
    get scale() {
      return b.get(this).GetScale();
    }
    set angle(a) {
      e.RequireFiniteNumber(a);
      b.get(this).SetAngle(a);
    }
    get angle() {
      return b.get(this).GetAngle();
    }
    set scrollX(a) {
      e.RequireNumber(a);
      b.get(this).SetScrollX(a);
    }
    get scrollX() {
      return b.get(this).GetScrollX();
    }
    set scrollY(a) {
      e.RequireNumber(a);
      b.get(this).SetScrollY(a);
    }
    get scrollY() {
      return b.get(this).GetScrollY();
    }
    scrollTo(a, c) {
      e.RequireNumber(a);
      e.RequireNumber(c);
      const d = b.get(this);
      d.SetScrollX(a);
      d.SetScrollY(c);
    }
    getLayer(a) {
      const c = b.get(this);
      if ("number" === typeof a || "string" === typeof a) a = c.GetLayer(a);
      else throw new TypeError("expected string or number");
      return a ? a.GetILayer() : null;
    }
    getAllLayers() {
      return b
        .get(this)
        .GetLayers()
        .map((a) => a.GetILayer());
    }
    *allLayers() {
      for (const a of b.get(this).allLayers()) yield a.GetILayer();
    }
    setVanishingPoint(a, c) {
      e.RequireFiniteNumber(a);
      e.RequireFiniteNumber(c);
      b.get(this).SetVanishingPointXY(a, c);
    }
    getVanishingPoint() {
      return b.get(this)._GetVanishingPoint();
    }
    set projection(a) {
      e.RequireString(a);
      const c = b.get(this);
      if ("perspective" === a) c.SetPerspectiveProjection();
      else if ("orthographic" === a) c.SetOrthographicProjection();
      else throw Error("invalid projection");
    }
    get projection() {
      return b.get(this).IsOrthographicProjection()
        ? "orthographic"
        : "perspective";
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.C3X,
    a = new WeakMap(),
    c = new Map([
      ["normal", 0],
      ["additive", 1],
      ["copy", 3],
      ["destination-over", 4],
      ["source-in", 5],
      ["destination-in", 6],
      ["source-out", 7],
      ["destination-out", 8],
      ["source-atop", 9],
      ["destination-atop", 10],
    ]),
    d = new Map([...c.entries()].map((h) => [h[1], h[0]])),
    f = e.New(e.Color);
  self.ILayer = class {
    constructor(h) {
      a.set(this, h);
      const g = [],
        k = h.GetEffectList(),
        m = k.GetAllEffectTypes().length;
      for (let q = 0; q < m; ++q) g.push(new self.IEffectInstance(k, q));
      Object.defineProperties(this, {
        name: { value: h.GetName(), writable: !1 },
        index: { value: h.GetIndex(), writable: !1 },
        layout: { value: h.GetLayout().GetILayout(), writable: !1 },
        effects: { value: g, writable: !1 },
      });
    }
    static _Unwrap(h) {
      return a.get(h);
    }
    get parentLayer() {
      const h = a.get(this).GetParentLayer();
      return h ? h.GetILayer() : null;
    }
    *parentLayers() {
      for (const h of a.get(this).parentLayers()) yield h.GetILayer();
    }
    *subLayers() {
      for (const h of a.get(this).GetSubLayers()) yield h.GetILayer();
    }
    *allSubLayers() {
      for (const h of a.get(this).GetSubLayers())
        for (const g of h.selfAndAllSubLayers()) yield g.GetILayer();
    }
    get isVisible() {
      return a.get(this)._IsVisibleFlagSet();
    }
    set isVisible(h) {
      a.get(this).SetVisible(h);
    }
    get isSelfAndParentsVisible() {
      return a.get(this).IsVisible();
    }
    get isInteractive() {
      return a.get(this).IsInteractive();
    }
    set isInteractive(h) {
      a.get(this).SetInteractive(h);
    }
    get isSelfAndParentsInteractive() {
      return a.get(this).IsSelfAndParentsInteractive();
    }
    get opacity() {
      return a.get(this).GetOpacity();
    }
    set opacity(h) {
      h = e.clamp(+h, 0, 1);
      isNaN(h) || a.get(this).SetOpacity(h);
    }
    set scale(h) {
      b.RequireFiniteNumber(h);
      a.get(this).SetOwnScale(h);
    }
    get scale() {
      return a.get(this).GetOwnScale();
    }
    set scaleRate(h) {
      b.RequireFiniteNumber(h);
      a.get(this).SetScaleRate(h);
    }
    get scaleRate() {
      return a.get(this).GetScaleRate();
    }
    set angle(h) {
      b.RequireFiniteNumber(h);
      a.get(this).SetAngle(h);
    }
    get angle() {
      return a.get(this).GetOwnAngle();
    }
    set parallaxX(h) {
      b.RequireFiniteNumber(h);
      a.get(this).SetParallaxX(h);
    }
    get parallaxX() {
      return a.get(this).GetParallaxX();
    }
    set parallaxY(h) {
      b.RequireFiniteNumber(h);
      a.get(this).SetParallaxY(h);
    }
    get parallaxY() {
      return a.get(this).GetParallaxY();
    }
    set zElevation(h) {
      b.RequireFiniteNumber(h);
      a.get(this).SetZElevation(h);
    }
    get zElevation() {
      return a.get(this).GetZElevation();
    }
    set isTransparent(h) {
      a.get(this).SetTransparent(h);
    }
    get isTransparent() {
      return a.get(this).IsTransparent();
    }
    set isForceOwnTexture(h) {
      a.get(this).SetForceOwnTexture(h);
    }
    get isForceOwnTexture() {
      return a.get(this).IsForceOwnTexture();
    }
    set blendMode(h) {
      b.RequireString(h);
      h = c.get(h);
      if ("number" !== typeof h) throw Error("invalid blend mode");
      a.get(this).SetBlendMode(h);
    }
    get blendMode() {
      return d.get(a.get(this).GetBlendMode());
    }
    set backgroundColor(h) {
      b.RequireArray(h);
      if (3 > h.length) throw Error("expected 3 elements");
      f.setRgb(h[0], h[1], h[2]);
      h = a.get(this);
      const g = h.GetBackgroundColor();
      g.equalsIgnoringAlpha(f) || (g.copyRgb(f), h.GetRuntime().UpdateRender());
    }
    get backgroundColor() {
      const h = a.get(this).GetBackgroundColor();
      return [h.getR(), h.getG(), h.getB()];
    }
    set scrollX(h) {
      b.RequireNumber(h);
      const g = a.get(this);
      g.SetOwnScrollPositionEnabled(!0);
      g.SetScrollX(h);
    }
    get scrollX() {
      return a.get(this).GetScrollX();
    }
    set scrollY(h) {
      b.RequireNumber(h);
      const g = a.get(this);
      g.SetOwnScrollPositionEnabled(!0);
      g.SetScrollY(h);
    }
    get scrollY() {
      return a.get(this).GetScrollY();
    }
    scrollTo(h, g) {
      b.RequireNumber(h);
      b.RequireNumber(g);
      const k = a.get(this);
      k.SetOwnScrollPositionEnabled(!0);
      k.SetScrollX(h);
      k.SetScrollY(g);
    }
    restoreScrollPosition() {
      a.get(this).SetOwnScrollPositionEnabled(!1);
    }
    getViewport() {
      return a.get(this).GetViewport().toDOMRect();
    }
    cssPxToLayer(h, g, k = 0) {
      b.RequireNumber(h);
      b.RequireNumber(g);
      b.RequireNumber(k);
      const m = a.get(this),
        q = m.GetRuntime();
      return m.CanvasCssToLayer(
        h - q.GetCanvasClientX(),
        g - q.GetCanvasClientY(),
        k
      );
    }
    layerToCssPx(h, g, k = 0) {
      b.RequireNumber(h);
      b.RequireNumber(g);
      b.RequireNumber(k);
      const m = a.get(this),
        q = m.GetRuntime(),
        [v, r] = m.LayerToCanvasCss(h, g, k);
      return [v + q.GetCanvasClientX(), r + q.GetCanvasClientY()];
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.C3X,
    a = new WeakMap(),
    c = new WeakMap();
  function d(h) {
    let g = c.get(h);
    if (g) return g;
    g = e.New(e.Event.Dispatcher);
    c.set(h, g);
    return g;
  }
  let f = null;
  self.IInstance = class {
    constructor() {
      a.set(this, f);
      const h = {
        runtime: { value: f.GetRuntime().GetIRuntime(), writable: !1 },
        objectType: {
          value: f.GetObjectClass().GetIObjectClass(),
          writable: !1,
        },
        uid: { value: f.GetUID(), writable: !1 },
      };
      f._GetInstVarsScriptDescriptor(h);
      f._GetBehaviorsScriptDescriptor(h);
      Object.defineProperties(this, h);
      f.GetRuntime()._MapScriptInterface(this, f);
    }
    static _Init(h) {
      f = h;
    }
    static _GetInitInst() {
      return f;
    }
    _Release() {
      const h = c.get(this);
      h && (h.Release(), c.delete(this));
      a.delete(this);
    }
    addEventListener(h, g, k) {
      b.RequireString(h);
      b.RequireFunction(g);
      d(this).addEventListener(h, g, k);
    }
    removeEventListener(h, g, k) {
      b.RequireString(h);
      b.RequireFunction(g);
      d(this).removeEventListener(h, g, k);
    }
    dispatchEvent(h) {
      d(this).dispatchEvent(h);
    }
    destroy() {
      const h = a.get(this),
        g = h.GetRuntime();
      g.DestroyInstance(h);
      g.GetEventSheetManager().IsInEventEngine() || g.FlushPendingInstances();
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.C3X,
    a = self.IInstance,
    c = self.ILayer,
    d = new WeakMap(),
    f = new Map([
      ["normal", 0],
      ["additive", 1],
      ["copy", 3],
      ["destination-over", 4],
      ["source-in", 5],
      ["destination-in", 6],
      ["source-out", 7],
      ["destination-out", 8],
      ["source-atop", 9],
      ["destination-atop", 10],
    ]),
    h = new Map([...f.entries()].map((k) => [k[1], k[0]])),
    g = e.New(e.Color);
  self.IWorldInstance = class k extends a {
    constructor() {
      super();
      var m = a._GetInitInst();
      d.set(this, m);
      const q = [];
      var v = m.GetWorldInfo();
      if ((m = v.GetInstanceEffectList())) {
        v = v.GetObjectClass().GetEffectList().GetAllEffectTypes().length;
        for (let r = 0; r < v; ++r) q.push(new self.IEffectInstance(m, r));
      }
      Object.defineProperties(this, { effects: { value: q, writable: !1 } });
    }
    get layout() {
      return d.get(this).GetWorldInfo().GetLayout().GetILayout();
    }
    get layer() {
      return d.get(this).GetWorldInfo().GetLayer().GetILayer();
    }
    get x() {
      return d.get(this).GetWorldInfo().GetX();
    }
    set x(m) {
      m = +m;
      const q = d.get(this).GetWorldInfo();
      isNaN(m) || q.GetX() === m || (q.SetX(m), q.SetBboxChanged());
    }
    get y() {
      return d.get(this).GetWorldInfo().GetY();
    }
    set y(m) {
      m = +m;
      const q = d.get(this).GetWorldInfo();
      isNaN(m) || q.GetY() === m || (q.SetY(m), q.SetBboxChanged());
    }
    get zElevation() {
      return d.get(this).GetWorldInfo().GetZElevation();
    }
    set zElevation(m) {
      m = +m;
      const q = d.get(this),
        v = q.GetWorldInfo();
      isNaN(m) ||
        v.GetZElevation() === m ||
        (v.SetZElevation(m), q.GetRuntime().UpdateRender());
    }
    get totalZElevation() {
      return d.get(this).GetWorldInfo().GetTotalZElevation();
    }
    get width() {
      return d.get(this).GetWorldInfo().GetWidth();
    }
    set width(m) {
      m = +m;
      const q = d.get(this).GetWorldInfo();
      isNaN(m) || q.GetWidth() === m || (q.SetWidth(m), q.SetBboxChanged());
    }
    get height() {
      return d.get(this).GetWorldInfo().GetHeight();
    }
    set height(m) {
      m = +m;
      const q = d.get(this).GetWorldInfo();
      isNaN(m) || q.GetHeight() === m || (q.SetHeight(m), q.SetBboxChanged());
    }
    get angle() {
      return d.get(this).GetWorldInfo().GetAngle();
    }
    set angle(m) {
      m = e.clampAngle(+m);
      const q = d.get(this).GetWorldInfo();
      isNaN(m) || q.GetAngle() === m || (q.SetAngle(m), q.SetBboxChanged());
    }
    get angleDegrees() {
      return e.toDegrees(this.angle);
    }
    set angleDegrees(m) {
      this.angle = e.toRadians(m);
    }
    getBoundingBox() {
      return d.get(this).GetWorldInfo().GetBoundingBox().toDOMRect();
    }
    getBoundingQuad() {
      return d.get(this).GetWorldInfo().GetBoundingQuad().toDOMQuad();
    }
    get isVisible() {
      return d.get(this).GetWorldInfo().IsVisible();
    }
    set isVisible(m) {
      m = !!m;
      const q = d.get(this),
        v = q.GetWorldInfo();
      v.IsVisible() !== m && (v.SetVisible(m), q.GetRuntime().UpdateRender());
    }
    get opacity() {
      return d.get(this).GetWorldInfo().GetOpacity();
    }
    set opacity(m) {
      m = e.clamp(+m, 0, 1);
      const q = d.get(this),
        v = q.GetWorldInfo();
      isNaN(m) ||
        v.GetOpacity() === m ||
        (v.SetOpacity(m), q.GetRuntime().UpdateRender());
    }
    set colorRgb(m) {
      b.RequireArray(m);
      if (3 > m.length) throw Error("expected 3 elements");
      g.setRgb(m[0], m[1], m[2]);
      m = d.get(this);
      const q = m.GetWorldInfo();
      q.GetUnpremultipliedColor().equalsIgnoringAlpha(g) ||
        (q.SetUnpremultipliedColor(g), m.GetRuntime().UpdateRender());
    }
    get colorRgb() {
      const m = d.get(this).GetWorldInfo().GetUnpremultipliedColor();
      return [m.getR(), m.getG(), m.getB()];
    }
    set blendMode(m) {
      b.RequireString(m);
      m = f.get(m);
      if ("number" !== typeof m) throw Error("invalid blend mode");
      const q = d.get(this);
      q.GetWorldInfo().SetBlendMode(m);
      q.GetRuntime().UpdateRender();
    }
    get blendMode() {
      return h.get(d.get(this).GetWorldInfo().GetBlendMode());
    }
    moveToTop() {
      d.get(this).GetWorldInfo().ZOrderMoveToTop();
    }
    moveToBottom() {
      d.get(this).GetWorldInfo().ZOrderMoveToBottom();
    }
    moveToLayer(m) {
      b.RequireInstanceOf(m, c);
      m = c._Unwrap(m);
      if (!m) throw Error("invalid layer");
      d.get(this).GetWorldInfo().ZOrderMoveToLayer(m);
    }
    moveAdjacentToInstance(m, q) {
      b.RequireInstanceOf(m, k);
      d.get(this).GetWorldInfo().ZOrderMoveAdjacentToInstance(d.get(m), q);
    }
    get zIndex() {
      return d.get(this).GetWorldInfo().GetZIndex();
    }
    containsPoint(m, q) {
      b.RequireNumber(m);
      b.RequireNumber(q);
      return d.get(this).GetWorldInfo().ContainsPoint(+m, +q);
    }
    testOverlap(m) {
      b.RequireInstanceOf(m, k);
      const q = d.get(this);
      m = d.get(m);
      return q.GetRuntime().GetCollisionEngine().TestOverlap(q, m);
    }
    testOverlapSolid() {
      var m = d.get(this);
      return (m = m.GetRuntime().GetCollisionEngine().TestOverlapSolid(m))
        ? m.GetInterfaceClass()
        : null;
    }
    getParent() {
      const m = d.get(this).GetParent();
      return m ? m.GetInterfaceClass() : null;
    }
    getTopParent() {
      const m = d.get(this).GetTopParent();
      return m ? m.GetInterfaceClass() : null;
    }
    *parents() {
      for (const m of d.get(this).parents()) yield m.GetInterfaceClass();
    }
    getChildCount() {
      return d.get(this).GetChildCount();
    }
    getChildAt(m) {
      return (m = d.get(this).GetChildAt(m)) ? m.GetInterfaceClass() : null;
    }
    *children() {
      for (const m of d.get(this).children()) yield m.GetInterfaceClass();
    }
    *allChildren() {
      for (const m of d.get(this).allChildren()) yield m.GetInterfaceClass();
    }
    addChild(m, q) {
      b.RequireInstanceOf(m, k);
      b.RequireOptionalObject(q);
      q || (q = {});
      const v = d.get(this);
      m = d.get(m);
      v.AddChild(m, q);
    }
    removeChild(m) {
      b.RequireInstanceOf(m, k);
      const q = d.get(this);
      m = d.get(m);
      q.RemoveChild(m);
    }
    removeFromParent() {
      const m = d.get(this);
      m.HasParent() && m.GetParent().RemoveChild(m);
    }
    createMesh(m, q) {
      b.RequireFiniteNumber(m);
      b.RequireFiniteNumber(q);
      d.get(this).GetWorldInfo().CreateMesh(m, q);
    }
    releaseMesh() {
      const m = d.get(this).GetWorldInfo();
      m.ReleaseMesh();
      m.SetBboxChanged();
    }
    setMeshPoint(m, q, v) {
      b.RequireFiniteNumber(m);
      b.RequireFiniteNumber(q);
      b.RequireObject(v);
      const r = d.get(this).GetWorldInfo();
      r.SetMeshPoint(m, q, v) && r.SetBboxChanged();
    }
    getMeshSize() {
      var m = d.get(this).GetWorldInfo();
      if (!m.HasMesh()) return [0, 0];
      m = m.GetSourceMesh();
      return [m.GetHSize(), m.GetVSize()];
    }
  };
}
{
  ("use strict");
  const e = self.C3X,
    b = new WeakMap();
  self.IDOMInstance = class extends self.IWorldInstance {
    constructor() {
      super();
      b.set(this, self.IInstance._GetInitInst());
    }
    getElement() {
      return b.get(this).GetSdkInstance()._GetElementInDOMMode();
    }
    focus() {
      b.get(this).GetSdkInstance().FocusElement();
    }
    blur() {
      b.get(this).GetSdkInstance().BlurElement();
    }
    setCssStyle(a, c) {
      e.RequireString(a);
      b.get(this).GetSdkInstance().SetElementCSSStyle(a, c);
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.C3X,
    a = new WeakMap(),
    c = new WeakMap();
  function d(h) {
    let g = c.get(h);
    if (g) return g;
    g = e.New(e.Event.Dispatcher);
    c.set(h, g);
    return g;
  }
  let f = null;
  self.IBehaviorInstance = class {
    constructor() {
      a.set(this, f);
      const h = {
        runtime: { value: f.GetRuntime().GetIRuntime(), writable: !1 },
        behavior: { value: f.GetBehavior().GetIBehavior(), writable: !1 },
      };
      Object.defineProperties(this, h);
    }
    static _Init(h) {
      f = h;
    }
    static _GetInitInst() {
      return f;
    }
    get instance() {
      return a.get(this).GetObjectInstance().GetInterfaceClass();
    }
    _Release() {
      const h = c.get(this);
      h && (h.Release(), c.delete(this));
      a.delete(this);
    }
    addEventListener(h, g, k) {
      b.RequireString(h);
      b.RequireFunction(g);
      d(this).addEventListener(h, g, k);
    }
    removeEventListener(h, g, k) {
      b.RequireString(h);
      b.RequireFunction(g);
      d(this).removeEventListener(h, g, k);
    }
    dispatchEvent(h) {
      d(this).dispatchEvent(h);
    }
  };
}
{
  ("use strict");
  const e = new WeakMap();
  self.IBehavior = class {
    constructor(b) {
      e.set(this, b);
      b = { runtime: { value: b.GetRuntime().GetIRuntime(), writable: !1 } };
      Object.defineProperties(this, b);
    }
    getAllInstances() {
      return e
        .get(this)
        .GetInstances()
        .map((b) => b.GetInterfaceClass());
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.C3X,
    a = new WeakMap(),
    c = e.New(e.Color);
  self.IEffectInstance = class {
    constructor(d, f) {
      a.set(this, d);
      Object.defineProperties(this, { index: { value: f, writable: !1 } });
    }
    get name() {
      return a.get(this).GetAllEffectTypes()[this.index].GetName();
    }
    get isActive() {
      return a.get(this).IsEffectIndexActive(this.index);
    }
    set isActive(d) {
      d = !!d;
      const f = a.get(this);
      f.IsEffectIndexActive(this.index) !== d &&
        (f.SetEffectIndexActive(this.index, d),
        f.UpdateActiveEffects(),
        f.GetRuntime().UpdateRender());
    }
    setParameter(d, f) {
      b.RequireFiniteNumber(d);
      d = Math.floor(+d);
      const h = a.get(this),
        g = h.GetEffectParameter(this.index, d);
      if (null === g) throw new RangeError("invalid index");
      if (g instanceof e.Color) {
        if (!Array.isArray(f) || 3 > f.length)
          throw new TypeError("expected array with 3 elements");
        c.setRgb(f[0], f[1], f[2]);
        f = c;
      } else if ("number" !== typeof f) throw new TypeError("expected number");
      h.SetEffectParameter(this.index, d, f) &&
        h.IsEffectIndexActive(this.index) &&
        h.GetRuntime().UpdateRender();
    }
    getParameter(d) {
      b.RequireFiniteNumber(d);
      d = Math.floor(+d);
      d = a.get(this).GetEffectParameter(this.index, d);
      if (null === d) throw new RangeError("invalid index");
      return d instanceof e.Color ? [d.getR(), d.getG(), d.getB()] : d;
    }
  };
}
{
  ("use strict");
  const e = new WeakMap();
  self.IAnimation = class {
    constructor(b) {
      e.set(this, b);
      Object.defineProperties(this, {
        name: { value: b.GetName(), writable: !1 },
        speed: { value: b.GetSpeed(), writable: !1 },
        isLooping: { value: b.IsLooping(), writable: !1 },
        repeatCount: { value: b.GetRepeatCount(), writable: !1 },
        repeatTo: { value: b.GetRepeatTo(), writable: !1 },
        isPingPong: { value: b.IsPingPong(), writable: !1 },
        frameCount: { value: b.GetFrameCount(), writable: !1 },
      });
    }
    getFrames() {
      return e
        .get(this)
        .GetFrames()
        .map((b) => b.GetIAnimationFrame());
    }
    *frames() {
      for (const b of e.get(this).GetFrames()) yield b.GetIAnimationFrame();
    }
  };
}
{
  ("use strict");
  const e = new WeakMap();
  self.IImageInfo = class {
    constructor(b) {
      e.set(this, b);
    }
    get width() {
      return e.get(this).GetWidth();
    }
    get height() {
      return e.get(this).GetHeight();
    }
  };
}
{
  ("use strict");
  const e = new WeakMap();
  self.IAnimationFrame = class extends self.IImageInfo {
    constructor(b) {
      super(b.GetImageInfo());
      e.set(this, b);
      Object.defineProperties(this, {
        duration: { value: b.GetDuration(), writable: !1 },
        originX: { value: b.GetOriginX(), writable: !1 },
        originY: { value: b.GetOriginY(), writable: !1 },
      });
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = new Set(["local", "remote"]),
    a = new Map([
      ["mp4", "video/mp4"],
      ["webm", "video/webm"],
      ["m4a", "audio/mp4"],
      ["mp3", "audio/mpeg"],
      ["js", "application/javascript"],
      ["wasm", "application/wasm"],
      ["svg", "image/svg+xml"],
      ["html", "text/html"],
    ]);
  function c(f) {
    if (!f) return "";
    f = f.split(".");
    if (2 > f.length) return "";
    f = f.at(-1).toLowerCase();
    return a.get(f) || "";
  }
  function d(f) {
    return new Promise((h, g) => {
      const k = document.createElement("script");
      k.onload = h;
      k.onerror = g;
      k.async = !1;
      k.type = "module";
      k.src = f;
      document.head.appendChild(k);
    });
  }
  e.AssetManager = class extends e.DefendedBase {
    constructor(f, h) {
      super();
      var g = h.exportType;
      this._runtime = f;
      this._localUrlBlobs = new Map();
      this._localBlobUrlCache = new Map();
      this._localBlobSWUrls = new Map();
      this._isCordova = "cordova" === g;
      this._isiOSCordova = !!h.isiOSCordova;
      this._isFileProtocol = !!h.isFileProtocol;
      this._swClientId = h.swClientId;
      this._supportedAudioFormats = h.supportedAudioFormats || {};
      this._audioFiles = new Map();
      this._preloadSounds = !1;
      this._iconsSubfolder = this._fontsSubfolder = this._mediaSubfolder = "";
      this._defaultLoadPolicy =
        "html5" === g || "scirra-arcade" === g || "instant-games" === g
          ? "remote"
          : "local";
      this._allAssets = [];
      this._assetsByUrl = new Map();
      this._webFonts = [];
      this._loadPromises = [];
      this._hasFinishedInitialLoad = !1;
      this._lastLoadProgress =
        this._assetSizeLoaded =
        this._totalAssetSizeToLoad =
          0;
      this._hasHadErrorLoading = !1;
      this._loadingRateLimiter = e.New(
        e.RateLimiter,
        () => this._FireLoadingProgressEvent(),
        50
      );
      this._promiseThrottle = new e.PromiseThrottle(
        Math.max(e.hardwareConcurrency, 8)
      );
      if ((f = h.previewImageBlobs)) {
        (g = h.previewProjectFileBlobs) && Object.assign(f, g);
        (g = h.projectData) && (f["data.json"] = g);
        for (const [k, m] of Object.entries(f))
          this._localUrlBlobs.set(k.toLowerCase(), m);
      }
      if ((h = h.previewProjectFileSWUrls))
        for (const [k, m] of Object.entries(h)) this._localBlobSWUrls.set(k, m);
      this._iAssetManager = new self.IAssetManager(this);
    }
    Release() {
      this._localUrlBlobs.clear();
      for (const f of this._localBlobUrlCache.values())
        f.startsWith("blob:") && URL.revokeObjectURL(f);
      this._localBlobUrlCache.clear();
      for (const f of this._allAssets) f.Release();
      e.clearArray(this._allAssets);
      this._assetsByUrl.clear();
      e.clearArray(this._loadPromises);
      this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    _SetMediaSubfolder(f) {
      this._mediaSubfolder = f;
    }
    GetMediaSubfolder() {
      return this._mediaSubfolder;
    }
    _SetFontsSubfolder(f) {
      this._fontsSubfolder = f;
    }
    GetFontsSubfolder() {
      return this._fontsSubfolder;
    }
    _SetIconsSubfolder(f) {
      this._iconsSubfolder = f;
    }
    GetIconsSubfolder() {
      return this._iconsSubfolder;
    }
    IsFileProtocol() {
      return this._isFileProtocol;
    }
    _HasLocalUrlBlob(f) {
      return this._localUrlBlobs.has(f.toLowerCase());
    }
    _GetLocalUrlBlob(f) {
      return this._localUrlBlobs.get(f.toLowerCase()) || null;
    }
    GetLocalUrlAsBlobUrl(f) {
      if (!this._HasLocalUrlBlob(f)) return f;
      f = f.toLowerCase();
      var h = this._localBlobUrlCache.get(f);
      h ||
        ((h = this._GetLocalUrlBlob(f)),
        (h = URL.createObjectURL(h)),
        this._localBlobUrlCache.set(f, h));
      return h;
    }
    FetchBlob(f, h) {
      h = h || this._defaultLoadPolicy;
      const g = this._GetLocalUrlBlob(f);
      if (g) return Promise.resolve(g);
      if (e.IsRelativeURL(f)) {
        const k = f.toLowerCase();
        return this._isCordova && this._isFileProtocol
          ? this.CordovaFetchLocalFileAsBlob(k)
          : "local" === h
          ? this._promiseThrottle.Add(() => e.FetchBlob(k))
          : e.FetchBlob(k);
      }
      return e.FetchBlob(f);
    }
    FetchArrayBuffer(f) {
      const h = this._GetLocalUrlBlob(f);
      if (h) return e.BlobToArrayBuffer(h);
      if (e.IsRelativeURL(f)) {
        const g = f.toLowerCase();
        return this._isCordova && this._isFileProtocol
          ? this.CordovaFetchLocalFileAsArrayBuffer(g)
          : "local" === this._defaultLoadPolicy
          ? this._promiseThrottle.Add(() => e.FetchArrayBuffer(g))
          : e.FetchArrayBuffer(g);
      }
      return e.FetchArrayBuffer(f);
    }
    FetchText(f) {
      const h = this._GetLocalUrlBlob(f);
      if (h) return e.BlobToString(h);
      if (e.IsRelativeURL(f)) {
        const g = f.toLowerCase();
        return this._isCordova && this._isFileProtocol
          ? this.CordovaFetchLocalFileAsText(g)
          : "local" === this._defaultLoadPolicy
          ? this._promiseThrottle.Add(() => e.FetchText(g))
          : e.FetchText(g);
      }
      return e.FetchText(f);
    }
    async FetchJson(f) {
      f = await this.FetchText(f);
      return JSON.parse(f);
    }
    _CordovaFetchLocalFileAs(f, h) {
      return this._runtime.PostComponentMessageToDOMAsync(
        "runtime",
        "cordova-fetch-local-file",
        { filename: f, as: h }
      );
    }
    CordovaFetchLocalFileAsText(f) {
      return this._CordovaFetchLocalFileAs(f, "text");
    }
    async CordovaFetchLocalFileAsBlob(f) {
      const h = await this._CordovaFetchLocalFileAs(f, "buffer");
      f = c(f);
      return new Blob([h], { type: f });
    }
    async CordovaFetchLocalFileAsBlobURL(f) {
      f = f.toLowerCase();
      var h = this._localBlobUrlCache.get(f);
      if (h) return h;
      h = await this.CordovaFetchLocalFileAsBlob(f);
      h = URL.createObjectURL(h);
      this._localBlobUrlCache.set(f, h);
      return h;
    }
    CordovaFetchLocalFileAsArrayBuffer(f) {
      return this._CordovaFetchLocalFileAs(f, "buffer");
    }
    GetMediaFileUrl(f) {
      return this._HasLocalUrlBlob(f)
        ? this.GetLocalUrlAsBlobUrl(f)
        : this._mediaSubfolder + f.toLowerCase();
    }
    GetProjectFileUrl(f, h = "") {
      if (e.IsAbsoluteURL(f)) {
        if (h) throw Error("cannot specify subfolder with remote URL");
        return Promise.resolve(f);
      }
      return this._HasLocalUrlBlob(f)
        ? Promise.resolve(this.GetLocalUrlAsBlobUrl(f))
        : this._isCordova && this._isFileProtocol
        ? this.CordovaFetchLocalFileAsBlobURL(h + f)
        : Promise.resolve(h + f.toLowerCase());
    }
    GetProjectFileIframeUrl(f) {
      if (e.IsAbsoluteURL(f)) return Promise.resolve(f);
      var h = f.indexOf("?"),
        g = -1 === h ? "" : f.substr(h);
      h = -1 === h ? f : f.substr(0, h);
      return this._HasLocalUrlBlob(h)
        ? ((f = this._localBlobSWUrls.get(h) || this.GetLocalUrlAsBlobUrl(h)),
          !f.startsWith("blob:") &&
            this._swClientId &&
            ((f = new URL(f)),
            (g = new URLSearchParams(g)),
            g.set("__c3_client_id", this._swClientId),
            (f.search = g.toString()),
            (f = f.toString())),
          Promise.resolve(f))
        : this._isCordova && this._isFileProtocol
        ? this.CordovaFetchLocalFileAsBlobURL(h)
        : Promise.resolve(f.toLowerCase());
    }
    LoadProjectFileUrl(f) {
      return this.GetProjectFileUrl(f);
    }
    LoadImage(f) {
      if (f.loadPolicy && !b.has(f.loadPolicy))
        throw Error("invalid load policy");
      let h = this._assetsByUrl.get(f.url);
      if (h) return h;
      h = e.New(e.ImageAsset, this, {
        url: f.url,
        size: f.size || 0,
        loadPolicy: f.loadPolicy || this._defaultLoadPolicy,
      });
      this._allAssets.push(h);
      this._assetsByUrl.set(h.GetURL(), h);
      this._hasFinishedInitialLoad ||
        ((this._totalAssetSizeToLoad += h.GetSize()),
        this._loadPromises.push(
          h.Load().then(() => this._AddLoadedSize(h.GetSize()))
        ));
      return h;
    }
    async WaitForAllToLoad() {
      try {
        await Promise.all(this._loadPromises), (this._lastLoadProgress = 1);
      } catch (f) {
        console.error("Error loading: ", f),
          (this._hasHadErrorLoading = !0),
          this._FireLoadingProgressEvent();
      }
    }
    SetInitialLoadFinished() {
      this._hasFinishedInitialLoad = !0;
    }
    HasHadErrorLoading() {
      return this._hasHadErrorLoading;
    }
    _AddLoadedSize(f) {
      this._assetSizeLoaded += f;
      this._loadingRateLimiter.Call();
    }
    _FireLoadingProgressEvent() {
      const f = e.New(e.Event, "loadingprogress");
      this._lastLoadProgress = e.clamp(
        this._assetSizeLoaded / this._totalAssetSizeToLoad,
        0,
        1
      );
      f.progress = this._lastLoadProgress;
      this._runtime.Dispatcher().dispatchEvent(f);
    }
    GetLoadProgress() {
      return this._lastLoadProgress;
    }
    _SetWebFonts(f) {
      e.shallowAssignArray(this._webFonts, f);
      this._webFonts.length && this._loadPromises.push(this._LoadWebFonts());
    }
    _LoadWebFonts() {
      if ("undefined" === typeof FontFace) return Promise.resolve();
      const f = [];
      for (const [h, g, k] of this._webFonts)
        (this._totalAssetSizeToLoad += k),
          f.push(this._LoadWebFont(h, g).then(() => this._AddLoadedSize(k)));
      return Promise.all(f);
    }
    async _LoadWebFont(f, h) {
      try {
        const g = await this.GetProjectFileUrl(h, this._fontsSubfolder),
          k = new FontFace(f, `url('${g}')`);
        this._runtime.IsInWorker() ? self.fonts.add(k) : document.fonts.add(k);
        await k.load();
      } catch (g) {
        console.warn(`[C3 runtime] Failed to load web font '${f}': `, g);
      }
    }
    IsAudioFormatSupported(f) {
      return !!this._supportedAudioFormats[f];
    }
    _SetAudioFiles(f, h) {
      this._preloadSounds = !!h;
      for (const [g, k, m] of f)
        this._audioFiles.set(g, {
          fileName: g,
          formats: k.map((q) => ({
            type: q[0],
            fileExtension: q[1],
            fullName: g + q[1],
            fileSize: q[2],
          })),
          isMusic: m,
        });
    }
    GetPreferredAudioFile(f) {
      f = this._audioFiles.get(f.toLowerCase());
      if (!f) return null;
      let h = null;
      for (const g of f.formats)
        if (
          (h || "audio/webm; codecs=opus" !== g.type || (h = g),
          this.IsAudioFormatSupported(g.type))
        )
          return g;
      return h;
    }
    GetProjectAudioFileUrl(f) {
      return (f = this.GetPreferredAudioFile(f))
        ? { url: this.GetMediaFileUrl(f.fullName), type: f.type }
        : null;
    }
    GetAudioToPreload() {
      if (this._preloadSounds) {
        const f = [];
        for (const h of this._audioFiles.values()) {
          if (h.isMusic) continue;
          const g = this.GetPreferredAudioFile(h.fileName);
          g &&
            f.push({
              originalUrl: h.fileName,
              url: this.GetMediaFileUrl(g.fullName),
              type: g.type,
              fileSize: g.fileSize,
            });
        }
        return f;
      }
      return [];
    }
    GetIAssetManager() {
      return this._iAssetManager;
    }
    async LoadScripts(...f) {
      const h = await Promise.all(f.map((g) => this.GetProjectFileUrl(g)));
      this._runtime.IsInWorker()
        ? 1 === f.length
          ? ((f = f[0]),
            await self.c3_import((e.IsRelativeURL(f) ? "./" : "") + f))
          : ((f = f
              .map((g) => `import "${e.IsRelativeURL(g) ? "./" : ""}${g}";`)
              .join("\n")),
            (f = URL.createObjectURL(
              new Blob([f], { type: "application/javascript" })
            )),
            await self.c3_import(f))
        : await Promise.all(h.map((g) => d(g)));
    }
    async CompileWebAssembly(f) {
      if (WebAssembly.compileStreaming)
        return (
          (f = await this.GetProjectFileUrl(f)),
          await WebAssembly.compileStreaming(fetch(f))
        );
      f = await e.FetchArrayBuffer(f);
      return await WebAssembly.compile(f);
    }
    async LoadStyleSheet(f) {
      f = await this.GetProjectFileUrl(f);
      return await this._runtime.PostComponentMessageToDOMAsync(
        "runtime",
        "add-stylesheet",
        { url: f }
      );
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Asset = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._assetManager = b;
      this._runtime = b.GetRuntime();
      this._url = a.url;
      this._size = a.size;
      this._loadPolicy = a.loadPolicy;
      this._blob = null;
      this._isLoaded = !1;
      this._loadPromise = null;
    }
    Release() {
      this._blob =
        this._runtime =
        this._assetManager =
        this._loadPromise =
          null;
    }
    GetURL() {
      return this._url;
    }
    GetSize() {
      return this._size;
    }
    Load() {
      return "local" === this._loadPolicy || this._blob
        ? ((this._isLoaded = !0), Promise.resolve())
        : this._loadPromise
        ? this._loadPromise
        : (this._loadPromise = this._assetManager
            .FetchBlob(this._url, this._loadPolicy)
            .then((b) => {
              this._isLoaded = !0;
              this._loadPromise = null;
              return (this._blob = b);
            })
            .catch((b) => console.error("Error loading resource: ", b)));
    }
    IsLoaded() {
      return this._isLoaded;
    }
    GetBlob() {
      return this._blob
        ? Promise.resolve(this._blob)
        : this._loadPromise
        ? this._loadPromise
        : this._assetManager.FetchBlob(this._url, this._loadPolicy);
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = new e.PromiseThrottle(),
    a = new Set();
  e.ImageAsset = class extends e.Asset {
    constructor(c, d) {
      super(c, d);
      this._webglTexture = this._texturePromise = null;
      this._refCount = 0;
      this._imageHeight = this._imageWidth = -1;
      a.add(this);
    }
    Release() {
      this.ReleaseTexture();
      if (0 !== this._refCount)
        throw Error("released image asset which still has texture references");
      this._texturePromise = null;
      a.delete(this);
      super.Release();
    }
    static OnWebGLContextLost() {
      for (const c of a)
        (c._texturePromise = null), (c._webglTexture = null), (c._refCount = 0);
    }
    LoadStaticTexture(c, d) {
      d = d || {};
      this._refCount++;
      if (this._webglTexture) return Promise.resolve(this._webglTexture);
      if (this._texturePromise) return this._texturePromise;
      d.anisotropy = this._runtime.GetCanvasManager().GetTextureAnisotropy();
      return (this._texturePromise = this.GetBlob()
        .then((f) =>
          b.Add(() =>
            c.CreateStaticTextureAsync(f, d).then((h) => {
              this._texturePromise = null;
              if (0 === this._refCount) return c.DeleteTexture(h), null;
              this._webglTexture = h;
              this._imageWidth = h.GetWidth();
              this._imageHeight = h.GetHeight();
              return this._webglTexture;
            })
          )
        )
        .catch((f) => {
          console.error("Failed to load texture: ", f);
          throw f;
        }));
    }
    ReleaseTexture() {
      if (0 >= this._refCount) throw Error("texture released too many times");
      this._refCount--;
      0 === this._refCount &&
        this._webglTexture &&
        (this._webglTexture.GetRenderer().DeleteTexture(this._webglTexture),
        (this._webglTexture = null));
    }
    GetTexture() {
      return this._webglTexture;
    }
    GetWidth() {
      return this._imageWidth;
    }
    GetHeight() {
      return this._imageHeight;
    }
    async LoadToDrawable() {
      const c = await this.GetBlob();
      return e.Supports.ImageBitmapOptions
        ? await createImageBitmap(c, { premultiplyAlpha: "none" })
        : e.Supports.ImageBitmap
        ? await createImageBitmap(c)
        : await e.BlobToImage(c);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  function b(a, c) {
    return (
      a.GetWorldInfo()._GetLastCachedZIndex() -
      c.GetWorldInfo()._GetLastCachedZIndex()
    );
  }
  e.RenderCell = class extends e.DefendedBase {
    constructor(a, c, d) {
      super();
      this._grid = a;
      this._x = c;
      this._y = d;
      this._instances = [];
      this._isSorted = !0;
      this._pendingRemoval = new Set();
      this._isAnyPendingRemoval = !1;
    }
    Release() {
      e.clearArray(this._instances);
      this._pendingRemoval.clear();
      this._grid = null;
    }
    Reset() {
      e.clearArray(this._instances);
      this._isSorted = !0;
      this._pendingRemoval.clear();
      this._isAnyPendingRemoval = !1;
    }
    SetChanged() {
      this._isSorted = !1;
    }
    IsEmpty() {
      if (!this._instances.length) return !0;
      if (this._instances.length > this._pendingRemoval.size) return !1;
      this._FlushPending();
      return !0;
    }
    Insert(a) {
      this._pendingRemoval.has(a)
        ? (this._pendingRemoval.delete(a),
          0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = !1))
        : (this._instances.push(a),
          (this._isSorted = 1 === this._instances.length));
    }
    Remove(a) {
      this._pendingRemoval.add(a);
      this._isAnyPendingRemoval = !0;
      50 <= this._pendingRemoval.size && this._FlushPending();
    }
    _FlushPending() {
      this._isAnyPendingRemoval &&
        (this._instances.length === this._pendingRemoval.size
          ? this.Reset()
          : (e.arrayRemoveAllInSet(this._instances, this._pendingRemoval),
            this._pendingRemoval.clear(),
            (this._isAnyPendingRemoval = !1)));
    }
    _EnsureSorted() {
      this._isSorted || (this._instances.sort(b), (this._isSorted = !0));
    }
    Dump(a) {
      this._FlushPending();
      this._EnsureSorted();
      this._instances.length && a.push(this._instances);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.RenderGrid = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._cellWidth = b;
      this._cellHeight = a;
      this._cells = e.New(e.PairMap);
    }
    Release() {
      this._cells.Release();
      this._cells = null;
    }
    GetCell(b, a, c) {
      let d = this._cells.Get(b, a);
      return d
        ? d
        : c
        ? ((d = e.New(e.RenderCell, this, b, a)), this._cells.Set(b, a, d), d)
        : null;
    }
    XToCell(b) {
      return Math.floor(b / this._cellWidth);
    }
    YToCell(b) {
      return Math.floor(b / this._cellHeight);
    }
    Update(b, a, c) {
      if (a)
        for (let d = a.getLeft(), f = a.getRight(); d <= f; ++d)
          for (let h = a.getTop(), g = a.getBottom(); h <= g; ++h) {
            if (c && c.containsPoint(d, h)) continue;
            const k = this.GetCell(d, h, !1);
            k && (k.Remove(b), k.IsEmpty() && this._cells.Delete(d, h));
          }
      if (c)
        for (let d = c.getLeft(), f = c.getRight(); d <= f; ++d)
          for (let h = c.getTop(), g = c.getBottom(); h <= g; ++h)
            (a && a.containsPoint(d, h)) || this.GetCell(d, h, !0).Insert(b);
    }
    QueryRange(b, a) {
      let c = this.XToCell(b.getLeft());
      const d = this.YToCell(b.getTop()),
        f = this.XToCell(b.getRight());
      for (b = this.YToCell(b.getBottom()); c <= f; ++c)
        for (let h = d; h <= b; ++h) {
          const g = this.GetCell(c, h, !1);
          g && g.Dump(a);
        }
    }
    MarkRangeChanged(b) {
      let a = b.getLeft();
      const c = b.getTop(),
        d = b.getRight();
      for (b = b.getBottom(); a <= d; ++a)
        for (let f = c; f <= b; ++f) {
          const h = this.GetCell(a, f, !1);
          h && h.SetChanged();
        }
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = new e.Rect(),
    a = new e.Quad(),
    c = [];
  new e.Rect();
  new e.Rect();
  const d = self.glMatrix,
    f = d.vec3,
    h = d.vec4,
    g = d.mat4,
    k = g.create(),
    m = f.create(),
    q = h.create(),
    v = f.create(),
    r = f.create(),
    n = f.create(),
    p = e.New(e.Vector2);
  e.New(e.Rect);
  function u(z, D) {
    return (
      z.GetWorldInfo()._GetLastCachedZIndex() -
      D.GetWorldInfo()._GetLastCachedZIndex()
    );
  }
  function w(z, D) {
    return z.GetWorldInfo().GetZElevation() - D.GetWorldInfo().GetZElevation();
  }
  const y = [],
    B = [],
    E = [];
  e.Layer = class extends e.DefendedBase {
    constructor(z, D, J) {
      super();
      this._layout = z;
      this._runtime = z.GetRuntime();
      this._parentLayer = D;
      this._name = J[0];
      this._index = -1;
      this._sid = J[2];
      this._isVisible = !!J[3];
      this._isInteractive = !!J[13];
      this._backgroundColor = e.New(e.Color);
      this._backgroundColor.setFromJSON(J[4].map((H) => H / 255));
      this._isTransparent = !!J[5];
      this._parallaxX = J[6];
      this._parallaxY = J[7];
      this._color = e.New(e.Color, 1, 1, 1, J[8]);
      this._premultipliedColor = e.New(e.Color);
      this._isForceOwnTexture = J[9];
      this._renderAs3d = J[17];
      this._useCameraDistanceDrawOrder = J[18];
      this._useRenderCells = J[10];
      this._scaleRate = J[11];
      this._blendMode = J[12];
      this._curRenderTarget = null;
      this._scale = 1;
      this._zElevation = J[16];
      this._scrollY = this._scrollX = this._angle = 0;
      this._hasOwnScrollPosition = !1;
      this._viewport = e.New(e.Rect);
      this._viewportZ0 = e.New(e.Rect);
      this._viewport3D = e.New(e.Rect);
      this._isViewportChanged = !0;
      this._projectionMatrix = g.create();
      this._isProjectionMatrixChanged = !0;
      this._modelViewMatrix = g.create();
      this._isMVMatrixChanged = !0;
      this._viewFrustum = e.New(e.Gfx.ViewFrustum);
      this._isViewFrustumChanged = !0;
      this._startupInitialInstances = [];
      this._initialInstancesData = J[14];
      this._initialInstances = [];
      this._createdGlobalUids = [];
      this._initialUIDsToInstanceData = new Map();
      this._instances = [];
      this._anyInstanceZElevated = this._zIndicesUpToDate = !1;
      const C = this._runtime.GetCanvasManager();
      this._effectList = e.New(e.EffectList, this, J[15]);
      this._effectChain = e.New(e.Gfx.EffectChain, C.GetEffectChainManager(), {
        drawContent: (H, K) => {
          K = K.GetContentObject();
          const P = K.GetRenderTarget();
          H.SetColor(K.GetPremultipliedColor());
          H.DrawRenderTarget(P);
          H.InvalidateRenderTarget(P);
          C.ReleaseAdditionalRenderTarget(P);
        },
        getShaderParameters: (H) =>
          this.GetEffectList()._GetEffectChainShaderParametersForIndex(H),
      });
      this._wasDefaultColor = this._needsRebuildEffectChainSteps = !0;
      this._renderGrid = null;
      this._lastRenderList = [];
      this._isRenderListUpToDate = !1;
      this._lastRenderCells = e.New(e.Rect, 0, 0, -1, -1);
      this._curRenderCells = e.New(e.Rect, 0, 0, -1, -1);
      this._iLayer = null;
      this._UpdatePremultipliedColor();
      this.UsesRenderCells() &&
        (this._renderGrid = e.New(
          e.RenderGrid,
          this._runtime.GetOriginalViewportWidth(),
          this._runtime.GetOriginalViewportHeight()
        ));
      this._subLayers = J[19].map((H) => e.New(e.Layer, this._layout, this, H));
    }
    _Init() {
      for (const z of this._initialInstancesData) {
        const D = this._runtime.GetObjectClassByIndex(z[1]);
        this._layout._AddInitialObjectClass(D);
        D.GetDefaultInstanceData() ||
          (D.SetDefaultInstanceData(z), D._SetDefaultLayerIndex(this._index));
        this._initialInstances.push(z);
        this._initialUIDsToInstanceData.set(z[2], z);
      }
      e.shallowAssignArray(
        this._startupInitialInstances,
        this._initialInstances
      );
      this._initialInstancesData = null;
      this._iLayer = new self.ILayer(this);
    }
    Release() {
      this._runtime = this._layout = null;
    }
    GetInitialInstanceData(z) {
      return this._initialUIDsToInstanceData.get(z);
    }
    CreateInitialInstances(z) {
      const D = this._layout.IsFirstVisit();
      let J = 0;
      const C = this._initialInstances;
      for (let K = 0, P = C.length; K < P; ++K) {
        var H = C[K];
        const S = this._runtime.GetObjectClassByIndex(H[1]);
        let U = !0;
        if (!S.HasPersistBehavior() || D)
          (H = this._runtime.CreateInstanceFromData(H, this, !0)),
            z.push(H),
            S.IsGlobal() &&
              ((U = !1), this._createdGlobalUids.push(H.GetUID()));
        U && ((C[J] = C[K]), ++J);
      }
      e.truncateArray(C, J);
      this._runtime.FlushPendingInstances();
      this.SetZIndicesChanged();
    }
    _AddInstance(z, D) {
      const J = z.GetWorldInfo();
      if (J.GetLayer() !== this) throw Error("instance added to wrong layer");
      this._instances.push(z);
      0 !== J.GetZElevation() && (this._anyInstanceZElevated = !0);
      D && this.UsesRenderCells() && z.GetWorldInfo().SetBboxChanged();
      this.SetZIndicesChanged();
    }
    _MaybeAddInstance(z) {
      this._instances.includes(z) ||
        (this._instances.push(z),
        0 !== z.GetWorldInfo().GetZElevation() &&
          (this._anyInstanceZElevated = !0),
        this.SetZIndicesChanged());
    }
    _PrependInstance(z, D) {
      const J = z.GetWorldInfo();
      if (J.GetLayer() !== this) throw Error("instance added to wrong layer");
      this._instances.unshift(z);
      0 !== J.GetZElevation() && (this._anyInstanceZElevated = !0);
      this.SetZIndicesChanged();
      D && this.UsesRenderCells() && z.GetWorldInfo().SetBboxChanged();
    }
    _RemoveInstance(z, D) {
      const J = this._instances.indexOf(z);
      0 > J ||
        (D &&
          this.UsesRenderCells() &&
          z.GetWorldInfo()._RemoveFromRenderCells(),
        this._instances.splice(J, 1),
        this.SetZIndicesChanged(),
        this._MaybeResetAnyInstanceZElevatedFlag());
    }
    _SetAnyInstanceZElevated() {
      this._anyInstanceZElevated = !0;
    }
    _MaybeResetAnyInstanceZElevatedFlag() {
      0 === this._instances.length && (this._anyInstanceZElevated = !1);
    }
    _SortInstancesByLastCachedZIndex(z) {
      if (z) {
        z = new Set();
        for (var D of this._instances) {
          var J = D.GetWorldInfo()._GetLastCachedZIndex();
          0 <= J && z.add(J);
        }
        D = -1;
        for (const C of this._instances)
          if (((J = C.GetWorldInfo()), !(0 <= J._GetLastCachedZIndex()))) {
            for (++D; z.has(D); ) ++D;
            J._SetZIndex(D);
          }
      }
      this._instances.sort(u);
    }
    _Start() {}
    _End() {
      for (const z of this._instances)
        z.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(z);
      this._runtime.FlushPendingInstances();
      e.clearArray(this._instances);
      this._anyInstanceZElevated = !1;
      this.SetZIndicesChanged();
    }
    RecreateInitialObjects(z, D, J, C, H) {
      const K = this._runtime.GetEventSheetManager(),
        P = this._runtime.GetAllObjectClasses(),
        S = z.IsFamily(),
        U = [];
      for (const ma of this._initialInstances) {
        var V = ma[0];
        if (D.containsPoint(V[0], V[1])) {
          V = P[ma[1]];
          if (V !== z)
            if (S) {
              if (!z.FamilyHasMember(V)) continue;
            } else continue;
          V = this;
          var aa = this._runtime.GetCurrentLayout();
          this.GetLayout() !== aa &&
            ((V = aa.GetLayerByName(this.GetName())) ||
              (V = aa.GetLayerByIndex(this.GetIndex())));
          aa = this._runtime.CreateInstanceFromData(
            ma,
            V,
            !1,
            void 0,
            void 0,
            !1,
            H
          );
          V.SortAndAddInstancesByZIndex(aa);
          V = aa.GetWorldInfo();
          V.OffsetXY(J, C);
          V.SetBboxChanged();
          K.BlockFlushingInstances(!0);
          aa._TriggerOnCreatedOnSelfAndRelated();
          K.BlockFlushingInstances(!1);
          U.push(aa);
        }
      }
      return U;
    }
    GetInstanceCount() {
      return this._instances.length;
    }
    GetLayout() {
      return this._layout;
    }
    GetName() {
      return this._name;
    }
    _SetIndex(z) {
      this._index = z;
    }
    GetIndex() {
      return this._index;
    }
    GetSID() {
      return this._sid;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetDevicePixelRatio() {
      return this._runtime.GetDevicePixelRatio();
    }
    GetEffectList() {
      return this._effectList;
    }
    GetEffectChain() {
      this._MaybeRebuildEffectChainSteps();
      return this._effectChain;
    }
    _MaybeRebuildEffectChainSteps() {
      const z = this.HasDefaultColor();
      if (this._needsRebuildEffectChainSteps || z !== this._wasDefaultColor) {
        var D = this.GetEffectList().GetActiveEffectTypes();
        this._effectChain.BuildSteps(
          D.map((J) => J.GetShaderProgram()),
          {
            indexMap: D.map((J) => J.GetIndex()),
            forcePreDraw: !z,
            useFullSurface: !0,
          }
        );
        this._needsRebuildEffectChainSteps = !1;
        this._wasDefaultColor = z;
      }
    }
    UpdateActiveEffects() {
      this.GetEffectList().UpdateActiveEffects();
      this._needsRebuildEffectChainSteps = !0;
    }
    UsesRenderCells() {
      return this._useRenderCells && !this._useCameraDistanceDrawOrder;
    }
    GetRenderGrid() {
      return this._renderGrid;
    }
    SetRenderListStale() {
      this._isRenderListUpToDate = !1;
    }
    IsVisible() {
      for (const z of this.selfAndParentLayers())
        if (!z._IsVisibleFlagSet()) return !1;
      return !0;
    }
    _IsVisibleFlagSet() {
      return this._isVisible;
    }
    SetVisible(z) {
      z = !!z;
      this._isVisible !== z &&
        ((this._isVisible = z), this._runtime.UpdateRender());
    }
    SetInteractive(z) {
      this._isInteractive = !!z;
    }
    IsInteractive() {
      return this._isInteractive;
    }
    IsSelfAndParentsInteractive() {
      for (const z of this.selfAndParentLayers())
        if (!z.IsInteractive()) return !1;
      return !0;
    }
    SetOwnScrollPositionEnabled(z) {
      z = !!z;
      if (this._hasOwnScrollPosition !== z) {
        if ((this._hasOwnScrollPosition = z))
          (z = this.GetLayout()),
            (this._scrollX = z.GetScrollX()),
            (this._scrollY = z.GetScrollY());
        this._SetMVMatrixChanged();
        this._runtime.UpdateRender();
      }
    }
    IsOwnScrollPositionEnabled() {
      return this._hasOwnScrollPosition;
    }
    SetScrollX(z) {
      var D = this.GetLayout();
      const J = D.GetScrollLeftBound();
      D = D.GetScrollRightBound();
      z > D && (z = D);
      z < J && (z = J);
      this._scrollX !== z &&
        ((this._scrollX = z),
        this.IsOwnScrollPositionEnabled() &&
          (this._SetMVMatrixChanged(), this._runtime.UpdateRender()));
    }
    SetScrollY(z) {
      var D = this.GetLayout();
      const J = D.GetScrollTopBound();
      D = D.GetScrollBottomBound();
      z > D && (z = D);
      z < J && (z = J);
      this._scrollY !== z &&
        ((this._scrollY = z),
        this.IsOwnScrollPositionEnabled() &&
          (this._SetMVMatrixChanged(), this._runtime.UpdateRender()));
    }
    GetScrollX() {
      return this.IsOwnScrollPositionEnabled()
        ? this._scrollX
        : this.GetLayout().GetScrollX();
    }
    GetScrollY() {
      return this.IsOwnScrollPositionEnabled()
        ? this._scrollY
        : this.GetLayout().GetScrollY();
    }
    GetViewport() {
      this._MaybeUpdateViewport();
      return this._viewport;
    }
    _GetViewportZ0() {
      this._MaybeUpdateViewport();
      return this._viewportZ0;
    }
    GetViewport3D() {
      this._MaybeUpdateViewport();
      return this._viewport3D;
    }
    _GetVanishingPoint() {
      const z = this.GetLayout();
      return [z.GetVanishingPointX(), z.GetVanishingPointY()];
    }
    GetDefaultCameraZ(z) {
      return this._runtime.GetDefaultCameraZ(z);
    }
    GetViewportForZ(z, D) {
      var J = this._GetViewportZ0();
      if (0 === z) D.copy(J);
      else {
        let P = J.midX(),
          S = J.midY();
        var C = this.Get2DScaleFactorToZ(z);
        const U = J.width() / C;
        J = J.height() / C;
        const [V, aa] = this._GetVanishingPoint();
        if (0.5 !== V || 0.5 !== aa) {
          const ma = this.GetCameraZ();
          var H = this._runtime,
            K = this.GetDefaultCameraZ() / ma;
          C = ((V - 0.5) * H.GetViewportWidth()) / K;
          H = ((aa - 0.5) * H.GetViewportHeight()) / K;
          K = this.GetAngle();
          0 !== K && (p.set(C, H), p.rotate(K), (C = p.getX()), (H = p.getY()));
          z = e.unlerp(ma, 0, z);
          P += e.lerp(C, 0, z);
          S += e.lerp(H, 0, z);
        }
        D.set(P - U / 2, S - J / 2, P + U / 2, S + J / 2);
      }
    }
    GetOpacity() {
      return this._color.getA();
    }
    SetOpacity(z) {
      z = e.clamp(z, 0, 1);
      this._color.getA() !== z &&
        (this._color.setA(z),
        this._UpdatePremultipliedColor(),
        this._runtime.UpdateRender());
    }
    _UpdatePremultipliedColor() {
      this._premultipliedColor.copy(this._color);
      this._premultipliedColor.premultiply();
    }
    GetPremultipliedColor() {
      return this._premultipliedColor;
    }
    HasDefaultColor() {
      return this._color.equalsRgba(1, 1, 1, 1);
    }
    GetScaleRate() {
      return this._scaleRate;
    }
    SetScaleRate(z) {
      this._scaleRate !== z &&
        ((this._scaleRate = z),
        this._SetMVMatrixChanged(),
        this._runtime.UpdateRender());
    }
    GetParallaxX() {
      return this._parallaxX;
    }
    GetParallaxY() {
      return this._parallaxY;
    }
    SetParallax(z, D) {
      if (this._parallaxX !== z || this._parallaxY !== D)
        if (
          ((this._parallaxX = z),
          (this._parallaxY = D),
          this._SetMVMatrixChanged(),
          this._runtime.UpdateRender(),
          1 !== this._parallaxX || 1 !== this._parallaxY)
        )
          for (const J of this._instances)
            J.GetObjectClass()._SetAnyInstanceParallaxed(!0);
    }
    SetParallaxX(z) {
      this.SetParallax(z, this.GetParallaxY());
    }
    SetParallaxY(z) {
      this.SetParallax(this.GetParallaxX(), z);
    }
    SetZElevation(z) {
      this._zElevation !== z &&
        ((this._zElevation = z), this._runtime.UpdateRender());
    }
    GetZElevation() {
      return this._zElevation;
    }
    SetAngle(z) {
      z = e.clampAngle(z);
      this._angle !== z &&
        ((this._angle = z),
        this._SetMVMatrixChanged(),
        this._runtime.UpdateRender());
    }
    GetAngle() {
      return e.clampAngle(this._layout.GetAngle() + this._angle);
    }
    GetOwnAngle() {
      return this._angle;
    }
    HasInstances() {
      return 0 < this._instances.length;
    }
    _GetInstances() {
      return this._instances;
    }
    _GetInstancesInDrawOrder() {
      return this.RendersIn3DMode() && this._useCameraDistanceDrawOrder
        ? (e.shallowAssignArray(E, this._GetInstances()),
          E.sort((z, D) => this._SortInstancesByCameraDistance(z, D)),
          E)
        : this._GetInstances();
    }
    _AppendAllInstancesIncludingSubLayersInDrawOrder(z) {
      e.appendArray(z, this._GetInstancesInDrawOrder());
      for (const D of this._subLayers)
        D.IsVisible() &&
          0 < D.GetOpacity() &&
          D._AppendAllInstancesIncludingSubLayersInDrawOrder(z);
    }
    _SortInstancesByCameraDistance(z, D) {
      var J = this.GetLayout().Get3DCameraPosition(),
        C = J[0],
        H = J[1];
      J = J[2];
      var K = z.GetWorldInfo();
      const P = D.GetWorldInfo();
      D = K.GetX() - C;
      z = K.GetY() - H;
      K = K.GetZElevation() - J;
      C = P.GetX() - C;
      H = P.GetY() - H;
      J = P.GetZElevation() - J;
      return C * C + H * H + J * J - (D * D + z * z + K * K);
    }
    GetBackgroundColor() {
      return this._backgroundColor;
    }
    IsTransparent() {
      return this._isTransparent;
    }
    SetTransparent(z) {
      z = !!z;
      this._isTransparent !== z &&
        ((this._isTransparent = z), this._runtime.UpdateRender());
    }
    IsForceOwnTexture() {
      return this._isForceOwnTexture;
    }
    SetForceOwnTexture(z) {
      z = !!z;
      this._isForceOwnTexture !== z &&
        ((this._isForceOwnTexture = z), this._runtime.UpdateRender());
    }
    RendersIn2DMode() {
      return !this.GetRuntime().Uses3DFeatures() || !this._renderAs3d;
    }
    RendersIn3DMode() {
      return !this.RendersIn2DMode();
    }
    Has3DCamera() {
      return this.RendersIn3DMode() && this.GetLayout().Is3DCameraEnabled();
    }
    SelfAndAllSubLayersHave3DCamera() {
      if (!this.Has3DCamera()) return !1;
      for (const z of this._subLayers)
        if (!z.SelfAndAllSubLayersHave3DCamera()) return !1;
      return !0;
    }
    SetBlendMode(z) {
      this._blendMode !== z &&
        ((this._blendMode = z), this._runtime.UpdateRender());
    }
    GetBlendMode() {
      return this._blendMode;
    }
    IsRootLayer() {
      return !this._parentLayer;
    }
    GetParentLayer() {
      return this._parentLayer;
    }
    GetSubLayers() {
      return this._subLayers;
    }
    HasAnySubLayers() {
      return 0 < this._subLayers.length;
    }
    HasAnyVisibleSubLayer() {
      for (const z of this._subLayers) if (z.ShouldDraw()) return !0;
      return !1;
    }
    *selfAndAllSubLayers() {
      for (const z of this._subLayers) yield* z.selfAndAllSubLayers();
      yield this;
    }
    *parentLayers() {
      let z = this.GetParentLayer();
      for (; z; ) yield z, (z = z.GetParentLayer());
    }
    *selfAndParentLayers() {
      yield this;
      yield* this.parentLayers();
    }
    IsTransformCompatibleWith(z) {
      return (
        this === z ||
        (this._parallaxX === z._parallaxX &&
          this._parallaxY === z._parallaxY &&
          this._scale === z._scale &&
          this._scaleRate === z._scaleRate &&
          this._angle === z._angle &&
          this.GetScrollX() === z.GetScrollX() &&
          this.GetScrollY() === z.GetScrollY())
      );
    }
    SaveTransform() {
      return {
        parallaxX: this.GetParallaxX(),
        parallaxY: this.GetParallaxY(),
        scale: this.GetOwnScale(),
        scaleRate: this.GetScaleRate(),
        angle: this.GetOwnAngle(),
        hasOwnScroll: this.IsOwnScrollPositionEnabled(),
        scrollX: this.GetScrollX(),
        scrollY: this.GetScrollY(),
      };
    }
    RestoreTransform(z) {
      this.SetParallax(z.parallaxX, z.parallaxY);
      this.SetOwnScale(z.scale);
      this.SetScaleRate(z.scaleRate);
      this.SetAngle(z.angle);
      this.SetOwnScrollPositionEnabled(z.hasOwnScroll);
      this.SetScrollX(z.scrollX);
      this.SetScrollY(z.scrollY);
      this._MaybeUpdateViewport();
    }
    _RemoveAllInstancesInSet(z) {
      0 !== z.size &&
        0 < e.arrayRemoveAllInSet(this._instances, z) &&
        (this._MaybeResetAnyInstanceZElevatedFlag(), this.SetZIndicesChanged());
    }
    SetZIndicesChanged() {
      this._isRenderListUpToDate = this._zIndicesUpToDate = !1;
    }
    _UpdateZIndices() {
      if (!this._zIndicesUpToDate) {
        this._instances.sort(w);
        if (this.UsesRenderCells())
          for (let z = 0, D = this._instances.length; z < D; ++z) {
            const J = this._instances[z].GetWorldInfo();
            J._SetZIndex(z);
            this._renderGrid.MarkRangeChanged(J.GetRenderCellRange());
          }
        else
          for (let z = 0, D = this._instances.length; z < D; ++z)
            this._instances[z].GetWorldInfo()._SetZIndex(z);
        this._zIndicesUpToDate = !0;
      }
    }
    MoveInstanceAdjacent(z, D, J) {
      var C = z.GetWorldInfo();
      D = D.GetWorldInfo();
      if (C.GetLayer() !== this || D.GetLayer() !== this)
        throw Error("can't arrange Z order unless both objects on this layer");
      C = C.GetZIndex();
      D = D.GetZIndex();
      if (C === D + (J ? 1 : -1)) return !1;
      e.arrayRemove(this._instances, C);
      C < D && D--;
      J && D++;
      D === this._instances.length
        ? this._instances.push(z)
        : this._instances.splice(D, 0, z);
      this.SetZIndicesChanged();
      return !0;
    }
    _MergeSortedZArrays(z, D) {
      const J = [];
      let C = 0,
        H = 0,
        K = z.length,
        P = D.length;
      for (; C < K && H < P; ) {
        const S = z[C],
          U = D[H];
        S.GetWorldInfo()._GetLastCachedZIndex() <
        U.GetWorldInfo()._GetLastCachedZIndex()
          ? (J.push(S), ++C)
          : (J.push(U), ++H);
      }
      for (; C < K; ++C) J.push(z[C]);
      for (; H < P; ++H) J.push(D[H]);
      return J;
    }
    _MergeAllSortedZArrays_pass(z) {
      const D = [],
        J = z.length;
      for (let C = 0; C < J - 1; C += 2)
        D.push(this._MergeSortedZArrays(z[C], z[C + 1]));
      1 === J % 2 && D.push(z[J - 1]);
      return D;
    }
    _MergeAllSortedZArrays(z) {
      for (; 1 < z.length; ) z = this._MergeAllSortedZArrays_pass(z);
      return z[0];
    }
    _GetRenderCellInstancesToDraw() {
      this._UpdateZIndices();
      e.clearArray(c);
      this._renderGrid.QueryRange(this.GetViewport(), c);
      return c.length
        ? 1 === c.length
          ? c[0]
          : this._MergeAllSortedZArrays(c)
        : [];
    }
    ShouldDraw() {
      return (
        this.IsVisible() &&
        0 < this.GetOpacity() &&
        this._DrawsAnyContentInSelfOrSubLayers()
      );
    }
    _DrawsAnyContentInSelfOrSubLayers() {
      if (this.HasInstances() || !this.IsTransparent()) return !0;
      for (const z of this._subLayers)
        if (z._DrawsAnyContentInSelfOrSubLayers()) return !0;
      return !1;
    }
    UsesOwnTexture() {
      return (
        this.IsForceOwnTexture() ||
        !this.HasDefaultColor() ||
        0 !== this.GetBlendMode() ||
        this._effectList.HasAnyActiveEffect()
      );
    }
    SelfOrAnySubLayerUsesOwnTexture() {
      if (this.UsesOwnTexture()) return !0;
      for (const z of this._subLayers)
        if (z.SelfOrAnySubLayerUsesOwnTexture()) return !0;
      return !1;
    }
    GetRenderTarget() {
      return this._curRenderTarget;
    }
    Get2DScaleFactorToZ(z) {
      if (this._layout.IsOrthographicProjection()) return 1;
      {
        const D = this.GetCameraZ();
        return D / (D - z);
      }
    }
    GetCameraZ(z) {
      return this.GetDefaultCameraZ(z) / this.GetNormalScale();
    }
    _SetMVMatrixChanged() {
      this._isViewportChanged =
        this._isViewFrustumChanged =
        this._isMVMatrixChanged =
          !0;
    }
    _GetModelViewMatrix(z) {
      this._isMVMatrixChanged &&
        (this._CalculateModelViewMatrix(z, this._modelViewMatrix, 0, 0, null),
        (this._isMVMatrixChanged = !1));
      return this._modelViewMatrix;
    }
    GetCameraPosition() {
      if (this.Has3DCamera()) {
        const z = this.GetLayout().Get3DCameraPosition();
        return [z[0], z[1], z[2]];
      }
      return this._Get2DCameraPosition();
    }
    _Get2DCameraPosition(z = 0, D = 0, J = 0) {
      var C = this._runtime,
        H = this.GetLayout(),
        K = C.GetParallaxXOrigin(),
        P = C.GetParallaxYOrigin();
      K = (this.GetScrollX() - K) * this._parallaxX + K;
      P = (this.GetScrollY() - P) * this._parallaxY + P;
      C.IsPixelRoundingEnabled() && ((K = Math.round(K)), (P = Math.round(P)));
      z = K + z;
      D = P + D;
      H = H.IsOrthographicProjection()
        ? this.GetDefaultCameraZ(J)
        : this.GetCameraZ(J);
      const [S, U] = this._GetVanishingPoint();
      if (0.5 !== S || 0.5 !== U)
        (P = this.GetDefaultCameraZ(J) / H),
          (J = ((S - 0.5) * C.GetViewportWidth()) / P),
          (C = ((U - 0.5) * C.GetViewportHeight()) / P),
          (P = this.GetAngle()),
          0 !== P && (p.set(J, C), p.rotate(P), (J = p.getX()), (C = p.getY())),
          (z += J),
          (D += C);
      return [z, D, H];
    }
    _CalculateModelViewMatrix(z, D, J, C, H) {
      const K = this._runtime;
      var P = this.GetLayout();
      if (this.Has3DCamera()) {
        f.copy(v, P.Get3DCameraPosition());
        f.copy(r, P.Get3DCameraLookAt());
        f.copy(n, P.Get3DCameraUpVector());
        J = K.GetParallaxXOrigin();
        C = K.GetParallaxYOrigin();
        P = r[0] - v[0];
        const S = r[1] - v[1],
          U = r[2] - v[2];
        v[0] = (v[0] - J) * this._parallaxX + J;
        v[1] = (v[1] - C) * this._parallaxY + C;
        v[2] *= Math.max(this._parallaxX, this._parallaxY);
        r[0] = v[0] + P;
        r[1] = v[1] + S;
        r[2] = v[2] + U;
      } else {
        const [S, U, V] = this._Get2DCameraPosition(J, C, H);
        f.set(v, S, U, V);
        f.set(r, S, U, V - 100);
        J = this.GetAngle();
        0 === J ? f.set(n, 0, 1, 0) : f.set(n, Math.sin(J), Math.cos(J), 0);
      }
      z.CalculateLookAtModelView(D, v, r, n, H || K.GetViewportHeight());
    }
    _SetProjectionMatrixChanged() {
      this._isViewportChanged =
        this._isViewFrustumChanged =
        this._isProjectionMatrixChanged =
          !0;
    }
    _GetProjectionMatrix(z) {
      this._isProjectionMatrixChanged &&
        (this._CalculateProjectionMatrix(z),
        (this._isProjectionMatrixChanged = !1));
      return this._projectionMatrix;
    }
    _CalculateProjectionMatrix(z) {
      var D = this._runtime.GetCanvasManager();
      const [J, C] = this._GetVanishingPoint();
      if (this._layout.IsOrthographicProjection())
        z.CalculateOrthographicMatrix(
          this._projectionMatrix,
          D.GetDrawWidth(),
          D.GetDrawHeight()
        );
      else if (0.5 === J && 0.5 === C)
        g.copy(this._projectionMatrix, D.GetDefaultProjectionMatrix());
      else {
        const H = D.GetDrawWidth();
        D = D.GetDrawHeight();
        z.CalculatePerspectiveMatrix(this._projectionMatrix, H / D, J, C);
      }
    }
    _SetTransform(z, D = !0, J = 0, C = 0, H = 0) {
      D && z.SetProjectionMatrix(this._GetProjectionMatrix(z));
      0 === J && 0 === C && 0 === H
        ? (D = this._GetModelViewMatrix(z))
        : (this._CalculateModelViewMatrix(z, k, J, C, H), (D = k));
      z.SetModelViewMatrix(D);
    }
    PrepareForDraw(z) {
      this._SetTransform(z);
      z.SetBaseZ(this.GetZElevation());
    }
    Draw(z, D, J) {
      var C = this._runtime.GetCanvasManager();
      const H = this.UsesOwnTexture();
      var K = null;
      let P = null;
      if (this._runtime.IsGPUProfiling())
        if (z.IsWebGL()) {
          const S = C.GetLayerTimingsBuffer(this);
          S && ((P = S.AddTimeElapsedQuery()), z.StartQuery(P));
        } else z.IsWebGPU() && z.WriteTimestamp(2 * (this.GetIndex() + 1));
      H
        ? ((K = {
            sampling: this._runtime.GetSampling(),
            isSampled: !0,
            canReadPixels: z.IsWebGPU()
              ? this._runtime.UsesAnyBackgroundBlending()
              : !1,
          }),
          "low" === C.GetCurrentFullscreenScalingQuality() &&
            ((K.width = C.GetDrawWidth()), (K.height = C.GetDrawHeight())),
          (this._curRenderTarget = K =
            this._runtime.GetAdditionalRenderTarget(K)),
          z.SetRenderTarget(K),
          this.IsTransparent() && z.ClearRgba(0, 0, 0, 0))
        : ((this._curRenderTarget = D), z.SetRenderTarget(D));
      this.IsTransparent() || z.Clear(this._backgroundColor);
      this._layout._DrawLayerList(
        z,
        this._curRenderTarget,
        this._subLayers,
        H && this.IsTransparent()
      );
      this._SetTransform(z);
      z.SetBaseZ(this.GetZElevation());
      z.SetDepthEnabled(this.RendersIn3DMode());
      this.GetNormalScale() > Number.EPSILON &&
        (this._UpdateZIndices(),
        (C =
          this.UsesRenderCells() &&
          0 === this.GetZElevation() &&
          !this._anyInstanceZElevated),
        this.Has3DCamera()
          ? this._DrawInstances_3DCamera(z)
          : C
          ? this._DrawInstances_RenderCells(z)
          : this._DrawInstances(z, this._GetInstancesInDrawOrder()));
      z.SetBaseZ(0);
      z.SetCurrentZ(0);
      H &&
        (z.SetDepthEnabled(!1),
        this._DrawLayerOwnTextureToRenderTarget(z, K, D, J));
      P && z.EndQuery(P);
      this._runtime.IsGPUProfiling() &&
        z.IsWebGPU() &&
        z.WriteTimestamp(2 * (this.GetIndex() + 1) + 1);
      this._curRenderTarget = null;
    }
    _DrawInstances(z, D) {
      const J = this.GetViewport(),
        C = this._curRenderTarget,
        H = this.GetLayout().IsOrthographicProjection(),
        K = this.GetLayout().HasVanishingPointOutsideViewport();
      let P = null;
      for (let S = 0, U = D.length; S < U; ++S) {
        const V = D[S];
        if (V === P) continue;
        P = V;
        const aa = V.GetWorldInfo();
        aa.IsVisible() &&
          aa.IsInViewport(J, K, H) &&
          this._DrawInstanceMaybeWithEffects(V, aa, z, C);
      }
    }
    _DrawInstances_3DCamera(z) {
      const D = this._curRenderTarget,
        J = this._GetViewFrustum(),
        C = this._GetInstancesInDrawOrder();
      for (let S = 0, U = C.length; S < U; ) {
        var H = C[S],
          K = H.GetWorldInfo();
        if (!K.IsVisible() || !K.IsInViewport3D(J)) {
          ++S;
          continue;
        }
        (!H.RendersToOwnZPlane() || 0 < K.GetDepth()) && B.push(H);
        var P = H.GetWorldInfo().GetTotalZElevation();
        y.push(H);
        let V = S + 1;
        for (; V < U; ++V) {
          const aa = C[V],
            ma = aa.GetWorldInfo();
          if (ma.IsVisible() && ma.IsInViewport3D(J)) {
            if (ma.GetTotalZElevation() !== P) break;
            aa.RendersToOwnZPlane()
              ? (0 < ma.GetDepth() && B.push(aa), y.push(aa))
              : B.push(aa);
          }
        }
        if (1 !== y.length || y[0].MustMitigateZFighting()) {
          this._DrawCoplanarInstances_3DCamera(z, y);
          for (let aa = 0, ma = B.length; aa < ma; ++aa)
            (H = B[aa]),
              (K = H.GetWorldInfo()),
              K._SetDrawNonBackFacesOnly(!0),
              this._DrawInstanceMaybeWithEffects(H, K, z, D),
              K._SetDrawNonBackFacesOnly(!1);
        } else {
          this._DrawInstanceMaybeWithEffects(H, K, z, D);
          for (let aa = 0, ma = B.length; aa < ma; ++aa)
            (K = B[aa]),
              K !== H &&
                ((P = K.GetWorldInfo()),
                P.GetLayer()._DrawInstanceMaybeWithEffects(K, P, z, D));
        }
        S = V;
        e.clearArray(y);
        e.clearArray(B);
      }
    }
    _DrawCoplanarInstances_3DCamera(z, D) {
      const J = this._curRenderTarget;
      z.CoplanarStartStencilPass();
      for (let K = 0, P = D.length; K < P; ++K) {
        var C = D[K],
          H = C.GetWorldInfo();
        H._SetDrawBackFaceOnly(!0);
        this._DrawInstance(C, H, z);
      }
      z.CoplanarStartColorPass();
      for (let K = 0, P = D.length; K < P; ++K)
        (C = D[K]),
          (H = C.GetWorldInfo()),
          this._DrawInstanceMaybeWithEffects(C, H, z, J),
          H._SetDrawBackFaceOnly(!1);
      z.CoplanarRestoreStandardRendering();
    }
    _DrawInstances_RenderCells(z) {
      var D = this._renderGrid;
      const J = this._curRenderCells,
        C = this._lastRenderCells,
        H = this.GetViewport();
      J.set(
        D.XToCell(H.getLeft()),
        D.YToCell(H.getTop()),
        D.XToCell(H.getRight()),
        D.YToCell(H.getBottom())
      );
      this._isRenderListUpToDate && J.equals(C)
        ? (D = this._lastRenderList)
        : ((D = this._GetRenderCellInstancesToDraw()),
          (this._isRenderListUpToDate = !0),
          C.copy(J));
      this._DrawInstances(z, D);
      D !== this._lastRenderList &&
        e.shallowAssignArray(this._lastRenderList, D);
    }
    _DrawInstanceMaybeWithEffects(z, D, J, C) {
      D.HasAnyActiveEffect()
        ? this._DrawInstanceWithEffectsAndRestore(z, D, J, C)
        : this._DrawInstance(z, D, J);
    }
    _DrawInstance(z, D, J) {
      D = D.GetRendererStateGroup();
      J.GetCurrentStateGroup() !== D && D.Apply();
      z.Draw(J);
    }
    _DrawInstanceWithEffectsAndRestore(z, D, J, C) {
      this._DrawInstanceWithEffects(z, D, J, C, null) && this._SetTransform(J);
    }
    _DrawInstanceWithEffects(z, D, J, C, H) {
      const K = D.GetInstanceEffectList().GetEffectChain();
      K.Render(J, C, {
        contentObject: z,
        blendMode: D.GetBlendMode(),
        devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(),
        time: z.GetInstanceGameTime(),
        layerScale:
          this._runtime.GetEffectLayerScaleParam() * this.GetNormalScale(),
        layerAngle: this.GetAngle(),
        layoutRect: D.GetBoundingBox(),
        drawSurfaceRect: K.CanSkipCalculatingDrawSurfaceRect()
          ? null
          : this._InstanceBoxToDrawSurface(D),
        drawContentHook: H && H.drawContentHook,
        compositOffX: H && H.compositOffX,
        compositOffY: H && H.compositOffY,
        updateOwnProjection: H && H.updateOwnProjection,
      });
      J.SetBaseZ(this.GetZElevation());
      return K.DidChangeTransform();
    }
    _DrawLayerOwnTextureToRenderTarget(z, D, J, C) {
      const H = this._effectList.GetActiveEffectTypes(),
        K = this._runtime;
      0 === H.length
        ? (z.SetRenderTarget(J),
          z.SetTextureFillMode(),
          C && 0 === this._blendMode && this.HasDefaultColor()
            ? z.CopyRenderTarget(D)
            : (z.SetBlendMode(this._blendMode),
              z.SetColor(this._premultipliedColor),
              z.DrawRenderTarget(D)),
          z.InvalidateRenderTarget(D),
          K.ReleaseAdditionalRenderTarget(D))
        : this.GetEffectChain().Render(z, J, {
            contentObject: this,
            blendMode: this.GetBlendMode(),
            devicePixelRatio: K.GetEffectDevicePixelRatioParam(),
            layerScale: K.GetEffectLayerScaleParam() * this.GetNormalScale(),
            layerAngle: this.GetAngle(),
            layoutRect: this.GetViewport(),
            drawSurfaceRect: null,
            invalidateRenderTargets: !0,
          });
    }
    GetOwnScale() {
      return this._scale;
    }
    SetOwnScale(z) {
      this._scale !== z &&
        ((this._scale = z),
        this._layout.BoundScrolling(),
        this._SetMVMatrixChanged(),
        this._runtime.UpdateRender());
    }
    GetRenderScale() {
      return this.GetNormalScale() * this._runtime.GetRenderScale();
    }
    GetDisplayScale() {
      return this.GetNormalScale() * this._runtime.GetDisplayScale();
    }
    GetNormalScale() {
      return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1;
    }
    _MaybeUpdateViewport() {
      if (this._isViewportChanged) {
        this._isViewportChanged = !1;
        var z = this._runtime.GetParallaxXOrigin(),
          D = this._runtime.GetParallaxYOrigin(),
          J = (this.GetScrollX() - z) * this._parallaxX + z,
          C = (this.GetScrollY() - D) * this._parallaxY + D;
        z = this.GetNormalScale();
        D = this._runtime.GetViewportWidth() / z;
        z = this._runtime.GetViewportHeight() / z;
        J -= D / 2;
        var H = C - z / 2;
        this._runtime.IsPixelRoundingEnabled() &&
          ((J = Math.round(J)), (H = Math.round(H)));
        C = this._viewportZ0;
        C.set(J, H, J + D, H + z);
        D = this.GetAngle();
        0 !== D &&
          (b.copy(C),
          b.offset(-C.midX(), -C.midY()),
          a.setFromRotatedRect(b, D),
          a.getBoundingBox(b),
          b.offset(C.midX(), C.midY()),
          C.copy(b));
        D = this._zElevation;
        this.GetViewportForZ(D, this._viewport);
        this.Has3DCamera()
          ? this.CalculateViewport3D(D, this._viewport3D)
          : this._viewport3D.copy(this._viewport);
      }
    }
    CalculateViewport3D(z, D) {
      var J = this._runtime.GetCanvasManager(),
        C = J.GetCssWidth();
      J = J.GetCssHeight();
      const [H, K] = this.CanvasCssToLayer(0, 0, z),
        [P, S] = this.CanvasCssToLayer(C, 0, z),
        [U, V] = this.CanvasCssToLayer(C, J, z),
        [aa, ma] = this.CanvasCssToLayer(0, J, z);
      z = Math.min(H, P, U, aa);
      C = Math.min(K, S, V, ma);
      J = Math.max(H, P, U, aa);
      let va = Math.max(K, S, V, ma);
      isFinite(z) || (z = -Infinity);
      isFinite(C) || (C = -Infinity);
      isFinite(J) || (J = Infinity);
      isFinite(va) || (va = Infinity);
      D.set(z, C, J, va);
    }
    CanvasCssToLayer(z, D, J = 0) {
      return this._CanvasToLayer(z, D, J, this.GetDisplayScale());
    }
    DrawSurfaceToLayer(z, D, J = 0) {
      return this._CanvasToLayer(
        z,
        D,
        J,
        this.GetRenderScale() * this.GetDevicePixelRatio()
      );
    }
    _CanvasToLayer(z, D, J, C) {
      var H = this._runtime,
        K = H.GetRenderer();
      const P = this.GetNormalScale(),
        S = H.GetViewportWidth() / P;
      H = H.GetViewportHeight() / P;
      h.set(q, 0, 0, S, H);
      z /= C;
      D = q[3] - D / C;
      C = this._GetProjectionMatrix(K);
      K = this._GetModelViewMatrix(K);
      return e.Gfx.UnprojectScreenToWorldZ(z, D, J, K, C, q, m)
        ? [m[0], m[1]]
        : [NaN, NaN];
    }
    CanvasCssToLayer_DefaultTransform(z, D) {
      const J = this._scale,
        C = this._scaleRate,
        H = this._parallaxX,
        K = this._parallaxY,
        P = this._angle;
      this._parallaxY = this._parallaxX = this._scaleRate = this._scale = 1;
      this._angle = 0;
      this._SetMVMatrixChanged();
      z = this.CanvasCssToLayer(z, D);
      this._scale = J;
      this._scaleRate = C;
      this._parallaxX = H;
      this._parallaxY = K;
      this._angle = P;
      this._SetMVMatrixChanged();
      return z;
    }
    LayerToCanvasCss(z, D, J = 0) {
      return this._LayerToCanvas(z, D, J, this.GetDisplayScale());
    }
    LayerToDrawSurface(z, D, J = 0) {
      return this._LayerToCanvas(
        z,
        D,
        J,
        this.GetRenderScale() * this.GetDevicePixelRatio()
      );
    }
    _LayerToCanvas(z, D, J, C) {
      var H = this._runtime,
        K = H.GetRenderer();
      const P = this.GetNormalScale();
      var S = H.GetViewportWidth() / P;
      H = H.GetViewportHeight() / P;
      h.set(q, 0, 0, S, H);
      S = this._GetProjectionMatrix(K);
      K = this._GetModelViewMatrix(K);
      return e.Gfx.Project(z, D, J, K, S, q, m)
        ? [m[0] * C, (q[3] - m[1]) * C]
        : [NaN, NaN];
    }
    _GetLayerToDrawSurfaceScale(z, D) {
      z *= this.GetRenderScale() * this.GetDevicePixelRatio();
      0 !== D && (z *= this.Get2DScaleFactorToZ(D));
      return z;
    }
    _InstanceBoxToDrawSurface(z) {
      var D = z.GetBoundingBox(),
        J = z.GetTotalZElevation();
      z = z.GetDepth();
      const C = J + z,
        H = D.getLeft(),
        K = D.getTop(),
        P = D.getRight();
      D = D.getBottom();
      if (this.Has3DCamera()) {
        if (
          this._IsPointBehindNearPlane(H, K, J) ||
          this._IsPointBehindNearPlane(P, K, J) ||
          this._IsPointBehindNearPlane(P, D, J) ||
          this._IsPointBehindNearPlane(H, D, J) ||
          (0 < z &&
            (this._IsPointBehindNearPlane(H, K, C) ||
              this._IsPointBehindNearPlane(P, K, C) ||
              this._IsPointBehindNearPlane(P, D, C) ||
              this._IsPointBehindNearPlane(H, D, C)))
        )
          return null;
      } else if (C >= this.GetCameraZ()) return null;
      let [S, U] = this.LayerToDrawSurface(H, K, J),
        [V, aa] = this.LayerToDrawSurface(P, D, J);
      if (0 !== this.GetAngle() || 0 < z) {
        const [ma, va] = this.LayerToDrawSurface(P, K, J),
          [Na, Ea] = this.LayerToDrawSurface(H, D, J);
        if (0 < z) {
          const [Ia, Ma] = this.LayerToDrawSurface(H, K, C),
            [Fa, ya] = this.LayerToDrawSurface(P, K, C),
            [na, Va] = this.LayerToDrawSurface(P, D, C),
            [xa, Ga] = this.LayerToDrawSurface(H, D, C);
          J = Math.min(S, V, ma, Na, Ia, Fa, na, xa);
          V = Math.max(S, V, ma, Na, Ia, Fa, na, xa);
          S = J;
          J = Math.min(U, aa, va, Ea, Ma, ya, Va, Ga);
          aa = Math.max(U, aa, va, Ea, Ma, ya, Va, Ga);
          U = J;
        } else
          (J = Math.min(S, V, ma, Na)),
            (V = Math.max(S, V, ma, Na)),
            (S = J),
            (J = Math.min(U, aa, va, Ea)),
            (aa = Math.max(U, aa, va, Ea)),
            (U = J);
      }
      b.set(S, U, V, aa);
      return b;
    }
    _GetViewFrustum() {
      this._isViewFrustumChanged &&
        (this._UpdateViewFrustum(), (this._isViewFrustumChanged = !1));
      return this._viewFrustum;
    }
    _UpdateViewFrustum() {
      var z = this._runtime.GetRenderer();
      const D = this._GetProjectionMatrix(z);
      z = this._GetModelViewMatrix(z);
      this._viewFrustum.CalculatePlanes(z, D);
    }
    _IsPointBehindNearPlane(z, D, J) {
      return this._GetViewFrustum().IsBehindNearPlane(z, D, J);
    }
    _SaveToJson() {
      return {
        s: this.GetOwnScale(),
        a: this.GetOwnAngle(),
        v: this._IsVisibleFlagSet(),
        i: this.IsInteractive(),
        bc: this._backgroundColor.toJSON(),
        t: this.IsTransparent(),
        sx: this._scrollX,
        sy: this._scrollY,
        hosp: this._hasOwnScrollPosition,
        px: this.GetParallaxX(),
        py: this.GetParallaxY(),
        c: this._color.toJSON(),
        sr: this.GetScaleRate(),
        fx: this._effectList.SaveToJson(),
        cg: this._createdGlobalUids,
      };
    }
    _LoadFromJson(z) {
      this._scale = z.s;
      this._angle = z.a;
      this._isVisible = !!z.v;
      this._isInteractive = z.hasOwnProperty("i") ? z.i : !0;
      this._backgroundColor.setFromJSON(z.bc);
      this._isTransparent = !!z.t;
      z.hasOwnProperty("sx") && (this._scrollX = z.sx);
      z.hasOwnProperty("sy") && (this._scrollY = z.sy);
      z.hasOwnProperty("hosp") && (this._hasOwnScrollPosition = !!z.hosp);
      this._parallaxX = z.px;
      this._parallaxY = z.py;
      this._color.setFromJSON(z.c);
      this._scaleRate = z.sr;
      e.shallowAssignArray(this._createdGlobalUids, z.cg);
      e.shallowAssignArray(
        this._initialInstances,
        this._startupInitialInstances
      );
      const D = new Set(this._createdGlobalUids);
      let J = 0;
      for (let C = 0, H = this._initialInstances.length; C < H; ++C)
        D.has(this._initialInstances[C][2]) ||
          ((this._initialInstances[J] = this._initialInstances[C]), ++J);
      e.truncateArray(this._initialInstances, J);
      this._effectList.LoadFromJson(z.fx);
      this._needsRebuildEffectChainSteps = !0;
      this._SortInstancesByLastCachedZIndex(!1);
      this.SetZIndicesChanged();
      this._SetMVMatrixChanged();
      this._SetProjectionMatrixChanged();
    }
    GetILayer() {
      return this._iLayer;
    }
    SortAndAddInstancesByZIndex(z) {
      if (!this._instances.includes(z))
        if (z.HasChildren()) {
          var D = [...z.allChildren()];
          D.push(z);
          D.sort((C, H) => {
            C = C.GetWorldInfo().GetSceneGraphZIndex();
            H = H.GetWorldInfo().GetSceneGraphZIndex();
            return C - H;
          });
          for (var J of D)
            if (J.IsInContainer())
              for (const C of J.siblings())
                D.includes(C) ||
                  ((z = [...C.allChildren()]),
                  z.push(C),
                  z.sort((H, K) => {
                    H = H.GetWorldInfo().GetSceneGraphZIndex();
                    K = K.GetWorldInfo().GetSceneGraphZIndex();
                    return H - K;
                  }),
                  z && z.length && D.splice(D.length, 0, ...z));
          for (const C of D) this._AddInstance(C, !0);
        } else if ((this._AddInstance(z, !0), z.IsInContainer()))
          for (D of z.siblings())
            if (
              ((J = [...D.allChildren()]),
              J.push(D),
              J.sort((C, H) => {
                C = C.GetWorldInfo().GetSceneGraphZIndex();
                H = H.GetWorldInfo().GetSceneGraphZIndex();
                return C - H;
              }),
              J && J.length)
            )
              for (const C of J) this._AddInstance(C, !0);
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.C3Debugger;
  e.New(e.Rect);
  e.New(e.Rect);
  const a = e.New(e.Rect),
    c = e.New(e.Color),
    d = self.glMatrix.vec3,
    f = [],
    h = [],
    g = [],
    k = [];
  function m(r, n, p, u) {
    return (
      r[0] === Math.fround(n) &&
      r[1] === Math.fround(p) &&
      r[2] === Math.fround(u)
    );
  }
  let q = null;
  function v(r, n) {
    q !== r && (r.PrepareForDraw(n), (q = r));
  }
  e.Layout = class extends e.DefendedBase {
    constructor(r, n, p) {
      super();
      this._layoutManager = r;
      this._runtime = r.GetRuntime();
      this._name = p[0];
      this._originalWidth = p[1];
      this._originalHeight = p[2];
      this._width = p[1];
      this._height = p[2];
      this._isUnboundedScrolling = !!p[3];
      this._isOrthographicProjection = !!p[4];
      this._vanishingPointX = p[5];
      this._vanishingPointY = p[6];
      this._eventSheetName = p[7];
      this._eventSheet = null;
      this._sid = p[8];
      this._index = n;
      this._scrollY = this._scrollX = 0;
      this._scale = 1;
      this._angle = 0;
      this._initialObjectClasses = new Set();
      this._textureLoadedTypes = new Set();
      this._textureLoadPendingPromises = new Set();
      this._createdInstances = [];
      this._initialNonWorld = [];
      this._is3dCameraEnabled = !1;
      this._cam3dposition = d.create();
      this._cam3dlook = d.create();
      this._cam3dup = d.create();
      this._rootLayers = [];
      this._allLayersFlat = [];
      this._layersByName = new Map();
      this._layersBySid = new Map();
      const u = this._runtime.GetCanvasManager();
      this._effectList = e.New(e.EffectList, this, p[11]);
      this._effectChain = e.New(e.Gfx.EffectChain, u.GetEffectChainManager(), {
        drawContent: (w, y) => {
          y = y.GetContentObject().GetRenderTarget();
          w.ResetColor();
          w.DrawRenderTarget(y);
          w.InvalidateRenderTarget(y);
          u.ReleaseAdditionalRenderTarget(y);
        },
        getShaderParameters: (w) =>
          this.GetEffectList()._GetEffectChainShaderParametersForIndex(w),
      });
      this._needsRebuildEffectChainSteps = !0;
      this._wasFullScreenQualityLow = !1;
      this._curRenderTarget = null;
      this._persistData = {};
      this._isFirstVisit = !0;
      this._iLayout = new self.ILayout(this);
      this._userScriptDispatcher = e.New(e.Event.Dispatcher);
      for (const w of p[9])
        this._rootLayers.push(e.New(e.Layer, this, null, w));
      this._allLayersFlat = [...this.allLayers()];
      for (let w = 0, y = this._allLayersFlat.length; w < y; ++w)
        (r = this._allLayersFlat[w]),
          r._SetIndex(w),
          r._Init(),
          this._layersByName.set(r.GetName().toLowerCase(), r),
          this._layersBySid.set(r.GetSID(), r);
      for (const w of p[10]) {
        p = this._runtime.GetObjectClassByIndex(w[1]);
        if (!p) throw Error("missing nonworld object class");
        p.GetDefaultInstanceData() || p.SetDefaultInstanceData(w);
        this._initialNonWorld.push(w);
        this._AddInitialObjectClass(p);
      }
    }
    Release() {
      for (const r of this._allLayersFlat) r.Release();
      e.clearArray(this._allLayersFlat);
      this._textureLoadPendingPromises.clear();
      this._runtime = this._layoutManager = this._eventSheet = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetName() {
      return this._name;
    }
    GetSID() {
      return this._sid;
    }
    GetIndex() {
      return this._index;
    }
    GetEffectList() {
      return this._effectList;
    }
    GetEffectChain() {
      this._MaybeRebuildEffectChainSteps();
      return this._effectChain;
    }
    _MaybeRebuildEffectChainSteps() {
      const r =
        "low" ===
        this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality();
      if (
        this._needsRebuildEffectChainSteps ||
        this._wasFullScreenQualityLow !== r
      ) {
        var n = this.GetEffectList().GetActiveEffectTypes();
        this._effectChain.BuildSteps(
          n.map((p) => p.GetShaderProgram()),
          {
            indexMap: n.map((p) => p.GetIndex()),
            forcePostDraw: r,
            useFullSurface: !0,
          }
        );
        this._needsRebuildEffectChainSteps = !1;
        this._wasFullScreenQualityLow = r;
      }
    }
    UpdateActiveEffects() {
      this.GetEffectList().UpdateActiveEffects();
      this._needsRebuildEffectChainSteps = !0;
    }
    GetMinLayerScale() {
      let r = this._allLayersFlat[0].GetNormalScale();
      for (let n = 1, p = this._allLayersFlat.length; n < p; ++n) {
        const u = this._allLayersFlat[n];
        if (0 !== u.GetParallaxX() || 0 !== u.GetParallaxY())
          r = Math.min(r, u.GetNormalScale());
      }
      return r;
    }
    _GetScrollBoundMarginHorizontal() {
      return (0.5 * this._runtime.GetViewportWidth()) / this.GetMinLayerScale();
    }
    _GetScrollBoundMarginVertical() {
      return (
        (0.5 * this._runtime.GetViewportHeight()) / this.GetMinLayerScale()
      );
    }
    GetScrollLeftBound() {
      return this.IsUnboundedScrolling()
        ? -Infinity
        : this._GetScrollBoundMarginHorizontal();
    }
    GetScrollRightBound() {
      return this.IsUnboundedScrolling()
        ? Infinity
        : this.GetWidth() - this._GetScrollBoundMarginHorizontal();
    }
    GetScrollTopBound() {
      return this.IsUnboundedScrolling()
        ? -Infinity
        : this._GetScrollBoundMarginVertical();
    }
    GetScrollBottomBound() {
      return this.IsUnboundedScrolling()
        ? Infinity
        : this.GetHeight() - this._GetScrollBoundMarginVertical();
    }
    SetScrollX(r) {
      const n = this.GetScrollLeftBound(),
        p = this.GetScrollRightBound();
      r > p && (r = p);
      r < n && (r = n);
      this._scrollX !== r &&
        ((this._scrollX = r),
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender());
    }
    GetScrollX() {
      return this._scrollX;
    }
    SetScrollY(r) {
      const n = this.GetScrollTopBound(),
        p = this.GetScrollBottomBound();
      r > p && (r = p);
      r < n && (r = n);
      this._scrollY !== r &&
        ((this._scrollY = r),
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender());
    }
    GetScrollY() {
      return this._scrollY;
    }
    IsUnboundedScrolling() {
      return this._isUnboundedScrolling;
    }
    BoundScrolling() {
      this.SetScrollX(this.GetScrollX());
      this.SetScrollY(this.GetScrollY());
      for (const r of this._allLayersFlat)
        r.IsOwnScrollPositionEnabled() &&
          (r.SetScrollX(r.GetScrollX()), r.SetScrollY(r.GetScrollY()));
    }
    SetVanishingPointXY(r, n) {
      if (this._vanishingPointX !== r || this._vanishingPointY !== n)
        (this._vanishingPointX = r),
          (this._vanishingPointY = n),
          this.IsPerspectiveProjection() &&
            (this._SetAllLayersProjectionChanged(),
            this._SetAllLayersMVChanged(),
            this._runtime.UpdateRender());
    }
    GetVanishingPointX() {
      return this.IsOrthographicProjection() ? 0.5 : this._vanishingPointX;
    }
    GetVanishingPointY() {
      return this.IsOrthographicProjection() ? 0.5 : this._vanishingPointY;
    }
    HasVanishingPointOutsideViewport() {
      const r = this.GetVanishingPointX(),
        n = this.GetVanishingPointY();
      return 0 > r || 1 < r || 0 > n || 1 < n;
    }
    SetPerspectiveProjection() {
      this._isOrthographicProjection &&
        ((this._isOrthographicProjection = !1),
        this._SetAllLayersProjectionChanged(),
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender());
    }
    SetOrthographicProjection() {
      this._isOrthographicProjection ||
        ((this._isOrthographicProjection = !0),
        this._SetAllLayersProjectionChanged(),
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender());
    }
    IsOrthographicProjection() {
      return this._isOrthographicProjection;
    }
    IsPerspectiveProjection() {
      return !this.IsOrthographicProjection();
    }
    Set3DCameraEnabled(r) {
      r = !!r;
      this._is3dCameraEnabled !== r &&
        ((this._is3dCameraEnabled = r),
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender());
    }
    Is3DCameraEnabled() {
      return this._is3dCameraEnabled;
    }
    Set3DCameraOrientation(r, n, p, u, w, y, B, E, z) {
      (m(this._cam3dposition, r, n, p) &&
        m(this._cam3dlook, u, w, y) &&
        m(this._cam3dup, B, E, z)) ||
        (d.set(this._cam3dposition, r, n, p),
        d.set(this._cam3dlook, u, w, y),
        d.set(this._cam3dup, B, E, z),
        this.Set3DCameraChanged());
    }
    Set3DCameraChanged() {
      this._SetAllLayersMVChanged();
      this._runtime.UpdateRender();
    }
    Get3DCameraPosition() {
      return this._cam3dposition;
    }
    Get3DCameraLookAt() {
      return this._cam3dlook;
    }
    Get3DCameraUpVector() {
      return this._cam3dup;
    }
    GetScale() {
      return this._scale;
    }
    SetScale(r) {
      this._scale !== r &&
        ((this._scale = r),
        this._SetAllLayersMVChanged(),
        this.BoundScrolling(),
        this._runtime.UpdateRender());
    }
    SetAngle(r) {
      r = e.clampAngle(r);
      this._angle !== r &&
        ((this._angle = r),
        this._SetAllLayersMVChanged(),
        this._runtime.UpdateRender());
    }
    GetAngle() {
      return this._angle;
    }
    GetWidth() {
      return this._width;
    }
    SetWidth(r) {
      !isFinite(r) || 1 > r || (this._width = r);
    }
    GetHeight() {
      return this._height;
    }
    SetHeight(r) {
      !isFinite(r) || 1 > r || (this._height = r);
    }
    GetEventSheet() {
      return this._eventSheet;
    }
    *allLayers() {
      for (const r of this._rootLayers) yield* r.selfAndAllSubLayers();
    }
    GetLayers() {
      return this._allLayersFlat;
    }
    GetLayerCount() {
      return this._allLayersFlat.length;
    }
    GetLayer(r) {
      return "number" === typeof r
        ? this.GetLayerByIndex(r)
        : this.GetLayerByName(r.toString());
    }
    GetLayerByIndex(r) {
      r = e.clamp(Math.floor(r), 0, this._allLayersFlat.length - 1);
      return this._allLayersFlat[r];
    }
    GetLayerByName(r) {
      return this._layersByName.get(r.toLowerCase()) || null;
    }
    GetLayerBySID(r) {
      return this._layersBySid.get(r) || null;
    }
    _SetAllLayersProjectionChanged() {
      for (const r of this._allLayersFlat) r._SetProjectionMatrixChanged();
    }
    _SetAllLayersMVChanged() {
      for (const r of this._allLayersFlat) r._SetMVMatrixChanged();
    }
    SaveTransform() {
      return {
        scrollX: this.GetScrollX(),
        scrollY: this.GetScrollY(),
        scale: this.GetScale(),
        angle: this.GetAngle(),
        vpX: this.GetVanishingPointX(),
        vpY: this.GetVanishingPointY(),
      };
    }
    RestoreTransform(r) {
      this.SetScrollX(r.scrollX);
      this.SetScrollY(r.scrollY);
      this.SetScale(r.scale);
      this.SetAngle(r.angle);
      this.SetVanishingPointXY(r.vpX, r.vpY);
    }
    GetLayoutBackgroundColor() {
      let r = this._rootLayers.filter((n) => n.ShouldDraw())[0];
      for (; r; ) {
        if (!r.IsTransparent())
          return c.copyRgb(r.GetBackgroundColor()), c.setA(1), c;
        if (r.UsesOwnTexture()) return c.setRgba(0, 0, 0, 0), c;
        r = r.GetSubLayers().filter((n) => n.ShouldDraw())[0];
      }
      c.setRgba(0, 0, 0, 0);
      return c;
    }
    IsFirstVisit() {
      return this._isFirstVisit;
    }
    _GetInitialObjectClasses() {
      return [...this._initialObjectClasses];
    }
    _AddInitialObjectClass(r) {
      if (r.IsInContainer())
        for (const n of r.GetContainer().GetObjectTypes())
          this._initialObjectClasses.add(n);
      else this._initialObjectClasses.add(r);
    }
    _GetTextureLoadedObjectTypes() {
      return [...this._textureLoadedTypes];
    }
    _Load(r, n) {
      if (r === this || !n) return Promise.resolve();
      r &&
        (e.CopySet(this._textureLoadedTypes, r._textureLoadedTypes),
        r._textureLoadedTypes.clear());
      r = [];
      for (const p of this._initialObjectClasses)
        this._textureLoadedTypes.has(p) ||
          (r.push(p.LoadTextures(n)), this._textureLoadedTypes.add(p));
      return Promise.all(r);
    }
    async MaybeLoadTexturesFor(r) {
      if (r.IsFamily()) throw Error("cannot load textures for family");
      var n = this._runtime.GetRenderer();
      !n ||
        n.IsContextLost() ||
        this._textureLoadedTypes.has(r) ||
        (this._textureLoadedTypes.add(r),
        (n = r.LoadTextures(n)),
        this._AddPendingTextureLoadPromise(n),
        await n,
        r.OnDynamicTextureLoadComplete(),
        this._runtime.UpdateRender());
    }
    _AddPendingTextureLoadPromise(r) {
      this._textureLoadPendingPromises.add(r);
      r.then(() => this._textureLoadPendingPromises.delete(r)).catch(() =>
        this._textureLoadPendingPromises.delete(r)
      );
    }
    WaitForPendingTextureLoadsToComplete() {
      return Promise.all([...this._textureLoadPendingPromises]);
    }
    MaybeUnloadTexturesFor(r) {
      if (r.IsFamily() || 0 < r.GetInstanceCount())
        throw Error("cannot unload textures");
      const n = this._runtime.GetRenderer();
      n &&
        this._textureLoadedTypes.has(r) &&
        (this._textureLoadedTypes.delete(r), r.ReleaseTextures(n));
    }
    _Unload(r, n) {
      if (r !== this && n)
        for (const p of this._textureLoadedTypes)
          p.IsGlobal() ||
            r._initialObjectClasses.has(p) ||
            (p.ReleaseTextures(), this._textureLoadedTypes.delete(p));
    }
    _OnWebGLContextLost() {
      this._textureLoadedTypes.clear();
    }
    async _StartRunning(r) {
      const n = this._runtime,
        p = this._layoutManager,
        u = n.GetEventSheetManager();
      this._eventSheetName &&
        ((this._eventSheet = u.GetEventSheetByName(this._eventSheetName)),
        this._eventSheet._UpdateDeepIncludes());
      p._SetMainRunningLayout(this);
      this._width = this._originalWidth;
      this._height = this._originalHeight;
      this._scrollX = n.GetOriginalViewportWidth() / 2;
      this._scrollY = n.GetOriginalViewportHeight() / 2;
      this.BoundScrolling();
      this._SetAllLayersProjectionChanged();
      this._SetAllLayersMVChanged();
      this._MoveGlobalObjectsToThisLayout(r);
      this._runtime.SetUsingCreatePromises(!0);
      this._CreateInitialInstances();
      this._isFirstVisit || this._CreatePersistedInstances();
      this._CreateAndLinkContainerInstances(this._createdInstances);
      this._CreateInitialNonWorldInstances();
      p.ClearPendingChangeLayout();
      n.FlushPendingInstances();
      this._runtime.SetUsingCreatePromises(!1);
      const w = this._runtime.GetCreatePromises();
      await Promise.all(w);
      e.clearArray(w);
      if (!n.IsLoadingState()) {
        for (const y of this._createdInstances)
          y.SetupInitialSceneGraphConnections();
        for (const y of this._createdInstances) y._TriggerOnCreated();
      }
      e.clearArray(this._createdInstances);
      await Promise.all(
        [...this._initialObjectClasses].map((y) =>
          y.PreloadTexturesWithInstances(this._runtime.GetRenderer())
        )
      );
      r &&
        (n.Dispatcher().dispatchEvent(new e.Event("beforefirstlayoutstart")),
        await n.DispatchUserScriptEventAsyncWait(
          new e.Event("beforeprojectstart")
        ));
      await this.DispatchUserScriptEventAsyncWait(
        new e.Event("beforelayoutstart")
      );
      n.IsLoadingState() ||
        (await n.TriggerAsync(e.Plugins.System.Cnds.OnLayoutStart, null, null));
      n.Dispatcher().dispatchEvent(new e.Event("afterlayoutstart"));
      await this.DispatchUserScriptEventAsyncWait(
        new e.Event("afterlayoutstart")
      );
      r &&
        (n.Dispatcher().dispatchEvent(new e.Event("afterfirstlayoutstart")),
        await n.DispatchUserScriptEventAsyncWait(
          new e.Event("afterprojectstart")
        ));
      u._RunQueuedTriggers(p);
      await this.WaitForPendingTextureLoadsToComplete();
      this._isFirstVisit = !1;
    }
    _MoveGlobalObjectsToThisLayout(r) {
      for (const p of this._runtime.GetAllObjectClasses())
        if (!p.IsFamily() && p.IsWorldType())
          for (const u of p.GetInstances()) {
            const w = u.GetWorldInfo();
            var n = w.GetLayer();
            n = e.clamp(n.GetIndex(), 0, this._allLayersFlat.length - 1);
            n = this._allLayersFlat[n];
            w._SetLayer(n);
            n._MaybeAddInstance(u);
          }
      if (!r)
        for (const p of this._allLayersFlat)
          p._SortInstancesByLastCachedZIndex(!1);
    }
    _CreateInitialInstances() {
      for (const r of this._allLayersFlat)
        r.CreateInitialInstances(this._createdInstances), r._Start();
    }
    _CreatePersistedInstances() {
      let r = !1;
      for (const [p, u] of Object.entries(this._persistData)) {
        const w = this._runtime.GetObjectClassBySID(parseInt(p, 10));
        if (w && !w.IsFamily() && w.HasPersistBehavior()) {
          for (const y of u) {
            var n = null;
            if (w.IsWorldType() && ((n = this.GetLayerBySID(y.w.l)), !n))
              continue;
            n = this._runtime.CreateInstanceFromData(w, n, !1, 0, 0, !0);
            n.LoadFromJson(y);
            r = !0;
            this._createdInstances.push(n);
          }
          e.clearArray(u);
        }
      }
      for (const p of this._allLayersFlat)
        p._SortInstancesByLastCachedZIndex(!0), p.SetZIndicesChanged();
      r &&
        (this._runtime.FlushPendingInstances(), this._runtime._RefreshUidMap());
    }
    _CreateAndLinkContainerInstances(r) {
      for (const p of r) {
        if (!p.IsInContainer()) continue;
        const u = p.GetWorldInfo(),
          w = p.GetIID();
        for (const y of p.GetObjectClass().GetContainer().objectTypes())
          if (y !== p.GetObjectClass()) {
            var n = y.GetInstances();
            n.length > w
              ? p._AddSibling(n[w])
              : ((n = u
                  ? this._runtime.CreateInstanceFromData(
                      y,
                      u.GetLayer(),
                      !0,
                      u.GetX(),
                      u.GetY(),
                      !0
                    )
                  : this._runtime.CreateInstanceFromData(
                      y,
                      null,
                      !0,
                      0,
                      0,
                      !0
                    )),
                this._runtime.FlushPendingInstances(),
                y._UpdateIIDs(),
                p._AddSibling(n),
                r.push(n));
          }
      }
    }
    _CreateInitialNonWorldInstances() {
      for (const r of this._initialNonWorld)
        this._runtime.GetObjectClassByIndex(r[1]).IsInContainer() ||
          this._runtime.CreateInstanceFromData(r, null, !0);
    }
    _CreateGlobalNonWorlds() {
      const r = [],
        n = this._initialNonWorld;
      let p = 0;
      for (let u = 0, w = n.length; u < w; ++u) {
        const y = n[u],
          B = this._runtime.GetObjectClassByIndex(y[1]);
        B.IsGlobal()
          ? (B.IsInContainer() && B.GetContainer().HasAnyWorldType()) ||
            r.push(this._runtime.CreateInstanceFromData(y, null, !0))
          : ((n[p] = y), ++p);
      }
      e.truncateArray(n, p);
      this._runtime.FlushPendingInstances();
      this._CreateAndLinkContainerInstances(r);
    }
    RecreateInitialObjects(r, n, p, u, w, y) {
      if (p) return p.RecreateInitialObjects(r, n, u, w, y);
      p = [];
      for (const B of this._allLayersFlat)
        p.push(B.RecreateInitialObjects(r, n, u, w, y));
      return p.flat();
    }
    async _StopRunning() {
      const r = this._layoutManager;
      this._runtime.IsLoadingState() ||
        (await this._runtime.TriggerAsync(
          e.Plugins.System.Cnds.OnLayoutEnd,
          null,
          null
        ));
      r.SetIsEndingLayout(!0);
      this._runtime.GetEventSheetManager().ClearAllScheduledWaits();
      this._isFirstVisit || this._SavePersistData();
      for (const n of this._allLayersFlat) n._End();
      for (const n of this._runtime.GetAllObjectClasses())
        if (
          !(
            n.IsGlobal() ||
            n.IsWorldType() ||
            n.GetPlugin().IsSingleGlobal() ||
            n.IsFamily()
          )
        ) {
          for (const p of n.GetInstances()) this._runtime.DestroyInstance(p);
          this._runtime.FlushPendingInstances();
        }
      r.SetIsEndingLayout(!1);
      r.GetMainRunningLayout() === this && r._SetMainRunningLayout(null);
    }
    _SaveInstanceToPersist(r) {
      const n = r.GetObjectClass().GetSID().toString();
      this._persistData.hasOwnProperty(n) || (this._persistData[n] = []);
      this._persistData[n].push(r.SaveToJson());
    }
    _SavePersistData() {
      for (const r of this._allLayersFlat) {
        r._UpdateZIndices();
        for (const n of r._GetInstances()) {
          const p = n.GetObjectClass();
          !p.IsGlobal() &&
            p.HasPersistBehavior() &&
            this._SaveInstanceToPersist(n);
        }
      }
    }
    ResetPersistData() {
      this._persistData = {};
      this._isFirstVisit = !0;
    }
    GetRenderTarget() {
      return this._curRenderTarget;
    }
    UsesOwnTexture() {
      const r = this._runtime,
        n = r.GetRenderer().IsWebGL();
      return (
        "low" === r.GetCanvasManager().GetCurrentFullscreenScalingQuality() ||
        (n && r.UsesAnyBackgroundBlending()) ||
        "low-latency" === r.GetCompositingMode() ||
        this._effectList.HasAnyActiveEffect() ||
        (n && r.Uses3DFeatures())
      );
    }
    Draw(r) {
      const n = this._runtime.GetCanvasManager(),
        p = this.UsesOwnTexture();
      if (p) {
        "low-latency" !== this._runtime.GetCompositingMode() &&
          (r.SetRenderTarget(null), r.ClearRgba(0, 0, 0, 0));
        const u = {
          sampling: this._runtime.GetSampling(),
          isSampled:
            r.IsWebGPU() ||
            this._runtime.UsesAnyBackgroundBlending() ||
            this._effectList.HasAnyActiveEffect(),
          canReadPixels: r.IsWebGPU()
            ? this._runtime.UsesAnyBackgroundBlending()
            : !1,
        };
        "low" === n.GetCurrentFullscreenScalingQuality() &&
          ((u.width = n.GetDrawWidth()), (u.height = n.GetDrawHeight()));
        this._curRenderTarget = this._runtime.GetAdditionalRenderTarget(u);
      } else this._curRenderTarget = null;
      r.SetRenderTarget(this._curRenderTarget);
      r.Clear(this.GetLayoutBackgroundColor());
      this._runtime.Uses3DFeatures() && r.ClearDepth();
      this._DrawLayerList(r, this._curRenderTarget, this._rootLayers, !0);
      p &&
        (r.SetDepthEnabled(!1),
        this._DrawLayoutOwnTextureToRenderTarget(r, this._curRenderTarget));
      this._curRenderTarget = null;
    }
    _DrawLayerList(r, n, p, u) {
      p = p.filter((w) => w.ShouldDraw());
      for (let w = 0, y = p.length; w < y; ) {
        const B = p[w];
        if (
          B.SelfAndAllSubLayersHave3DCamera() &&
          !B.SelfOrAnySubLayerUsesOwnTexture()
        ) {
          f.push(B);
          for (let E = w + 1; E < y; ++E) {
            const z = p[E];
            if (
              z.SelfAndAllSubLayersHave3DCamera() &&
              !z.SelfOrAnySubLayerUsesOwnTexture()
            )
              f.push(p[E]);
            else break;
          }
          if (
            2 <= f.length ||
            (1 === f.length && f[0].HasAnyVisibleSubLayer())
          ) {
            this._Draw3DLayers(r, n, f);
            w += f.length;
            e.clearArray(f);
            continue;
          }
          e.clearArray(f);
        }
        B.Draw(r, n, u && 0 === w);
        ++w;
      }
    }
    _DrawLayoutOwnTextureToRenderTarget(r, n) {
      const p = this._effectList.GetActiveEffectTypes(),
        u = this._runtime;
      0 === p.length
        ? (r.SetRenderTarget(null),
          r.SetTextureFillMode(),
          r.CopyRenderTarget(n),
          r.InvalidateRenderTarget(n),
          u.ReleaseAdditionalRenderTarget(n))
        : (a.set(0, 0, u.GetViewportWidth(), u.GetViewportHeight()),
          this.GetEffectChain().Render(r, null, {
            contentObject: this,
            blendMode: 3,
            devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(),
            layerScale:
              this._runtime.GetEffectLayerScaleParam() * this.GetScale(),
            layerAngle: this.GetAngle(),
            layoutRect: a,
            drawSurfaceRect: null,
            invalidateRenderTargets: !0,
          }));
    }
    _Draw3DLayers(r, n, p) {
      p[0].IsTransparent() ||
        (c.copyRgb(p[0].GetBackgroundColor()), c.setA(1), r.Clear(c));
      var u = this._runtime.GetCanvasManager();
      r.SetDepthEnabled(!0);
      for (var w of p)
        w._UpdateZIndices(),
          w._AppendAllInstancesIncludingSubLayersInDrawOrder(h);
      p = p[0];
      w = null;
      if (this._runtime.IsGPUProfiling())
        if (r.IsWebGL()) {
          if ((u = u.GetLayerTimingsBuffer(p)))
            (w = u.AddTimeElapsedQuery()), r.StartQuery(w);
        } else r.IsWebGPU() && r.WriteTimestamp(2 * (p.GetIndex() + 1));
      for (let D = 0, J = h.length; D < J; ) {
        var y = h[D],
          B = y.GetWorldInfo(),
          E = B.GetLayer();
        if (B.IsVisible() && B.IsInViewport3D(E._GetViewFrustum())) {
          (!y.RendersToOwnZPlane() || 0 < B.GetDepth()) && k.push(y);
          var z = y.GetWorldInfo().GetTotalZElevation();
          g.push(y);
          for (u = D + 1; u < J; ++u) {
            const C = h[u],
              H = C.GetWorldInfo();
            if (
              H.IsVisible() &&
              H.IsInViewport3D(H.GetLayer()._GetViewFrustum())
            ) {
              if (H.GetTotalZElevation() !== z) break;
              C.RendersToOwnZPlane()
                ? (0 < H.GetDepth() && k.push(C), g.push(C))
                : k.push(C);
            }
          }
          if (1 !== g.length || g[0].MustMitigateZFighting()) {
            this._Draw3DLayersCoplanarInstances(r, n, g);
            for (let C = 0, H = k.length; C < H; ++C)
              (y = k[C]),
                (B = y.GetWorldInfo()),
                (E = B.GetLayer()),
                B._SetDrawNonBackFacesOnly(!0),
                v(E, r),
                E._DrawInstanceMaybeWithEffects(y, B, r, n),
                B._SetDrawNonBackFacesOnly(!1);
          } else {
            v(E, r);
            E._DrawInstanceMaybeWithEffects(y, B, r, n);
            for (let C = 0, H = k.length; C < H; ++C)
              (B = k[C]),
                B !== y &&
                  ((E = B.GetWorldInfo()),
                  (z = E.GetLayer()),
                  v(z, r),
                  z._DrawInstanceMaybeWithEffects(B, E, r, n));
          }
          D = u;
          e.clearArray(g);
          e.clearArray(k);
        } else ++D;
      }
      w && r.EndQuery(w);
      this._runtime.IsGPUProfiling() &&
        r.IsWebGPU() &&
        r.WriteTimestamp(2 * (p.GetIndex() + 1) + 1);
      e.clearArray(h);
      q = null;
    }
    _Draw3DLayersCoplanarInstances(r, n, p) {
      r.CoplanarStartStencilPass();
      for (let B = 0, E = p.length; B < E; ++B) {
        var u = p[B],
          w = u.GetWorldInfo(),
          y = w.GetLayer();
        w._SetDrawBackFaceOnly(!0);
        v(y, r);
        y._DrawInstance(u, w, r);
      }
      r.CoplanarStartColorPass();
      for (let B = 0, E = p.length; B < E; ++B)
        (u = p[B]),
          (w = u.GetWorldInfo()),
          (y = w.GetLayer()),
          v(y, r),
          y._DrawInstanceMaybeWithEffects(u, w, r, n),
          w._SetDrawBackFaceOnly(!1);
      r.CoplanarRestoreStandardRendering();
    }
    _SaveToJson() {
      const r = {
        sx: this.GetScrollX(),
        sy: this.GetScrollY(),
        s: this.GetScale(),
        a: this.GetAngle(),
        w: this.GetWidth(),
        h: this.GetHeight(),
        ortho: this.IsOrthographicProjection(),
        vpX: this.GetVanishingPointX(),
        vpY: this.GetVanishingPointY(),
        fv: this._isFirstVisit,
        persist: this._persistData,
        fx: this._effectList.SaveToJson(),
        layers: {},
      };
      for (const n of this._allLayersFlat)
        r.layers[n.GetSID().toString()] = n._SaveToJson();
      return r;
    }
    _LoadFromJson(r) {
      this._scrollX = r.sx;
      this._scrollY = r.sy;
      this._scale = r.s;
      this._angle = r.a;
      this._width = r.w;
      this._height = r.h;
      this._isOrthographicProjection = !!r.ortho;
      r.hasOwnProperty("vpX") && (this._vanishingPointX = r.vpX);
      r.hasOwnProperty("vpY") && (this._vanishingPointY = r.vpY);
      this._isFirstVisit = !!r.fv;
      this._persistData = r.persist;
      this._effectList.LoadFromJson(r.fx);
      this._needsRebuildEffectChainSteps = !0;
      for (const [n, p] of Object.entries(r.layers))
        (r = parseInt(n, 10)),
          (r = this.GetLayerBySID(r)) && r._LoadFromJson(p);
      this._SetAllLayersProjectionChanged();
      this._SetAllLayersMVChanged();
    }
    GetILayout() {
      return this._iLayout;
    }
    UserScriptDispatcher() {
      return this._userScriptDispatcher;
    }
    DispatchUserScriptEvent(r) {
      r.layout = this.GetILayout();
      var n = this._runtime;
      (n = n.IsDebug() && !n.GetEventSheetManager().IsInEventEngine()) &&
        b.StartMeasuringScriptTime();
      this._userScriptDispatcher.dispatchEvent(r);
      n && b.AddScriptTime();
    }
    DispatchUserScriptEventAsyncWait(r) {
      r.layout = this.GetILayout();
      return this._userScriptDispatcher.dispatchEventAndWaitAsync(r);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.LayoutManager = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._runtime = b;
      this._allLayouts = [];
      this._layoutsByName = new Map();
      this._layoutsBySid = new Map();
      this._mainRunningLayout = null;
      this._runningSubLayouts = [];
      this._firstLayout = null;
      this._isEndingLayout = 0;
      this._pendingChangeLayout = null;
    }
    Release() {
      this._pendingChangeLayout =
        this._firstLayout =
        this._mainRunningLayout =
        this._runtime =
          null;
      e.clearArray(this._allLayouts);
      this._layoutsByName.clear();
      this._layoutsBySid.clear();
      e.clearArray(this._runningSubLayouts);
    }
    Create(b) {
      b = e.New(e.Layout, this, this._allLayouts.length, b);
      this._allLayouts.push(b);
      this._layoutsByName.set(b.GetName().toLowerCase(), b);
      this._layoutsBySid.set(b.GetSID(), b);
    }
    GetRuntime() {
      return this._runtime;
    }
    SetFirstLayout(b) {
      this._firstLayout = b;
    }
    GetFirstLayout() {
      if (this._firstLayout) return this._firstLayout;
      if (this._allLayouts.length) return this._allLayouts[0];
      throw Error("no first layout");
    }
    GetLayoutByName(b) {
      return this._layoutsByName.get(b.toLowerCase()) || null;
    }
    GetLayoutBySID(b) {
      return this._layoutsBySid.get(b) || null;
    }
    GetLayoutByIndex(b) {
      b = e.clamp(Math.floor(b), 0, this._allLayouts.length - 1);
      return this._allLayouts[b];
    }
    GetLayout(b) {
      return "number" === typeof b
        ? this.GetLayoutByIndex(b)
        : this.GetLayoutByName(b.toString());
    }
    GetAllLayouts() {
      return this._allLayouts;
    }
    _SetMainRunningLayout(b) {
      this._mainRunningLayout = b;
    }
    GetMainRunningLayout() {
      return this._mainRunningLayout;
    }
    _AddRunningSubLayout(b) {
      if (this._runningSubLayouts.includes(b))
        throw Error("layout already running");
      this._runningSubLayouts.push(b);
    }
    _RemoveRunningSubLayout(b) {
      b = this._runningSubLayouts.indexOf(b);
      if (-1 === b) throw Error("layout not running");
      this._runningSubLayouts.splice(b, 1);
    }
    *runningLayouts() {
      this._mainRunningLayout && (yield this._mainRunningLayout);
      this._runningSubLayouts.length && (yield* this._runningSubLayouts);
    }
    IsLayoutRunning(b) {
      return (
        this._mainRunningLayout === b || this._runningSubLayouts.includes(b)
      );
    }
    SetIsEndingLayout(b) {
      if (b) this._isEndingLayout++;
      else {
        if (0 >= this._isEndingLayout) throw Error("already unset");
        this._isEndingLayout--;
      }
    }
    IsEndingLayout() {
      return 0 < this._isEndingLayout;
    }
    ChangeMainLayout(b) {
      this._pendingChangeLayout = b;
    }
    ClearPendingChangeLayout() {
      this._pendingChangeLayout = null;
    }
    IsPendingChangeMainLayout() {
      return !!this._pendingChangeLayout;
    }
    GetPendingChangeMainLayout() {
      return this._pendingChangeLayout;
    }
    SetAllLayerProjectionChanged() {
      const b = this.GetMainRunningLayout();
      b && b._SetAllLayersProjectionChanged();
    }
    SetAllLayerMVChanged() {
      const b = this.GetMainRunningLayout();
      b && b._SetAllLayersMVChanged();
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = /<(.+?)>/g;
  e.TimelineManager = class extends e.DefendedBase {
    constructor(a) {
      super();
      this._runtime = a;
      this._timelineDataManager = e.New(e.TimelineDataManager);
      this._pluginInstance = null;
      this._timelines = [];
      this._timelinesByName = new Map();
      this._objectClassToTimelineMap = new Map();
      this._timelinesCreatedByTemplate = new Map();
      this._scheduledTimelines = [];
      this._playingTimelines = [];
      this._markedForRemovalTimelines = [];
      this._isTickingTimelines =
        this._changingLayout =
        this._hasRuntimeListeners =
          !1;
      this._tickFunc = () => this._OnTick();
      this._tick2Func = () => this._OnTick2();
      this._beforeLayoutChange = () => this._OnBeforeChangeLayout();
      this._layoutChange = () => this._OnAfterChangeLayout();
      this._instanceDestroy = (c) => this._OnInstanceDestroy(c.instance);
      this._beforeLoad = (c) => this._OnBeforeLoad();
      this._afterLoad = (c) => this._OnAfterLoad();
      this._afterLayoutStart = (c) => this._OnAfterLayoutStart();
      this._destroyedWhileLoadingState = [];
      this._renderChange = 0;
    }
    Release() {
      this.RemoveRuntimeListeners();
      this._afterLoad =
        this._instanceDestroy =
        this._layoutChange =
        this._beforeLayoutChange =
        this._tick2Func =
        this._tickFunc =
          null;
      for (const a of this._timelines) a.Stop(), a.Release();
      e.clearArray(this._timelines);
      this._timelines = null;
      this._timelineDataManager.Release();
      this._timelineDataManager = null;
      e.clearArray(this._scheduledTimelines);
      this._scheduledTimelines = null;
      e.clearArray(this._playingTimelines);
      this._playingTimelines = null;
      e.clearArray(this._markedForRemovalTimelines);
      this._markedForRemovalTimelines = null;
      this._timelinesByName.clear();
      this._timelinesByName = null;
      this._objectClassToTimelineMap.clear();
      this._objectClassToTimelineMap = null;
      this._timelinesCreatedByTemplate.clear();
      this._timelinesCreatedByTemplate = null;
      e.clearArray(this._destroyedWhileLoadingState);
      this._runtime = this._destroyedWhileLoadingState = null;
    }
    AddRuntimeListeners() {
      const a = this._runtime.Dispatcher();
      a.addEventListener("pretick", this._tickFunc);
      a.addEventListener("tick2", this._tick2Func);
      a.addEventListener("beforelayoutchange", this._beforeLayoutChange);
      a.addEventListener("layoutchange", this._layoutChange);
      a.addEventListener("instancedestroy", this._instanceDestroy);
      a.addEventListener("beforeload", this._beforeLoad);
      a.addEventListener("afterload", this._afterLoad);
      a.addEventListener("afterlayoutstart", this._afterLayoutStart);
    }
    RemoveRuntimeListeners() {
      const a = this._runtime.Dispatcher();
      a.removeEventListener("pretick", this._tickFunc);
      a.removeEventListener("tick2", this._tick2Func);
      a.removeEventListener("beforelayoutchange", this._beforeLayoutChange);
      a.removeEventListener("layoutchange", this._layoutChange);
      a.removeEventListener("instancedestroy", this._instanceDestroy);
      a.removeEventListener("beforeload", this._beforeLoad);
      a.removeEventListener("afterload", this._afterLoad);
      a.removeEventListener("afterlayoutstart", this._afterLayoutStart);
    }
    Create(a) {
      this._timelineDataManager.Add(a);
      a = e.TimelineState.CreateInitial(a, this);
      this.Add(a);
      this.SetTimelineObjectClassesToMap(a);
      this._timelinesCreatedByTemplate.set(a.GetName(), 0);
    }
    CreateFromTemplate(a) {
      var c = this.GetTimelineDataManager();
      a = a.GetTemplateName();
      c = c.Get(a);
      c = e.TimelineState.CreateFromTemplate(
        `${a}:${this._timelinesCreatedByTemplate.get(a)}`,
        c,
        this
      );
      this._IncreaseTemplateTimelinesCount(a);
      this.Add(c);
      return c;
    }
    _IncreaseTemplateTimelinesCount(a) {
      this._timelinesCreatedByTemplate.set(
        a,
        this._timelinesCreatedByTemplate.get(a) + 1
      );
    }
    _SetCreatedTemplateTimelinesCount() {
      for (const a of this._timelines) {
        if (a.IsTemplate()) continue;
        const c = a.GetTemplateName();
        this._IncreaseTemplateTimelinesCount(c);
      }
    }
    _ClearCreatedTemplateTimelinesCount() {
      for (const a of this._timelinesCreatedByTemplate.keys())
        this._timelinesCreatedByTemplate.set(a, 0);
    }
    Add(a) {
      this._timelines.push(a);
      this._timelinesByName.set(a.GetName().toLowerCase(), a);
    }
    Remove(a) {
      a.Removed();
      a.IsTemplate() ||
        (e.arrayFindRemove(this._timelines, a),
        e.arrayFindRemove(this._scheduledTimelines, a),
        e.arrayFindRemove(this._playingTimelines, a),
        e.arrayFindRemove(this._markedForRemovalTimelines, a),
        this._timelinesByName.delete(a.GetName().toLowerCase()),
        this.RemoveTimelineFromObjectClassMap(a),
        a.IsReleased() || a.Release());
    }
    Trigger(a) {
      this._runtime.Trigger(a, this._pluginInstance, null);
    }
    GetRuntime() {
      return this._runtime;
    }
    GetTimelineDataManager() {
      return this._timelineDataManager;
    }
    SetPluginInstance(a) {
      this._pluginInstance = a;
    }
    GetPluginInstance() {
      return this._pluginInstance;
    }
    *GetTimelines() {
      for (const a of this._timelines) yield a;
    }
    SetTimelineObjectClassToMap(a, c) {
      this._objectClassToTimelineMap.has(a) ||
        this._objectClassToTimelineMap.set(a, new Set());
      this._objectClassToTimelineMap.get(a).add(c);
    }
    SetTimelineObjectClassesToMap(a) {
      for (const c of a.GetObjectClasses())
        this.SetTimelineObjectClassToMap(c, a);
    }
    RemoveTimelineFromObjectClassMap(a) {
      for (const [c, d] of this._objectClassToTimelineMap.entries())
        d.has(a) &&
          (d.delete(a),
          0 === d.size && this._objectClassToTimelineMap.delete(c));
    }
    GetTimelinesForObjectClass(a) {
      if (this._objectClassToTimelineMap.has(a))
        return this._objectClassToTimelineMap.get(a);
    }
    GetTimelineOfTemplateForInstances(a, c) {
      if (c)
        for (const d of this._timelines)
          if (
            c.every((f) => d.HasTrackInstance(f.instance, f.trackId)) &&
            d.GetName().includes(a.GetName())
          )
            return d;
    }
    GetTimelineByName(a) {
      return this._timelinesByName.get(a.toLowerCase()) || null;
    }
    GetScheduledOrPlayingTimelineByName(a) {
      for (const c of this._scheduledTimelines) if (c.GetName() === a) return c;
      for (const c of this._playingTimelines) if (c.GetName() === a) return c;
      return null;
    }
    *GetTimelinesByName(a) {
      if (b.test(a)) {
        b.lastIndex = 0;
        let d;
        var c = new Set();
        do
          if ((d = b.exec(a))) {
            const f = d[1].split(",");
            for (const h of f) c.add(h);
          }
        while (d);
        for (const f of c.values())
          (a = this.GetTimelineByName(f)) && (yield a);
        c.clear();
      } else (c = this.GetTimelineByName(a)) && (yield c);
    }
    *GetTimelinesByTags(a) {
      for (const c of this._timelines) c.HasTags(a) && (yield c);
    }
    AddScheduledTimeline(a) {
      this._scheduledTimelines.includes(a) || this._scheduledTimelines.push(a);
      this._MaybeEnableRuntimeListeners();
    }
    RemovePlayingTimeline(a) {
      e.arrayFindRemove(this._playingTimelines, a);
      this._MaybeDisableRuntimeListeners();
    }
    ScheduleTimeline(a) {
      this._playingTimelines.includes(a)
        ? (a.SetPlaying(!0), a.SetScheduled(!1), a.SetMarkedForRemoval(!1))
        : (a.SetPlaying(!1),
          a.SetScheduled(!0),
          a.SetMarkedForRemoval(!1),
          this._scheduledTimelines.includes(a) ||
            this._scheduledTimelines.push(a));
      this._MaybeEnableRuntimeListeners();
    }
    DeScheduleTimeline(a) {
      a.SetPlaying(!1);
      a.SetScheduled(!1);
      a.ResolvePlayPromise();
      e.arrayFindRemove(this._scheduledTimelines, a);
      this._MaybeDisableRuntimeListeners();
    }
    CompleteTimeline(a) {
      a.SetPlaying(!1);
      a.SetScheduled(!1);
      this._playingTimelines.includes(a) &&
        (a.SetMarkedForRemoval(!0),
        this._markedForRemovalTimelines.push(a),
        e.arrayFindRemove(this._playingTimelines, a));
    }
    CompleteTimelineBeforeChangeOfLayout(a) {
      a.SetPlaying(!1);
      a.SetScheduled(!1);
      a.SetMarkedForRemoval(!1);
      a.SetPlaybackRate(1);
      e.arrayFindRemove(this._playingTimelines, a);
    }
    CompleteTimelineAndResolve(a) {
      this.CompleteTimeline(a);
      a.ResolvePlayPromise();
    }
    _OnTick() {
      if (
        !this.GetRuntime().IsLoadingState() &&
        this._hasRuntimeListeners &&
        !this._changingLayout
      ) {
        for (this._isTickingTimelines = !0; this._scheduledTimelines.length; ) {
          var a = this._scheduledTimelines.pop();
          a.SetInitialState();
          0 !== a.GetRenderChange() && (this._renderChange = 1);
          this._playingTimelines.push(a);
        }
        a = this._runtime._GetDtFast();
        var c = this._runtime.GetDt1(),
          d = this._runtime.GetTimeScale();
        for (let f = this._playingTimelines.length - 1; 0 <= f; f--)
          this._playingTimelines[f].Tick(a, d, c);
        this._isTickingTimelines = !1;
        0 !== this._renderChange && this.GetRuntime().UpdateRender();
      }
    }
    _OnTick2() {
      if (
        !this.GetRuntime().IsLoadingState() &&
        this._hasRuntimeListeners &&
        !this._changingLayout
      ) {
        var a;
        for (
          let c = 0, d = this._markedForRemovalTimelines.length;
          c < d;
          c++
        ) {
          const f = this._markedForRemovalTimelines[c];
          a || (a = new Set());
          f.Removed();
          this._MaybeExecuteTimelineFinishTriggers(f);
          a.add(f);
        }
        if (a) {
          e.arrayRemoveAllInSet(this._markedForRemovalTimelines, a);
          this._renderChange = 0;
          for (let c = 0, d = this._playingTimelines.length; c < d; c++)
            if (0 !== this._playingTimelines[c].GetRenderChange()) {
              this._renderChange = 1;
              break;
            }
        }
        this._MaybeDisableRuntimeListeners();
      }
    }
    _MaybeExecuteTimelineFinishTriggers(a) {
      a.IsReleased() ||
        (a.HasValidTracks() &&
          a.IsComplete() &&
          a.InitialStateSet() &&
          a.FinishTriggers());
    }
    _MaybeEnableRuntimeListeners() {
      this._hasRuntimeListeners || (this._hasRuntimeListeners = !0);
    }
    _MaybeDisableRuntimeListeners() {
      this._markedForRemovalTimelines.length ||
        this._playingTimelines.length ||
        this._scheduledTimelines.length ||
        this._isTickingTimelines ||
        (this._hasRuntimeListeners = !1);
    }
    _OnBeforeChangeLayout() {
      for (this._changingLayout = !0; this._scheduledTimelines.length; )
        this.DeScheduleTimeline(this._scheduledTimelines.pop());
      const a = new Set();
      for (const c of this._playingTimelines)
        c._OnBeforeChangeLayout() && (c.Removed(), a.add(c));
      e.arrayRemoveAllInSet(this._playingTimelines, a);
      a.clear();
      for (const c of this._markedForRemovalTimelines)
        c._OnBeforeChangeLayout() && (c.Removed(), a.add(c));
      e.arrayRemoveAllInSet(this._markedForRemovalTimelines, a);
      this._MaybeDisableRuntimeListeners();
      for (const c of this._timelines) c.CleanCaches();
    }
    _OnAfterChangeLayout() {
      this._changingLayout = !1;
    }
    _OnInstanceDestroy(a) {
      var c = a.GetObjectClass();
      if ((c = this.GetTimelinesForObjectClass(c)))
        if (this._runtime.IsLoadingState())
          this._destroyedWhileLoadingState.push(a);
        else
          for (const d of c)
            d.IsTemplate() ||
              (d.IsReleased()
                ? this.Remove(d)
                : d.HasValidTracks() ||
                  (this._MaybeExecuteTimelineFinishTriggers(d),
                  this.Remove(d)));
    }
    _OnBeforeLoad() {
      for (const a of this._scheduledTimelines.map((c) => c))
        this._MaybeExecuteTimelineFinishTriggers(a), this.Remove(a);
      for (const a of this._playingTimelines.map((c) => c))
        this._MaybeExecuteTimelineFinishTriggers(a), this.Remove(a);
    }
    _OnAfterLoad() {
      for (const a of this._destroyedWhileLoadingState)
        this._OnInstanceDestroy(a);
      e.clearArray(this._destroyedWhileLoadingState);
    }
    _OnAfterLayoutStart() {
      const a = this._runtime.GetLayoutManager().GetMainRunningLayout();
      if (a)
        for (const c of this._timelines) {
          const d = c.GetStartOnLayout();
          d && a.GetName() === d && this.ScheduleTimeline(c);
        }
    }
    _SaveToJson() {
      return {
        timelinesJson: this._SaveTimelinesToJson(),
        scheduledTimelinesJson: this._SaveScheduledTimelinesToJson(),
        playingTimelinesJson: this._SavePlayingTimelinesToJson(),
        markedForRemovalTimelinesJson:
          this._SaveMarkedForRemovalTimelinesToJson(),
        hasRuntimeListeners: this._hasRuntimeListeners,
        changingLayout: this._changingLayout,
        isTickingTimelines: this._isTickingTimelines,
      };
    }
    _LoadFromJson(a) {
      a &&
        (this._ClearCreatedTemplateTimelinesCount(),
        this._LoadTimelinesFromJson(a.timelinesJson),
        this._LoadScheduledTimelinesFromJson(a.scheduledTimelinesJson),
        this._LoadPlayingTimelinesFromJson(a.playingTimelinesJson),
        this._LoadMarkedForRemovalTimelinesFromJson(
          a.markedForRemovalTimelinesJson
        ),
        (this._hasRuntimeListeners = !a.hasRuntimeListeners),
        (this._changingLayout = !!a.changingLayout),
        (this._isTickingTimelines = !!a.isTickingTimelines),
        this._SetCreatedTemplateTimelinesCount(),
        this._MaybeEnableRuntimeListeners(),
        this._MaybeDisableRuntimeListeners());
    }
    _SaveTimelinesToJson() {
      return this._timelines.map((a) => a._SaveToJson());
    }
    _LoadTimelinesFromJson(a) {
      for (const c of a) {
        a = this.GetTimelineByName(c.name);
        if (!a) {
          a = this._GetTemplateNameFromJson(c);
          if (!a) continue;
          a = this.GetTimelineByName(a);
          a = this.CreateFromTemplate(a);
        }
        a._LoadFromJson(c);
        a.HasTracks() || this.Remove(a);
      }
    }
    _GetTemplateNameFromJson(a) {
      return (a = a.name.split(":")) && 2 === a.length ? a[0] : null;
    }
    _SaveScheduledTimelinesToJson() {
      return this._SaveTimelines(this._scheduledTimelines);
    }
    _LoadScheduledTimelinesFromJson(a) {
      this._LoadTimelines(a, this._scheduledTimelines);
    }
    _SavePlayingTimelinesToJson() {
      return this._SaveTimelines(this._playingTimelines);
    }
    _LoadPlayingTimelinesFromJson(a) {
      this._LoadTimelines(a, this._playingTimelines);
    }
    _SaveMarkedForRemovalTimelinesToJson() {
      return this._SaveTimelines(this._markedForRemovalTimelines);
    }
    _LoadMarkedForRemovalTimelinesFromJson(a) {
      this._LoadTimelines(a, this._markedForRemovalTimelines);
    }
    _IsTimelineInJson(a, c) {
      if (!c) return !1;
      for (const d of c) if (d === a.GetName()) return !0;
      return !1;
    }
    _SaveTimelines(a) {
      return a.map((c) => c.GetName());
    }
    _LoadTimelines(a, c) {
      var d = new Set();
      for (const f of c) this._IsTimelineInJson(f, a) || d.add(f);
      e.arrayRemoveAllInSet(c, d);
      if (a) {
        d = (f) => (h) => h.GetName() === f;
        for (const f of a)
          (a = this.GetTimelineByName(f)) && (c.find(d(f)) || c.push(a));
      }
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.TimelineState = class extends e.DefendedBase {
    constructor(b, a, c) {
      super();
      this._runtime = c.GetRuntime();
      this._timelineManager = c;
      this._timelineDataItem = a;
      this._name = b;
      this._tracks = [];
      this._tracksLength = 0;
      this._beforeAndAfterTracks = null;
      this._beforeAndAfterTracksLength = 0;
      this.CreateTrackStates();
      this._playResolve = this._playPromise = null;
      this._playheadTime = 0;
      this._playbackRate = 1;
      this._pingPongState = 0;
      this._currentRepeatCount = 1;
      this._initialStateSet = this._isScheduled = this._isPlaying = !1;
      this._complete = !0;
      this._markedForRemoval = this._released = !1;
      this._completedTick = -1;
      this._firstTick =
        this._finishedTriggers =
        this._isTemplate =
        this._implicitPause =
          !1;
      this._lastDelta = NaN;
      this._tags = [""];
      this._stringTags = "";
      this._tagsChanged = !1;
      this._hasNestedContent = this._renderChange = 0;
    }
    static CreateInitial(b, a) {
      var c = a.GetTimelineDataManager();
      const d = c.GetNameId();
      c = c.Get(b[d]);
      b = e.New(e.TimelineState, b[d], c, a);
      b.SetIsTemplate(!0);
      return b;
    }
    static CreateFromTemplate(b, a, c) {
      return e.New(e.TimelineState, b, a, c);
    }
    Release() {
      if (!this.IsReleased()) {
        this._timelineManager.DeScheduleTimeline(this);
        this._timelineManager.CompleteTimelineAndResolve(this);
        for (const b of this._tracks) b.Release();
        e.clearArray(this._tracks);
        this._timelineDataItem =
          this._timelineManager =
          this._runtime =
          this._tracks =
            null;
        this._released = !0;
        this._playResolve = this._playPromise = null;
      }
    }
    CreateTrackStates() {
      for (const b of this._timelineDataItem.GetTrackData().trackDataItems())
        this._tracksLength = this._tracks.push(e.TrackState.Create(this, b));
    }
    GetTimelineManager() {
      return this._timelineManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetTracks() {
      return this._tracks;
    }
    GetSimilarPropertyTracks(b, a, c) {
      if (this._hasNestedContent) {
        var d;
        for (let h = 0; h < this._tracks.length; h++) {
          var f = this._tracks[h];
          b === f.GetInstance() &&
            (f = f.GetPropertyTrack(c)) &&
            a.constructor === f.GetSourceAdapter().constructor &&
            (d || (d = []), d.push(f));
        }
        return d;
      }
    }
    HasTracks() {
      return !!this._tracks.length;
    }
    GetTrackById(b) {
      for (const a of this._tracks) if (e.equalsNoCase(a.GetId(), b)) return a;
      return null;
    }
    GetTrackByName(b) {
      for (const a of this._tracks)
        if (!a.IsInstanceTrack() && e.equalsNoCase(a.GetName(), b)) return a;
      return null;
    }
    SetName(b) {
      this._name = b;
    }
    GetName() {
      return this._name;
    }
    GetTimelineDataItem() {
      return this._timelineDataItem;
    }
    GetTemplateName() {
      return this._timelineDataItem.GetName();
    }
    GetTotalTime() {
      return this._timelineDataItem.GetTotalTime();
    }
    SetTotalTime(b) {
      this._timelineDataItem.SetTotalTime(b);
    }
    GetStep() {
      return this._timelineDataItem.GetStep();
    }
    SetStep(b) {
      this._timelineDataItem.SetStep(b);
    }
    GetInterpolationMode() {
      return this._timelineDataItem.GetInterpolationMode();
    }
    SetInterpolationMode(b) {
      this._timelineDataItem.SetInterpolationMode(b);
    }
    GetResultMode() {
      return this._timelineDataItem.GetResultMode();
    }
    SetResultMode(b) {
      this._timelineDataItem.GetResultMode(b);
    }
    SetEase(b) {
      for (const a of this.GetTracks()) a.SetEase(b);
    }
    GetLoop() {
      return this._timelineDataItem.GetLoop();
    }
    SetLoop(b) {
      return this._timelineDataItem.SetLoop(b);
    }
    GetPingPong() {
      return this._timelineDataItem.GetPingPong();
    }
    SetPingPong(b) {
      return this._timelineDataItem.SetPingPong(b);
    }
    GetRepeatCount() {
      return this._timelineDataItem.GetRepeatCount();
    }
    SetPlaybackRate(b) {
      return (this._playbackRate = b);
    }
    GetPlaybackRate() {
      return this._playbackRate;
    }
    GetStartOnLayout() {
      return this._timelineDataItem.GetStartOnLayout();
    }
    IsForwardPlayBack() {
      return this.IsPlaying() ? 0 < this._playbackRate : !0;
    }
    GetPlayPromise() {
      return this._playPromise
        ? this._playPromise
        : (this._playPromise = new Promise((b) => {
            this._playResolve = b;
          }));
    }
    ResolvePlayPromise() {
      this._playPromise &&
        (this._playResolve(), (this._playResolve = this._playPromise = null));
    }
    SetTags(b) {
      this._tags = e.TimelineState._GetTagArray(b);
      this._tagsChanged = !0;
    }
    GetTags() {
      return this._tags;
    }
    GetStringTags() {
      this._tagsChanged && (this._stringTags = this._tags.join(" "));
      this._tagsChanged = !1;
      return this._stringTags;
    }
    HasTags(b) {
      return this._tags && this._tags.length
        ? (b = e.TimelineState._GetTagArray(b)) && b.length
          ? b.every(e.TimelineState._HasTag, this)
          : !1
        : !1;
    }
    OnStarted() {
      e.Plugins.Timeline &&
        this.constructor === e.TimelineState &&
        (e.Plugins.Timeline.Cnds.SetTriggerTimeline(this),
        this._timelineManager.Trigger(
          e.Plugins.Timeline.Cnds.OnTimelineStarted
        ),
        this._timelineManager.Trigger(
          e.Plugins.Timeline.Cnds.OnTimelineStartedByName
        ),
        this._timelineManager.Trigger(
          e.Plugins.Timeline.Cnds.OnTimelineStartedByTags
        ),
        this._timelineManager.Trigger(
          e.Plugins.Timeline.Cnds.OnAnyTimelineStarted
        ),
        e.Plugins.Timeline.Cnds.SetTriggerTimeline(null));
    }
    OnCompleted() {
      this._completedTick = this._runtime.GetTickCount();
    }
    FinishTriggers() {
      this._finishedTriggers ||
        ((this._finishedTriggers = !0),
        e.Plugins.Timeline &&
          this.constructor === e.TimelineState &&
          (e.Plugins.Timeline.Cnds.SetTriggerTimeline(this),
          this._timelineManager.Trigger(
            e.Plugins.Timeline.Cnds.OnTimelineFinished
          ),
          this._timelineManager.Trigger(
            e.Plugins.Timeline.Cnds.OnTimelineFinishedByName
          ),
          this._timelineManager.Trigger(
            e.Plugins.Timeline.Cnds.OnTimelineFinishedByTags
          ),
          this._timelineManager.Trigger(
            e.Plugins.Timeline.Cnds.OnAnyTimelineFinished
          ),
          e.Plugins.Timeline.Cnds.SetTriggerTimeline(null)));
    }
    SetPlaying(b) {
      this._isPlaying = b;
    }
    IsCompletedTick() {
      return this._completedTick === this._runtime.GetTickCount();
    }
    IsPlaying(b = !1) {
      return this.IsCompletedTick() || (this.IsScheduled() && !b)
        ? !0
        : this._isPlaying;
    }
    _IsPlaying() {
      return this.IsPlaying(!0);
    }
    IsPaused() {
      return this._IsPaused();
    }
    _IsPaused() {
      return this.IsReleased() ||
        this.IsScheduled() ||
        this._IsPlaying() ||
        this.IsComplete()
        ? !1
        : !0;
    }
    SetScheduled(b) {
      this._isScheduled = b;
    }
    IsScheduled() {
      return this._isScheduled;
    }
    SetComplete(b) {
      this._complete = b;
      b = this.GetTime();
      if (0 >= b || b >= this.GetTotalTime()) this._complete = !0;
    }
    IsComplete() {
      return this._complete;
    }
    IsReleased() {
      return this._released;
    }
    SetMarkedForRemoval(b) {
      this._markedForRemoval = b;
    }
    IsMarkedForRemoval() {
      return this._markedForRemoval;
    }
    SetImplicitPause(b) {
      this._implicitPause = b;
    }
    IsImplicitPause() {
      return this._implicitPause;
    }
    SetIsTemplate(b) {
      this._isTemplate = !!b;
    }
    IsTemplate() {
      return this._isTemplate;
    }
    InitialStateSet() {
      return this._initialStateSet;
    }
    GetTime() {
      return this._playheadTime;
    }
    SetTime(b) {
      const a = this.GetTime();
      this._SetTime(b);
      this.SetComplete(!1);
      this.IsComplete() || this.SetImplicitPause(!0);
      if (this._IsPlaying() || this.IsScheduled() || !this._initialStateSet)
        this._IsPlaying() || this.IsScheduled() || this._initialStateSet
          ? this._IsPlaying()
            ? this.Stop()
            : this.IsScheduled() &&
              (this._timelineManager.DeScheduleTimeline(this),
              this.SetInitialStateFromSetTime())
          : this.SetInitialStateFromSetTime();
      this._SetUpdateStateBefore();
      this._Interpolate(this.GetTime(), !1, !0, !0, a);
      this._SetUpdateStateAfter();
      this._renderChange && this.GetRuntime().UpdateRender();
      this._OnSetTime();
    }
    _SetTime(b) {
      e.IsFiniteNumber(b) || (b = this.GetTotalTime());
      0 > b
        ? (this._playheadTime = 0)
        : b >= this.GetTotalTime()
        ? (this._playheadTime = this.GetTotalTime())
        : (this._playheadTime = b);
    }
    _SetTimeAndReset(b) {
      e.IsFiniteNumber(b) || (b = this.GetTotalTime());
      0 > b
        ? (this._playheadTime = 0)
        : b >= this.GetTotalTime()
        ? (this._playheadTime = this.GetTotalTime())
        : (this._playheadTime = b);
      for (const a of this._tracks) a.SetResetState();
    }
    _OnSetTime() {
      e.Plugins.Timeline &&
        this.constructor === e.TimelineState &&
        (e.Plugins.Timeline.Cnds.SetTriggerTimeline(this),
        this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSet),
        this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSetByName),
        this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSetByTags),
        e.Plugins.Timeline.Cnds.SetTriggerTimeline(null));
    }
    _CanResume() {
      if (!this.GetLoop())
        if (this.GetPingPong() && 1 === this._pingPongState)
          if (this.IsForwardPlayBack()) {
            if (this.GetTime() >= this.GetTotalTime()) return !1;
          } else {
            if (0 >= this.GetTime()) return !1;
          }
        else if (!this.GetLoop() && !this.GetPingPong())
          if (this.IsForwardPlayBack()) {
            if (this.GetTime() >= this.GetTotalTime()) return !1;
          } else if (0 >= this.GetTime()) return !1;
      return !0;
    }
    Resume() {
      this.IsReleased() || (this._CanResume() && this.Play(!0));
    }
    Play(b = !1) {
      return this.IsReleased() || this.IsScheduled()
        ? !1
        : this._IsPlaying() && this.IsCompletedTick()
        ? this._SchedulePlayingTimeline()
        : this._IsPlaying() ||
          (!this.IsComplete() && !b && !this.IsImplicitPause())
        ? !1
        : this._ScheduleStoppedTimeline();
    }
    _SchedulePlayingTimeline() {
      this.SetImplicitPause(!1);
      this._timelineManager.RemovePlayingTimeline(this);
      this._timelineManager.ScheduleTimeline(this);
      this.GetPlayPromise();
      return !0;
    }
    _ScheduleStoppedTimeline() {
      this.SetImplicitPause(!1);
      this._timelineManager.ScheduleTimeline(this);
      this.GetPlayPromise();
      return !0;
    }
    Stop(b = !1) {
      this.IsReleased() ||
        (this.SetComplete(b),
        this._timelineManager.CompleteTimeline(this),
        this.IsComplete() && this.ResolvePlayPromise());
    }
    Reset(b = !0, a = !1) {
      if (!this.IsReleased()) {
        if (!this._IsPlaying() && this.IsScheduled())
          return this._timelineManager.DeScheduleTimeline(this);
        if (!this.IsComplete()) {
          this.Stop(!0);
          this.IsForwardPlayBack()
            ? this._SetTime(0)
            : this._SetTime(this.GetTotalTime());
          var c = this.GetTime();
          this._SetUpdateStateBefore();
          a
            ? this._InterpolateBeforeChangeLayout(c)
            : this._Interpolate(c, !1, !1, !0);
          b && this._OnSetTime();
          this._SetUpdateStateAfter();
          this._renderChange && b && this.GetRuntime().UpdateRender();
        }
      }
    }
    ResetBeforeChangeLayout() {
      this.Reset(!1, !0);
    }
    _InterpolateBeforeChangeLayout(b) {
      this._Interpolate(b, !1, !1, !0, NaN, !1, !0);
    }
    _OnBeforeChangeLayout() {
      if (this.IsReleased()) return !0;
      if (!this.GetRuntime().IsLoadingState() && this.HasValidGlobalTracks())
        return !1;
      this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this);
      this.GetRuntime().IsLoadingState() || this.ResetBeforeChangeLayout();
      return !0;
    }
    SetInitialStateFromSetTime() {
      this.SetInitialState(!0);
    }
    SetInitialState(b) {
      if (!this.IsMarkedForRemoval()) {
        if (b) {
          this._firstTick = this._initialStateSet = !0;
          this._SetUpdateStateBefore();
          for (const a of this._tracks) a.SetInitialState();
        } else if (
          (this.SetPlaying(!0),
          this.SetScheduled(!1),
          this.OnStarted(),
          this.IsComplete())
        ) {
          this._completedTick = -1;
          this._pingPongState = 0;
          this._currentRepeatCount = 1;
          this._finishedTriggers = this._complete = !1;
          this._firstTick = this._initialStateSet = !0;
          this.IsForwardPlayBack()
            ? this._SetTime(0)
            : this._SetTime(this.GetTotalTime());
          this._SetUpdateStateBefore();
          for (const a of this._tracks) a.SetInitialState();
        } else {
          this._firstTick = !0;
          this._SetUpdateStateBefore();
          for (const a of this._tracks) a.SetResumeState();
        }
        this._SetUpdateStateAfter();
      }
    }
    GetRenderChange() {
      return this._renderChange;
    }
    _SetUpdateStateBefore() {
      this._hasNestedContent = 0;
      for (const b of this._tracks)
        b.IsNested() && (this._hasNestedContent = 1);
    }
    _SetUpdateStateAfter() {
      this._renderChange = 0;
      for (const b of this._tracks)
        b._SetUpdateState(),
          0 === this._renderChange &&
            1 === b.GetRenderChange() &&
            (this._renderChange = 1),
          this._beforeAndAfterTracks ||
            1 !== b.GetNeedsBeforeAndAfter() ||
            (this._beforeAndAfterTracks || (this._beforeAndAfterTracks = []),
            (this._beforeAndAfterTracksLength =
              this._beforeAndAfterTracks.push(b)));
    }
    Tick(b, a, c) {
      if (0 !== b || 0 !== this._lastDelta) {
        this._lastDelta = b;
        c = this._playheadTime;
        a = c + b * a * this._playbackRate;
        b = this._timelineDataItem._totalTime;
        this._playheadTime = 0 > a ? 0 : a >= b ? b : a;
        var d = !1;
        a = !1;
        var f = this.GetLoop(),
          h = this.GetPingPong();
        f || h
          ? f && !h
            ? 0 < this._playbackRate
              ? this._playheadTime >= b && (this._SetTimeAndReset(0), (a = !0))
              : 0 >= this._playheadTime && (this._SetTimeAndReset(b), (a = !0))
            : !f && h
            ? 0 < this._playbackRate
              ? this._playheadTime >= b &&
                (this._SetTime(b),
                this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
                (a = !0),
                1 === this._pingPongState
                  ? this._currentRepeatCount < this.GetRepeatCount()
                    ? (this._currentRepeatCount++, (this._pingPongState = 0))
                    : (d = !0)
                  : 0 === this._pingPongState && (this._pingPongState = 1))
              : 0 >= this._playheadTime &&
                (this._SetTime(0),
                this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
                (a = !0),
                1 === this._pingPongState
                  ? this._currentRepeatCount < this.GetRepeatCount()
                    ? (this._currentRepeatCount++, (this._pingPongState = 0))
                    : (d = !0)
                  : 0 === this._pingPongState && (this._pingPongState = 1))
            : f &&
              h &&
              (0 < this._playbackRate
                ? this._playheadTime >= b &&
                  (this._SetTime(b),
                  this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
                  (a = !0))
                : 0 >= this._playheadTime &&
                  (this._SetTime(0),
                  this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
                  (a = !0)))
          : 0 < this._playbackRate
          ? this._playheadTime >= b &&
            (this._currentRepeatCount < this.GetRepeatCount()
              ? (this._currentRepeatCount++, this._SetTimeAndReset(0), (a = !0))
              : (this._SetTime(b), (d = !0)))
          : 0 >= this._playheadTime &&
            (this._currentRepeatCount < this.GetRepeatCount()
              ? (this._currentRepeatCount++, this._SetTimeAndReset(b), (a = !0))
              : (this._SetTime(0), (d = !0)));
        f = this._tracksLength;
        if (d) {
          for (d = 0; d < f; d++) this._tracks[d].SetEndState();
          this.Stop(!0);
          this.OnCompleted();
        } else {
          h = this._beforeAndAfterTracksLength;
          for (d = 0; d < h; d++)
            this._beforeAndAfterTracks[d].BeforeInterpolate();
          if (1 === this._hasNestedContent)
            for (d = 0; d < f; d++) {
              const g = this._tracks[d],
                k = g.GetStartOffset(),
                m = c - k;
              0 > this._playheadTime - k && 0 < m
                ? ((this._playheadTime = 0 > k ? 0 : k >= b ? b : k),
                  g.Interpolate(k, !0, !1, a, this._firstTick, !1))
                : g.Interpolate(
                    this._playheadTime,
                    !0,
                    !1,
                    a,
                    this._firstTick,
                    !1
                  );
            }
          else
            for (d = 0; d < f; d++)
              this._tracks[d].Interpolate(
                this._playheadTime,
                !0,
                !1,
                a,
                this._firstTick,
                !1
              );
          for (d = 0; d < h; d++)
            this._beforeAndAfterTracks[d].AfterInterpolate();
          this._firstTick && (this._firstTick = !1);
        }
      }
    }
    _Interpolate(b, a = !1, c = !1, d = !1, f = NaN, h = !1, g = !1) {
      for (var k of this._tracks) k.BeforeInterpolate();
      for (const m of this._tracks) {
        k = b;
        if ("number" === typeof f && !isNaN(f)) {
          const q = this.GetTime() - m.GetStartOffset(),
            v = f - m.GetStartOffset();
          0 > q && 0 < v && ((k = m.GetStartOffset()), this._SetTime(k));
        }
        m.Interpolate(k, a, c, d, this._firstTick, g);
      }
      for (const m of this._tracks) m.AfterInterpolate();
      this._firstTick && h && (this._firstTick = !1);
    }
    AddTrack() {
      var b = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem();
      b = e.TrackState.Create(this, b);
      this._tracksLength = this._tracks.push(b);
      return b;
    }
    Removed() {
      if (!this.IsReleased()) for (const b of this._tracks) b.TimelineRemoved();
    }
    CleanCaches() {
      for (const b of this._tracks) b.CleanCaches();
    }
    ClearTrackInstances() {
      for (const b of this._tracks) b.ClearInstance();
    }
    SetTrackInstance(b, a) {
      if (a)
        for (const c of this._tracks)
          if (c.IsInstanceTrack()) {
            if (b) {
              if (c.GetId() !== b) continue;
            } else if (c.HasInstance()) continue;
            c.SetInstance(a);
            this._timelineManager.SetTimelineObjectClassToMap(
              a.GetObjectClass(),
              this
            );
            break;
          }
    }
    HasTrackInstance(b, a) {
      for (const c of this._tracks)
        if (c.IsInstanceTrack())
          if (a) {
            if (a === c.GetId() && b === c.GetInstance()) return !0;
          } else if (b === c.GetInstance()) return !0;
      return !1;
    }
    HasValidTracks() {
      return this._tracks.some((b) =>
        b.IsInstanceTrack() ? b.CanInstanceBeValid() : !0
      );
    }
    HasValidGlobalTracks() {
      return this._tracks.some((b) =>
        b.IsInstanceTrack()
          ? b.CanInstanceBeValid()
            ? (b = b.GetObjectClass())
              ? b.IsGlobal()
              : !1
            : !1
          : !1
      );
    }
    GetPropertyTrack(b) {
      for (const a of this.GetTracks())
        for (const c of a.GetPropertyTracks())
          if (c.GetPropertyName() === b) return c;
    }
    GetTrackFromInstance(b) {
      for (const a of this._tracks) if (b === a.GetInstance()) return a;
      return null;
    }
    GetKeyframeWithTags(b) {
      b = b ? b.split(" ") : [];
      b = [...new Set(b.map((a) => a.toLowerCase().trim())).values()];
      for (const a of this.GetTracks())
        for (const c of a.GetKeyframeDataItems())
          if (b.every((d) => c.HasTag(d))) return c;
    }
    GetObjectClasses() {
      const b = [];
      for (const a of this.GetTracks()) b.push(a.GetObjectClass());
      return b.filter((a) => a);
    }
    _SaveToJson() {
      return {
        tracksJson: this._SaveTracksToJson(),
        name: this._name,
        playheadTime: this.GetTime(),
        playbackRate: this._playbackRate,
        pingPongState: this._pingPongState,
        currentRepeatCount: this._currentRepeatCount,
        isPlaying: this._isPlaying,
        isScheduled: this._isScheduled,
        initialStateSet: this._initialStateSet,
        finishedTriggers: this._finishedTriggers,
        complete: this._complete,
        released: this._released,
        markedForRemoval: this._markedForRemoval,
        completedTick: this._completedTick,
        implicitPause: this._implicitPause,
        isTemplate: this._isTemplate,
        tags: this._tags.join(" "),
        stringTags: this._stringTags,
        tagsChanged: this._tagsChanged,
        firstTick: this._firstTick,
      };
    }
    _LoadFromJson(b) {
      b &&
        (this._LoadTracksFromJson(b.tracksJson),
        (this._name = b.name),
        (this._playheadTime = b.playheadTime),
        (this._playbackRate = b.playbackRate),
        (this._pingPongState = b.pingPongState),
        (this._currentRepeatCount = b.currentRepeatCount),
        (this._isPlaying = !!b.isPlaying),
        (this._isScheduled = !!b.isScheduled),
        (this._initialStateSet = !!b.initialStateSet),
        (this._finishedTriggers = b.hasOwnProperty("finishedTriggers")
          ? !!b.finishedTriggers
          : !1),
        (this._complete = !!b.complete),
        (this._released = !!b.released),
        (this._markedForRemoval = !!b.markedForRemoval),
        (this._completedTick = b.completedTick),
        (this._implicitPause = !!b.implicitPause),
        (this._isTemplate = !!b.isTemplate),
        (this._tags = b.tags.split(" ")),
        (this._stringTags = b.stringTags),
        (this._tagsChanged = !!b.tagsChanged),
        (this._firstTick = !!b.firstTick));
    }
    _SaveTracksToJson() {
      return this._tracks.map((b) => b._SaveToJson());
    }
    _LoadTracksFromJson(b) {
      b.forEach((a, c) => {
        this._tracks[c]._LoadFromJson(a);
      });
      this._tracks.filter((a) => a.CanInstanceBeValid());
    }
    static _HasTag(b) {
      const a = this.GetTags();
      return "" === b
        ? 1 === a.length && "" === a[0]
        : a.map((c) => c.toLowerCase()).includes(b.toLowerCase());
    }
    static _GetTagArray(b) {
      if (e.IsArray(b)) return b.slice(0);
      if (e.IsString(b)) return b.split(" ");
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.TrackState = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._timeline = b;
      this._trackDataItem = a;
      this._trackData = a.GetTrackData();
      this._objectClassIndex = this._instanceUid = NaN;
      this._worldInfo = this._instance = null;
      this._isNested = 0 < a.GetStartOffset();
      this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
      this._lastKeyframeDataItem = null;
      this._keyframeDataItems = this._trackDataItem
        .GetKeyframeData()
        .GetKeyframeDataItemArray();
      this._propertyTracks = [];
      this.CreatePropertyTrackStates();
      this._needsBeforeAndAfter =
        this._renderChange =
        this._worldInfoChange =
          0;
    }
    static Create(b, a) {
      return e.New(e.TrackState, b, a);
    }
    Release() {
      this._keyframeDataItems = null;
      for (const b of this._propertyTracks) b.Release();
      e.clearArray(this._propertyTracks);
      this._lastKeyframeDataItem =
        this._trackDataItem =
        this._worldInfo =
        this._instance =
        this._timeline =
        this._propertyTracks =
          null;
    }
    CreatePropertyTrackStates() {
      for (const b of this._trackDataItem
        .GetPropertyTrackData()
        .propertyTrackDataItems())
        this._propertyTracks.push(e.PropertyTrackState.Create(this, b));
    }
    TimelineRemoved() {
      for (const b of this._propertyTracks) b.TimelineRemoved();
    }
    CleanCaches() {
      for (const b of this._propertyTracks) b.CleanCaches();
      this._worldInfo = this._instance = null;
    }
    GetTimeline() {
      return this._timeline;
    }
    GetRuntime() {
      return this._timeline.GetRuntime();
    }
    GetKeyframeDataItems() {
      return this._keyframeDataItems
        ? this._keyframeDataItems
        : (this._keyframeDataItems = this._trackDataItem
            .GetKeyframeData()
            .GetKeyframeDataItemArray());
    }
    GetPropertyTracks() {
      return this._propertyTracks;
    }
    GetPropertyTrack(b) {
      for (let a = 0; a < this._propertyTracks.length; a++) {
        const c = this._propertyTracks[a];
        if (c.GetPropertyName() === b) return c;
      }
    }
    MaybeGetInstance() {
      this._instance || this.GetInstance();
    }
    IsInstanceValid() {
      return this._instance ? !this._instance.IsDestroyed() : !1;
    }
    CanInstanceBeValid() {
      if (!this.IsInstanceTrack()) return !1;
      var b = this.GetInstanceUID();
      return (b = this.GetRuntime().GetInstanceByUID(b))
        ? !b.IsDestroyed()
        : !1;
    }
    GetObjectClass() {
      if (this.IsInstanceTrack()) {
        var b = this.GetObjectClassIndex();
        if (-1 !== b) return this.GetRuntime().GetObjectClassByIndex(b);
      }
    }
    ClearInstance() {
      this._instance = null;
      this._instanceUid = -1;
      this._worldInfo = null;
      this._objectClassIndex = -1;
    }
    HasInstance() {
      return !!this._instance;
    }
    GetInstance() {
      if (this._instance && this.IsInstanceValid()) return this._instance;
      const b = this.GetInstanceUID();
      return (this._instance = this.GetRuntime().GetInstanceByUID(b));
    }
    SetInstance(b) {
      if (this._instance !== b) {
        this.CleanCaches();
        this._instance = b;
        this._objectClassIndex = b.GetObjectClass().GetIndex();
        this._instanceUid = b.GetUID();
        this._worldInfo = b.GetWorldInfo();
        for (const h of this.propertyTrackItems()) {
          const g = h.sourceAdapter;
          switch (h.propertyTrack.GetSourceAdapterId()) {
            case "instance-variable":
              g.GetEditorIndex();
              var a = b.GetObjectClass(),
                c = a.GetInstanceVariableIndexByName(h.name),
                d = a.GetInstanceVariableName(c);
              a = a.GetInstanceVariableType(c);
              d === h.name && a === h.type && g.UpdateInstanceVariableIndex(c);
              break;
            case "behavior":
              var f = h.behaviorType;
              c = this.GetObjectClass();
              d = b.GetObjectClass();
              a = g.GetBehaviorType(d);
              f &&
                a &&
                ((f = f.GetName()),
                c.GetBehaviorIndexByName(f),
                d.GetBehaviorIndexByName(f),
                g.GetEditorIndex(),
                g.UpdateBehaviorTypeSid(a.GetSID()));
          }
        }
      }
    }
    *propertyTrackItems() {
      for (const c of this._propertyTracks) {
        var b = c.GetSourceAdapter(),
          a = this.GetObjectClass();
        const d = { propertyTrack: c, sourceAdapter: b };
        switch (c.GetSourceAdapterId()) {
          case "world-instance":
            d.property = c.GetPropertyName();
            break;
          case "instance-variable":
            b = b.GetEditorIndex();
            d.name = a.GetInstanceVariableName(b);
            d.type = a.GetInstanceVariableType(b);
            break;
          case "effect":
            a = a.GetEffectList();
            b = b.GetEffectType(a);
            d.effectType = b;
            break;
          case "behavior":
            b = b.GetBehaviorType(a);
            d.behaviorType = b;
            break;
          case "plugin":
            d.plugin = a.GetPlugin();
        }
        yield d;
      }
    }
    GetWorldInfo() {
      if (this._worldInfo && this.IsInstanceValid()) return this._worldInfo;
      const b = this.GetInstance();
      b && (this._worldInfo = b.GetWorldInfo());
      return this._worldInfo;
    }
    GetTrackDataItem() {
      return this._trackDataItem;
    }
    GetInstanceUID() {
      return this._instanceUid
        ? this._instanceUid
        : this._trackDataItem.GetInstanceUID();
    }
    SetInstanceUID(b) {
      this._trackDataItem.SetInstanceUID(b);
    }
    GetInterpolationMode() {
      return this._trackDataItem.GetInterpolationMode();
    }
    SetInterpolationMode(b) {
      this._trackDataItem.SetInterpolationMode(b);
    }
    GetResultMode() {
      return this._trackDataItem.GetResultMode();
    }
    GetId() {
      return this._trackDataItem.GetId();
    }
    GetStartOffset() {
      return this._trackDataItem.GetStartOffset();
    }
    GetLocalTotalTime() {
      return this._trackDataItem.GetLocalTotalTime();
    }
    SetLocalTotalTime(b) {
      this._trackDataItem.SetLocalTotalTime(b);
    }
    SetResultMode(b) {
      this._trackDataItem.SetResultMode(b);
    }
    SetEase(b) {
      for (const a of this.GetKeyframeDataItems()) a.SetEase(b);
      for (const a of this.GetPropertyTracks()) a.SetEase(b);
    }
    GetEnable() {
      return this._trackDataItem.GetEnable();
    }
    SetEnable(b) {
      this._trackDataItem.SetEnable(b);
    }
    GetObjectClassIndex() {
      return isNaN(this._objectClassIndex)
        ? this._trackDataItem.GetObjectClassIndex()
        : this._objectClassIndex;
    }
    SetObjectClassIndex(b) {
      this._trackDataItem.SetObjectClassIndex(b);
    }
    SetOriginalWidth(b) {
      this._trackDataItem.SetOriginalWidth(b);
    }
    GetOriginalWidth() {
      const b = this.GetInstance();
      return b && b.GetSdkInstance().IsOriginalSizeKnown()
        ? b.GetSdkInstance().GetOriginalWidth()
        : this._trackDataItem.GetOriginalWidth();
    }
    SetOriginalHeight(b) {
      this._trackDataItem.SetOriginalHeight(b);
    }
    GetOriginalHeight() {
      const b = this.GetInstance();
      return b && b.GetSdkInstance().IsOriginalSizeKnown()
        ? b.GetSdkInstance().GetOriginalHeight()
        : this._trackDataItem.GetOriginalHeight();
    }
    GetType() {
      return this._trackDataItem.GetType();
    }
    GetName() {
      return this._trackDataItem.GetName();
    }
    IsInstanceTrack() {
      return 0 === this.GetType();
    }
    IsValueTrack() {
      return 1 === this.GetType();
    }
    IsAudioTrack() {
      return 2 === this.GetType();
    }
    GetWorldInfoChange() {
      return this._worldInfoChange;
    }
    GetRenderChange() {
      return this._renderChange;
    }
    GetNeedsBeforeAndAfter() {
      return this._needsBeforeAndAfter;
    }
    IsNested() {
      return this._isNested;
    }
    SetResetState() {
      for (const b of this._propertyTracks) b.SetResetState();
    }
    SetInitialState() {
      this.MaybeGetInstance();
      if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
        var b = this.GetTimeline().IsForwardPlayBack()
          ? 0
          : this.GetLocalTotalTime();
        for (const a of this._propertyTracks)
          a.SetInitialState(b),
            0 === this._worldInfoChange &&
              1 === a.GetWorldInfoChange() &&
              (this._worldInfoChange = 1),
            0 === this._renderChange &&
              1 === a.GetRenderChange() &&
              (this._renderChange = 1);
        this._needsBeforeAndAfter = 0;
        this._propertyTracks.some((a) => a.GetNeedsBeforeAndAfter()) &&
          (this._needsBeforeAndAfter = 1);
        this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(b);
        this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
        this.Interpolate(b);
        this.OnKeyframeReached(this._GetLastKeyFrameBeforeTime(b));
      }
    }
    SetResumeState() {
      this.MaybeGetInstance();
      if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
        this._timeline.IsForwardPlayBack();
        var b = this._timeline.GetTime() - this.GetStartOffset();
        this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(b);
        for (const a of this._propertyTracks) a.SetResumeState(b);
      }
    }
    SetEndState() {
      if (
        !(
          this.GetTimeline().IsComplete() ||
          (this.MaybeGetInstance(),
          (!this.IsInstanceValid() && this.IsInstanceTrack()) || this._isNested)
        )
      ) {
        const b = this._timeline.GetTime(),
          a = this.GetStartOffset() + this.GetLocalTotalTime();
        b >= a
          ? this.Interpolate(this.GetLocalTotalTime(), !0, !1, !0)
          : 0 >= b && this.Interpolate(0, !0, !1, !0);
      }
    }
    _SetUpdateState() {
      for (let b = 0, a = this._propertyTracks.length; b < a; b++) {
        const c = this._propertyTracks[b];
        c._SetUpdateState();
        0 === this._worldInfoChange &&
          1 === c.GetWorldInfoChange() &&
          (this._worldInfoChange = 1);
        0 === this._renderChange &&
          1 === c.GetRenderChange() &&
          (this._renderChange = 1);
      }
    }
    BeforeInterpolate() {
      const b = this._propertyTracks.length;
      for (let a = 0; a < b; a++) this._propertyTracks[a].BeforeInterpolate();
    }
    Interpolate(b, a = !1, c = !1, d = !1, f = !1, h = !1) {
      this._instance || this.GetInstance();
      const g = this._instance && !this._instance.IsDestroyed(),
        k = 0 === this._trackDataItem._type;
      if (
        !(
          (!g && k) ||
          (h && k && this.GetObjectClass().IsGlobal()) ||
          ((b -= this.GetStartOffset()), 0 > b)
        )
      ) {
        this.MaybeSetInitialStateOfNestedTrack(b, a);
        this.MaybeTriggerKeyframeReachedConditions(b, a, f);
        for (let m = 0, q = this._propertyTracks.length; m < q; m++)
          this._propertyTracks[m].Interpolate(b, c, d);
        this.MaybeSetEndStateOfNestedTrack(b, a);
        0 !== this._worldInfoChange &&
          (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()),
          this._worldInfo && this._worldInfo.SetBboxChanged());
      }
    }
    AfterInterpolate() {
      const b = this._propertyTracks.length;
      for (let a = 0; a < b; a++) this._propertyTracks[a].AfterInterpolate();
    }
    MaybeSetInitialStateOfNestedTrack(b, a) {
      if (a && this._isNested && !this._initialStateOfNestedSet) {
        if (this.GetTimeline().IsForwardPlayBack()) {
          if (0 > b) return;
          for (const c of this._propertyTracks) c.Interpolate(0, !1, !0);
        } else {
          if (b > this.GetLocalTotalTime()) return;
          for (const c of this._propertyTracks)
            c.Interpolate(this.GetLocalTotalTime(), !1, !0);
        }
        for (const c of this._propertyTracks) c.SetInitialState();
        this._initialStateOfNestedSet = !0;
      }
    }
    MaybeSetEndStateOfNestedTrack(b, a) {
      if (a && this._isNested && !this._endStateOfNestedSet)
        if (this.GetTimeline().IsForwardPlayBack()) {
          if (b >= this.GetLocalTotalTime()) {
            for (const c of this._propertyTracks)
              c.Interpolate(this.GetLocalTotalTime(), !1, !0);
            this._endStateOfNestedSet = !0;
          }
        } else if (0 >= b) {
          for (const c of this._propertyTracks) c.Interpolate(0, !1, !0);
          this._endStateOfNestedSet = !0;
        }
    }
    MaybeTriggerKeyframeReachedConditions(b, a, c) {
      if (!c && a && e.Plugins.Timeline) {
        a = this.GetTimeline();
        c = this._lastKeyframeDataItem.GetNext();
        var d = this._lastKeyframeDataItem.GetTime(),
          f = c ? c.GetTime() : a.GetTotalTime();
        if (b <= d || b >= f)
          (this._lastKeyframeDataItem =
            this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(
              b,
              this._trackDataItem
            )),
            a.IsForwardPlayBack()
              ? c && this.OnKeyframeReached(this._lastKeyframeDataItem)
              : (b = this._lastKeyframeDataItem.GetNext()) &&
                this.OnKeyframeReached(b);
      }
    }
    _GetLastKeyFrameBeforeTime(b) {
      const a = this._trackData.GetKeyFrameDataItemAtTime(
        b,
        this._trackDataItem
      );
      return a
        ? a
        : this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(
            b,
            this._trackDataItem
          );
    }
    OnKeyframeReached(b) {
      const a = this.GetTimeline();
      e.Plugins.Timeline.Cnds.SetTriggerTimeline(a);
      e.Plugins.Timeline.Cnds.SetTriggerKeyframe(b);
      b = a.GetTimelineManager();
      b.Trigger(e.Plugins.Timeline.Cnds.OnAnyKeyframeReached);
      b.Trigger(e.Plugins.Timeline.Cnds.OnKeyframeReached);
      e.Plugins.Timeline.Cnds.SetTriggerTimeline(null);
      e.Plugins.Timeline.Cnds.SetTriggerKeyframe(null);
    }
    AddKeyframe() {
      return this._trackDataItem.GetKeyframeData().AddEmptyKeyframeDataItem();
    }
    AddPropertyTrack() {
      var b = this._trackDataItem
        .GetPropertyTrackData()
        .AddEmptyPropertyTrackDataItem();
      b = e.PropertyTrackState.Create(this, b);
      this._propertyTracks.push(b);
      return b;
    }
    DeleteKeyframes(b) {
      this._trackDataItem.GetKeyframeData().DeleteKeyframeDataItems(b);
    }
    DeletePropertyKeyframes(b) {
      for (const a of this._propertyTracks) a.DeletePropertyKeyframes(b);
    }
    SaveState() {
      for (const b of this._propertyTracks) b.SaveState();
    }
    CompareInitialStateWithCurrent() {
      this.MaybeGetInstance();
      if (this.IsInstanceValid() || !this.IsInstanceTrack())
        for (const b of this._propertyTracks)
          b.CompareInitialStateWithCurrent();
    }
    CompareSaveStateWithCurrent() {
      this.MaybeGetInstance();
      if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
        var b = !1;
        for (const a of this._propertyTracks) {
          const c = a.CompareSaveStateWithCurrent();
          !b && c && (b = !0);
        }
        b &&
          ((b = this.AddKeyframe()),
          b.SetTime(this.GetTimeline().GetTime()),
          b.SetEase("noease"),
          b.SetEnable(!0),
          b.SetTags(""));
      }
    }
    _SaveToJson() {
      var b = this.GetInstance();
      b = b ? b.GetUID() : this.GetInstanceUID();
      return {
        propertyTracksJson: this._SavePropertyTracksToJson(),
        lastKeyframeDataItemJson: this._SaveLastKeyframeDataItemToJson(),
        initialStateOfNestedSet: this._initialStateOfNestedSet,
        endStateOfNestedSet: this._endStateOfNestedSet,
        instanceUid: b,
      };
    }
    _LoadFromJson(b) {
      if (b) {
        this._LoadPropertyTracksFromJson(b.propertyTracksJson);
        this._LoadLastKeyframeDataItemFromJson(b.lastKeyframeDataItemJson);
        this._LoadInstanceFromJson(b.instanceUid);
        this._initialStateOfNestedSet = !1;
        b.hasOwnProperty.initialStateOfNestedSet &&
          (this._initialStateOfNestedSet = b.initialStateOfNestedSet);
        this._endStateOfNestedSet = !1;
        b.hasOwnProperty.endStateOfNestedSet &&
          (this._endStateOfNestedSet = b.endStateOfNestedSet);
        for (const a of this._propertyTracks)
          0 === this._worldInfoChange &&
            1 === a.GetWorldInfoChange() &&
            (this._worldInfoChange = 1),
            0 === this._renderChange &&
              1 === a.GetRenderChange() &&
              (this._renderChange = 1);
        this._needsBeforeAndAfter = 0;
        this._propertyTracks.some((a) => a.GetNeedsBeforeAndAfter()) &&
          (this._needsBeforeAndAfter = 1);
      }
    }
    _SaveLastKeyframeDataItemToJson() {
      return this._trackDataItem
        .GetKeyframeData()
        .GetKeyframeDataItemIndex(this._lastKeyframeDataItem);
    }
    _SavePropertyTracksToJson() {
      return this._propertyTracks.map((b) => b._SaveToJson());
    }
    _LoadPropertyTracksFromJson(b) {
      b.forEach((a, c) => {
        this._propertyTracks[c]._LoadFromJson(a);
      });
    }
    _LoadInstanceFromJson(b) {
      if (e.IsFiniteNumber(b) && (b = this.GetRuntime().GetInstanceByUID(b))) {
        var a = this.GetTimeline();
        a.ClearTrackInstances();
        a.SetTrackInstance(this._trackDataItem.GetId(), b);
      }
    }
    _LoadLastKeyframeDataItemFromJson(b) {
      this._lastKeyframeDataItem = this._trackDataItem
        .GetKeyframeData()
        .GetKeyframeDataItemFromIndex(b);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.PropertyTrackState = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._track = b;
      this._propertyTrackDataItem = a;
      this._propertyTrackData = a.GetPropertyTrackData();
      this._needsBeforeAndAfter =
        this._renderChange =
        this._worldInfoChange =
          0;
      this._sourceAdapter = this.GetSourceAdapter();
      this._propertyKeyframeDataItems = this._propertyTrackDataItem
        .GetPropertyKeyframeData()
        .GetPropertyKeyframeDataItemArray();
      this._absoluteValueObject = this._lastPropertyKeyframeDataItem = null;
    }
    static Create(b, a) {
      return e.New(e.PropertyTrackState, b, a);
    }
    Release() {
      this._track = null;
      this._sourceAdapter &&
        (this._sourceAdapter.Release(), (this._sourceAdapter = null));
      this._propertyTrackData =
        this._propertyTrackDataItem =
        this._propertyKeyframeDataItems =
          null;
    }
    GetWorldInfoChange() {
      return this._worldInfoChange;
    }
    GetRenderChange() {
      return this._renderChange;
    }
    GetNeedsBeforeAndAfter() {
      return this._needsBeforeAndAfter;
    }
    HasAbsoluteValueObject() {
      return !!this._absoluteValueObject;
    }
    SetAbsoluteValueObject(b) {
      this._absoluteValueObject = b;
    }
    GetAbsoluteValueObject() {
      return this._absoluteValueObject;
    }
    GetTrack() {
      return this._track;
    }
    GetPropertyTrackDataItem() {
      return this._propertyTrackDataItem;
    }
    GetPropertyTrackData() {
      return this._propertyTrackData;
    }
    GetTimeline() {
      return this._track.GetTimeline();
    }
    GetRuntime() {
      return this._track.GetRuntime();
    }
    GetInstance() {
      return this._track.GetInstance();
    }
    GetSourceAdapter() {
      if (this._sourceAdapter) return this._sourceAdapter;
      let b;
      switch (this._propertyTrackDataItem.GetSourceAdapterId()) {
        case "behavior":
          b = new e.PropertyTrackState.BehaviorSourceAdapter(this);
          break;
        case "effect":
          b = new e.PropertyTrackState.EffectSourceAdapter(this);
          this._renderChange = 1;
          break;
        case "instance-variable":
          b = new e.PropertyTrackState.InstanceVariableSourceAdapter(this);
          break;
        case "plugin":
          b = new e.PropertyTrackState.PluginSourceAdapter(this);
          this._renderChange = 1;
          break;
        case "world-instance":
          b = new e.PropertyTrackState.PropertySourceAdapter(this);
          this._worldInfoChange = this._renderChange = 1;
          break;
        case "value":
          b = new e.PropertyTrackState.ValueSourceAdapter(this);
          break;
        case "audio":
          b = new e.PropertyTrackState.AudioSourceAdapter(this);
      }
      return (this._sourceAdapter = b);
    }
    GetSourceAdapterId() {
      return this._propertyTrackDataItem.GetSourceAdapterId();
    }
    SetSourceAdapterId(b) {
      this._propertyTrackDataItem.SetSourceAdapterId(b);
    }
    GetSourceAdapterArgs() {
      return this._propertyTrackDataItem.GetSourceAdapterArguments();
    }
    SetSourceAdapterArgs(b) {
      this._propertyTrackDataItem.SetSourceAdapterArguments(b);
    }
    GetSourceAdapterValue() {
      return this.GetSourceAdapter().GetValue();
    }
    GetPropertyName() {
      return this._propertyTrackDataItem.GetProperty();
    }
    SetPropertyName(b) {
      this._propertyTrackDataItem.SetProperty(b);
    }
    GetPropertyType() {
      return this._propertyTrackDataItem.GetType();
    }
    SetPropertyType(b) {
      this._propertyTrackDataItem.SetType(b);
    }
    GetPropertyKeyframeType() {
      return this.GetPropertyTrackData()
        .GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem)
        .GetType();
    }
    GetMin() {
      return this._propertyTrackDataItem.GetMin();
    }
    SetMin(b) {
      this._propertyTrackDataItem.SetMin(b);
    }
    GetMax() {
      return this._propertyTrackDataItem.GetMax();
    }
    SetMax(b) {
      this._propertyTrackDataItem.SetMax(b);
    }
    GetEnable() {
      return this._propertyTrackDataItem.GetEnable();
    }
    SetEnable(b) {
      this._propertyTrackDataItem.SetEnable(b);
    }
    GetInterpolationMode() {
      return this._propertyTrackDataItem.GetInterpolationMode();
    }
    SetInterpolationMode(b) {
      this._propertyTrackDataItem.SetInterpolationMode(b);
    }
    GetResultMode() {
      return this._propertyTrackDataItem.GetResultMode();
    }
    SetResultMode(b) {
      this._propertyTrackDataItem.SetResultMode(b);
    }
    SetEase(b) {
      for (const a of this.GetPropertyKeyframeDataItems()) a.SetEase(b);
    }
    CanHavePropertyKeyframes() {
      return this._propertyTrackDataItem.CanHavePropertyKeyframes();
    }
    GetPropertyKeyframeDataItems() {
      return this._propertyKeyframeDataItems
        ? this._propertyKeyframeDataItems
        : (this._propertyKeyframeDataItems = this._propertyTrackDataItem
            .GetPropertyKeyframeData()
            .GetPropertyKeyframeDataItemArray());
    }
    *GetPropertyKeyframeValues() {
      for (const b of this.GetPropertyKeyframeDataItems())
        yield b.GetValueWithResultMode();
    }
    TimelineRemoved() {
      this.GetSourceAdapter().TimelineRemoved();
    }
    CleanCaches() {
      this.GetSourceAdapter().CleanCaches();
    }
    GetCurrentState() {
      return this.GetSourceAdapter().GetCurrentState();
    }
    SetResetState() {
      this.GetSourceAdapter().SetResetState();
    }
    SetInitialState(b) {
      this.GetSourceAdapter().SetInitialState();
      this._lastPropertyKeyframeDataItem =
        this._GetLastPropertyKeyFrameBeforeTime(b);
      this._SetUpdateState();
    }
    SetResumeState(b) {
      this.GetSourceAdapter().SetResumeState();
      this._lastPropertyKeyframeDataItem =
        this._GetLastPropertyKeyFrameBeforeTime(b);
    }
    _SetUpdateState() {
      var b = this.GetTrack();
      this._needsBeforeAndAfter = 0;
      if (b.IsInstanceTrack()) {
        var a = this.GetTimeline();
        b = b.GetInstance();
        const c = this.GetSourceAdapter(),
          d = this.GetPropertyName();
        c.MayNeedBeforeAndAfterInterpolate()
          ? (a = a.GetSimilarPropertyTracks(b, c, d)) &&
            a.length &&
            (this._needsBeforeAndAfter = 1)
          : (this._needsBeforeAndAfter = 0);
      }
    }
    _GetLastPropertyKeyFrameBeforeTime(b) {
      const a = this.GetTimeline(),
        c = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(
          b,
          this._propertyTrackDataItem
        );
      return c
        ? c
        : a.IsForwardPlayBack()
        ? this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(
            b,
            this._propertyTrackDataItem
          )
        : this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(
            b,
            this._propertyTrackDataItem
          );
    }
    BeforeInterpolate() {
      this._sourceAdapter.BeforeInterpolate();
    }
    Interpolate(b, a = !1, c = !1) {
      let d;
      if (a)
        var f =
          this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(
            b,
            this._propertyTrackDataItem
          );
      else {
        if (this._lastPropertyKeyframeDataItem) {
          var h = this.GetTimeline();
          const g = this._lastPropertyKeyframeDataItem.GetNext();
          f = this._lastPropertyKeyframeDataItem.GetTime();
          h = g ? g.GetTime() : h.GetTotalTime();
          if (b <= f || b >= h)
            this._lastPropertyKeyframeDataItem =
              this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(
                b,
                this._propertyTrackDataItem
              );
        } else
          this._lastPropertyKeyframeDataItem =
            this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(
              b,
              this._propertyTrackDataItem
            );
        f = this._lastPropertyKeyframeDataItem;
      }
      f && (d = f.GetNext());
      this._sourceAdapter.Interpolate(b, f, d, a, c);
    }
    GetInterpolatedValue(b) {
      if (this._lastPropertyKeyframeDataItem) {
        var a = this.GetTimeline();
        const d = this._lastPropertyKeyframeDataItem.GetNext();
        var c = this._lastPropertyKeyframeDataItem.GetTime();
        a = d ? d.GetTime() : a.GetTotalTime();
        if (b <= c || b >= a)
          this._lastPropertyKeyframeDataItem =
            this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(
              b,
              this._propertyTrackDataItem
            );
      } else
        this._lastPropertyKeyframeDataItem =
          this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(
            b,
            this._propertyTrackDataItem
          );
      c = this._lastPropertyKeyframeDataItem;
      a = c.GetNext();
      return this._sourceAdapter.GetInterpolatedValue(b, c, a);
    }
    AfterInterpolate() {
      this._sourceAdapter.AfterInterpolate();
    }
    static GetStartPropertyKeyframeForTime(b, a) {
      const c = a.GetPropertyTrackDataItem();
      return a._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(
        b,
        c
      );
    }
    static GetEndPropertyKeyframeForTime(b, a) {
      const c = a.GetPropertyTrackDataItem();
      return a._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(
        b,
        c
      );
    }
    AddPropertyKeyframe() {
      const b = this._propertyTrackDataItem
        .GetPropertyKeyframeData()
        .AddEmptyPropertyKeyframeDataItem();
      this._lastPropertyKeyframeDataItem = null;
      return b;
    }
    DeletePropertyKeyframes(b) {
      this._lastPropertyKeyframeDataItem = null;
      this._propertyTrackDataItem
        .GetPropertyKeyframeData()
        .DeletePropertyKeyframeDataItems(b);
    }
    SaveState() {
      this.GetSourceAdapter().SaveState();
    }
    CompareInitialStateWithCurrent() {
      if (this.GetSourceAdapter().CompareInitialStateWithCurrent()) {
        const b = this._propertyTrackData.GetFirstPropertyKeyframeDataItem(
            this._propertyTrackDataItem
          ),
          a = this.GetSourceAdapter().GetCurrentState();
        b.SetAbsoluteValue(a);
      }
    }
    CompareSaveStateWithCurrent() {
      const b = this.GetSourceAdapter().CompareSaveStateWithCurrent();
      b && this.AddPropertyKeyframeAtCurrentTime();
      this.GetSourceAdapter().ClearSaveState();
      return b;
    }
    AddPropertyKeyframeAtCurrentTime() {
      const b = this.GetTimeline().GetTime(),
        a = this.GetSourceAdapter(),
        c = e.PropertyTrackState.GetStartPropertyKeyframeForTime(b, this),
        d = this.AddPropertyKeyframe();
      d.SetType(c.GetType());
      d.SetTime(b);
      d.SetEase(c.GetEase());
      d.SetEnable(!0);
      d.SetValue(a.GetValueAtTime());
      d.SetAbsoluteValue(a.GetCurrentState());
    }
    _SaveToJson() {
      return { sourceAdapterJson: this.GetSourceAdapter()._SaveToJson() };
    }
    _LoadFromJson(b) {
      b && this.GetSourceAdapter()._LoadFromJson(b.sourceAdapterJson);
    }
  };
}
{
  ("use strict");
  const e = self.C3.PropertyTrackState;
  e.PropertySourceAdapter = class {
    constructor(b) {
      this._propertyTrack = b;
      this._propertyAdapter = null;
      this.GetPropertyAdapter();
    }
    Release() {
      this._propertyAdapter &&
        (this._propertyAdapter.Release(), (this._propertyAdapter = null));
      this._propertyTrack = null;
    }
    MayNeedBeforeAndAfterInterpolate() {
      return this._propertyAdapter.MayNeedBeforeAndAfterInterpolate();
    }
    GetPropertyTrack() {
      return this._propertyTrack;
    }
    TimelineRemoved() {
      this._propertyAdapter && this._propertyAdapter.TimelineRemoved();
    }
    CleanCaches() {
      this._propertyAdapter && this._propertyAdapter.CleanCaches();
    }
    GetPropertyAdapter() {
      return this._propertyAdapter
        ? this._propertyAdapter
        : (this._propertyAdapter = this._CreatePropertyAdapter());
    }
    GetEditorIndex() {}
    GetIndex() {
      return this.GetEditorIndex();
    }
    GetTarget() {}
    SetResetState() {
      this.GetPropertyAdapter().SetResetState();
    }
    SetInitialState() {
      this.GetPropertyAdapter().SetInitialState();
    }
    SetResumeState() {
      this.GetPropertyAdapter().SetResumeState();
    }
    BeforeInterpolate() {
      this._propertyAdapter.BeforeChangeProperty();
    }
    Interpolate(b, a, c, d, f) {
      let h;
      switch (this._propertyTrack.GetPropertyKeyframeType()) {
        case "numeric":
          h = e.NumericTypeAdapter.Interpolate(b, a, c, this._propertyTrack);
          break;
        case "angle":
          h = e.AngleTypeAdapter.Interpolate(b, a, c, this._propertyTrack);
          break;
        case "boolean":
          h = e.BooleanTypeAdapter.Interpolate(b, a, c, this._propertyTrack);
          break;
        case "color":
          h = e.ColorTypeAdapter.Interpolate(b, a, c, this._propertyTrack);
          break;
        case "text":
          h = e.TextTypeAdapter.Interpolate(b, a, c, this._propertyTrack);
      }
      this._propertyAdapter.ChangeProperty(b, h, a, c, d, f);
    }
    GetInterpolatedValue(b, a, c) {
      switch (this._propertyTrack.GetPropertyKeyframeType()) {
        case "numeric":
          return e.NumericTypeAdapter.Interpolate(b, a, c, this._propertyTrack);
        case "angle":
          return e.AngleTypeAdapter.Interpolate(b, a, c, this._propertyTrack);
        case "boolean":
          return e.BooleanTypeAdapter.Interpolate(b, a, c, this._propertyTrack);
        case "color":
          return e.ColorTypeAdapter.Interpolate(b, a, c, this._propertyTrack);
        case "text":
          return e.TextTypeAdapter.Interpolate(b, a, c, this._propertyTrack);
      }
    }
    AfterInterpolate() {
      this._propertyAdapter.AfterChangeProperty();
    }
    SaveState() {
      this.GetPropertyAdapter().SetSaveState();
    }
    ClearSaveState() {
      this.GetPropertyAdapter().ClearSaveState();
    }
    GetCurrentState() {
      return this.GetPropertyAdapter().GetCurrentState();
    }
    CompareInitialStateWithCurrent() {
      return this.GetPropertyAdapter().CompareInitialStateWithCurrent();
    }
    CompareSaveStateWithCurrent() {
      return this.GetPropertyAdapter().CompareSaveStateWithCurrent();
    }
    GetValueAtTime() {
      const b = this._propertyTrack,
        a = b.GetTrack().GetTimeline().GetTime(),
        c = e.GetStartPropertyKeyframeForTime(a, b),
        d = c.GetNext();
      switch (b.GetPropertyKeyframeType()) {
        case "numeric":
          return e.NumericTypeAdapter.Interpolate(a, c, d, b);
        case "angle":
          return e.AngleTypeAdapter.Interpolate(a, c, d, b);
        case "boolean":
          return e.BooleanTypeAdapter.Interpolate(a, c, d, b);
        case "color":
          return e.ColorTypeAdapter.Interpolate(a, c, d, b);
        case "text":
          return e.TextTypeAdapter.Interpolate(a, c, d, b);
      }
    }
    _CreatePropertyAdapter() {
      const b = this._propertyTrack;
      switch (b.CanHavePropertyKeyframes() ? b.GetPropertyKeyframeType() : "") {
        case "combo":
        case "boolean":
        case "text":
        case "string":
          return new e.PropertyInterpolationAdapter.NoInterpolationAdapter(
            this
          );
        case "numeric":
        case "number":
        case "angle":
          return "combo" === this._propertyTrack.GetPropertyType()
            ? new e.PropertyInterpolationAdapter.NoInterpolationAdapter(this)
            : new e.PropertyInterpolationAdapter.NumericInterpolationAdapter(
                this
              );
        case "color":
        case "offsetColor":
          return new e.PropertyInterpolationAdapter.ColorInterpolationAdapter(
            this
          );
        default:
          return new e.PropertyInterpolationAdapter.NumericInterpolationAdapter(
            this
          );
      }
    }
    _SaveToJson() {
      return { propertyAdapterJson: this.GetPropertyAdapter()._SaveToJson() };
    }
    _LoadFromJson(b) {
      b && this.GetPropertyAdapter()._LoadFromJson(b.propertyAdapterJson);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  class b extends e.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
      super(a);
      this._updatedIndex = NaN;
    }
    GetEditorIndex() {
      return this._propertyTrack
        .GetPropertyTrackDataItem()
        .GetSourceAdapterArguments()[0];
    }
    GetIndex() {
      return this._updatedIndex ? this._updatedIndex : super.GetIndex();
    }
    GetTarget() {
      return this._propertyTrack.GetTrack().GetInstance();
    }
    UpdateInstanceVariableIndex(a) {
      this._propertyTrack
        .GetPropertyTrackDataItem()
        .GetSourceAdapterArguments()[0] !== a && (this._updatedIndex = a);
    }
    Interpolate(a, c, d, f, h) {
      this.GetPropertyAdapter().CanChange(c.GetValue()) &&
        super.Interpolate(a, c, d, f, h);
    }
    GetInterpolatedValue(a, c, d) {
      if (this.GetPropertyAdapter().CanChange(c.GetValue()))
        return super.GetInterpolatedValue(a, c, d);
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), { index: this._updatedIndex });
    }
    _LoadFromJson(a) {
      a && (super._LoadFromJson(a), (this._updatedIndex = a.index));
    }
  }
  e.PropertyTrackState.InstanceVariableSourceAdapter = b;
}
{
  ("use strict");
  const e = self.C3;
  class b extends e.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
      super(a);
      this._sid = NaN;
    }
    GetEditorIndex() {
      return this._propertyTrack
        .GetPropertyTrackDataItem()
        .GetSourceAdapterArguments()[1];
    }
    GetTarget() {
      var a = this._propertyTrack.GetPropertyTrackDataItem(),
        c = this._propertyTrack.GetTrack();
      a = this._sid ? this._sid : a.GetSourceAdapterArguments()[0];
      c = c.GetInstance();
      a = c.GetBehaviorIndexBySID(a);
      return c.GetBehaviorInstances()[a].GetSdkInstance();
    }
    GetBehaviorType(a) {
      const c = this._propertyTrack
        .GetPropertyTrackDataItem()
        .GetSourceAdapterArguments()[2];
      return a.GetBehaviorTypeByName(c);
    }
    UpdateBehaviorTypeSid(a) {
      this._propertyTrack
        .GetPropertyTrackDataItem()
        .GetSourceAdapterArguments()[0] !== a && (this._sid = a);
    }
    Interpolate(a, c, d, f, h) {
      const g = this._propertyTrack.GetTrack().GetInstance();
      this.GetBehaviorType(g.GetObjectClass()) &&
        super.Interpolate(a, c, d, f, h);
    }
    GetInterpolatedValue(a, c, d) {
      const f = this._propertyTrack.GetTrack().GetInstance();
      if (this.GetBehaviorType(f.GetObjectClass()))
        return super.GetInterpolatedValue(a, c, d);
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), { sid: this._sid });
    }
    _LoadFromJson(a) {
      a && (super._LoadFromJson(a), (this._sid = a.sid));
    }
  }
  e.PropertyTrackState.BehaviorSourceAdapter = b;
}
{
  ("use strict");
  const e = self.C3;
  class b extends e.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
      super(a);
    }
    GetEditorIndex() {
      return this._propertyTrack
        .GetPropertyTrackDataItem()
        .GetSourceAdapterArguments()[1];
    }
    GetTarget() {
      const a = this._propertyTrack
        .GetTrack()
        .GetWorldInfo()
        .GetInstanceEffectList();
      var c = a.GetEffectList();
      c = this.GetEffectType(c).GetIndex();
      return a.IsEffectIndexActive(c) ? a.GetEffectParametersForIndex(c) : null;
    }
    GetEffectType(a) {
      const c = this._propertyTrack
        .GetPropertyTrackDataItem()
        .GetSourceAdapterArguments()[0];
      return a.GetEffectTypeByName(c);
    }
    Interpolate(a, c, d, f, h) {
      this._IsEffectActive() && super.Interpolate(a, c, d, f, h);
    }
    GetInterpolatedValue(a, c, d) {
      if (this._IsEffectActive()) return super.GetInterpolatedValue(a, c, d);
    }
    _IsEffectActive() {
      const a = this._propertyTrack
        .GetTrack()
        .GetWorldInfo()
        .GetInstanceEffectList();
      var c = a.GetEffectList();
      if ((c = this.GetEffectType(c)))
        return (c = c.GetIndex()), a.IsEffectIndexActive(c);
    }
  }
  e.PropertyTrackState.EffectSourceAdapter = b;
}
{
  ("use strict");
  const e = self.C3;
  class b extends e.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
      super(a);
    }
    GetEditorIndex() {
      return this._propertyTrack
        .GetPropertyTrackDataItem()
        .GetSourceAdapterArguments()[0];
    }
    GetTarget() {
      return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance();
    }
    Interpolate(a, c, d, f, h) {
      var g = this._propertyTrack.GetTrack();
      const k = g.GetObjectClass().GetPlugin();
      g = g.GetInstance().GetObjectClass().GetPlugin();
      k === g && super.Interpolate(a, c, d, f, h);
    }
    GetInterpolatedValue(a, c, d) {
      var f = this._propertyTrack.GetTrack();
      const h = f.GetObjectClass().GetPlugin();
      f = f.GetInstance().GetObjectClass().GetPlugin();
      if (h === f) return super.GetInterpolatedValue(a, c, d);
    }
  }
  e.PropertyTrackState.PluginSourceAdapter = b;
}
{
  ("use strict");
  const e = self.C3;
  class b extends e.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
      super(a);
      this._value = 0;
      this._init = !1;
    }
    MayNeedBeforeAndAfterInterpolate() {
      return !1;
    }
    SetInitialState() {
      const a = this._propertyTrack.GetPropertyTrackData();
      let c = this._propertyTrack.GetPropertyTrackDataItem();
      c = a.GetFirstPropertyKeyframeDataItem(c);
      this._value = c.GetValueWithResultMode();
    }
    SetResumeState() {}
    GetValue() {
      this._init || this._propertyTrack.Interpolate(0);
      return this._value;
    }
    Interpolate(a, c, d, f, h) {
      this._value = e.PropertyTrackState.NumericTypeAdapter.Interpolate(
        a,
        c,
        d,
        this._propertyTrack
      );
      this._init = !0;
    }
    SaveState() {}
    ClearSaveState() {}
    GetCurrentState() {
      return this._value;
    }
    CompareInitialStateWithCurrent() {
      return !1;
    }
    CompareSaveStateWithCurrent() {
      return !1;
    }
    _SaveToJson() {
      return { value: this._value, init: this._init };
    }
    _LoadFromJson(a) {
      a &&
        ((this._value = a.value),
        (this._init = a.hasOwnProperty("init") ? a.init : !0));
    }
  }
  e.PropertyTrackState.ValueSourceAdapter = b;
}
{
  ("use strict");
  const e = self.C3;
  class b extends e.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
      super(a);
      this._audioPlaybackStarted = !1;
      this._expressions = this._actions = this._sdkInstance = null;
      this._timeline = this._propertyTrack.GetTimeline();
      this._track = this._propertyTrack.GetTrack();
      this._sourceAdapterArgs = this._propertyTrack.GetSourceAdapterArgs();
      this._fileArgs = this._sourceAdapterArgs[0];
      this._startOffsetTime = this._sourceAdapterArgs[1];
      this._audioTag = this._sourceAdapterArgs[3]
        ? this._sourceAdapterArgs[3]
        : Math.random().toString(36).slice(2);
      this._volume = this._pauseVolume = this._pauseTime = NaN;
      this._audioSource = null;
      this._Initialize();
    }
    Release() {
      super.Release();
      this._audioSource =
        this._fileArgs =
        this._sourceAdapterArgs =
        this._track =
        this._timeline =
        this._expressions =
        this._actions =
        this._sdkInstance =
          null;
    }
    _Initialize() {
      if (self.C3.Plugins.Audio) {
        var a = this._propertyTrack.GetRuntime().GetObjectClassByName("audio");
        a && (this._sdkInstance = a.GetSingleGlobalInstance().GetSdkInstance());
        this._actions = self.C3.Plugins.Audio.Acts;
        this._expressions = self.C3.Plugins.Audio.Exps;
      }
    }
    _MaybeSetAudioSource() {
      if (!this._audioSource) {
        var a = this._propertyTrack.GetTrack().GetPropertyTrack("audioSource");
        a && (this._audioSource = a.GetSourceAdapter());
      }
    }
    _GetPauseVolume() {
      const a = this._propertyTrack.GetTrack().GetPropertyTrack("volume");
      return a ? a.GetSourceAdapter()._pauseVolume : this._pauseVolume;
    }
    TimelineRemoved() {
      super.TimelineRemoved();
      this._audioPlaybackStarted = !1;
      this._sdkInstance &&
        (this._expressions &&
          ((this._pauseTime = this._expressions.PlaybackTime.call(
            this._sdkInstance,
            this._audioTag
          )),
          (this._pauseVolume = this._expressions.Volume.call(
            this._sdkInstance,
            this._audioTag
          ))),
        this._actions &&
          this._actions.Stop.call(this._sdkInstance, this._audioTag));
    }
    GetAudioTag() {
      return this._audioTag;
    }
    GetVolume() {
      return this._volume;
    }
    SetVolume(a) {
      this._volume = a;
    }
    SetInitialState() {
      super.SetInitialState();
      this._pauseTime = NaN;
      this._audioPlaybackStarted = !1;
    }
    SetResumeState() {
      super.SetResumeState();
      const a = this._propertyTrack.GetTimeline().GetTime();
      this._pauseTime = a - this._startOffsetTime;
      switch (this._propertyTrack.GetPropertyName()) {
        case "volume":
          this._pauseVolume = this._propertyTrack.GetInterpolatedValue(a);
      }
      this._audioPlaybackStarted = !1;
    }
    Interpolate(a, c, d, f, h) {
      if (this._sdkInstance)
        switch (this._propertyTrack.GetPropertyName()) {
          case "audioSource":
            if (!this._timeline.IsForwardPlayBack()) break;
            if (f) {
              this._actions &&
                this._actions.Stop.call(this._sdkInstance, this._audioTag);
              break;
            }
            if (a < this._startOffsetTime) {
              this._audioPlaybackStarted = !1;
              break;
            }
            c = this._expressions.PlaybackRate.call(
              this._sdkInstance,
              this._audioTag
            );
            d = this._timeline.GetPlaybackRate();
            d !== c &&
              this._actions.SetPlaybackRate.call(
                this._sdkInstance,
                this._audioTag,
                d
              );
            if (this._audioPlaybackStarted) break;
            this._audioPlaybackStarted = !0;
            isNaN(this._pauseTime)
              ? ((c = self.performance.now()),
                (a -= this._startOffsetTime),
                "suspended" === this._sdkInstance.GetAudioContextState()
                  ? (this._audioPlaybackStarted = !1)
                  : ((c = (self.performance.now() - c) / 1e3),
                    (a += c),
                    this._actions &&
                      ((c = this.GetVolume()),
                      isNaN(c)
                        ? (this.SetVolume(0), (c = 0))
                        : this.SetVolume(c),
                      this._actions.Play.call(
                        this._sdkInstance,
                        this._fileArgs,
                        0,
                        c,
                        this._audioTag,
                        a
                      ))))
              : ((a = this._pauseTime),
                (this._pauseTime = NaN),
                (c = this._GetPauseVolume()),
                (this._pauseVolume = NaN),
                "suspended" === this._sdkInstance.GetAudioContextState()
                  ? (this._audioPlaybackStarted = !1)
                  : this._actions &&
                    (this.SetVolume(c),
                    this._actions.Play.call(
                      this._sdkInstance,
                      this._fileArgs,
                      0,
                      c,
                      this._audioTag,
                      a
                    )));
            break;
          case "volume":
            this._MaybeSetAudioSource(), super.Interpolate(a, c, d, f, h);
        }
    }
    GetInterpolatedValue(a, c, d) {
      if (this._sdkInstance)
        switch (this._propertyTrack.GetPropertyName()) {
          case "volume":
            return (
              this._MaybeSetAudioSource(), super.GetInterpolatedValue(a, c, d)
            );
        }
    }
    Getter(a, c) {
      return this._audioSource ? this._audioSource.GetVolume() : 0;
    }
    Setter(a, c, d, f) {
      this._audioSource && this._audioSource.SetVolume(this.Getter() + c);
      this._actions &&
        this._audioSource &&
        this._actions.SetVolume.call(
          this._sdkInstance,
          this._audioSource.GetAudioTag(),
          this._audioSource.GetVolume()
        );
    }
    AbsoluteSetter(a, c, d) {
      this._audioSource && this._audioSource.SetVolume(c);
      this._actions &&
        this._audioSource &&
        this._actions.SetVolume.call(
          this._sdkInstance,
          this._audioSource.GetAudioTag(),
          this._audioSource.GetVolume()
        );
    }
    DoesRounding() {
      return !0;
    }
    _SaveToJson() {
      return {
        audioPlaybackStarted: this._audioPlaybackStarted,
        audioTag: this._audioTag,
        pauseTime: this._pauseTime,
        pauseVolume: this._pauseVolume,
        volume: this._volume,
      };
    }
    _LoadFromJson(a) {
      a &&
        ((this._audioPlaybackStarted = a.audioPlaybackStarted),
        (this._audioTag = a.audioTag),
        (this._pauseTime = a.pauseTime),
        (this._pauseVolume = a.pauseVolume),
        (this._volume = a.volume),
        this._Initialize());
    }
  }
  e.PropertyTrackState.AudioSourceAdapter = b;
}
("use strict");
self.C3.PropertyTrackState.PropertyInterpolationAdapter = class {
  constructor(e) {
    this._sourceAdapter = e;
    this._propertyTrack = e.GetPropertyTrack();
    this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo();
    this._property = this._propertyTrack.GetPropertyName();
    this._firstAbsoluteUpdate = !1;
    this._target = this._saveState = null;
  }
  Release() {
    this._target =
      this._saveState =
      this._worldInfo =
      this._propertyTrack =
      this._sourceAdapter =
        null;
  }
  MayNeedBeforeAndAfterInterpolate() {
    return !1;
  }
  TimelineRemoved() {}
  CleanCaches() {
    this._target = this._saveState = this._worldInfo = null;
  }
  GetSourceAdapter() {
    return this._sourceAdapter;
  }
  GetPropertyTrack() {
    return this._propertyTrack;
  }
  GetWorldInfo() {
    return this._worldInfo
      ? this._worldInfo
      : (this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo());
  }
  SetFirstAbsoluteUpdate(e) {
    this._firstAbsoluteUpdate = !!e;
  }
  GetFirstAbsoluteUpdate() {
    return this._firstAbsoluteUpdate;
  }
  SetResetState() {}
  SetInitialState() {}
  SetResumeState() {}
  SetSaveState() {
    this._saveState = this.GetCurrentState();
  }
  ClearSaveState() {
    this._saveState = null;
  }
  GetCurrentState() {}
  CompareInitialStateWithCurrent() {}
  CompareSaveStateWithCurrent() {}
  CanChange(e) {
    return typeof this._Getter() === typeof e;
  }
  BeforeChangeProperty() {}
  ChangeProperty(e, b, a, c, d) {}
  AfterChangeProperty() {}
  _FirstKeyframeGetter() {
    return this._PickTimelinePlaybackMode(
      () => {
        const e = this._propertyTrack.GetPropertyTrackDataItem();
        return this._propertyTrack
          .GetPropertyTrackData()
          .GetFirstPropertyKeyframeDataItem(e);
      },
      () => {
        const e = this._propertyTrack.GetPropertyTrackDataItem();
        return this._propertyTrack
          .GetPropertyTrackData()
          .GetLastPropertyKeyframeDataItem(e);
      }
    ).GetAbsoluteValue();
  }
  _CurrentKeyframeGetter() {
    const e =
      this._propertyTrack.GetTimeline().GetTime() -
      this._propertyTrack.GetTrack().GetStartOffset();
    return this._PickTimelinePlaybackMode(
      () => {
        const b = this._propertyTrack.GetPropertyTrackDataItem();
        return this._propertyTrack
          .GetPropertyTrackData()
          .GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, b);
      },
      () => {
        const b = this._propertyTrack.GetPropertyTrackDataItem(),
          a = this._propertyTrack.GetPropertyTrackData(),
          c = a.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, b);
        return c ? c : a.GetLastPropertyKeyframeDataItem(b);
      }
    ).GetAbsoluteValue();
  }
  _PickTimelinePlaybackMode(e, b) {
    return this._propertyTrack.GetTimeline().IsForwardPlayBack() ? e() : b();
  }
  _PickResultMode(e, b) {
    return "relative" === this._propertyTrack.GetResultMode() ? e() : b();
  }
  _PickFirstAbsoluteUpdate(e, b) {
    return this.GetFirstAbsoluteUpdate()
      ? (this.SetFirstAbsoluteUpdate(!1), e())
      : b();
  }
  _GetAbsoluteInitialValue(e) {}
  _GetIndex() {
    return this._sourceAdapter.GetIndex();
  }
  _GetTarget() {
    return this._target
      ? this._target
      : (this._target = this._sourceAdapter.GetTarget());
  }
  _PickSource(e, b, a, c, d, f) {
    switch (this._propertyTrack.GetSourceAdapterId()) {
      case "behavior":
        return e();
      case "effect":
        return b();
      case "instance-variable":
        return a();
      case "plugin":
        return c();
      case "world-instance":
        return d();
      case "audio":
        return f();
    }
  }
  _SaveToJson() {
    return {
      firstAbsoluteUpdate: this._firstAbsoluteUpdate,
      saveState: this._saveState,
    };
  }
  _LoadFromJson(e) {
    e &&
      ((this._firstAbsoluteUpdate = e.firstAbsoluteUpdate),
      (this._saveState = e.saveState));
  }
  _GetPropertyKeyframeStubs(e, b = !1) {
    const a = [];
    for (const c of e) {
      e = c.GetTrack().GetStartOffset();
      for (const d of c.GetPropertyKeyframeDataItems())
        b && 0 === d.GetTime()
          ? a.push({ time: e + d.GetTime(), value: d.GetAbsoluteValue() })
          : b || a.push({ time: e + d.GetTime(), value: d.GetAbsoluteValue() });
    }
    return a.sort((c, d) => c.time - d.time);
  }
  _GetLastPropertyKeyframeStub(e, b, a) {
    return this._GetPropertyKeyframeStubLowerThanPlayhead(b, a);
  }
  _GetPropertyKeyframeStubLowerThanPlayhead(e, b) {
    for (let a = b.length - 1; 0 <= a; a--) if (b[a].time <= e) return b[a];
    return null;
  }
};
{
  ("use strict");
  const e = self.C3,
    b = new Map(),
    a = [0, 0, 0];
  class c extends e.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(d) {
      super(d);
    }
    SetResetState() {}
    SetInitialState() {}
    SetResumeState() {}
    GetCurrentState() {
      const d = this._propertyTrack.GetSourceAdapterId(),
        f = this._GetTarget(),
        h = this._GetIndex();
      switch (d) {
        case "behavior":
          return this._ToColorArray(f.GetPropertyValueByIndex(h));
        case "effect":
          return this._ToColorArray(f[h]);
        case "plugin":
          return this._ToColorArray(f.GetPropertyValueByIndex(h));
        case "world-instance":
          return this._ToColorArray(this._Getter());
      }
    }
    CompareInitialStateWithCurrent() {
      const d = this._FirstKeyframeGetter();
      return !this._CompareColors(d, this._Getter());
    }
    CompareSaveStateWithCurrent() {
      return e.IsNullOrUndefined(this._saveState)
        ? !1
        : !this._CompareColors(this._saveState, this._Getter());
    }
    _CompareColors(d, f) {
      d = this._GetColorFromArray(d);
      f = this._GetColorFromArray(f);
      return d.equalsIgnoringAlpha(f);
    }
    _FirstKeyframeGetter() {
      const d = super._FirstKeyframeGetter();
      return this._GetColorFromArray(d);
    }
    _CurrentKeyframeGetter() {
      const d = super._CurrentKeyframeGetter();
      return this._GetColorFromArray(d);
    }
    _GetAbsoluteInitialValue(d) {}
    _ToColorArray(d) {
      return e.IsInstanceOf(d, e.Color)
        ? d.toArray().slice(0, 3)
        : d.slice(0, 3);
    }
    _GetColorFromArray(d) {
      return e.IsInstanceOf(d, e.Color) ? d : new e.Color(d[0], d[1], d[2], 1);
    }
    CanChange(d) {
      return !0;
    }
    MayNeedBeforeAndAfterInterpolate() {
      return !0;
    }
    BeforeChangeProperty() {
      var d = this._propertyTrack.GetTimeline(),
        f = this._propertyTrack.GetInstance();
      const h = this._propertyTrack.GetSourceAdapter();
      (d = d.GetSimilarPropertyTracks(f, h, this._property)) &&
        1 < d.length &&
        (b.has(f) || b.set(f, new Map()),
        (f = b.get(f)),
        (d = this._propertyTrack.GetSourceAdapterId()),
        f.has(d) || f.set(d, new Map()),
        (f = f.get(d)),
        f.has(this._property) ||
          f.set(this._property, { used: !1, color: new e.Color(0, 0, 0, 1) }));
    }
    _GetTmpColor(d, f, h) {
      d = b.get(d).get(f).get(h);
      d.used = !0;
      return d.color;
    }
    ChangeProperty(d, f, h, g, k) {
      k = this._propertyTrack.GetTimeline();
      g = this._propertyTrack.GetTrack();
      d = this._propertyTrack.GetInstance();
      var m = this._propertyTrack.GetSourceAdapter();
      h = this._propertyTrack.GetSourceAdapterId();
      if (
        (m = k.GetSimilarPropertyTracks(d, m, this._property)) &&
        1 < m.length
      ) {
        if (
          ((m = this._GetPropertyKeyframeStubs(m, !0)),
          (k = this._GetLastPropertyKeyframeStub(k, k.GetTime(), m)))
        )
          (g = g.GetStartOffset()),
            (m = k.time - g),
            0 === m
              ? this._GetTmpColor(d, h, this._property).addRgb(f[0], f[1], f[2])
              : 0 > m ||
                ((k = f[0]),
                (g = f[1]),
                (f = f[2]),
                (m = this._propertyTrack.Interpolate(m, !1, !0)),
                (k = e.Color.DiffChannel(k, m[0])),
                (g = e.Color.DiffChannel(g, m[1])),
                (f = e.Color.DiffChannel(f, m[2])),
                this._GetTmpColor(d, h, this._property).addRgb(k, g, f));
      } else this._Setter(f[0], f[1], f[2]);
    }
    AfterChangeProperty() {
      const d = this._propertyTrack.GetInstance();
      if (b.has(d)) {
        var f = b.get(d),
          h = this._propertyTrack.GetSourceAdapterId();
        if (f.has(h)) {
          var g = f.get(h);
          if (g.has(this._property)) {
            var k = g.get(this._property),
              m = k.color;
            k.used && this._Setter(m.getR(), m.getG(), m.getB());
            0 === g.size && f.delete(h);
            0 === f.size && b.delete(d);
          }
        }
      }
    }
    _Getter() {
      const d = this._propertyTrack.GetSourceAdapterId(),
        f = this._GetTarget(),
        h = this._GetIndex();
      switch (d) {
        case "behavior":
          return this._GetColorFromArray(f.GetPropertyValueByIndex(h));
        case "effect":
          return f[h].clone();
        case "plugin":
          return this._GetColorFromArray(f.GetPropertyValueByIndex(h));
        case "world-instance":
          return this.GetWorldInfo().GetUnpremultipliedColor().clone();
      }
    }
    _Setter(d, f, h) {
      const g = this._propertyTrack.GetSourceAdapterId(),
        k = this._GetTarget(),
        m = this._GetIndex();
      switch (g) {
        case "behavior":
          a[0] = d;
          a[1] = f;
          a[2] = h;
          k.SetPropertyValueByIndex(m, a);
          break;
        case "effect":
          k[m].setRgb(d, f, h);
          break;
        case "plugin":
          a[0] = d;
          a[1] = f;
          a[2] = h;
          k.SetPropertyValueByIndex(m, a);
          break;
        case "world-instance":
          this.GetWorldInfo().SetUnpremultipliedColorRGB(d, f, h);
      }
    }
    _SaveToJson() {}
    _LoadFromJson(d) {}
  }
  e.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter =
    c;
}
{
  ("use strict");
  const e = self.C3,
    b = e.PropertyTrackState;
  class a extends e.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(c) {
      super(c);
    }
    SetResetState() {}
    SetInitialState() {}
    SetResumeState() {}
    GetCurrentState() {
      return this._Getter();
    }
    CompareInitialStateWithCurrent() {
      return this._FirstKeyframeGetter() !== this.GetCurrentState();
    }
    CompareSaveStateWithCurrent() {
      return e.IsNullOrUndefined(this._saveState)
        ? !1
        : this._saveState !== this.GetCurrentState();
    }
    MayNeedBeforeAndAfterInterpolate() {
      return !1;
    }
    ChangeProperty(c, d, f, h, g) {
      f = this._propertyTrack;
      const k = f.GetTrack();
      h = f.GetSourceAdapterId();
      g = f.GetTimeline();
      var m = k.GetInstance();
      const q = f.GetSourceAdapter();
      (m = g.GetSimilarPropertyTracks(m, q, this._property)) &&
        1 < m.length &&
        ((m = this._GetPropertyKeyframeStubs(m)),
        (c += k.GetStartOffset()),
        (c = this._GetLastPropertyKeyframeStub(g, c, m))) &&
        (d = c.value);
      switch (f.GetPropertyKeyframeType()) {
        case "numeric":
          if (
            !b.NumericTypeAdapter.WillChange(
              this._GetIndex(),
              this._GetTarget(),
              d,
              h
            )
          )
            return;
          break;
        case "angle":
          if (
            !b.AngleTypeAdapter.WillChange(
              this._GetIndex(),
              this._GetTarget(),
              d,
              h
            )
          )
            return;
          break;
        case "boolean":
          if (
            !b.BooleanTypeAdapter.WillChange(
              this._GetIndex(),
              this._GetTarget(),
              d,
              h
            )
          )
            return;
          break;
        case "color":
          if (
            !b.ColorTypeAdapter.WillChange(
              this._GetIndex(),
              this._GetTarget(),
              d,
              h
            )
          )
            return;
          break;
        case "text":
          if (
            !b.TextTypeAdapter.WillChange(
              this._GetIndex(),
              this._GetTarget(),
              d,
              h
            )
          )
            return;
      }
      this._Setter(d);
    }
    _Getter() {
      const c = this._propertyTrack.GetSourceAdapterId(),
        d = this._GetTarget(),
        f = this._GetIndex();
      switch (c) {
        case "behavior":
          return d.GetPropertyValueByIndex(f);
        case "effect":
          return d[f];
        case "instance-variable":
          return d.GetInstanceVariableValue(f);
        case "plugin":
          return d.GetPropertyValueByIndex(f);
      }
    }
    _Setter(c) {
      const d = this._propertyTrack.GetSourceAdapterId(),
        f = this._GetTarget(),
        h = this._GetIndex();
      switch (d) {
        case "behavior":
          f.SetPropertyValueByIndex(h, c);
          break;
        case "effect":
          f[h] = c;
          break;
        case "instance-variable":
          f.SetInstanceVariableValue(h, c);
          break;
        case "plugin":
          f.SetPropertyValueByIndex(h, c);
      }
    }
  }
  e.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = a;
}
{
  ("use strict");
  const e = self.C3,
    b = new Map(),
    a = (d, f, h, g, k, m = !1, q = null, v = null) => {
      b.set(d, {
        setter: f,
        absolute_setter: h,
        getter: g,
        round: k,
        fRound: m,
        init: q,
        reset: v,
      });
    };
  a(
    "offsetX",
    (d, f) => d.OffsetX(f),
    (d, f) => d.SetX(f),
    (d) => d.GetX(),
    !0
  );
  a(
    "offsetY",
    (d, f) => d.OffsetY(f),
    (d, f) => d.SetY(f),
    (d) => d.GetY(),
    !0
  );
  a(
    "offsetWidth",
    (d, f) => d.OffsetWidth(f),
    (d, f) => d.SetWidth(f),
    (d) => d.GetWidth(),
    !0
  );
  a(
    "offsetHeight",
    (d, f) => d.OffsetHeight(f),
    (d, f) => d.SetHeight(f),
    (d) => d.GetHeight(),
    !0
  );
  a(
    "offsetAngle",
    (d, f) => d.OffsetAngle(f),
    (d, f) => d.SetAngle(f),
    (d) => d.GetAngle(),
    !1
  );
  a(
    "offsetOpacity",
    (d, f, h, g) => {
      h = d.GetOpacity() + f;
      0 === g._clampAccumulator
        ? (1 < h
            ? (g._clampAccumulator += h - 1)
            : 0 > h && (g._clampAccumulator += h),
          d.OffsetOpacity(f))
        : ((d = d.GetOpacity() + f),
          0 < f && 0 < g._clampAccumulator
            ? 1 < d && (g._clampAccumulator += d - 1)
            : 0 < f && 0 > g._clampAccumulator
            ? ((g._clampAccumulator += f),
              0 < g._clampAccumulator && (g._clampAccumulator = 0))
            : 0 > f && 0 < g._clampAccumulator
            ? ((g._clampAccumulator += f),
              0 > g._clampAccumulator && (g._clampAccumulator = 0))
            : 0 > f &&
              0 > g._clampAccumulator &&
              0 > d &&
              (g._clampAccumulator += d));
    },
    (d, f) => {
      d.SetOpacity(f);
    },
    (d) => d.GetOpacity(),
    !1,
    !0,
    (d) => {
      d._clampAccumulator = 0;
      switch (d._propertyTrack.GetResultMode()) {
        case "relative": {
          d._propertyTrack.GetPropertyTrackData();
          const k = d._propertyTrack
            .GetPropertyTrackDataItem()
            .GetPropertyKeyframeData()
            .GetPropertyKeyframeDataItemArray();
          var f = d.GetWorldInfo().GetOpacity(),
            h = f;
          for (var g of k)
            (h = g.GetTime()),
              (h = d._propertyTrack.GetInterpolatedValue(h)),
              (h = f + h),
              (h = e.clamp(h, 0, 1));
          d._totalForewardOpacityDelta = f - h;
          d._totalForewardOpacityDelta =
            Math.round(100 * (d._totalForewardOpacityDelta + Number.EPSILON)) /
            100;
          h = f;
          for (f = k.length - 1; 0 <= f; f--)
            (g = k[f].GetTime()),
              (g = d._propertyTrack.GetInterpolatedValue(g)),
              (h -= g),
              (h = e.clamp(h, 0, 1));
          d._totalBackwardOpacityDelta = h;
          d._totalBackwardOpacityDelta =
            Math.round(100 * (d._totalBackwardOpacityDelta + Number.EPSILON)) /
            100;
        }
      }
    },
    (d) => {
      switch (d._propertyTrack.GetResultMode()) {
        case "relative": {
          d._clampAccumulator = 0;
          const f = d.GetWorldInfo();
          let h = f.GetOpacity();
          h = Math.round(100 * (h + Number.EPSILON)) / 100;
          d._propertyTrack.GetTimeline().IsForwardPlayBack()
            ? (f.SetOpacity(h + d._totalForewardOpacityDelta),
              (d._lastValue = 0))
            : (f.SetOpacity(h - d._totalBackwardOpacityDelta),
              (d._lastValue = d.GetSourceAdapter().GetValueAtTime()));
        }
      }
    }
  );
  a(
    "offsetOriginX",
    (d, f) => d.OffsetOriginX(f),
    (d, f) => d.SetOriginX(f),
    (d) => d.GetOriginX(),
    !1
  );
  a(
    "offsetOriginY",
    (d, f) => d.OffsetOriginY(f),
    (d, f) => d.SetOriginY(f),
    (d) => d.GetOriginY(),
    !1
  );
  a(
    "offsetZElevation",
    (d, f) => d.OffsetZElevation(f),
    (d, f) => d.SetZElevation(f),
    (d) => d.GetZElevation(),
    !0
  );
  a(
    "offsetScaleX",
    (d, f, h, g) => {
      g = 0 > d.GetWidth() ? -1 : 1;
      d.GetTransformWithParentWidth();
      d.OffsetWidth(h.GetOriginalWidth() * g * f);
    },
    (d, f, h) => {
      d.SetWidth(h.GetOriginalWidth() * f);
    },
    (d, f) => {
      const h = 0 > d.GetWidth() ? -1 : 1;
      if (d.GetTransformWithParentWidth()) {
        var g = d.GetParent(),
          k = f.GetTimeline().GetTrackFromInstance(g.GetInstance());
        k
          ? (g = g.GetWidth() / k.GetOriginalWidth())
          : ((k = g.GetInstance().GetSdkInstance()),
            (g = k.IsOriginalSizeKnown()
              ? g.GetWidth() / k.GetOriginalWidth()
              : 1));
        return (d.GetWidth() * h) / (f.GetOriginalWidth() * g);
      }
      return (d.GetWidth() * h) / f.GetOriginalWidth();
    },
    !1
  );
  a(
    "offsetScaleY",
    (d, f, h, g) => {
      g = 0 > d.GetHeight() ? -1 : 1;
      d.GetTransformWithParentHeight();
      d.OffsetHeight(h.GetOriginalHeight() * g * f);
    },
    (d, f, h) => {
      d.SetHeight(h.GetOriginalHeight() * f);
    },
    (d, f) => {
      const h = 0 > d.GetHeight() ? -1 : 1;
      if (d.GetTransformWithParentHeight()) {
        var g = d.GetParent(),
          k = f.GetTimeline().GetTrackFromInstance(g.GetInstance());
        k
          ? (g = g.GetHeight() / k.GetOriginalHeight())
          : ((k = g.GetInstance().GetSdkInstance()),
            (g = k.IsOriginalSizeKnown()
              ? g.GetHeight() / k.GetOriginalHeight()
              : 1));
        return (d.GetHeight() * h) / (f.GetOriginalHeight() * g);
      }
      return (d.GetHeight() * h) / f.GetOriginalHeight();
    },
    !1
  );
  class c extends e.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(d) {
      super(d);
      this._totalBackwardOpacityDelta =
        this._totalForewardOpacityDelta =
        this._clampAccumulator =
        this._lastValue =
          0;
      this._source_adapter_absolute_setter =
        this._source_adapter_setter =
        this._source_adapter_getter =
        this._init_action =
        this._reset_action =
        this._instance_absolute_setter =
        this._instance_setter =
        this._instance_getter =
          null;
      this._fRound = this._round = !1;
      e.IsInstanceOf(this._propertyTrack.GetTimeline(), e.TweenState)
        ? (this._typeAdapter =
            new e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(
              this
            ))
        : (this._typeAdapter =
            new e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(
              this
            ));
      const f = this._propertyTrack.GetPropertyName();
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "world-instance":
          d = b.get(f);
          this._instance_getter = d.getter;
          this._instance_setter = d.setter;
          this._instance_absolute_setter = d.absolute_setter;
          this._round = d.round;
          this._fRound = d.fRound;
          this._init_action = d.init;
          this._reset_action = d.reset;
          break;
        case "audio":
          (this._source_adapter_getter = d.Getter),
            (this._source_adapter_setter = d.Setter),
            (this._source_adapter_absolute_setter = d.AbsoluteSetter),
            (this._round = !!d.DoesRounding()),
            (this._fRound = !1);
      }
    }
    Release() {
      this._instance_absolute_setter =
        this._instance_setter =
        this._instance_getter =
        this._typeAdapter =
          null;
      super.Release();
    }
    MayNeedBeforeAndAfterInterpolate() {
      return this._typeAdapter.MayNeedBeforeAndAfterInterpolate();
    }
    GetLastValue() {
      return this._lastValue;
    }
    SetLastValue(d) {
      this._lastValue = d;
    }
    SetResetState() {
      this._reset_action && this._reset_action(this);
    }
    SetInitialState() {
      const d = this._typeAdapter.SetInitialState();
      "number" === typeof d && (this._lastValue = d);
      this._init_action && this._init_action(this);
    }
    SetResumeState() {
      const d = this._typeAdapter.SetResumeState();
      "number" === typeof d && (this._lastValue = d);
    }
    GetCurrentState() {
      return this._Getter();
    }
    CompareInitialStateWithCurrent() {
      return this._FirstKeyframeGetter() !== this.GetCurrentState();
    }
    CompareSaveStateWithCurrent() {
      return e.IsNullOrUndefined(this._saveState)
        ? !1
        : this._saveState !== this.GetCurrentState();
    }
    BeforeChangeProperty() {
      this._typeAdapter.BeforeChangeProperty();
    }
    ChangeProperty(d, f, h, g, k, m, q) {
      return this._typeAdapter.ChangeProperty(d, f, h, g, k, m, q);
    }
    AfterChangeProperty() {
      this._typeAdapter.AfterChangeProperty();
    }
    _Getter() {
      const d = this._GetTarget(),
        f = this._GetIndex(),
        h = this.GetWorldInfo(),
        g = this._propertyTrack.GetTrack();
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
          return d.GetPropertyValueByIndex(f);
        case "effect":
          return d[f];
        case "instance-variable":
          return d.GetInstanceVariableValue(f);
        case "plugin":
          return d.GetPropertyValueByIndex(f);
        case "world-instance":
          return this._instance_getter(h, g);
        case "audio":
          return this._source_adapter_getter.call(
            this.GetSourceAdapter(),
            h,
            g
          );
      }
    }
    _Setter(d, f, h) {
      f = this._GetTarget();
      h = this._GetIndex();
      const g = this.GetWorldInfo(),
        k = this._propertyTrack.GetTrack();
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
          f.OffsetPropertyValueByIndex(h, d);
          break;
        case "effect":
          f[h] += d;
          break;
        case "instance-variable":
          f.SetInstanceVariableOffset(h, d);
          break;
        case "plugin":
          f.OffsetPropertyValueByIndex(h, d);
          break;
        case "world-instance":
          this._instance_setter(g, d, k, this);
          break;
        case "audio":
          this._source_adapter_setter.call(
            this.GetSourceAdapter(),
            g,
            d,
            k,
            this
          );
      }
    }
    _SetterAbsolute(d, f, h) {
      f = this._GetTarget();
      h = this._GetIndex();
      const g = this.GetWorldInfo(),
        k = this._propertyTrack.GetTrack();
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
          f.SetPropertyValueByIndex(h, d);
          break;
        case "effect":
          f[h] = d;
          break;
        case "instance-variable":
          f.SetInstanceVariableValue(h, d);
          break;
        case "plugin":
          f.SetPropertyValueByIndex(h, d);
          break;
        case "world-instance":
          this._instance_absolute_setter(g, d, k);
          break;
        case "audio":
          this._source_adapter_absolute_setter.call(
            this.GetSourceAdapter(),
            g,
            d,
            k
          );
      }
    }
    _MaybeEnsureValue(d, f, h, g, k, m) {
      this._typeAdapter._MaybeEnsureValue(d, f, h, g, k, m);
    }
    _AddDelta(d, f, h) {
      var g = (d.toString().split(".")[1] || "").length;
      d = this._Getter();
      g =
        0 === g
          ? this._round
            ? Math.round(d)
            : this._fRound
            ? Math.round(100 * (d + Number.EPSILON)) / 100
            : d
          : e.toFixed(d, g);
      this._Setter(g - d, f, h);
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), {
        v: this._lastValue,
        a: this._clampAccumulator,
        fod: this._totalForewardOpacityDelta,
        bod: this._totalBackwardOpacityDelta,
      });
    }
    _LoadFromJson(d) {
      d &&
        (super._LoadFromJson(d),
        (this._lastValue = d.v),
        (this._clampAccumulator = d.a),
        (this._totalForewardOpacityDelta = e.IsFiniteNumber(d.fod) ? d.fod : 0),
        (this._totalBackwardOpacityDelta = e.IsFiniteNumber(d.bod)
          ? d.bod
          : 0));
    }
  }
  e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter =
    c;
}
{
  ("use strict");
  class e {
    constructor(a) {
      this._used = !1;
      this._value = 0;
      this._propertyTracks = a;
      for (let c = 0, d = this._propertyTracks.length; c < d; c++)
        this._propertyTracks[c].SetAbsoluteValueObject(this);
    }
    GetPropertyTracks() {
      return this._propertyTracks;
    }
    SetUsed() {
      this._used = !0;
    }
    GetUsed() {
      return this._used;
    }
    SetValue(a) {
      this._value = a;
    }
    GetValue() {
      return this._value;
    }
    Reset() {
      this._used = !1;
      this._value = 0;
    }
  }
  class b {
    constructor(a) {
      this._numericInterpolationAdapter = a;
    }
    Release() {
      this._numericInterpolationAdapter = null;
    }
    SetInitialState() {
      const a = this._numericInterpolationAdapter;
      this._numericInterpolationAdapter.GetPropertyTrack();
      return a._PickResultMode(
        () =>
          a._PickTimelinePlaybackMode(
            () => 0,
            () => a.GetSourceAdapter().GetValueAtTime()
          ),
        () => {}
      );
    }
    SetResumeState() {}
    MayNeedBeforeAndAfterInterpolate() {
      switch (
        this._numericInterpolationAdapter.GetPropertyTrack().GetResultMode()
      ) {
        case "relative":
          return !1;
        case "absolute":
          return !0;
      }
    }
    BeforeChangeProperty() {
      var a = this._numericInterpolationAdapter.GetPropertyTrack(),
        c = a.GetPropertyName();
      switch (a.GetResultMode()) {
        case "absolute":
          if (a.HasAbsoluteValueObject()) a.GetAbsoluteValueObject().Reset();
          else {
            const d = a.GetTimeline(),
              f = a.GetInstance();
            a = a.GetSourceAdapter();
            (c = d.GetSimilarPropertyTracks(f, a, c)) &&
              1 < c.length &&
              new e(c);
          }
      }
    }
    ChangeProperty(a, c, d, f, h, g) {
      var k = this._numericInterpolationAdapter,
        m = this._numericInterpolationAdapter.GetPropertyTrack();
      switch (m.GetResultMode()) {
        case "relative":
          m = k.GetLastValue();
          k._Setter(c - m, d, f);
          g && this._MaybeEnsureValue(a, d, f, h, m, c);
          k.SetLastValue(c);
          break;
        case "absolute":
          if (
            ((f = m.GetTimeline()),
            (d = m.GetTrack()),
            m.GetInstance(),
            m.GetSourceAdapter(),
            m.HasAbsoluteValueObject())
          ) {
            if (
              ((a = m.GetAbsoluteValueObject()),
              (h = a.GetPropertyTracks()),
              (h = k._GetPropertyKeyframeStubs(h, !0)),
              (k = k._GetLastPropertyKeyframeStub(f, f.GetTime(), h)))
            )
              (d = d.GetStartOffset()),
                (k = k.time - d),
                0 === k
                  ? (a.SetUsed(), a.SetValue(a.GetValue() + c))
                  : 0 > k ||
                    ((m = m.GetInterpolatedValue(k)),
                    a.SetUsed(),
                    a.SetValue(a.GetValue() + (c - m)));
          } else k._SetterAbsolute(c);
      }
    }
    AfterChangeProperty() {
      const a = this._numericInterpolationAdapter;
      var c = this._numericInterpolationAdapter.GetPropertyTrack();
      switch (c.GetResultMode()) {
        case "absolute":
          c.HasAbsoluteValueObject() &&
            ((c = c.GetAbsoluteValueObject()),
            c.GetUsed() && a._SetterAbsolute(c.GetValue()));
      }
    }
    _MaybeEnsureValue(a, c, d, f, h, g) {
      const k = this._numericInterpolationAdapter;
      f ||
        (c && a === c.GetTime()
          ? k._AddDelta(c.GetValueWithResultMode(), c, d)
          : d && a === d.GetTime()
          ? k._AddDelta(d.GetValueWithResultMode(), c, d)
          : 0 === g - h && k._AddDelta(c.GetValueWithResultMode(), c, d));
    }
  }
  self.C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline =
    b;
}
{
  ("use strict");
  class e {
    constructor(b) {
      this._numericInterpolationAdapter = b;
    }
    Release() {
      this._numericInterpolationAdapter = null;
    }
    SetInitialState() {
      const b = this._numericInterpolationAdapter;
      b.SetFirstAbsoluteUpdate(!0);
      return this._GetAbsoluteInitialValue(b._FirstKeyframeGetter());
    }
    SetResumeState() {
      const b = this._numericInterpolationAdapter;
      if (b._FirstKeyframeGetter() !== b._CurrentKeyframeGetter())
        return (
          b.SetFirstAbsoluteUpdate(!0),
          this._GetAbsoluteInitialValue(b._CurrentKeyframeGetter())
        );
    }
    MayNeedBeforeAndAfterInterpolate() {
      return !1;
    }
    BeforeChangeProperty() {}
    ChangeProperty(b, a, c, d, f, h) {
      const g = this._numericInterpolationAdapter,
        k = g.GetLastValue();
      switch (g.GetPropertyTrack().GetResultMode()) {
        case "relative":
          g._Setter(a - k, c, d);
          h && this._MaybeEnsureValue(b, c, d, f, k, a);
          break;
        case "absolute":
          g.GetFirstAbsoluteUpdate()
            ? (g.SetFirstAbsoluteUpdate(!1), g._Setter(k, c, d))
            : (g._Setter(a - k, c, d),
              h && this._MaybeEnsureValue(b, c, d, f, k, a));
      }
      g.SetLastValue(a);
    }
    AfterChangeProperty() {}
    _GetAbsoluteInitialValue(b) {
      return b - this._numericInterpolationAdapter.GetCurrentState();
    }
    _MaybeEnsureValue(b, a, c, d, f, h) {
      const g = this._numericInterpolationAdapter;
      d
        ? a && b === a.GetTime()
          ? g._AddDelta(a.GetValueWithResultMode(), a, c)
          : c && b === c.GetTime()
          ? g._AddDelta(c.GetValueWithResultMode(), a, c)
          : c || g._AddDelta(a.GetValueWithResultMode(), a, c)
        : a && b === a.GetTime()
        ? g._AddDelta(a.GetValueWithResultMode(), a, c)
        : c && b === c.GetTime()
        ? g._AddDelta(c.GetValueWithResultMode(), a, c)
        : 0 === h - f && g._AddDelta(a.GetValueWithResultMode(), a, c);
    }
  }
  self.C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween =
    e;
}
{
  ("use strict");
  const e = self.C3,
    b = self.Ease;
  e.PropertyTrackState.NumericTypeAdapter = class {
    constructor() {}
    static WillChange(a, c, d, f) {
      let h;
      switch (f) {
        case "behavior":
          h = c.GetPropertyValueByIndex(a);
          break;
        case "effect":
          h = c[a];
          break;
        case "instance-variable":
          h = c.GetInstanceVariableValue(a);
          break;
        case "plugin":
          h = c.GetPropertyValueByIndex(a);
      }
      return h === d ? !1 : !0;
    }
    static Interpolate(a, c, d, f) {
      if (!d)
        return (
          (d = f.GetPropertyTrackDataItem()),
          (d = f.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(d)),
          d.GetValueWithResultMode()
        );
      var h = f.GetInterpolationMode();
      "default" === h && (h = "continuous");
      "combo" === f.GetPropertyType() && (h = "discrete");
      if ("discrete" === h) return c.GetValueWithResultMode();
      if ("continuous" === h || "step" === h) {
        "step" === h &&
          ((h = f.GetTimeline().GetStep()),
          0 !== h && ((h = 1 / h), (a = Math.floor(a * h) / h)));
        var g = c.GetTime();
        const k = d.GetTime();
        h = c.GetValueWithResultMode();
        const m = d.GetValueWithResultMode();
        if (h === m) return h;
        a = e.normalize(a, g, k);
        const q = c.GetEase();
        c = c.GetAddOn("cubic-bezier");
        d = d.GetAddOn("cubic-bezier");
        c && c.GetStartEnable() && d && d.GetEndEnable()
          ? ((g = k - g),
            (g = b.GetRuntimeEase(q)(g * a, 0, 1, g)),
            (g = b.GetRuntimeEase("cubicbezier")(
              g,
              h,
              h + c.GetStartAnchor(),
              m + d.GetEndAnchor(),
              m
            )))
          : (g = b.GetRuntimeEase(q)((k - g) * a, h, m - h, k - g));
        return "integer" === f.GetPropertyType() ? Math.floor(g) : g;
      }
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.PropertyTrackState.AngleTypeAdapter = class {
    constructor() {}
    static WillChange(b, a, c, d) {
      let f;
      switch (d) {
        case "behavior":
          f = a.GetPropertyValueByIndex(b);
          break;
        case "effect":
          f = a[b];
          break;
        case "instance-variable":
          f = a.GetInstanceVariableValue(b);
          break;
        case "plugin":
          f = a.GetPropertyValueByIndex(b);
      }
      return f === c ? !1 : !0;
    }
    static Interpolate(b, a, c, d) {
      if (!c)
        return (
          (a = d.GetPropertyTrackDataItem()),
          (a = d.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(a)),
          a.GetValueWithResultMode()
        );
      var f = d.GetInterpolationMode();
      "default" === f && (f = "continuous");
      "combo" === d.GetPropertyType() && (f = "discrete");
      if ("discrete" === f) return a.GetValueWithResultMode();
      if ("continuous" === f || "step" === f) {
        "step" === f &&
          ((d = d.GetTimeline().GetStep()),
          0 !== d && ((d = 1 / d), (b = Math.floor(b * d) / d)));
        const h = a.GetTime(),
          g = c.GetTime();
        d = a.GetValueWithResultMode();
        c = c.GetValueWithResultMode();
        if ((f = a.GetAddOn("angle"))) {
          const k = f.GetRevolutions();
          if (d === c && 0 === k) return d;
          b = e.normalize(b, h, g);
          a = self.Ease.GetRuntimeEase(a.GetEase())(b, 0, 1, 1);
          switch (f.GetDirection()) {
            case "closest":
              return e.angleLerp(d, c, a, k);
            case "clockwise":
              return e.angleLerpClockwise(d, c, a, k);
            case "anti-clockwise":
              return e.angleLerpAntiClockwise(d, c, a, k);
          }
        } else {
          if (d === c) return d;
          b = e.normalize(b, h, g);
          a = self.Ease.GetRuntimeEase(a.GetEase());
          return e.angleLerp(d, c, a(b, 0, 1, 1));
        }
      }
    }
  };
}
("use strict");
self.C3.PropertyTrackState.BooleanTypeAdapter = class {
  constructor() {}
  static WillChange(e, b, a, c) {
    let d;
    switch (c) {
      case "behavior":
        d = b.GetPropertyValueByIndex(e);
        break;
      case "effect":
        d = b[e];
        break;
      case "instance-variable":
        d = b.GetInstanceVariableValue(e);
        break;
      case "plugin":
        d = b.GetPropertyValueByIndex(e);
    }
    return !!d === !!a ? !1 : !0;
  }
  static Interpolate(e, b, a, c) {
    return a
      ? b.GetValueWithResultMode()
        ? 1
        : 0
      : ((e = c.GetPropertyTrackDataItem()),
        (e = c.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e)),
        e.GetValueWithResultMode() ? 1 : 0);
  }
};
{
  ("use strict");
  const e = self.C3,
    b = [0, 0, 0],
    a = [0, 0, 0],
    c = [0, 0, 0];
  e.PropertyTrackState.ColorTypeAdapter = class {
    constructor() {}
    static WillChange(d, f, h, g) {
      let k;
      switch (g) {
        case "behavior":
          k = f.GetPropertyValueByIndex(d);
          break;
        case "effect":
          k = f[d];
          break;
        case "instance-variable":
          k = f.GetInstanceVariableValue(d);
          break;
        case "plugin":
          k = f.GetPropertyValueByIndex(d);
      }
      Array.isArray(h)
        ? ((b[0] = h[0]), (b[1] = h[1]), (b[2] = h[2]))
        : (c.parseCommaSeparatedRgb(h),
          (b[0] = Math.floor(255 * c.getR())),
          (b[1] = Math.floor(255 * c.getG())),
          (b[2] = Math.floor(255 * c.getB())));
      Array.isArray(k)
        ? ((a[0] = k[0]), (a[1] = k[1]), (a[2] = k[2]))
        : (c.parseCommaSeparatedRgb(k),
          (a[0] = Math.floor(255 * c.getR())),
          (a[1] = Math.floor(255 * c.getG())),
          (a[2] = Math.floor(255 * c.getB())));
      return b[0] !== a[0] || b[1] !== a[1] || b[2] !== a[2] ? !0 : !1;
    }
    static Interpolate(d, f, h, g) {
      if (!h) {
        var k = g.GetPropertyTrackDataItem();
        k = g.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(k);
        g = k.GetValueWithResultMode();
        b[0] = g[0];
        b[1] = g[1];
        b[2] = g[2];
        return b;
      }
      k = g.GetInterpolationMode();
      "default" === k && (k = "continuous");
      if ("discrete" === k)
        return (
          (g = f.GetValueWithResultMode()),
          (b[0] = g[0]),
          (b[1] = g[1]),
          (b[2] = g[2]),
          b
        );
      if ("continuous" === k || "step" === k) {
        "step" === k &&
          ((g = g.GetTimeline().GetStep()),
          0 !== g && ((g = 1 / g), (d = Math.floor(d * g) / g)));
        g = f.GetTime();
        k = h.GetTime();
        var m = f.GetValueWithResultMode(),
          q = h.GetValueWithResultMode();
        d = e.normalize(d, g, k);
        var v = f.GetEase();
        f = m[0];
        h = m[1];
        m = m[2];
        const r = q[0],
          n = q[1];
        q = q[2];
        v = self.Ease.GetRuntimeEase(v);
        g = k - g;
        k = g * d;
        b[0] = f === r ? f : v(k, f, r - f, g);
        b[1] = h === n ? h : v(k, h, n - h, g);
        b[2] = m === q ? m : v(k, m, q - m, g);
        return b;
      }
    }
  };
}
("use strict");
self.C3.PropertyTrackState.TextTypeAdapter = class {
  constructor() {}
  static WillChange(e, b, a, c) {
    let d;
    switch (c) {
      case "behavior":
        d = b.GetPropertyValueByIndex(e);
        break;
      case "effect":
        d = b[e];
        break;
      case "instance-variable":
        d = b.GetInstanceVariableValue(e);
        break;
      case "plugin":
        d = b.GetPropertyValueByIndex(e);
    }
    return d === a ? !1 : !0;
  }
  static Interpolate(e, b, a, c) {
    return a
      ? b.GetValueWithResultMode()
      : ((e = c.GetPropertyTrackDataItem()),
        (e = c.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e)),
        e.GetValueWithResultMode());
  }
};
{
  ("use strict");
  const e = self.C3;
  e.TimelineDataManager = class {
    constructor() {
      this._timelineDataItems = new Map();
    }
    Release() {
      for (const b of this._timelineDataItems.values()) b.Release();
      this._timelineDataItems.clear();
      this._timelineDataItems = null;
    }
    Add(b) {
      b = new e.TimelineDataItem(b);
      const a = b.GetName();
      this._timelineDataItems.set(a, b);
    }
    Get(b) {
      return this._timelineDataItems.get(b);
    }
    GetNameId() {
      return 0;
    }
    static _CreateDataItems(b, a, c, d) {
      if (a)
        for (const f of a)
          e.TimelineDataManager._CreateDataItem("create", f, b, c, d);
    }
    static _LoadDataItemsFromJson(b, a, c, d) {
      b.length
        ? a.forEach((f, h) => {
            b[h]._LoadFromJson(f);
          })
        : a.forEach((f) => {
            e.TimelineDataManager._CreateDataItem("load", f, b, c, d);
          });
    }
    static _CreateDataItem(b, a, c, d, f) {
      let h;
      if ("function" === typeof d)
        switch (b) {
          case "load":
            h = new d(null, f);
            break;
          case "create":
            h = new d(a, f);
        }
      else if ("object" === typeof d)
        switch (((d = d.map.get(a[d.prop])), b)) {
          case "load":
            h = new d(null, f);
            break;
          case "create":
            h = new d(a, f);
        }
      switch (b) {
        case "load":
          h._LoadFromJson(a);
          c.push(h);
          break;
        case "create":
          if ("function" === typeof h.GetEnable && !h.GetEnable())
            return h.Release();
          c.push(h);
      }
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.TimelineDataItem = class {
    constructor(b) {
      this._name = "";
      this._totalTime = NaN;
      this._step = 0;
      this._resultMode = this._interpolationMode = "default";
      this._pingPong = this._loop = !1;
      this._repeatCount = 1;
      this._trackData = null;
      this._startOnLayout = "";
      b &&
        ((this._name = b[0]),
        (this._totalTime = b[1]),
        (this._step = b[2]),
        (this._interpolationMode = b[3]),
        (this._resultMode = b[4]),
        (this._loop = !!b[6]),
        (this._pingPong = !!b[7]),
        (this._repeatCount = b[8]),
        (this._startOnLayout = b[9]),
        (this._trackData = new e.TrackData(b[5], this)));
    }
    Release() {
      this._trackData.Release();
      this._trackData = null;
    }
    GetTrackData() {
      this._trackData || (this._trackData = new e.TrackData(null, this));
      return this._trackData;
    }
    GetName() {
      return this._name;
    }
    SetName(b) {
      this._name = b;
    }
    GetTotalTime() {
      return this._totalTime;
    }
    SetTotalTime(b) {
      this._totalTime = b;
    }
    GetStep() {
      return this._step;
    }
    SetStep(b) {
      this._step = b;
    }
    GetInterpolationMode() {
      return this._interpolationMode;
    }
    SetInterpolationMode(b) {
      this._interpolationMode = b;
    }
    GetResultMode() {
      return this._resultMode;
    }
    SetResultMode(b) {
      this._resultMode = b;
    }
    GetLoop() {
      return this._loop;
    }
    SetLoop(b) {
      this._loop = b;
    }
    GetPingPong() {
      return this._pingPong;
    }
    SetPingPong(b) {
      this._pingPong = b;
    }
    GetRepeatCount() {
      return this._repeatCount;
    }
    GetStartOnLayout() {
      return this._startOnLayout;
    }
    _SaveToJson() {
      return {
        trackDataJson: this._trackData._SaveToJson(),
        name: this._name,
        totalTime: this._totalTime,
        step: this._step,
        interpolationMode: this._interpolationMode,
        resultMode: this._resultMode,
        loop: this._loop,
        pingPong: this._pingPong,
        repeatCount: this._repeatCount,
        startOnLayout: this._startOnLayout,
      };
    }
    _LoadFromJson(b) {
      b &&
        (this.GetTrackData()._LoadFromJson(b.trackDataJson),
        (this._name = b.name),
        (this._totalTime = b.totalTime),
        (this._step = b.step),
        (this._interpolationMode = b.interpolationMode),
        (this._resultMode = b.resultMode),
        (this._loop = b.loop),
        (this._pingPong = b.pingPong),
        (this._repeatCount = b.repeatCount),
        (this._startOnLayout = b.startOnLayout));
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  class b {
    constructor(a, c) {
      this._trackData = c;
      this._additionalInstanceData = this._instanceData = null;
      this._objectClassIndex = this._instanceUid = NaN;
      this._resultMode = this._interpolationMode = "default";
      this._enabled = !1;
      this._propertyTrackData = this._keyframeData = null;
      this._id = "";
      this._nestedData = null;
      this._startOffset = 0;
      this._localTotalTime = this._trackData
        .GetTimelineDataItem()
        .GetTotalTime();
      this._type = 0;
      this._name = "";
      a &&
        (a[0] &&
          ((this._instanceData = a[0]),
          (this._instanceUid = a[0][2]),
          (this._objectClassIndex = a[0][1])),
        (this._interpolationMode = a[1]),
        (this._resultMode = a[2]),
        (this._enabled = !!a[3]),
        a[6] && (this._id = a[6]),
        a[7] &&
          ((this._nestedData = a[7]),
          (this._startOffset = a[7][0]),
          (this._localTotalTime = a[7][1])),
        a[8] && (this._additionalInstanceData = a[8]),
        a[8] && (this._additionalInstanceData = a[8]),
        a[9] && (this._type = a[9]),
        a[10] && (this._name = a[10]),
        (this._keyframeData = new e.KeyframeData(a[4], this)),
        (this._propertyTrackData = new e.PropertyTrackData(a[5], this)));
    }
    Release() {
      this._trackData = this._instanceData = null;
      this._keyframeData &&
        (this._keyframeData.Release(), (this._keyframeData = null));
      this._propertyTrackData &&
        (this._propertyTrackData.Release(), (this._propertyTrackData = null));
      this._nestedData = null;
    }
    GetTrackData() {
      return this._trackData;
    }
    GetKeyframeData() {
      this._keyframeData ||
        (this._keyframeData = new e.KeyframeData(null, this));
      return this._keyframeData;
    }
    GetPropertyTrackData() {
      this._propertyTrackData ||
        (this._propertyTrackData = new e.PropertyTrackData(null, this));
      return this._propertyTrackData;
    }
    GetInstanceData() {
      return this._instanceData;
    }
    GetObjectClassIndex() {
      return this._objectClassIndex;
    }
    SetObjectClassIndex(a) {
      this._objectClassIndex = a;
    }
    GetInstanceUID() {
      return this._instanceUid;
    }
    SetInstanceUID(a) {
      this._instanceUid = a;
    }
    GetInterpolationMode() {
      return this._interpolationMode;
    }
    SetInterpolationMode(a) {
      this._interpolationMode = a;
    }
    GetResultMode() {
      return this._resultMode;
    }
    SetResultMode(a) {
      this._resultMode = a;
    }
    GetEnable() {
      return this._enabled;
    }
    SetEnable(a) {
      this._enabled = !!a;
    }
    GetId() {
      return this._id;
    }
    GetStartOffset() {
      return this._startOffset;
    }
    GetLocalTotalTime() {
      return this._localTotalTime;
    }
    SetLocalTotalTime(a) {
      this._localTotalTime = a;
    }
    GetOriginalWidth() {
      return this._additionalInstanceData[0];
    }
    SetOriginalWidth(a) {
      this._additionalInstanceData || (this._additionalInstanceData = []);
      this._additionalInstanceData[0] = a;
    }
    GetOriginalHeight() {
      this._additionalInstanceData || (this._additionalInstanceData = []);
      return this._additionalInstanceData[1];
    }
    SetOriginalHeight(a) {
      this._additionalInstanceData || (this._additionalInstanceData = []);
      this._additionalInstanceData[1] = a;
    }
    GetType() {
      return this._type;
    }
    GetName() {
      return this._name;
    }
    _SaveToJson() {
      return {
        keyframeDataJson: this._keyframeData._SaveToJson(),
        propertyTrackDataJson: this._propertyTrackData._SaveToJson(),
        instanceData: this._instanceData,
        additionalInstanceData: this._additionalInstanceData,
        instanceUid: this._instanceUid,
        objectClassIndex: this._objectClassIndex,
        interpolationMode: this._interpolationMode,
        resultMode: this._resultMode,
        enabled: this._enabled,
        id: this._id,
        nestedData: this._nestedData,
        type: this._type,
        name: this._name,
      };
    }
    _LoadFromJson(a) {
      a &&
        ((this._instanceData = a.instanceData),
        (this._instanceUid = a.instanceUid),
        (this._objectClassIndex = a.objectClassIndex),
        (this._interpolationMode = a.interpolationMode),
        (this._resultMode = a.resultMode),
        (this._enabled = a.enabled),
        (this._id = a.id),
        (this._type = a.type ? a.type : 0),
        (this._name = a.name ? a.name : ""),
        (this._localTotalTime = this._trackData
          .GetTimelineDataItem()
          .GetTotalTime()),
        a.nestedData &&
          ((this._nestedData = a.nestedData),
          (this._startOffset = this._nestedData[0]),
          (this._localTotalTime = this._nestedData[1])),
        a.additionalInstanceData &&
          (this._additionalInstanceData = a.additionalInstanceData),
        this.GetKeyframeData()._LoadFromJson(a.keyframeDataJson),
        this.GetPropertyTrackData()._LoadFromJson(a.propertyTrackDataJson));
    }
  }
  e.TrackData = class {
    constructor(a, c) {
      this._timelineDataItem = c;
      this._trackDataItems = [];
      e.TimelineDataManager._CreateDataItems(this._trackDataItems, a, b, this);
    }
    Release() {
      this._timelineDataItem = null;
      for (const a of this._trackDataItems) a.Release();
      e.clearArray(this._trackDataItems);
      this._trackDataItems = null;
    }
    GetTimelineDataItem() {
      return this._timelineDataItem;
    }
    AddEmptyTrackDataItem() {
      const a = new b(null, this);
      this._trackDataItems.push(a);
      return a;
    }
    GetFirstKeyframeDataItem(a) {
      return a.GetKeyframeData().GetKeyframeDataItemArray()[0];
    }
    GetLastKeyframeDataItem(a) {
      return a.GetKeyframeData().GetKeyframeDataItemArray().at(-1);
    }
    GetKeyFrameDataItemAtTime(a, c) {
      c = c.GetKeyframeData().GetKeyframeDataItemArray();
      const d = c.length;
      for (let f = 0; f < d; f++) {
        const h = c[f];
        if (h.GetTime() === a) return h;
      }
    }
    GetFirstKeyFrameDataItemHigherThan(a, c) {
      c = c.GetKeyframeData().GetKeyframeDataItemArray();
      const d = c.length;
      for (let f = 0; f < d; f++) {
        const h = c[f];
        if (h.GetTime() > a) return h;
      }
    }
    GetFirstKeyFrameDataItemHigherOrEqualThan(a, c) {
      c = c.GetKeyframeData().GetKeyframeDataItemArray();
      const d = c.length;
      for (let f = 0; f < d; f++) {
        const h = c[f];
        if (h.GetTime() >= a) return h;
      }
    }
    GetFirstKeyFrameDataItemLowerOrEqualThan(a, c) {
      c = c.GetKeyframeData().GetKeyframeDataItemArray();
      for (let d = c.length - 1; 0 <= d; d--) {
        const f = c[d];
        if (f.GetTime() <= a) return f;
      }
    }
    *trackDataItems() {
      for (const a of this._trackDataItems) yield a;
    }
    _SaveToJson() {
      return {
        trackDataItemsJson: this._trackDataItems.map((a) => a._SaveToJson()),
      };
    }
    _LoadFromJson(a) {
      a &&
        e.TimelineDataManager._LoadDataItemsFromJson(
          this._trackDataItems,
          a.trackDataItemsJson,
          b,
          this
        );
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  class b {
    constructor(a, c) {
      this._propertyTrackData = c;
      this._sourceAdapterId = "";
      this._type = this._property = this._sourceAdapterArguments = null;
      this._max = this._min = NaN;
      this._resultMode = this._interpolationMode = "default";
      this._enabled = !1;
      this._propertyKeyframeData = null;
      this._canHavePropertyKeyframes = !0;
      a &&
        ((this._sourceAdapterId = a[0][0]),
        (this._sourceAdapterArguments = a[0].slice(1)),
        (this._property = a[1]),
        (this._type = a[2]),
        (this._min = a[3]),
        (this._max = a[4]),
        (this._interpolationMode = a[5]),
        (this._resultMode = a[6]),
        (this._enabled = !!a[7]),
        (this._propertyKeyframeData = new e.PropertyKeyframeData(a[8], this)),
        (this._canHavePropertyKeyframes = a[9]));
    }
    Release() {
      this._propertyKeyframeData.Release();
      this._sourceAdapterArguments =
        this._propertyTrackData =
        this._propertyKeyframeData =
          null;
    }
    GetPropertyTrackData() {
      return this._propertyTrackData;
    }
    GetPropertyKeyframeData() {
      this._propertyKeyframeData ||
        (this._propertyKeyframeData = new e.PropertyKeyframeData(null, this));
      return this._propertyKeyframeData;
    }
    GetSourceAdapterId() {
      return this._sourceAdapterId;
    }
    SetSourceAdapterId(a) {
      this._sourceAdapterId = a;
    }
    GetSourceAdapterArguments() {
      return this._sourceAdapterArguments;
    }
    SetSourceAdapterArguments(a) {
      this._sourceAdapterArguments = a;
    }
    GetProperty() {
      return this._property;
    }
    SetProperty(a) {
      this._property = a;
    }
    GetType() {
      return this._type;
    }
    SetType(a) {
      this._type = a;
    }
    GetMin() {
      return this._min;
    }
    SetMin(a) {
      this._min = a;
    }
    GetMax() {
      return this._max;
    }
    SetMax(a) {
      this._max = a;
    }
    GetInterpolationMode() {
      return this._interpolationMode;
    }
    SetInterpolationMode(a) {
      this._interpolationMode = a;
    }
    GetResultMode() {
      return this._resultMode;
    }
    SetResultMode(a) {
      this._resultMode = a;
    }
    GetEnable() {
      return this._enabled;
    }
    SetEnable(a) {
      this._enabled = !!a;
    }
    CanHavePropertyKeyframes() {
      return !!this._canHavePropertyKeyframes;
    }
    _SaveToJson() {
      return {
        propertyKeyframeDataJson: this._propertyKeyframeData._SaveToJson(),
        sourceAdapterId: this._sourceAdapterId,
        sourceAdapterArguments: this._sourceAdapterArguments,
        property: this._property,
        type: this._type,
        min: this._min,
        max: this._max,
        interpolationMode: this._interpolationMode,
        resultMode: this._resultMode,
        enabled: this._enabled,
        canHavePropertyKeyframes: this._canHavePropertyKeyframes,
      };
    }
    _LoadFromJson(a) {
      a &&
        ((this._sourceAdapterId = a.sourceAdapterId),
        (this._sourceAdapterArguments = a.sourceAdapterArguments),
        (this._property = a.property),
        (this._type = a.type),
        (this._min = a.min),
        (this._max = a.max),
        (this._interpolationMode = a.interpolationMode),
        (this._resultMode = a.resultMode),
        (this._enabled = a.enabled),
        (this._canHavePropertyKeyframes = a.canHavePropertyKeyframes),
        this.GetPropertyKeyframeData()._LoadFromJson(
          a.propertyKeyframeDataJson
        ));
    }
  }
  e.PropertyTrackData = class {
    constructor(a, c) {
      this._trackDataItem = c;
      this._propertyTrackDataItems = [];
      e.TimelineDataManager._CreateDataItems(
        this._propertyTrackDataItems,
        a,
        b,
        this
      );
    }
    Release() {
      this._trackDataItem = null;
      for (const a of this._propertyTrackDataItems) a.Release();
      e.clearArray(this._propertyTrackDataItems);
      this._propertyTrackDataItems = null;
    }
    GetTrackDataItem() {
      return this._trackDataItem;
    }
    AddEmptyPropertyTrackDataItem() {
      const a = new b(null, this);
      this._propertyTrackDataItems.push(a);
      return a;
    }
    GetFirstPropertyKeyframeDataItem(a) {
      return a.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()[0];
    }
    GetLastPropertyKeyframeDataItem(a) {
      return a
        .GetPropertyKeyframeData()
        .GetPropertyKeyframeDataItemArray()
        .at(-1);
    }
    GetPropertyKeyFrameDataItemAtTime(a, c) {
      c = c.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
      const d = c.length;
      for (let f = 0; f < d; f++) {
        const h = c[f];
        if (h.GetTime() === a) return h;
      }
    }
    GetFirstPropertyKeyFrameDataItemHigherThan(a, c) {
      c = c.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
      const d = c.length;
      for (let f = 0; f < d; f++) {
        const h = c[f];
        if (h.GetTime() > a) return h;
      }
    }
    GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, c) {
      c = c.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
      const d = c.length;
      for (let f = 0; f < d; f++) {
        const h = c[f];
        if (h.GetTime() >= a) return h;
      }
    }
    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, c) {
      c = c.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
      for (let d = c.length - 1; 0 <= d; d--) {
        const f = c[d];
        if (f.GetTime() <= a) return f;
      }
    }
    *propertyTrackDataItems() {
      for (const a of this._propertyTrackDataItems) yield a;
    }
    _SaveToJson() {
      return {
        propertyTrackDataItemsJson: this._propertyTrackDataItems.map((a) =>
          a._SaveToJson()
        ),
      };
    }
    _LoadFromJson(a) {
      a &&
        e.TimelineDataManager._LoadDataItemsFromJson(
          this._propertyTrackDataItems,
          a.propertyTrackDataItemsJson,
          b,
          this
        );
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  class b {
    constructor(a, c) {
      this._keyframeData = c;
      this._time = -1;
      this._ease = "noease";
      this._enable = !1;
      this._lowerTags = this._tags = null;
      a &&
        ((this._time = a[0]),
        (this._ease = a[1]),
        (this._enable = !!a[2]),
        (this._tags = (a = a[3]) ? a.split(" ") : []),
        (this._lowerTags = new Set(this._tags.map((d) => d.toLowerCase()))),
        (this._next = null));
    }
    Release() {
      this._keyframeData = null;
      e.clearArray(this._tags);
      this._tags = null;
      this._lowerTags.clear();
      this._lowerTags = null;
    }
    GetKeyframeData() {
      return this._keyframeData;
    }
    GetNext() {
      return this._next;
    }
    SetNext(a) {
      this._next = a;
    }
    GetTime() {
      return this._time;
    }
    SetTime(a) {
      this._time = a;
      this._keyframeData._LinkKeyframeDataItems();
    }
    GetEase() {
      return this._ease;
    }
    SetEase(a) {
      this._ease = a;
    }
    GetEnable() {
      return this._enable;
    }
    SetEnable(a) {
      this._enable = !!a;
    }
    GetTags() {
      return this._tags;
    }
    SetTags(a) {
      this._tags = a ? a.split(" ") : [];
      this._lowerTags = new Set(this._tags.map((c) => c.toLowerCase()));
    }
    GetLowerTags() {
      return this._lowerTags;
    }
    HasTag(a) {
      return this._lowerTags.has(a.toLowerCase());
    }
    _SaveToJson() {
      return {
        time: this._time,
        ease: this._ease,
        enable: this._enable,
        tags: this._tags,
      };
    }
    _LoadFromJson(a) {
      a &&
        ((this._time = a.time),
        (this._ease = a.ease),
        (this._enable = a.enable),
        (this._tags = a.tags),
        (this._lowerTags = new Set(this._tags.map((c) => c.toLowerCase()))));
    }
  }
  e.KeyframeData = class {
    constructor(a, c) {
      this._trackDataItem = c;
      this._keyframeDataItems = [];
      e.TimelineDataManager._CreateDataItems(
        this._keyframeDataItems,
        a,
        b,
        this
      );
      this._LinkKeyframeDataItems();
    }
    Release() {
      this._trackDataItem = null;
      for (const a of this._keyframeDataItems) a.Release();
      e.clearArray(this._keyframeDataItems);
      this._keyframeDataItems = null;
    }
    _LinkKeyframeDataItems() {
      this._keyframeDataItems.sort((a, c) => a.GetTime() - c.GetTime());
      for (let a = 0; a < this._keyframeDataItems.length; a++)
        this._keyframeDataItems[a].SetNext(this._keyframeDataItems[a + 1]);
    }
    GetTrackDataItem() {
      return this._trackDataItem;
    }
    GetKeyframeDataItemCount() {
      return this._keyframeDataItems.length;
    }
    GetKeyframeDataItemArray() {
      return this._keyframeDataItems;
    }
    AddEmptyKeyframeDataItem() {
      const a = new b(null, this);
      this._keyframeDataItems.push(a);
      this._LinkKeyframeDataItems();
      return a;
    }
    DeleteKeyframeDataItems(a) {
      for (const c of this._keyframeDataItems) {
        if (!a(c)) continue;
        const d = this._keyframeDataItems.indexOf(c);
        -1 !== d && (c.Release(), this._keyframeDataItems.splice(d, 1));
      }
      this.SortKeyframeDataItems();
      this._LinkKeyframeDataItems();
    }
    SortKeyframeDataItems() {
      this._keyframeDataItems.sort((a, c) => a.GetTime() - c.GetTime());
    }
    GetKeyframeDataItemIndex(a) {
      return this._keyframeDataItems.indexOf(a);
    }
    GetKeyframeDataItemFromIndex(a) {
      return this._keyframeDataItems[a];
    }
    *keyframeDataItems() {
      for (const a of this._keyframeDataItems) yield a;
    }
    *keyframeDataItemsReverse() {
      for (let a = this._keyframeDataItems.length - 1; 0 <= a; a--)
        yield this._keyframeDataItems[a];
    }
    _SaveToJson() {
      return {
        keyframeDataItemsJson: this._keyframeDataItems.map((a) =>
          a._SaveToJson()
        ),
      };
    }
    _LoadFromJson(a) {
      a &&
        (e.TimelineDataManager._LoadDataItemsFromJson(
          this._keyframeDataItems,
          a.keyframeDataItemsJson,
          b,
          this
        ),
        this._LinkKeyframeDataItems());
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  class b {
    constructor(a, c) {
      this._propertyKeyframeData = c;
      this._aValue = this._value = null;
      this._type = "";
      this._time = NaN;
      this._ease = "noease";
      this._enable = !1;
      this._addonData = null;
      this._addonInstance = void 0;
      a &&
        ((this._value = a[0][0]),
        (this._aValue = a[0][1]),
        (this._type = a[0][2]),
        (this._time = a[1]),
        (this._ease = a[2]),
        (this._enable = !!a[3]),
        (this._addonData = null),
        a[4] && (this._addonData = new e.AddonData(a[4], this)),
        (this._next = null));
    }
    Release() {
      this._propertyKeyframeData = null;
      this._addonData && (this._addonData.Release(), (this._addonData = null));
    }
    GetAddonData() {
      return this._addonData;
    }
    SetNext(a) {
      this._next = a;
    }
    GetNext() {
      return this._next;
    }
    GetValue() {
      return this._value;
    }
    SetValue(a) {
      "color" === this._type && e.IsFiniteNumber(a)
        ? ((this._value[0] = e.GetRValue(a)),
          (this._value[1] = e.GetGValue(a)),
          (this._value[2] = e.GetBValue(a)))
        : (this._value = a);
    }
    GetAbsoluteValue() {
      return this._aValue;
    }
    SetAbsoluteValue(a) {
      "color" === this._type && e.IsFiniteNumber(a)
        ? ((this._aValue[0] = e.GetRValue(a)),
          (this._aValue[1] = e.GetGValue(a)),
          (this._aValue[2] = e.GetBValue(a)))
        : (this._aValue = a);
    }
    GetValueWithResultMode() {
      const a = this._propertyKeyframeData
        .GetPropertyTrackDataItem()
        .GetResultMode();
      if ("relative" === a) return this.GetValue();
      if ("absolute" === a) return this.GetAbsoluteValue();
    }
    GetType() {
      return this._type;
    }
    SetType(a) {
      this._type = a;
    }
    GetTime() {
      return this._time;
    }
    SetTime(a) {
      this._time = a;
      this._propertyKeyframeData._LinkPropertyKeyframeDataItems();
    }
    GetEase() {
      return this._ease;
    }
    SetEase(a) {
      this._ease = a;
    }
    GetEnable() {
      return this._enable;
    }
    SetEnable(a) {
      this._enable = !!a;
    }
    GetAddOn(a) {
      if (this._addonData) {
        if (this._addonInstance || null === this._addonInstance)
          return this._addonInstance;
        var c = this._addonData.GetAddDataItemArray();
        if (!c) return (this._addonInstance = null);
        var d = c.length;
        for (let f = 0; f < d; f++) {
          const h = c[f];
          if (h.GetId() === a) return (this._addonInstance = h);
        }
        return (this._addonInstance = null);
      }
    }
    _SaveToJson() {
      const a = this._addonData;
      return {
        addonDataJson: a ? a._SaveToJson() : a,
        value: this._value,
        aValue: this._aValue,
        type: this._type,
        time: this._time,
        ease: this._ease,
        enable: this._enable,
      };
    }
    _LoadFromJson(a) {
      a &&
        (a.addonDataJson && this._addonData._SetFromJson(a.addonDataJson),
        (this._value = a.value),
        (this._aValue = a.aValue),
        (this._type = a.type),
        (this._time = a.time),
        (this._ease = a.ease),
        (this._enable = a.enable));
    }
  }
  e.PropertyKeyframeData = class {
    constructor(a, c) {
      this._propertyTrackDataItem = c;
      this._propertyKeyframeDataItems = [];
      e.TimelineDataManager._CreateDataItems(
        this._propertyKeyframeDataItems,
        a,
        b,
        this
      );
      this._LinkPropertyKeyframeDataItems();
    }
    Release() {
      this._propertyTrackDataItem = null;
      for (const a of this._propertyKeyframeDataItems) a.Release();
      e.clearArray(this._propertyKeyframeDataItems);
      this._propertyKeyframeDataItems = null;
    }
    _LinkPropertyKeyframeDataItems() {
      this._propertyKeyframeDataItems.sort((a, c) => a.GetTime() - c.GetTime());
      for (let a = 0; a < this._propertyKeyframeDataItems.length; a++)
        this._propertyKeyframeDataItems[a].SetNext(
          this._propertyKeyframeDataItems[a + 1]
        );
    }
    AddEmptyPropertyKeyframeDataItem() {
      const a = new b(null, this);
      this._propertyKeyframeDataItems.push(a);
      this._LinkPropertyKeyframeDataItems();
      return a;
    }
    DeletePropertyKeyframeDataItems(a) {
      for (const c of this._propertyKeyframeDataItems) {
        if (!a(c)) continue;
        const d = this._propertyKeyframeDataItems.indexOf(c);
        -1 !== d && (c.Release(), this._propertyKeyframeDataItems.splice(d, 1));
      }
      this.SortPropertyKeyFrameDataItems();
      this._LinkPropertyKeyframeDataItems();
    }
    SortPropertyKeyFrameDataItems() {
      this._propertyKeyframeDataItems.sort((a, c) => a.GetTime() - c.GetTime());
    }
    GetPropertyTrackDataItem() {
      return this._propertyTrackDataItem;
    }
    GetPropertyKeyframeDataItemCount() {
      return this._propertyKeyframeDataItems.length;
    }
    GetPropertyKeyframeDataItemArray() {
      return this._propertyKeyframeDataItems;
    }
    *propertyKeyframeDataItems() {
      for (const a of this._propertyKeyframeDataItems) yield a;
    }
    *propertyKeyframeDataItemsReverse() {
      for (let a = this._propertyKeyframeDataItems.length - 1; 0 <= a; a--)
        yield this._propertyKeyframeDataItems[a];
    }
    _SaveToJson() {
      return {
        propertyKeyframeDataItemsJson: this._propertyKeyframeDataItems.map(
          (a) => a._SaveToJson()
        ),
      };
    }
    _LoadFromJson(a) {
      a &&
        (e.TimelineDataManager._LoadDataItemsFromJson(
          this._propertyKeyframeDataItems,
          a.propertyKeyframeDataItemsJson,
          b,
          this
        ),
        this._LinkPropertyKeyframeDataItems());
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  class b {
    constructor(d, f) {
      this._addonData = f;
      this._id = d[0];
      this._data = d[1];
    }
    Release() {
      this._data = this._addonData = null;
    }
    GetAddonData() {
      return this._addonData;
    }
    GetId() {
      return this._id;
    }
    _SaveToJson() {
      return { id: this._id, data: this._data };
    }
    _LoadFromJson(d) {
      d && ((this._id = d.id), (this._data = d.data));
    }
  }
  class a extends b {
    constructor(d, f) {
      super(d, f);
      this._startAnchor = this._data[0];
      this._startEnable = !!this._data[1];
      this._endAnchor = this._data[2];
      this._endEnable = !!this._data[3];
    }
    Release() {
      super.Release();
    }
    GetStartAnchor() {
      return this._startAnchor;
    }
    GetStartEnable() {
      return this._startEnable;
    }
    GetEndAnchor() {
      return this._endAnchor;
    }
    GetEndEnable() {
      return this._endEnable;
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), {
        startAnchor: this._startAnchor,
        startEnable: !!this._startEnable,
        endAnchor: this._endAnchor,
        endEnable: !!this._endEnable,
      });
    }
    _LoadFromJson(d) {
      d &&
        (super._LoadFromJson(d),
        (this._startAnchor = d.startAnchor),
        (this._startEnable = !!d.startEnable),
        (this._endAnchor = d.endAnchor),
        (this._endEnable = !!d.endEnable));
    }
  }
  class c extends b {
    constructor(d, f) {
      super(d, f);
      this._direction = this._data[0];
      this._revolutions = this._data[1];
    }
    Release() {
      super.Release();
    }
    GetDirection() {
      return this._direction;
    }
    GetRevolutions() {
      return this._revolutions;
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), {
        direction: this._direction,
        revolutions: this._revolutions,
      });
    }
    _LoadFromJson(d) {
      d &&
        (super._LoadFromJson(d),
        (this._direction = d.direction),
        (this._revolutions = d.revolutions));
    }
  }
  e.AddonData = class {
    constructor(d, f) {
      this._propertyKeyframeDataItem = f;
      this._addonDataItems = [];
      e.TimelineDataManager._CreateDataItems(
        this._addonDataItems,
        d,
        {
          prop: 0,
          map: new Map([
            ["cubic-bezier", a],
            ["angle", c],
          ]),
        },
        this
      );
    }
    Release() {
      this._propertyKeyframeDataItem = null;
      for (const d of this._addonDataItems) d.Release();
      e.clearArray(this._addonDataItems);
      this._addonDataItems = null;
    }
    GetPropertyKeyframeDataItem() {
      return this._propertyKeyframeDataItem;
    }
    GetAddDataItemArray() {
      return this._addonDataItems;
    }
    *addonDataItems() {
      for (const d of this._addonDataItems) yield d;
    }
    _SaveToJson() {
      return {
        addonDataItemsJson: this._addonDataItems.map((d) => d._SaveToJson()),
      };
    }
    _LoadFromJson(d) {
      d &&
        e.TimelineDataManager._LoadDataItemsFromJson(
          this._addonDataItems,
          d.addonDataItemsJson,
          {
            prop: "id",
            map: new Map([
              ["cubic-bezier", a],
              ["angle", c],
            ]),
          },
          this
        );
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  let b = 0;
  e.TweenState = class extends e.TimelineState {
    constructor(a, c) {
      super(`tween-${b++}`, a, c);
      this._id = "";
      this._destroyInstanceOnComplete = !1;
      this._initialValueMode = "start-value";
      this._track =
        this._on_started_callbacks =
        this._on_completed_callbacks =
        this._instance =
          null;
    }
    CreateTrackStates() {
      for (const a of this._timelineDataItem.GetTrackData().trackDataItems())
        this._tracks.push(e.TweenTrackState.Create(this, a));
      this._track = this._tracks[0];
    }
    AddTrack() {
      var a = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem();
      a = e.TweenTrackState.Create(this, a);
      this._tracks.push(a);
      this._track = this._tracks[0];
      return a;
    }
    GetPropertyTrack(a) {
      return this._track.GetPropertyTracks()[0];
    }
    SetPropertyType(a) {
      this._propertyType = a;
    }
    GetInstance() {
      var a = this.GetTracks();
      if (a && a.length && (this._track = a = a[0])) {
        var c = a.GetInstance();
        return a.IsInstanceValid() ? c : void 0;
      }
    }
    AddStartedCallback(a) {
      this._on_started_callbacks || (this._on_started_callbacks = []);
      this._on_started_callbacks.push(a);
    }
    AddCompletedCallback(a) {
      this._on_completed_callbacks || (this._on_completed_callbacks = []);
      this._on_completed_callbacks.push(a);
    }
    RemoveStartedCallback(a) {
      this._on_started_callbacks &&
        ((a = this._on_started_callbacks.indexOf(a)),
        -1 !== a && this._on_started_callbacks.splice(a, 1));
    }
    RemoveCompletedCallback(a) {
      this._on_completed_callbacks &&
        ((a = this._on_completed_callbacks.indexOf(a)),
        -1 !== a && this._on_completed_callbacks.splice(a, 1));
    }
    SetStartValue(a, c) {
      for (const f of this._tracks)
        for (const h of f._propertyTracks) {
          if (h.GetPropertyName() !== c) continue;
          var d = h.GetPropertyTrackData();
          const g = h.GetPropertyTrackDataItem();
          d = d.GetFirstPropertyKeyframeDataItem(g);
          d.SetValue(a);
          d.SetAbsoluteValue(a);
        }
    }
    _GetPropertyTrackState(a) {
      for (const c of this._tracks)
        for (const d of c._propertyTracks)
          if (d.GetPropertyName() === a) return d;
    }
    BeforeSetEndValues(a) {
      for (const f of a)
        (a = this._GetPropertyTrackState(f)),
          this.SetStartValue(a.GetCurrentState(), f);
      if (this.IsForwardPlayBack()) {
        var c = this.GetTotalTime() - this.GetTime();
        this.SetTotalTime(c);
        for (var d of this._tracks) d.SetLocalTotalTime(c);
        this._SetTime(0);
      } else {
        d = this.GetTime();
        this.SetTotalTime(d);
        for (c of this._tracks) c.SetLocalTotalTime(d);
        this._SetTime(d);
      }
      this.SetInitialStateFromSetTime();
    }
    SetEndValue(a, c) {
      var d = this._GetPropertyTrackState(c);
      c = d.GetPropertyTrackData();
      d = d.GetPropertyTrackDataItem();
      c = c.GetLastPropertyKeyframeDataItem(d);
      c.SetTime(this.GetTotalTime());
      c.SetValue(a);
      c.SetAbsoluteValue(a);
    }
    SetId(a) {
      this._id = a;
    }
    GetId() {
      return this._id;
    }
    SetInitialValueMode(a) {
      this._initialValueMode = a;
    }
    GetInitialValueMode() {
      return this._initialValueMode;
    }
    SetDestroyInstanceOnComplete(a) {
      this._destroyInstanceOnComplete = a;
    }
    GetDestroyInstanceOnComplete() {
      return this._destroyInstanceOnComplete;
    }
    OnStarted() {
      if (this._on_started_callbacks)
        for (const a of this._on_started_callbacks) a(this);
      if (!this.IsComplete())
        for (const a of this._tracks) a.CompareSaveStateWithCurrent();
    }
    OnCompleted() {
      this._completedTick = this._runtime.GetTickCount();
    }
    FinishTriggers() {
      if (
        !this._finishedTriggers &&
        ((this._finishedTriggers = !0), this._on_completed_callbacks)
      )
        for (const a of this._on_completed_callbacks) a(this);
    }
    SetTime(a) {
      this._DeleteIntermediateKeyframes();
      super.SetTime(a);
    }
    _SetTimeAndReset(a) {
      e.IsFiniteNumber(a) || (a = this.GetTotalTime());
      0 > a
        ? (this._playheadTime = 0)
        : a >= this.GetTotalTime()
        ? (this._playheadTime = this.GetTotalTime())
        : (this._playheadTime = a);
      this._track.SetResetState();
    }
    SetInitialState(a) {
      if (
        !this.InitialStateSet() &&
        "current-state" === this.GetInitialValueMode()
      )
        for (const c of this._tracks) c.CompareInitialStateWithCurrent();
      super.SetInitialState(a);
    }
    Stop(a = !1) {
      super.Stop(a);
      if (!this.IsComplete()) for (const c of this._tracks) c.SaveState();
    }
    Reset(a = !0, c = !1) {
      this._DeleteIntermediateKeyframes();
      super.Reset(a, c);
    }
    _DeleteIntermediateKeyframes() {
      for (const a of this._tracks) {
        const c = (d) => {
          d = d.GetTime();
          const f = this.GetTotalTime();
          return 0 !== d && d !== f;
        };
        a.DeleteKeyframes(c);
        a.DeletePropertyKeyframes(c);
      }
    }
    _OnBeforeChangeLayout() {
      if (this.IsReleased()) return !0;
      const a = this.GetInstance();
      if (a && a.GetObjectClass().IsGlobal()) return !1;
      this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this);
      this.ResetBeforeChangeLayout();
      return !0;
    }
    Tick(a, c, d) {
      this._instance || (this._instance = this.GetInstance());
      if (!this._instance || this._instance.IsDestroyed())
        this.Stop(!0), this.OnCompleted();
      else if (
        ((c = this._instance.GetTimeScale()),
        -1 !== c && (a = d * c),
        0 !== a || 0 !== this._lastDelta)
      ) {
        this._lastDelta = a;
        d = this._playheadTime + a * this._playbackRate;
        a = this._timelineDataItem._totalTime;
        this._playheadTime = 0 > d ? 0 : d >= a ? a : d;
        c = d = !1;
        var f = this.GetLoop(),
          h = this.GetPingPong();
        f || h
          ? f && !h
            ? 0 < this._playbackRate
              ? this._playheadTime >= a && (this._SetTimeAndReset(0), (c = !0))
              : 0 >= this._playheadTime && (this._SetTimeAndReset(a), (c = !0))
            : !f && h
            ? 0 < this._playbackRate
              ? this._playheadTime >= a &&
                (this._SetTime(a),
                this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
                (c = !0),
                1 === this._pingPongState
                  ? this._currentRepeatCount < this.GetRepeatCount()
                    ? (this._currentRepeatCount++, (this._pingPongState = 0))
                    : (d = !0)
                  : 0 === this._pingPongState && (this._pingPongState = 1))
              : 0 >= this._playheadTime &&
                (this._SetTime(0),
                this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
                (c = !0),
                1 === this._pingPongState
                  ? this._currentRepeatCount < this.GetRepeatCount()
                    ? (this._currentRepeatCount++, (this._pingPongState = 0))
                    : (d = !0)
                  : 0 === this._pingPongState && (this._pingPongState = 1))
            : f &&
              h &&
              (0 < this._playbackRate
                ? this._playheadTime >= a &&
                  (this._SetTime(a),
                  this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
                  (c = !0))
                : 0 >= this._playheadTime &&
                  (this._SetTime(0),
                  this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
                  (c = !0)))
          : 0 < this._playbackRate
          ? this._playheadTime >= a &&
            (this._currentRepeatCount < this.GetRepeatCount()
              ? (this._currentRepeatCount++, this._SetTimeAndReset(0), (c = !0))
              : (this._SetTime(a), (d = !0)))
          : 0 >= this._playheadTime &&
            (this._currentRepeatCount < this.GetRepeatCount()
              ? (this._currentRepeatCount++, this._SetTimeAndReset(a), (c = !0))
              : (this._SetTime(0), (d = !0)));
        d
          ? (this._track.SetEndState(), this.Stop(!0), this.OnCompleted())
          : (this._track.Interpolate(
              this._playheadTime,
              !0,
              !1,
              c,
              this._firstTick,
              !1
            ),
            this._firstTick && (this._firstTick = !1));
      }
    }
    _SaveToJson() {
      const a = super._SaveToJson(),
        c = this.GetTimelineDataItem();
      return Object.assign(a, {
        tweenDataItemJson: c._SaveToJson(),
        id: this._id,
        destroyInstanceOnComplete: this._destroyInstanceOnComplete,
        initialValueMode: this._initialValueMode,
      });
    }
    _LoadFromJson(a) {
      a &&
        (this.GetTimelineDataItem()._LoadFromJson(a.tweenDataItemJson),
        super._LoadFromJson(a),
        (this._id = a.id),
        (this._destroyInstanceOnComplete = a.destroyInstanceOnComplete),
        (this._initialValueMode = a.initialValueMode));
    }
    static IsPlaying(a) {
      return a.IsPlaying();
    }
    static IsPaused(a) {
      return a.IsPaused();
    }
    static Build(a) {
      var c = a.runtime.GetTimelineManager(),
        d = new e.TimelineDataItem();
      if (a.json) {
        d._LoadFromJson(a.json.tweenDataItemJson);
        var f = new e.TweenState(d, c);
        f._LoadFromJson(a.json);
        return f;
      }
      c = new e.TweenState(d, c);
      e.IsArray(a.propertyTracksConfig) ||
        (a.propertyTracksConfig = [a.propertyTracksConfig]);
      c.SetId(a.id);
      c.SetTags(a.tags);
      c.SetInitialValueMode(a.initialValueMode);
      c.SetDestroyInstanceOnComplete(a.releaseOnComplete);
      c.SetLoop(a.loop);
      c.SetPingPong(a.pingPong);
      c.SetTotalTime(a.time);
      c.SetStep(0);
      c.SetInterpolationMode("default");
      c.SetResultMode(a.propertyTracksConfig[0].resultMode);
      d = c.AddTrack();
      d.SetInstanceUID(a.instance.GetUID());
      d.SetInterpolationMode("default");
      d.SetResultMode(a.propertyTracksConfig[0].resultMode);
      d.SetEnable(!0);
      d.SetObjectClassIndex(a.instance.GetObjectClass().GetIndex());
      var h = a.instance.GetSdkInstance(),
        g = h.IsOriginalSizeKnown()
          ? h.GetOriginalWidth()
          : a.instance.GetWorldInfo().GetWidth();
      h = h.IsOriginalSizeKnown()
        ? h.GetOriginalHeight()
        : a.instance.GetWorldInfo().GetHeight();
      d.SetOriginalWidth(g);
      d.SetOriginalHeight(h);
      g = d.AddKeyframe();
      g.SetTime(0);
      g.SetEase("noease");
      g.SetEnable(!0);
      g.SetTags("");
      g = d.AddKeyframe();
      g.SetTime(a.time);
      g.SetEase("noease");
      g.SetEnable(!0);
      g.SetTags("");
      for (f of a.propertyTracksConfig)
        (g = d.AddPropertyTrack()),
          g.SetSourceAdapterId(f.sourceId),
          g.SetSourceAdapterArgs(f.sourceArgs),
          g.SetPropertyName(f.property),
          g.SetPropertyType(f.type),
          g.SetMin(NaN),
          g.SetMax(NaN),
          g.SetInterpolationMode("default"),
          g.SetResultMode(f.resultMode),
          g.SetEnable(!0),
          (h = g.AddPropertyKeyframe()),
          h.SetType(f.valueType),
          h.SetTime(0),
          h.SetEase(f.ease),
          h.SetEnable(!0),
          h.SetValue(f.startValue),
          h.SetAbsoluteValue(f.startValue),
          (h = g.AddPropertyKeyframe()),
          h.SetType(f.valueType),
          h.SetTime(a.time),
          h.SetEase(f.ease),
          h.SetEnable(!0),
          h.SetValue(f.endValue),
          h.SetAbsoluteValue(f.endValue),
          g.GetSourceAdapter();
      return c;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.TweenTrackState = class extends e.TrackState {
    constructor(b, a) {
      super(b, a);
      this._secondPropertyTrack = this._firstPropertyTrack = null;
    }
    static Create(b, a) {
      return e.New(e.TweenTrackState, b, a);
    }
    _CachePropertyTracks() {
      1 === this._propertyTracks.length
        ? (this._firstPropertyTrack = this._propertyTracks[0])
        : ((this._firstPropertyTrack = this._propertyTracks[0]),
          (this._secondPropertyTrack = this._propertyTracks[1]));
    }
    CreatePropertyTrackStates() {
      for (const b of this._trackDataItem
        .GetPropertyTrackData()
        .propertyTrackDataItems())
        this._propertyTracks.push(e.TweenPropertyTrackState.Create(this, b));
      this._CachePropertyTracks();
    }
    AddPropertyTrack() {
      var b = this._trackDataItem
        .GetPropertyTrackData()
        .AddEmptyPropertyTrackDataItem();
      b = e.TweenPropertyTrackState.Create(this, b);
      this._propertyTracks.push(b);
      this._CachePropertyTracks();
      return b;
    }
    SetInitialState() {
      this.MaybeGetInstance();
      if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
        var b = this.GetTimeline().IsForwardPlayBack()
          ? 0
          : this.GetLocalTotalTime();
        for (const a of this._propertyTracks)
          a.SetInitialState(b),
            0 === this._worldInfoChange &&
              1 === a.GetWorldInfoChange() &&
              (this._worldInfoChange = 1),
            0 === this._renderChange &&
              1 === a.GetRenderChange() &&
              (this._renderChange = 1);
        this._needsBeforeAndAfter = 0;
        this._propertyTracks.some((a) => a.GetNeedsBeforeAndAfter()) &&
          (this._needsBeforeAndAfter = 1);
        this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(b);
        this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
        this.Interpolate(b);
      }
    }
    BeforeInterpolate() {}
    Interpolate(b, a, c = !1, d = !1, f, h = !1) {
      this._instance || this.GetInstance();
      if (this._instance) {
        if (
          this._instance.IsDestroyed() ||
          (h && this.GetObjectClass().IsGlobal())
        )
          return !1;
        this._secondPropertyTrack
          ? (this._firstPropertyTrack.Interpolate(b, c, d),
            this._secondPropertyTrack.Interpolate(b, c, d))
          : this._firstPropertyTrack.Interpolate(b, c, d);
        0 !== this._firstPropertyTrack.GetWorldInfoChange() &&
          (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()),
          this._worldInfo && this._worldInfo.SetBboxChanged());
      }
    }
    AfterInterpolate() {}
    _LoadFromJson(b) {
      super._LoadFromJson(b);
      this._CachePropertyTracks();
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.TweenPropertyTrackState = class extends e.PropertyTrackState {
    constructor(b, a) {
      super(b, a);
      this._basic = !1;
    }
    static Create(b, a) {
      return e.New(e.TweenPropertyTrackState, b, a);
    }
    Interpolate(b, a = !1, c = !1) {
      if (this._basic) {
        var d = this._propertyKeyframeDataItems[0];
        var f = this._propertyKeyframeDataItems[1];
      } else {
        if (a)
          d =
            this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(
              b,
              this._propertyTrackDataItem
            );
        else {
          if (this._lastPropertyKeyframeDataItem) {
            f = this.GetTimeline();
            const h = this._lastPropertyKeyframeDataItem.GetNext();
            d = this._lastPropertyKeyframeDataItem.GetTime();
            f = h ? h.GetTime() : f.GetTotalTime();
            if (b <= d || b >= f)
              this._lastPropertyKeyframeDataItem =
                this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(
                  b,
                  this._propertyTrackDataItem
                );
          } else
            this._lastPropertyKeyframeDataItem =
              this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(
                b,
                this._propertyTrackDataItem
              );
          d = this._lastPropertyKeyframeDataItem;
        }
        f = d.GetNext();
      }
      this._sourceAdapter.Interpolate(b, d, f, a, c);
    }
    AddPropertyKeyframe() {
      const b = this._propertyTrackDataItem
        .GetPropertyKeyframeData()
        .AddEmptyPropertyKeyframeDataItem();
      this._lastPropertyKeyframeDataItem = null;
      this._basic = 2 >= this.GetPropertyKeyframeDataItems().length;
      return b;
    }
    DeletePropertyKeyframes(b) {
      this._lastPropertyKeyframeDataItem = null;
      this._propertyTrackDataItem
        .GetPropertyKeyframeData()
        .DeletePropertyKeyframeDataItems(b);
      this._basic = 2 >= this.GetPropertyKeyframeDataItems().length;
    }
    _SaveToJson() {
      return {
        sourceAdapterJson: this.GetSourceAdapter()._SaveToJson(),
        basic: this._basic,
      };
    }
    _LoadFromJson(b) {
      b &&
        (this.GetSourceAdapter()._LoadFromJson(b.sourceAdapterJson),
        (this._basic = b.basic));
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.Ease;
  e.Transition = class extends e.DefendedBase {
    constructor(a) {
      super();
      this._name = a[0];
      this._transitionKeyframes = [];
      for (var c of a[1])
        (a = e.TransitionKeyframe.Create(this, c)),
          this._transitionKeyframes.push(a);
      for (c = 0; c < this._transitionKeyframes.length; c++)
        this._transitionKeyframes[c].SetNext(this._transitionKeyframes[c + 1]);
      this._precalculatedSamples = new Map();
      this._transitionKeyframeCache = new Map();
      this._PreCalcSamples();
      b.AddCustomEase(this._name, (d, f, h, g) => this.Interpolate(d, f, h, g));
    }
    static Create(a) {
      return e.New(e.Transition, a);
    }
    Release() {
      for (const a of this._transitionKeyframes) a.Release();
      e.clearArray(this._transitionKeyframes);
      this._transitionKeyframes = null;
      this._precalculatedSamples.clear();
      this._precalculatedSamples = null;
      this._transitionKeyframeCache.clear();
      this._transitionKeyframeCache = null;
    }
    GetTransitionKeyFrameAt(a) {
      const c = this._transitionKeyframeCache.get(a);
      if (c) return c;
      for (const d of this._transitionKeyframes)
        if (d.GetValueX() === a)
          return this._transitionKeyframeCache.set(a, d), d;
    }
    GetFirstTransitionKeyFrameHigherThan(a) {
      for (const c of this._transitionKeyframes)
        if (c.GetValueX() > a) return c;
    }
    GetFirstTransitionKeyFrameHigherOrEqualThan(a) {
      for (const c of this._transitionKeyframes)
        if (c.GetValueX() >= a) return c;
    }
    GetFirstTransitionKeyFrameLowerThan(a) {
      for (let c = this._transitionKeyframes.length - 1; 0 <= c; c--) {
        const d = this._transitionKeyframes[c];
        if (d.GetValueX() < a) return d;
      }
    }
    GetFirstTransitionKeyFrameLowerOrEqualThan(a) {
      for (let c = this._transitionKeyframes.length - 1; 0 <= c; c--) {
        const d = this._transitionKeyframes[c];
        if (d.GetValueX() <= a) return d;
      }
    }
    Interpolate(a, c, d, f) {
      var h = a / f;
      a = this.GetFirstTransitionKeyFrameLowerOrEqualThan(h);
      f = a.GetNext();
      f ||
        ((a = this.GetFirstTransitionKeyFrameLowerThan(h)), (f = a.GetNext()));
      var g = f.GetValueX() - a.GetValueX();
      h = e.mapToRange(h, a.GetValueX(), f.GetValueX(), 0, g);
      g = a.GetValueX();
      const k = a.GetValueY(),
        m = a.GetValueX() + a.GetStartAnchorX(),
        q = a.GetValueY() + a.GetStartAnchorY(),
        v = f.GetValueX() + f.GetEndAnchorX(),
        r = f.GetValueY() + f.GetEndAnchorY(),
        n = f.GetValueX();
      f = f.GetValueY();
      f = b.GetRuntimeEase("spline")(
        h,
        g,
        k,
        m,
        q,
        v,
        r,
        n,
        f,
        this._precalculatedSamples.get(a)
      );
      f += a.GetValueY();
      return (1 - f) * c + f * (c + d);
    }
    _PreCalcSamples() {
      this._precalculatedSamples.clear();
      for (let d = 0; d < this._transitionKeyframes.length - 1; d++) {
        var a = this._transitionKeyframes[d];
        if (!a.GetStartEnable()) continue;
        var c = this._transitionKeyframes[d + 1];
        const f = a.GetValueX(),
          h = a.GetValueX() + a.GetStartAnchorX(),
          g = c.GetValueX() + c.GetEndAnchorX();
        c = c.GetValueX();
        this._precalculatedSamples.set(a, b.GetBezierSamples(f, h, g, c));
      }
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.TransitionKeyframe = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._transition = b;
      this._valueX = a[0];
      this._valueY = a[1];
      this._startAnchorX = a[2];
      this._startAnchorY = a[3];
      this._endAnchorX = a[4];
      this._endAnchorY = a[5];
      this._startEnable = a[6];
      this._endEnable = a[7];
      this._next = null;
    }
    Release() {
      this._transition = null;
    }
    static Create(b, a) {
      return e.New(e.TransitionKeyframe, b, a);
    }
    SetNext(b) {
      this._next = b;
    }
    GetNext() {
      return this._next;
    }
    GetValueX() {
      return this._valueX;
    }
    GetValueY() {
      return this._valueY;
    }
    GetStartAnchorX() {
      return this._startAnchorX;
    }
    GetStartAnchorY() {
      return this._startAnchorY;
    }
    GetEndAnchorX() {
      return this._endAnchorX;
    }
    GetEndAnchorY() {
      return this._endAnchorY;
    }
    GetStartEnable() {
      return this._startEnable;
    }
    GetEndEnable() {
      return this._endEnable;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.TransitionManager = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._runtime = b;
      this._transitions = [];
    }
    Release() {
      for (const b of this._transitions) b.Release();
      e.clearArray(this._transitions);
      this._transitions = null;
    }
    Create(b) {
      this._transitions.push(e.Transition.Create(b));
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.TemplateManager = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._runtime = b;
      this._templateDataMap = null;
    }
    Release() {
      if (this._templateDataMap) {
        for (const b of this._templateDataMap.values()) b.clear();
        this._templateDataMap.clear();
      }
      this._runtime = this._templateDataMap = null;
    }
    Create(b) {
      this._templateDataMap || (this._templateDataMap = new Map());
      if (b) {
        var a = b[0][16][0],
          c = b[1];
        this._templateDataMap.has(c) || this._templateDataMap.set(c, new Map());
        this._templateDataMap.get(c).set(a, b);
      }
    }
    HasTemplates() {
      return this._templateDataMap ? 0 !== this._templateDataMap.size : !1;
    }
    GetTemplateData(b, a) {
      b = b instanceof e.ObjectClass ? b.GetIndex() : b;
      if (
        this._templateDataMap.has(b) &&
        (a = this._templateDataMap.get(b).get(a))
      )
        return JSON.parse(JSON.stringify(a));
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.SolStack = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._objectClass = b;
      this._stack = [];
      this._stack.push(e.New(e.Sol, this));
      this._index = 0;
      this._current = this._stack[0];
    }
    Release() {
      for (const b of this._stack) b.Release();
      e.clearArray(this._stack);
      this._objectClass = this._current = null;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetCurrentSol() {
      return this._current;
    }
    Clear() {
      this.GetCurrentSol().Clear();
    }
    PushClean() {
      var b = this._stack,
        a = ++this._index;
      a === b.length
        ? ((a = e.New(e.Sol, this)), b.push(a), (this._current = a))
        : ((b = b[a]), b.Reset(), (this._current = b));
    }
    PushCopy() {
      const b = this._stack,
        a = ++this._index;
      a === b.length && b.push(e.New(e.Sol, this));
      const c = b[a];
      c.Copy(b[a - 1]);
      this._current = c;
    }
    Pop() {
      this._current = this._stack[--this._index];
    }
    RemoveInstances(b) {
      const a = this._stack;
      for (let c = 0, d = a.length; c < d; ++c) a[c].RemoveInstances(b);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Sol = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._stack = b;
      this._objectClass = this._stack.GetObjectClass();
      this._eventStack = this._objectClass.GetRuntime().GetEventStack();
      this._selectAll = !0;
      this._instances = [];
      this._elseInstances = [];
    }
    Release() {
      this.ClearArrays();
      this._eventStack = this._objectClass = this._stack = null;
    }
    ClearArrays() {
      e.clearArray(this._instances);
      e.clearArray(this._elseInstances);
    }
    GetObjectClass() {
      return this._objectClass;
    }
    IsSelectAll() {
      return this._selectAll;
    }
    HasAnyInstances() {
      return this._selectAll
        ? !!this._objectClass.GetInstanceCount()
        : !!this._instances.length;
    }
    GetInstances() {
      return this._selectAll
        ? this._objectClass.GetInstances()
        : this._instances;
    }
    HasAnyElseInstances() {
      return !!this._elseInstances.length;
    }
    GetElseInstances() {
      return this._elseInstances;
    }
    GetExpressionInstances() {
      const b = this.GetInstances();
      return b.length ? b : this._elseInstances;
    }
    Reset() {
      this._selectAll = !0;
      e.clearArray(this._elseInstances);
    }
    Clear() {
      this._selectAll = !0;
    }
    Copy(b) {
      b.IsSelectAll()
        ? this.Reset()
        : ((this._selectAll = !1),
          e.shallowAssignArray(this._instances, b._instances),
          e.clearArray(this._elseInstances));
    }
    _PushInstance(b) {
      this._instances.push(b);
    }
    _PushElseInstance(b) {
      this._elseInstances.push(b);
    }
    _SetSelectAll(b) {
      this._selectAll = !!b;
    }
    _GetOwnInstances() {
      return this._instances;
    }
    _GetOwnElseInstances() {
      return this._elseInstances;
    }
    SetSinglePicked(b) {
      this._selectAll = !1;
      e.clearArray(this._instances);
      this._instances.push(b);
    }
    SetArrayPicked(b) {
      this._selectAll = !1;
      e.shallowAssignArray(this._instances, b);
    }
    SetSetPicked(b) {
      this._selectAll = !1;
      e.clearArray(this._instances);
      for (const a of b) this._instances.push(a);
    }
    AddElseInstances(b, a) {
      for (const c of a) b.has(c) || this._elseInstances.push(c);
    }
    TransferElseInstancesToOwn(b) {
      for (const a of b) this._instances.push(a);
      e.arrayRemoveAllInSet(this._elseInstances, b);
    }
    PickOne(b) {
      b &&
        (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock()
          ? (this.IsSelectAll() &&
              (e.clearArray(this._instances),
              e.shallowAssignArray(
                this._elseInstances,
                b.GetObjectClass().GetInstances()
              ),
              (this._selectAll = !1)),
            (b = this._elseInstances.indexOf(b)),
            -1 !== b &&
              (this._instances.push(this._elseInstances[b]),
              this._elseInstances.splice(b, 1)))
          : this.SetSinglePicked(b));
    }
    RemoveInstances(b) {
      e.arrayRemoveAllInSet(this._instances, b);
      e.arrayRemoveAllInSet(this._elseInstances, b);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.EventStack = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._eventSheetManager = b;
      this._runtime = this._eventSheetManager.GetRuntime();
      this._stack = [];
      this._stack.push(e.New(e.EventStackFrame, this, null));
      this._index = 0;
      this._expFuncStack = [];
    }
    Release() {
      for (const b of this._stack) b.Release();
      e.clearArray(this._stack);
      e.clearArray(this._expFuncStack);
      this._runtime = this._eventSheetManager = null;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetCurrentStackFrame() {
      return this._stack[this._index];
    }
    Push(b) {
      var a = this._stack;
      const c = ++this._index;
      if (c === a.length)
        return (b = e.New(e.EventStackFrame, this, b)), a.push(b), b;
      a = a[c];
      a.Reset(b);
      return a;
    }
    Pop() {
      --this._index;
    }
    PushExpFunc(b) {
      this._expFuncStack.push(b);
    }
    PopExpFunc() {
      this._expFuncStack.pop();
    }
    GetCurrentExpFuncStackFrame() {
      const b = this._expFuncStack;
      return 0 === b.length ? null : b.at(-1);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.EventStackFrame = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._stack = b;
      this._runtime = this._stack.GetRuntime();
      this._currentEvent = a;
      this._actIndex = this._cndIndex = 0;
      this._elseBranchRan = this._lastEventTrue = !1;
      this._expressionObjectClass = null;
      this._functionReturnValue = this._functionReturnType = 0;
    }
    Release() {
      this.Reset(null);
      this._runtime = this._stack = null;
    }
    Reset(b) {
      this._currentEvent = b;
      this._actIndex = this._cndIndex = 0;
      this._elseBranchRan = this._lastEventTrue = !1;
    }
    _Restore(b, a) {
      this._currentEvent = b;
      this._cndIndex = 0;
      this._actIndex = a;
    }
    ResetQuick() {
      this._actIndex = this._cndIndex = 0;
    }
    GetCurrentEvent() {
      return this._currentEvent;
    }
    SetCurrentEvent(b) {
      this._currentEvent = b;
    }
    GetConditionIndex() {
      return this._cndIndex;
    }
    SetConditionIndex(b) {
      this._cndIndex = b;
    }
    GetActionIndex() {
      return this._actIndex;
    }
    SetActionIndex(b) {
      this._actIndex = b;
    }
    SetLastEventTrue(b) {
      this._lastEventTrue = !!b;
    }
    GetLastEventTrue() {
      return this._lastEventTrue;
    }
    SetElseBranchRan(b) {
      this._elseBranchRan = !!b;
    }
    GetElseBranchRan() {
      return this._elseBranchRan;
    }
    SetExpressionObjectClass(b) {
      this._expressionObjectClass = b;
    }
    GetExpressionObjectClass() {
      return this._expressionObjectClass;
    }
    InitCallFunctionExpression(b, a) {
      this._functionReturnType = b;
      this._functionReturnValue = a;
    }
    GetFunctionReturnType() {
      return this._functionReturnType;
    }
    SetFunctionReturnValue(b) {
      this._functionReturnValue = b;
    }
    GetFunctionReturnValue() {
      return this._functionReturnValue;
    }
    IsSolModifierAfterCnds() {
      const b = this._currentEvent;
      return b.IsSolWriterAfterCnds()
        ? !0
        : this._cndIndex < b.GetConditionCount() - 1
        ? !!b.GetSolModifiers().length
        : !1;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.LocalVarStack = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._eventSheetManager = b;
      this._runtime = this._eventSheetManager.GetRuntime();
      this._stack = [];
      this._index = -1;
      this._current = null;
      this._initialValues = [];
    }
    Release() {
      e.clearArray(this._stack);
      this._runtime = this._eventSheetManager = null;
    }
    _SetInitialValues(b) {
      this._initialValues = b;
      b = this._initialValues.slice(0);
      this._stack.push(b);
      this._index = 0;
      this._current = b;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetCurrent() {
      return this._current;
    }
    Push() {
      const b = ++this._index,
        a = this._stack;
      b === a.length
        ? a.push(this._initialValues.slice(0))
        : e.shallowAssignArray(a[b], this._initialValues);
      this._current = a[b];
    }
    Pop() {
      this._current = this._stack[--this._index];
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.LoopStack = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._eventSheetManager = b;
      this._runtime = this._eventSheetManager.GetRuntime();
      this._stack = [];
      this._index = -1;
    }
    Release() {
      e.clearArray(this._stack);
      this._runtime = this._eventSheetManager = null;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    IsInLoop() {
      return 0 <= this._index;
    }
    GetCurrent() {
      return this._stack[this._index];
    }
    Push() {
      ++this._index;
      if (this._index === this._stack.length) {
        var b = e.New(e.Loop, this);
        this._stack.push(b);
        return b;
      }
      b = this._stack[this._index];
      b.Reset();
      return b;
    }
    Pop() {
      --this._index;
    }
    FindByName(b) {
      const a = this._stack;
      for (let c = this._index; 0 <= c; --c) {
        const d = a[c];
        if (d.GetName() === b) return d;
      }
      return null;
    }
    _GetStack() {
      return this._stack.slice(0, this._index + 1);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Loop = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._loopStack = b;
      this._name = "";
      this._index = 0;
      this._isStopped = !1;
      this._end = NaN;
    }
    Reset() {
      this._name = "";
      this._index = 0;
      this._isStopped = !1;
      this._end = NaN;
    }
    SetName(b) {
      this._name = b;
    }
    GetName() {
      return this._name;
    }
    SetIndex(b) {
      this._index = b;
    }
    GetIndex() {
      return this._index;
    }
    Stop() {
      this._isStopped = !0;
    }
    IsStopped() {
      return this._isStopped;
    }
    SetEnd(b) {
      this._end = b;
    }
    GetEnd() {
      return this._end;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.ArrayStack = class extends e.DefendedBase {
    constructor() {
      super();
      this._stack = [];
      this._index = -1;
    }
    Release() {
      e.clearArray(this._stack);
    }
    GetCurrent() {
      return this._stack[this._index];
    }
    Push() {
      ++this._index;
      if (this._index === this._stack.length) {
        const b = [];
        this._stack.push(b);
        return b;
      }
      return this._stack[this._index];
    }
    Pop() {
      --this._index;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  function b(c, d) {
    return c.GetIndex() - d.GetIndex();
  }
  function a(c, d) {
    for (let f = 0, h = c.length; f < h; ++f) if (c[f] !== d[f]) return !1;
    return !0;
  }
  e.EventSheetManager = class extends e.DefendedBase {
    constructor(c) {
      super();
      this._runtime = c;
      this._allSheets = [];
      this._sheetsByName = new Map();
      this._allGroups = [];
      this._groupsByName = new Map();
      this._blocksBySid = new Map();
      this._cndsBySid = new Map();
      this._actsBySid = new Map();
      this._allUniqueSolModifiers = new Map();
      this._eventVarsBySid = new Map();
      this._nextLocalVarIndex = 0;
      this._allGlobalVars = [];
      this._allLocalVars = [];
      this._localVarInitialValues = [];
      this._functionBlocksByName = new Map();
      this._eventStack = e.New(e.EventStack, this);
      this._localVarStack = e.New(e.LocalVarStack, this);
      this._loopStack = e.New(e.LoopStack, this);
      this._triggersToPostInit = [];
      this._queuedTriggers = [];
      this._queuedDebugTriggers = [];
      this._blockFlushingDepth =
        this._executingTriggerDepth =
        this._runningEventsDepth =
          0;
      this._scheduledWaits = [];
      this._asyncActionPromises = [];
      self.c3_callFunction = (d, f) => this._InvokeFunctionFromJS(d, f);
    }
    Release() {
      this.ClearAllScheduledWaits();
      this._eventStack.Release();
      this._eventStack = null;
      this._localVarStack.Release();
      this._localVarStack = null;
      e.clearArray(this._queuedTriggers);
      e.clearArray(this._queuedDebugTriggers);
      this._runtime = null;
      e.clearArray(this._allSheets);
      this._sheetsByName.clear();
    }
    Create(c) {
      c = e.New(e.EventSheet, this, c);
      this._allSheets.push(c);
      this._sheetsByName.set(c.GetName().toLowerCase(), c);
    }
    _AddTriggerToPostInit(c) {
      this._triggersToPostInit.push(c);
    }
    _PostInit() {
      for (const c of this._functionBlocksByName.values()) c._PostInit(!1);
      for (const c of this._allSheets) c._PostInit();
      for (const c of this._allSheets) c._UpdateDeepIncludes();
      for (const c of this._triggersToPostInit) c._PostInit(!1);
      e.clearArray(this._triggersToPostInit);
      this._localVarStack._SetInitialValues(this._localVarInitialValues);
    }
    GetRuntime() {
      return this._runtime;
    }
    GetEventSheetByName(c) {
      return this._sheetsByName.get(c.toLowerCase()) || null;
    }
    _RegisterGroup(c) {
      this._allGroups.push(c);
      this._groupsByName.set(c.GetGroupName(), c);
    }
    _RegisterEventBlock(c) {
      this._blocksBySid.set(c.GetSID(), c);
    }
    _RegisterCondition(c) {
      this._cndsBySid.set(c.GetSID(), c);
    }
    _RegisterAction(c) {
      this._actsBySid.set(c.GetSID(), c);
    }
    _RegisterFunctionBlock(c) {
      this._functionBlocksByName.set(c.GetFunctionName().toLowerCase(), c);
    }
    _RegisterEventVariable(c) {
      this._eventVarsBySid.set(c.GetSID(), c);
      c.IsGlobal() ? this._allGlobalVars.push(c) : this._allLocalVars.push(c);
    }
    _DeduplicateSolModifierList(c) {
      2 <= c.length && c.sort(b);
      let d = this._allUniqueSolModifiers.get(c.length);
      d || ((d = []), this._allUniqueSolModifiers.set(c.length, d));
      for (let f = 0, h = d.length; f < h; ++f) {
        const g = d[f];
        if (a(c, g)) return g;
      }
      d.push(c);
      return c;
    }
    _GetNextLocalVarIndex(c) {
      this._localVarInitialValues.push(c.GetInitialValue());
      return this._nextLocalVarIndex++;
    }
    GetEventStack() {
      return this._eventStack;
    }
    GetCurrentEventStackFrame() {
      return this.GetEventStack().GetCurrentStackFrame();
    }
    GetCurrentEvent() {
      return this.GetCurrentEventStackFrame().GetCurrentEvent();
    }
    GetCurrentCondition() {
      const c = this.GetCurrentEventStackFrame();
      return c.GetCurrentEvent().GetConditionAt(c.GetConditionIndex());
    }
    GetCurrentAction() {
      const c = this.GetCurrentEventStackFrame();
      return c.GetCurrentEvent().GetActionAt(c.GetActionIndex());
    }
    GetLocalVarStack() {
      return this._localVarStack;
    }
    GetLoopStack() {
      return this._loopStack;
    }
    GetAllLocalVariablesInScope(c) {
      const d = [];
      for (c = c.GetScopeParent(); c; )
        e.appendArray(d, c._GetAllLocalVariablesInScope()),
          (c = c.GetScopeParent());
      return d;
    }
    _GetLocalVariablesScriptInterface(c) {
      const d = {};
      for (const f of this.GetAllLocalVariablesInScope(c))
        d[f.GetJsPropName()] = f._GetScriptInterfaceDescriptor();
      return Object.create(Object.prototype, d);
    }
    GetEventVariableBySID(c) {
      return this._eventVarsBySid.get(c) || null;
    }
    GetEventBlockBySID(c) {
      return this._blocksBySid.get(c) || null;
    }
    GetConditionBySID(c) {
      return this._cndsBySid.get(c) || null;
    }
    GetActionBySID(c) {
      return this._actsBySid.get(c) || null;
    }
    GetFunctionBlockByName(c) {
      return this._functionBlocksByName.get(c.toLowerCase()) || null;
    }
    GetAllGlobalVariables() {
      return this._allGlobalVars;
    }
    GetAllLocalVariables() {
      return this._allLocalVars;
    }
    ResetAllGlobalsToInitialValue() {
      for (const c of this._allGlobalVars) c.ResetToInitialValue();
    }
    GetEventGroupByName(c) {
      return this._groupsByName.get(c.toLowerCase()) || null;
    }
    GetEventGroupBySID(c) {
      return (c = this._blocksBySid.get(c)) && c.IsGroup() ? c : null;
    }
    GetAllGroups() {
      return this._allGroups;
    }
    ResetAllGroupsInitialActivation() {
      for (const c of this._allGroups) c.ResetInitialActivation();
    }
    _ResetAllHasRunFlags() {
      for (const c of this._allSheets) c._ResetHasRunFlag();
    }
    RunEvents(c) {
      this._ResetAllHasRunFlags();
      this._runningEventsDepth++;
      for (const d of c.runningLayouts())
        if ((c = d.GetEventSheet()))
          this._runtime.PushCurrentLayout(d),
            c.Run(),
            this._runtime.PopCurrentLayout();
      this._runningEventsDepth--;
    }
    async DebugRunEvents(c) {
      this._ResetAllHasRunFlags();
      this._runningEventsDepth++;
      for (const d of this._DebugRunEventsGen(c))
        await this._runtime.DebugBreak(d);
      this._runningEventsDepth--;
    }
    *_DebugRunEventsGen(c) {
      for (const d of c.runningLayouts())
        if ((c = d.GetEventSheet()))
          this._runtime.PushCurrentLayout(d),
            yield* c.DebugRun(),
            this._runtime.PopCurrentLayout();
    }
    _Trigger(c, d, f, h) {
      let g = !1;
      if (!c.GetMainRunningLayout()) return this.QueueTrigger(d, f, h);
      this._executingTriggerDepth++;
      for (const k of c.runningLayouts())
        if ((c = k.GetEventSheet())) {
          this._runtime.PushCurrentLayout(k);
          for (const m of c.deepIncludes()) {
            const q = m._Trigger(d, f, h);
            g = g || q;
          }
          c = c._Trigger(d, f, h);
          g = g || c;
          this._runtime.PopCurrentLayout();
        }
      this._executingTriggerDepth--;
      return g;
    }
    *_DebugTrigger(c, d, f, h) {
      let g = !1;
      if (!c.GetMainRunningLayout()) return this.QueueTrigger(d, f, h);
      this._executingTriggerDepth++;
      for (const k of c.runningLayouts())
        if ((c = k.GetEventSheet())) {
          this._runtime.PushCurrentLayout(k);
          for (const m of c.deepIncludes()) {
            const q = yield* m._DebugTrigger(d, f, h);
            g = g || q;
          }
          c = yield* c._DebugTrigger(d, f, h);
          g = g || c;
          this._runtime.PopCurrentLayout();
        }
      this._executingTriggerDepth--;
      return g;
    }
    QueueTrigger(c, d, f) {
      this._queuedTriggers.push([c, d, f]);
      return !1;
    }
    QueueDebugTrigger(c, d, f) {
      let h = null;
      const g = new Promise((k) => (h = k));
      this._queuedDebugTriggers.push([c, d, f, h]);
      return g;
    }
    *_RunQueuedDebugTriggersGen() {
      if (this._runtime.HitBreakpoint())
        throw Error("should not be in breakpoint");
      const c = this._runtime.GetLayoutManager();
      for (; this._queuedDebugTriggers.length; ) {
        const [d, f, h, g] = this._queuedDebugTriggers.shift(),
          k = yield* this._DebugTrigger(c, d, f, h);
        g(k);
      }
    }
    async RunQueuedDebugTriggersAsync() {
      for (const c of this._RunQueuedDebugTriggersGen())
        await this._runtime.DebugBreak(c);
    }
    _FastTrigger(c, d, f, h) {
      let g = !1;
      var k = c.GetMainRunningLayout();
      if ((c = k.GetEventSheet())) {
        this._executingTriggerDepth++;
        this._runtime.PushCurrentLayout(k);
        k = c.deepIncludes();
        for (let m = 0, q = k.length; m < q; ++m) {
          const v = k[m]._FastTrigger(d, f, h);
          g = g || v;
        }
        d = c._FastTrigger(d, f, h);
        g = g || d;
        this._runtime.PopCurrentLayout();
        this._executingTriggerDepth--;
        return g;
      }
    }
    *_DebugFastTrigger(c, d, f, h) {
      let g = !1;
      var k = c.GetMainRunningLayout();
      if ((c = k.GetEventSheet())) {
        this._executingTriggerDepth++;
        this._runtime.PushCurrentLayout(k);
        k = c.deepIncludes();
        for (let m = 0, q = k.length; m < q; ++m) {
          const v = yield* k[m]._DebugFastTrigger(d, f, h);
          g = g || v;
        }
        d = yield* c._DebugFastTrigger(d, f, h);
        g = g || d;
        this._runtime.PopCurrentLayout();
        this._executingTriggerDepth--;
        return g;
      }
    }
    GetTriggerDepth() {
      return this._executingTriggerDepth;
    }
    IsInTrigger() {
      return 0 < this.GetTriggerDepth();
    }
    _IncTriggerDepth() {
      return ++this._executingTriggerDepth;
    }
    _DecTriggerDepth() {
      --this._executingTriggerDepth;
    }
    IsRunningEvents() {
      return 0 < this._runningEventsDepth;
    }
    IsInEventEngine() {
      return this.IsRunningEvents() || this.IsInTrigger();
    }
    _RunQueuedTriggers(c) {
      for (const [d, f, h] of this._queuedTriggers) this._Trigger(c, d, f, h);
      e.clearArray(this._queuedTriggers);
    }
    BlockFlushingInstances(c) {
      c ? this._blockFlushingDepth++ : this._blockFlushingDepth--;
    }
    IsFlushingBlocked() {
      return 0 < this._blockFlushingDepth;
    }
    ClearSol(c) {
      for (let d = 0, f = c.length; d < f; ++d) c[d].GetSolStack().Clear();
    }
    PushCleanSol(c) {
      for (let d = 0, f = c.length; d < f; ++d) c[d].GetSolStack().PushClean();
    }
    PushCopySol(c) {
      for (let d = 0, f = c.length; d < f; ++d) c[d].GetSolStack().PushCopy();
    }
    PopSol(c) {
      for (let d = 0, f = c.length; d < f; ++d) c[d].GetSolStack().Pop();
    }
    AddScheduledWait() {
      const c = e.New(e.ScheduledWait, this);
      this._scheduledWaits.push(c);
      return c;
    }
    scheduledWaits() {
      return this._scheduledWaits;
    }
    RunScheduledWaits() {
      if (this._scheduledWaits.length) {
        var c = this.GetCurrentEventStackFrame(),
          d = !1;
        this._runningEventsDepth++;
        for (let f = 0, h = this._scheduledWaits.length; f < h; ++f) {
          const g = this._scheduledWaits[f];
          g._ShouldRun() && g._Run(c);
          g.ShouldRelease() && (d = !0);
        }
        d && this._FilterScheduledWaitsToRelease();
        this._runningEventsDepth--;
      }
    }
    async DebugRunScheduledWaits() {
      if (this._scheduledWaits.length) {
        var c = this.GetCurrentEventStackFrame(),
          d = !1;
        this._runningEventsDepth++;
        for (let f = 0, h = this._scheduledWaits.length; f < h; ++f) {
          const g = this._scheduledWaits[f];
          g._ShouldRun() && (await g._DebugRun(c));
          g.ShouldRelease() && (d = !0);
        }
        d && this._FilterScheduledWaitsToRelease();
        this._runningEventsDepth--;
      }
    }
    _FilterScheduledWaitsToRelease() {
      const c = e.arrayFilterOut(this._scheduledWaits, (d) =>
        d.ShouldRelease()
      );
      for (const d of c) d.Release();
    }
    ClearAllScheduledWaits() {
      for (const c of this._scheduledWaits) c.Release();
      e.clearArray(this._scheduledWaits);
    }
    RemoveInstancesFromScheduledWaits(c) {
      for (const d of this._scheduledWaits) d.RemoveInstances(c);
    }
    AddAsyncActionPromise(c) {
      this._asyncActionPromises.push(c);
    }
    ClearAsyncActionPromises() {
      e.clearArray(this._asyncActionPromises);
    }
    GetPromiseForAllAsyncActions() {
      const c = Promise.all(this._asyncActionPromises);
      this._asyncActionPromises = [];
      return c;
    }
    _SaveToJson() {
      return {
        groups: this._SaveGroupsToJson(),
        cnds: this._SaveCndsToJson(),
        acts: this._SaveActsToJson(),
        vars: this._SaveVarsToJson(),
        waits: this._SaveScheduledWaitsToJson(),
      };
    }
    _LoadFromJson(c) {
      this._LoadGroupsFromJson(c.groups);
      this._LoadCndsFromJson(c.cnds);
      this._LoadActsFromJson(c.acts);
      this._LoadVarsFromJson(c.vars);
      this._LoadScheduledWaitsFromJson(c.waits);
    }
    _SaveGroupsToJson() {
      const c = {};
      for (const d of this.GetAllGroups())
        c[d.GetSID().toString()] = d.IsGroupActive();
      return c;
    }
    _LoadGroupsFromJson(c) {
      for (const [d, f] of Object.entries(c))
        (c = parseInt(d, 10)),
          (c = this.GetEventGroupBySID(c)) && c.SetGroupActive(f);
    }
    _SaveCndsToJson() {
      const c = {};
      for (const [d, f] of this._cndsBySid) {
        const h = f._SaveToJson();
        h && (c[d.toString()] = h);
      }
      return c;
    }
    _LoadCndsFromJson(c) {
      const d = new Map();
      for (const [f, h] of Object.entries(c)) d.set(parseInt(f, 10), h);
      for (const [f, h] of this._cndsBySid) h._LoadFromJson(d.get(f) || null);
    }
    _SaveActsToJson() {
      const c = {};
      for (const [d, f] of this._actsBySid) {
        const h = f._SaveToJson();
        h && (c[d.toString()] = h);
      }
      return c;
    }
    _LoadActsFromJson(c) {
      const d = new Map();
      for (const [f, h] of Object.entries(c)) d.set(parseInt(f, 10), h);
      for (const [f, h] of this._actsBySid) h._LoadFromJson(d.get(f) || null);
    }
    _SaveVarsToJson() {
      const c = {};
      for (const [d, f] of this._eventVarsBySid)
        f.IsConstant() ||
          (!f.IsGlobal() && !f.IsStatic()) ||
          (c[d.toString()] = f.GetValue());
      return c;
    }
    _LoadVarsFromJson(c) {
      for (const [d, f] of Object.entries(c))
        (c = parseInt(d, 10)),
          (c = this.GetEventVariableBySID(c)) && c.SetValue(f);
    }
    _SaveScheduledWaitsToJson() {
      return this._scheduledWaits
        .filter((c) => !c.IsPromise())
        .map((c) => c._SaveToJson());
    }
    _LoadScheduledWaitsFromJson(c) {
      this.ClearAllScheduledWaits();
      for (const d of c)
        (c = e.ScheduledWait._CreateFromJson(this, d)) &&
          this._scheduledWaits.push(c);
    }
    _GetPerfRecords() {
      return [...this._runtime.GetLayoutManager().runningLayouts()]
        .map((c) => c.GetEventSheet())
        .filter((c) => c)
        .map((c) => c._GetPerfRecord());
    }
    FindFirstFunctionBlockParent(c) {
      for (; c; )
        if (((c = c.GetScopeParent()), c instanceof e.FunctionBlock)) return c;
      return null;
    }
    _InvokeFunctionFromJS(c, d) {
      Array.isArray(d) || (d = []);
      c = this.GetFunctionBlockByName(c.toLowerCase());
      if (!c) return null;
      if (!c.IsEnabled()) return c.GetDefaultReturnValue();
      var f = c.GetFunctionParameters();
      if (d.length < f.length) {
        d = d.slice(0);
        do d.push(f[d.length].GetInitialValue());
        while (d.length < f.length);
      }
      f = c.GetEventBlock();
      return f.RunAsExpressionFunctionCall(
        f.GetSolModifiersIncludingParents(),
        c.GetReturnType(),
        c.GetDefaultReturnValue(),
        ...d
      );
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.EventSheet = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._eventSheetManager = b;
      this._runtime = b.GetRuntime();
      this._name = a[0];
      this._events = [];
      this._triggers = new Map();
      this._fastTriggers = new Map();
      this._eventsByDisplayNumber = new Map();
      this._hasRun = !1;
      this._shallowIncludes = [];
      this._deepIncludes = [];
      this._alreadyIncludedSheets = new Set();
      for (const c of a[1]) this._CreateEvent(c, null, this._events);
      this._perfRecord = this._runtime.IsDebug()
        ? { type: "sheet", name: this._name, totalTimeCounter: 0, children: [] }
        : null;
    }
    Release() {
      this._runtime = this._eventSheetManager = null;
    }
    _CreateEvent(b, a, c) {
      switch (b[0]) {
        case 0:
        case 3:
          this._CreateEventBlock(b, a, c);
          break;
        case 1:
          this._CreateEventVariable(b, a, c);
          break;
        case 2:
          this._CreateInclude(b, a, c);
          break;
        case 4:
          this._CreateFunctionBlock(b, a);
          break;
        case 5:
          this._CreateScriptBlock(b, a, c);
          break;
        default:
          throw Error("invalid event type");
      }
    }
    _CreateEventBlock(b, a, c) {
      b = e.EventBlock.Create(this, a, b);
      if (b.IsOrBlock()) {
        c.push(b);
        c = b.GetConditions();
        for (let d = 0, f = c.length; d < f; ++d)
          c[d].IsTrigger() && this._InitTrigger(b, d);
      } else b.IsTrigger() ? this._InitTrigger(b, 0) : c.push(b);
    }
    _CreateFunctionBlock(b, a) {
      b = e.FunctionBlock.Create(this, a, b);
      this._eventSheetManager._RegisterFunctionBlock(b);
    }
    _CreateEventVariable(b, a, c) {
      b = e.EventVariable.Create(this, a, b);
      c.push(b);
    }
    _CreateInclude(b, a, c) {
      b = e.EventInclude.Create(this, a, b);
      c.push(b);
    }
    _CreateScriptBlock(b, a, c) {
      b = e.EventScript.Create(this, a, b);
      c.push(b);
    }
    _InitTrigger(b, a) {
      b.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(b);
      var c = b.GetConditionAt(a),
        d = c._GetFunc(),
        f = c.GetObjectClass();
      if (c.IsFastTrigger()) {
        var h = this._fastTriggers.get(f);
        h || ((h = new Map()), this._fastTriggers.set(f, h));
        c = c.GetFastTriggerValue().toLowerCase();
        f = h.get(d);
        f || ((f = new Map()), h.set(d, f));
        d = f.get(c);
        d || ((d = []), f.set(c, d));
        d.push([b, a]);
      } else
        (h = this._triggers.get(f)),
          h ||
            ((h = { methodMap: new Map(), behaviors: new Map() }),
            this._triggers.set(f, h)),
          (f = c.GetBehaviorType())
            ? ((c = h.behaviors.get(f)),
              c || ((c = new Map()), h.behaviors.set(f, c)))
            : (c = h.methodMap),
          (h = c.get(d)),
          h || ((h = []), c.set(d, h)),
          h.push([b, a]);
    }
    _PostInit() {
      const b = this._events;
      for (let a = 0, c = b.length; a < c; ++a) {
        const d =
          a < c - 1 &&
          b[a + 1] instanceof e.EventBlock &&
          b[a + 1].IsElseBlock();
        b[a]._PostInit(d);
      }
    }
    _AddShallowInclude(b) {
      this._shallowIncludes.push(b);
    }
    _UpdateDeepIncludes() {
      e.clearArray(this._deepIncludes);
      this._AddDeepIncludes(this);
      this._alreadyIncludedSheets.clear();
    }
    _AddDeepIncludes(b) {
      const a = b._deepIncludes,
        c = b._alreadyIncludedSheets;
      for (const d of this._shallowIncludes) {
        const f = d.GetIncludeSheet();
        d.IsActive() &&
          b !== f &&
          !c.has(f) &&
          (c.add(f), f._AddDeepIncludes(b), a.push(f));
      }
    }
    deepIncludes() {
      return this._deepIncludes;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetName() {
      return this._name;
    }
    _RegisterEventByDisplayNumber(b, a) {
      this._eventsByDisplayNumber.set(a, b);
    }
    _GetEventByDisplayNumber(b) {
      return this._eventsByDisplayNumber.get(b) || null;
    }
    _ResetHasRunFlag() {
      this._hasRun = !1;
    }
    Run() {
      if (!this._hasRun) {
        var b = this._runtime,
          a = b.IsCPUProfiling(),
          c = a ? performance.now() : 0;
        this._hasRun = !0;
        var d = this.GetEventSheetManager(),
          f = d.GetCurrentEventStackFrame();
        for (const h of this._events)
          h.Run(f),
            d.ClearSol(h.GetSolModifiers()),
            d.ClearAsyncActionPromises(),
            b.FlushPendingInstances();
        f.Reset(null);
        a && (this._perfRecord.totalTimeCounter += performance.now() - c);
      }
    }
    *DebugRun() {
      if (!this._hasRun) {
        this._hasRun = !0;
        var b = this._runtime,
          a = this.GetEventSheetManager(),
          c = a.GetCurrentEventStackFrame();
        for (const d of this._events)
          yield* d.DebugRun(c),
            a.ClearSol(d.GetSolModifiers()),
            a.ClearAsyncActionPromises(),
            b.FlushPendingInstances();
        c.Reset(null);
      }
    }
    _Trigger(b, a, c) {
      if (a) {
        const d = a.GetObjectClass();
        this._TriggerForClass(b, a, d, c);
        for (const f of d.GetFamilies()) this._TriggerForClass(b, a, f, c);
      } else return this._TriggerForClass(b, a, null, null);
    }
    _TriggerForClass(b, a, c, d) {
      c = this._triggers.get(c);
      if (!c) return !1;
      d = d ? c.behaviors.get(d) : c.methodMap;
      if (!d) return !1;
      d = d.get(b);
      if (!d) return !1;
      b = !1;
      for (const [f, h] of d) (d = this._ExecuteTrigger(a, f, h)), (b = b || d);
      return b;
    }
    *_DebugTrigger(b, a, c) {
      if (a) {
        const d = a.GetObjectClass();
        yield* this._DebugTriggerForClass(b, a, d, c);
        for (const f of d.GetFamilies())
          yield* this._DebugTriggerForClass(b, a, f, c);
      } else return yield* this._DebugTriggerForClass(b, a, null, null);
    }
    *_DebugTriggerForClass(b, a, c, d) {
      c = this._triggers.get(c);
      if (!c) return !1;
      d = d ? c.behaviors.get(d) : c.methodMap;
      if (!d) return !1;
      d = d.get(b);
      if (!d) return !1;
      b = !1;
      for (const [f, h] of d)
        (d = f.DebugCanRunFast()
          ? this._ExecuteTrigger(a, f, h)
          : yield* this._DebugExecuteTrigger(a, f, h)),
          (b = b || d);
      return b;
    }
    _FastTrigger(b, a, c) {
      a = a.GetObjectClass();
      a = this._fastTriggers.get(a);
      if (!a) return !1;
      b = a.get(b);
      if (!b) return !1;
      c = b.get(c);
      if (!c) return !1;
      b = !1;
      for (let d = 0, f = c.length; d < f; ++d)
        (a = c[d]), (a = this._ExecuteTrigger(null, a[0], a[1])), (b = b || a);
      return b;
    }
    *_DebugFastTrigger(b, a, c) {
      a = a.GetObjectClass();
      a = this._fastTriggers.get(a);
      if (!a) return !1;
      b = a.get(b);
      if (!b) return !1;
      c = b.get(c);
      if (!c) return !1;
      b = !1;
      for (let f = 0, h = c.length; f < h; ++f) {
        var d = c[f];
        a = d[0];
        d = d[1];
        a = a.DebugCanRunFast()
          ? this._ExecuteTrigger(null, a, d)
          : yield* this._DebugExecuteTrigger(null, a, d);
        b = b || a;
      }
      return b;
    }
    _ExecuteTrigger(b, a, c) {
      const d = this._runtime,
        f = this._eventSheetManager,
        h = f.GetCurrentEvent(),
        g = f.GetEventStack(),
        k = f.GetTriggerDepth();
      let m = !1;
      h && f.PushCleanSol(h.GetSolModifiersIncludingParents());
      f.PushCleanSol(a.GetSolModifiersIncludingParents());
      const q = 1 < k;
      q && f.GetLocalVarStack().Push();
      const v = g.Push(a);
      b &&
        (a
          .GetConditions()
          [c].GetObjectClass()
          .GetCurrentSol()
          .SetSinglePicked(b),
        b.IsInContainer() && b.SetSiblingsSinglePicked());
      b = !0;
      if (a.GetParent()) {
        const r = a.GetTriggerParents();
        for (let n = 0, p = r.length; n < p; ++n)
          if (!r[n].RunPreTrigger(v)) {
            b = !1;
            break;
          }
      }
      b &&
        (a.IsOrBlock() ? a.RunOrBlockTrigger(v, c) : a.Run(v),
        (m = v.GetLastEventTrue()));
      g.Pop();
      q && f.GetLocalVarStack().Pop();
      f.PopSol(a.GetSolModifiersIncludingParents());
      h && f.PopSol(h.GetSolModifiersIncludingParents());
      h ||
        1 !== k ||
        (f.ClearAsyncActionPromises(),
        f.IsFlushingBlocked() || d.FlushPendingInstances());
      return m;
    }
    *_DebugExecuteTrigger(b, a, c) {
      const d = this._runtime,
        f = this._eventSheetManager,
        h = f.GetCurrentEvent(),
        g = f.GetEventStack(),
        k = f.GetTriggerDepth();
      let m = !1;
      h && f.PushCleanSol(h.GetSolModifiersIncludingParents());
      f.PushCleanSol(a.GetSolModifiersIncludingParents());
      const q = 1 < k;
      q && f.GetLocalVarStack().Push();
      const v = g.Push(a);
      b &&
        (a
          .GetConditions()
          [c].GetObjectClass()
          .GetCurrentSol()
          .SetSinglePicked(b),
        b.IsInContainer() && b.SetSiblingsSinglePicked());
      b = !0;
      if (a.GetParent()) {
        const r = a.GetTriggerParents();
        for (let n = 0, p = r.length; n < p; ++n)
          if (!(yield* r[n].DebugRunPreTrigger(v))) {
            b = !1;
            break;
          }
      }
      b &&
        (a.IsOrBlock()
          ? yield* a.DebugRunOrBlockTrigger(v, c)
          : yield* a.DebugRun(v),
        (m = v.GetLastEventTrue()));
      g.Pop();
      q && f.GetLocalVarStack().Pop();
      f.PopSol(a.GetSolModifiersIncludingParents());
      h && f.PopSol(h.GetSolModifiersIncludingParents());
      h ||
        1 !== k ||
        (f.ClearAsyncActionPromises(),
        f.IsFlushingBlocked() || d.FlushPendingInstances());
      return m;
    }
    _GetPerfRecord() {
      return this._perfRecord;
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = [];
  function a(d, f) {
    return !0;
  }
  function* c(d, f) {
    return !0;
  }
  e.EventBlock = class extends e.DefendedBase {
    constructor(d, f, h) {
      super();
      this._eventSheet = d;
      this._runtime = d.GetRuntime();
      this._parent = f;
      this._scopeParent = null;
      this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
      this._solModifiers = [];
      this._solModifiersIncludingParents = [];
      this._hasElseBlock =
        this._isTopLevelGroup =
        this._isSolWriterAfterCnds =
        this._hasGotSolModifiersIncludingParents =
          !1;
      this._isOrBlock = !!h[2];
      this._isElseBlock = !1;
      this._triggerParents = null;
      this._conditions = [];
      this._actions = [];
      this._subEvents = [];
      this._RunActions = a;
      this._DebugRunActions = c;
      this._isInitiallyActive = this._isGroup = !1;
      this._groupName = "";
      this._isGroupActive = !1;
      this._perfRecord = this._containedIncludes = null;
      this._sid = h[4];
      this._displayNumber = h[5];
      this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);
      this._debugData = this._runtime.IsDebug()
        ? {
            isBreakpoint: h[3][0],
            isBreakable: h[3][1],
            canRunAllConditionsFast: !1,
            canRunAllActionsFast: !1,
            canRunAllSubEventsFast: !1,
            canRunSelfFast: !1,
          }
        : null;
      this.GetEventSheetManager()._RegisterEventBlock(this);
      3 === h[0] && this._InitGroup(h[1]);
      d = 0;
      for (var g of h[6])
        (f = e.Condition.Create(this, g, d++)),
          this._conditions.push(f),
          this._AddSolModifier(f.GetObjectClass());
      d = 0;
      for (const k of h[7])
        (g = e.Action.Create(this, k, d++)), this._actions.push(g);
      if (9 === h.length) {
        h = h[8];
        for (const k of h)
          this._eventSheet._CreateEvent(k, this, this._subEvents);
      }
      this._conditions.length &&
        (this._isElseBlock =
          null === this._conditions[0].GetObjectClass() &&
          this._conditions[0]._GetFunc() === e.Plugins.System.Cnds.Else);
      0 === this._conditions.length && (this._conditions = b);
      0 === this._actions.length && (this._actions = b);
      0 === this._subEvents.length && (this._subEvents = b);
    }
    static Create(d, f, h) {
      return e.New(e.EventBlock, d, f, h);
    }
    _InitGroup(d) {
      this._isGroup = !0;
      this._isGroupActive = this._isInitiallyActive = !!d[0];
      this._groupName = d[1].toLowerCase();
      this._containedIncludes = [];
      this.GetEventSheetManager()._RegisterGroup(this);
      this._runtime.IsDebug() &&
        (this._perfRecord = {
          type: "group",
          name: d[1],
          totalTimeCounter: 0,
          children: [],
        });
    }
    _AddContainedInclude(d) {
      this._containedIncludes.push(d);
    }
    _AddContainerSolModifierToList(d, f) {
      for (const h of d.GetContainer().objectTypes())
        f.includes(h) || f.push(h);
    }
    _AddSolModifierToList(d, f) {
      if (d)
        if ((f.includes(d) || f.push(d), d.IsFamily()))
          for (const h of d.GetFamilyMembers())
            h.IsInContainer() && this._AddContainerSolModifierToList(h, f);
        else d.IsInContainer() && this._AddContainerSolModifierToList(d, f);
    }
    _AddSolModifier(d) {
      this._AddSolModifierToList(d, this._solModifiers);
    }
    _AddParentSolModifier(d) {
      this._AddSolModifierToList(d, this._solModifiersIncludingParents);
    }
    SetAllSolModifiers() {
      this._solModifiers = this._runtime.GetAllObjectClasses();
    }
    _PostInit(d) {
      this._hasElseBlock = !!d;
      this._IdentifyTopLevelGroup();
      this._IdentifyTriggerParents();
      for (const h of this._conditions) h._PostInit();
      if (0 < this._actions.length) {
        d = !1;
        for (var f of this._actions)
          f._PostInit(), f.HasReturnType() && (d = !0);
        d
          ? ((this._RunActions = this._RunActions_ReturnValue),
            (this._DebugRunActions = this._DebugRunActions_ReturnValue))
          : ((this._RunActions = this._RunActions_Fast),
            (this._DebugRunActions = this._DebugRunActions_Fast));
      }
      f = this._subEvents;
      for (let h = 0, g = f.length; h < g; ++h)
        (d =
          h < g - 1 &&
          f[h + 1] instanceof e.EventBlock &&
          f[h + 1].IsElseBlock()),
          f[h]._PostInit(d);
      this._debugData && this._UpdateCanRunFast();
      this._perfRecord &&
        this._GetPerfRecordParent()
          ._GetPerfRecord()
          .children.push(this._perfRecord);
    }
    _GetPerfRecord() {
      return this._perfRecord;
    }
    _GetPerfRecordParent() {
      let d = this.GetParent();
      for (; d; ) {
        if (d.IsGroup()) return d;
        d = d.GetParent();
      }
      return this._eventSheet;
    }
    _UpdateCanRunFast() {
      const d = this._debugData;
      d.canRunAllConditionsFast = this._conditions.every((f) =>
        f.DebugCanRunFast()
      );
      d.canRunAllActionsFast = this._actions.every((f) => f.DebugCanRunFast());
      d.canRunAllSubEventsFast = this._subEvents.every((f) =>
        f.DebugCanRunFast()
      );
      d.canRunSelfFast =
        d.canRunAllConditionsFast &&
        d.canRunAllActionsFast &&
        d.canRunAllSubEventsFast;
    }
    _UpdateCanRunFastRecursive() {
      let d = this;
      do d._UpdateCanRunFast(), (d = d.GetParent());
      while (d);
    }
    _IdentifyTopLevelGroup() {
      if (this.IsGroup()) {
        var d = this.GetParent();
        for (this._isTopLevelGroup = !0; d; ) {
          if (!d.IsGroup()) {
            this._isTopLevelGroup = !1;
            break;
          }
          d = d.GetParent();
        }
      }
    }
    _IdentifySolModifiersIncludingParents() {
      var d = this._runtime.GetAllObjectClasses();
      if (this._solModifiers === d) this._solModifiersIncludingParents = d;
      else {
        this._solModifiersIncludingParents = e.cloneArray(this._solModifiers);
        for (d = this.GetParent(); d; ) {
          for (var f of d._solModifiers) this._AddParentSolModifier(f);
          d = d.GetParent();
        }
        f = this.GetEventSheetManager();
        this._solModifiers = f._DeduplicateSolModifierList(this._solModifiers);
        this._solModifiersIncludingParents = f._DeduplicateSolModifierList(
          this._solModifiersIncludingParents
        );
      }
    }
    _IdentifyTriggerParents() {
      if (this.HasAnyTriggeredCondition()) {
        this._triggerParents = [];
        for (var d = this.GetParent(); d; )
          this._triggerParents.push(d), (d = d.GetParent());
        this._triggerParents.reverse();
      }
    }
    SetSolWriterAfterCnds() {
      this._isSolWriterAfterCnds = !0;
      this._parent && this._parent.SetSolWriterAfterCnds();
    }
    IsSolWriterAfterCnds() {
      return this._isSolWriterAfterCnds;
    }
    GetSolModifiers() {
      return this._solModifiers;
    }
    GetSolModifiersIncludingParents() {
      this._hasGotSolModifiersIncludingParents ||
        ((this._hasGotSolModifiersIncludingParents = !0),
        this._IdentifySolModifiersIncludingParents());
      return this._solModifiersIncludingParents;
    }
    HasSolModifier(d) {
      return this._solModifiers.includes(d);
    }
    GetTriggerParents() {
      return this._triggerParents;
    }
    GetEventSheet() {
      return this._eventSheet;
    }
    GetEventSheetManager() {
      return this._eventSheet.GetEventSheetManager();
    }
    GetRuntime() {
      return this._runtime;
    }
    GetParent() {
      return this._parent;
    }
    _SetScopeParent(d) {
      this._scopeParent = d;
    }
    GetScopeParent() {
      return this._scopeParent || this._parent;
    }
    GetDisplayNumber() {
      return this._displayNumber;
    }
    IsDebugBreakable() {
      return this._debugData && this._debugData.isBreakable;
    }
    IsDebugBreakpoint() {
      return this.IsDebugBreakable() && this._debugData.isBreakpoint;
    }
    _SetDebugBreakpoint(d) {
      this._debugData.isBreakpoint = !!d;
      this._UpdateCanRunFastRecursive();
    }
    IsGroup() {
      return this._isGroup;
    }
    IsTopLevelGroup() {
      return this._isTopLevelGroup;
    }
    IsElseBlock() {
      return this._isElseBlock;
    }
    HasElseBlock() {
      return this._hasElseBlock;
    }
    GetGroupName() {
      return this._groupName;
    }
    IsGroupActive() {
      return this._isGroupActive;
    }
    ResetInitialActivation() {
      this.SetGroupActive(this._isInitiallyActive);
    }
    SetGroupActive(d) {
      d = !!d;
      if (!this._isGroup) throw Error("not a group");
      if (this._isGroupActive !== d) {
        this._isGroupActive = d;
        for (const f of this._containedIncludes) f.UpdateActive();
        this._containedIncludes.length &&
          (d = this._runtime.GetCurrentLayout().GetEventSheet()) &&
          d._UpdateDeepIncludes();
      }
    }
    GetSID() {
      return this._sid;
    }
    IsOrBlock() {
      return this._isOrBlock;
    }
    IsTrigger() {
      return this._conditions.length && this._conditions[0].IsTrigger();
    }
    IsForFunctionBlock() {
      return this._scopeParent && this._scopeParent instanceof e.FunctionBlock;
    }
    HasAnyTriggeredCondition() {
      return (
        this.IsForFunctionBlock() || this._conditions.some((d) => d.IsTrigger())
      );
    }
    GetConditions() {
      return this._conditions;
    }
    GetConditionCount() {
      return this._conditions.length;
    }
    GetConditionAt(d) {
      d = Math.floor(d);
      if (0 > d || d >= this._conditions.length)
        throw new RangeError("invalid condition index");
      return this._conditions[d];
    }
    GetConditionByDebugIndex(d) {
      return this.GetConditionAt(d);
    }
    IsFirstConditionOfType(d) {
      let f = d.GetIndex();
      if (0 === f) return !0;
      for (--f; 0 <= f; --f)
        if (this._conditions[f].GetObjectClass() === d.GetObjectClass())
          return !1;
      return !0;
    }
    GetActions() {
      return this._actions;
    }
    GetActionCount() {
      return this._actions.length;
    }
    GetActionAt(d) {
      d = Math.floor(d);
      if (0 > d || d >= this._actions.length)
        throw new RangeError("invalid action index");
      return this._actions[d];
    }
    GetActionByDebugIndex(d) {
      d = Math.floor(d);
      const f = this._actions.find((h) => h.GetDebugIndex() === d);
      if (!f) throw new RangeError("invalid action debug index");
      return f;
    }
    _HasActionIndex(d) {
      d = Math.floor(d);
      return 0 <= d && d < this._actions.length;
    }
    GetSubEvents() {
      return this._subEvents;
    }
    _GetAllLocalVariablesInScope() {
      return this._subEvents.filter((d) => d instanceof e.EventVariable);
    }
    RunPreTrigger(d) {
      d.SetCurrentEvent(this);
      let f = !1;
      const h = this._conditions;
      for (let g = 0, k = h.length; g < k; ++g) {
        const m = h[g];
        d.SetConditionIndex(g);
        if (m.IsLooping())
          throw Error("trigger cannot be used as sub-event to a loop");
        if (m.Run()) f = !0;
        else if (!this._isOrBlock) return !1;
      }
      return this._isOrBlock ? f : !0;
    }
    RunOrBlockTrigger(d, f) {
      d.SetCurrentEvent(this);
      this._conditions[f].Run() &&
        (this._RunActions(d, 0) && this._RunSubEvents(d),
        d.SetLastEventTrue(!0));
    }
    *DebugRunPreTrigger(d) {
      d.SetCurrentEvent(this);
      let f = !1;
      const h = this._conditions;
      for (let g = 0, k = h.length; g < k; ++g) {
        const m = h[g];
        d.SetConditionIndex(g);
        if (m.IsLooping())
          throw Error("trigger cannot be used as sub-event to a loop");
        if (m.DebugCanRunFast() ? m.Run() : yield* m.DebugRun()) f = !0;
        else if (!this._isOrBlock) return !1;
      }
      return this._isOrBlock ? f : !0;
    }
    *DebugRunOrBlockTrigger(d, f) {
      d.SetCurrentEvent(this);
      f = this._conditions[f];
      if (f.DebugCanRunFast() ? f.Run() : yield* f.DebugRun())
        (this.DebugCanRunActionsFast()
          ? this._RunActions(d, 0)
          : yield* this._DebugRunActions(d, 0)) &&
          (this.DebugCanRunSubEventsFast()
            ? this._RunSubEvents()
            : yield* this._DebugRunSubEvents()),
          d.SetLastEventTrue(!0);
    }
    Run(d) {
      d.SetCurrentEvent(this);
      this._isElseBlock || d.SetElseBranchRan(!1);
      this._isOrBlock ? this._RunOrBlock(d) : this._RunAndBlock(d);
    }
    *DebugRun(d) {
      if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
        yield this;
      d.SetCurrentEvent(this);
      this._isElseBlock || d.SetElseBranchRan(!1);
      this._isOrBlock
        ? yield* this._DebugRunOrBlock(d)
        : yield* this._DebugRunAndBlock(d);
    }
    _RunOrBlock(d) {
      const f = this._conditions;
      let h = 0 === f.length;
      for (let k = 0, m = f.length; k < m; ++k) {
        var g = f[k];
        g.IsTrigger() || (d.SetConditionIndex(k), (g = g.Run()), (h = h || g));
      }
      d.SetLastEventTrue(h);
      h &&
        (this._RunActions(d, 0) && this._RunSubEvents(d),
        this._hasElseBlock && d.SetElseBranchRan(!0));
    }
    *_DebugRunOrBlock(d) {
      const f = this._conditions;
      let h = 0 === f.length;
      for (let k = 0, m = f.length; k < m; ++k) {
        var g = f[k];
        g.IsTrigger() ||
          (d.SetConditionIndex(k),
          (g = g.DebugCanRunFast() ? g.Run() : yield* g.DebugRun()),
          (h = h || g));
      }
      d.SetLastEventTrue(h);
      h &&
        ((this.DebugCanRunActionsFast()
          ? this._RunActions(d, 0)
          : yield* this._DebugRunActions(d, 0)) &&
          (this.DebugCanRunSubEventsFast()
            ? this._RunSubEvents()
            : yield* this._DebugRunSubEvents()),
        this._hasElseBlock && d.SetElseBranchRan(!0));
    }
    _RunAndBlock(d) {
      const f = this._conditions;
      for (let h = 0, g = f.length; h < g; ++h) {
        const k = f[h];
        d.SetConditionIndex(h);
        if (!k.Run()) {
          d.SetLastEventTrue(!1);
          return;
        }
      }
      d.SetLastEventTrue(!0);
      this._RunActions(d, 0) && this._RunSubEvents(d);
      d.GetLastEventTrue() && this._hasElseBlock && d.SetElseBranchRan(!0);
    }
    *_DebugRunAndBlock(d) {
      const f = this._conditions;
      for (let h = 0, g = f.length; h < g; ++h) {
        const k = f[h];
        d.SetConditionIndex(h);
        if (k.DebugCanRunFast() ? !k.Run() : !(yield* k.DebugRun())) {
          d.SetLastEventTrue(!1);
          return;
        }
      }
      d.SetLastEventTrue(!0);
      (this.DebugCanRunActionsFast()
        ? this._RunActions(d, 0)
        : yield* this._DebugRunActions(d, 0)) &&
        (this.DebugCanRunSubEventsFast()
          ? this._RunSubEvents()
          : yield* this._DebugRunSubEvents());
      d.GetLastEventTrue() && this._hasElseBlock && d.SetElseBranchRan(!0);
    }
    _RunActions_Fast(d, f) {
      const h = this._actions;
      for (let g = f, k = h.length; g < k; ++g)
        (f = h[g]), d.SetActionIndex(g), f.Run();
      return !0;
    }
    *_DebugRunActions_Fast(d, f) {
      const h = this._actions;
      for (let g = f, k = h.length; g < k; ++g)
        (f = h[g]),
          d.SetActionIndex(g),
          f.DebugCanRunFast() ? f.Run() : yield* f.DebugRun();
      return !0;
    }
    _RunActions_ReturnValue(d, f) {
      const h = this.GetEventSheetManager(),
        g = this._actions;
      for (let k = f, m = g.length; k < m; ++k) {
        f = g[k];
        d.SetActionIndex(k);
        const q = f.Run();
        if (f.CanBailOut() && !0 === q) return !1;
        f.IsAsync() && q instanceof Promise && h.AddAsyncActionPromise(q);
      }
      return !0;
    }
    *_DebugRunActions_ReturnValue(d, f) {
      const h = this.GetEventSheetManager(),
        g = this._actions;
      for (let k = f, m = g.length; k < m; ++k) {
        f = g[k];
        d.SetActionIndex(k);
        let q;
        q = f.DebugCanRunFast() ? f.Run() : yield* f.DebugRun();
        if (f.CanBailOut() && !0 === q) return !1;
        f.IsAsync() && q instanceof Promise && h.AddAsyncActionPromise(q);
      }
      return !0;
    }
    _ResumeActionsAndSubEvents(d) {
      this._RunActions(d, d.GetActionIndex()) && this._RunSubEvents();
    }
    *_DebugResumeActionsAndSubEvents(d) {
      if (yield* this._DebugRunActions(d, d.GetActionIndex()))
        yield* this._DebugRunSubEvents();
    }
    _RunSubEvents() {
      if (this._subEvents.length) {
        var d = this.IsGroup() && this._runtime.IsCPUProfiling(),
          f = d ? performance.now() : 0,
          h = this._eventStack,
          g = h.Push(this);
        this._isSolWriterAfterCnds
          ? this._RunSubEvents_SolWriterAfterCnds(g)
          : this._RunSubEvents_Fast(g);
        h.Pop();
        d && (this._perfRecord.totalTimeCounter += performance.now() - f);
      }
    }
    _RunSubEvents_SolWriterAfterCnds(d) {
      const f = this._isGroup,
        h = this._isTopLevelGroup,
        g = this.GetEventSheetManager(),
        k = this._subEvents;
      for (let m = 0, q = k.length, v = q - 1; m < q; ++m) {
        const r = k[m],
          n = r.GetSolModifiers(),
          p = !h || (!f && m < v);
        p && g.PushCopySol(n);
        r.Run(d);
        p ? g.PopSol(n) : g.ClearSol(n);
      }
    }
    _RunSubEvents_Fast(d) {
      const f = this._subEvents;
      for (let h = 0, g = f.length; h < g; ++h) f[h].Run(d);
    }
    *_DebugRunSubEvents() {
      if (this._subEvents.length) {
        var d = this._eventStack,
          f = d.Push(this);
        this._isSolWriterAfterCnds
          ? yield* this._DebugRunSubEvents_SolWriterAfterCnds(f)
          : yield* this._DebugRunSubEvents_Fast(f);
        d.Pop();
      }
    }
    *_DebugRunSubEvents_SolWriterAfterCnds(d) {
      const f = this._isGroup,
        h = this._isTopLevelGroup,
        g = this.GetEventSheetManager(),
        k = this._subEvents;
      for (let m = 0, q = k.length, v = q - 1; m < q; ++m) {
        const r = k[m],
          n = r.GetSolModifiers(),
          p = !h || (!f && m < v);
        p && g.PushCopySol(n);
        yield* r.DebugRun(d);
        p ? g.PopSol(n) : g.ClearSol(n);
      }
    }
    *_DebugRunSubEvents_Fast(d) {
      const f = this._subEvents;
      for (let h = 0, g = f.length; h < g; ++h) yield* f[h].DebugRun(d);
    }
    Retrigger(d, f) {
      f.ResetQuick();
      const h = this._conditions;
      if (!this.IsOrBlock())
        for (let g = d.GetConditionIndex() + 1, k = h.length; g < k; ++g)
          if (((d = h[g]), f.SetConditionIndex(g), !d.Run())) return !1;
      this._RunActions(f, 0) && this._RunSubEvents(f);
      return !0;
    }
    *DebugRetrigger(d, f) {
      f.ResetQuick();
      const h = this._conditions;
      if (!this.IsOrBlock())
        for (let g = d.GetConditionIndex() + 1, k = h.length; g < k; ++g)
          if (
            ((d = h[g]),
            f.SetConditionIndex(g),
            d.DebugCanRunFast() ? !d.Run() : !(yield* d.DebugRun()))
          )
            return !1;
      (this.DebugCanRunActionsFast()
        ? this._RunActions(f, 0)
        : yield* this._DebugRunActions(f, 0)) &&
        (this.DebugCanRunSubEventsFast()
          ? this._RunSubEvents()
          : yield* this._DebugRunSubEvents());
      return !0;
    }
    DebugCanRunFast() {
      return (
        !this.IsDebugBreakpoint() &&
        !this._runtime.DebugBreakNext() &&
        this._debugData.canRunSelfFast
      );
    }
    DebugCanRunActionsFast() {
      return (
        !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast
      );
    }
    DebugCanRunSubEventsFast() {
      return (
        !this._runtime.DebugBreakNext() &&
        this._debugData.canRunAllSubEventsFast
      );
    }
    _CheckParentsOKToRun(d) {
      if (this.GetParent()) {
        const f = this.GetTriggerParents();
        for (let h = 0, g = f.length; h < g; ++h)
          if (!f[h].RunPreTrigger(d)) return !1;
      }
      return !0;
    }
    *_DebugCheckParentsOKToRun(d) {
      if (this.GetParent()) {
        const f = this.GetTriggerParents();
        for (let h = 0, g = f.length; h < g; ++h)
          if (!(yield* f[h].DebugRunPreTrigger(d))) return !1;
      }
      return !0;
    }
    _EvaluateFunctionCallParameters(d, f, h) {
      0 < f.length
        ? h
          ? ((f = f.map((g) => g.Get(0))),
            d.GetLocalVarStack().Push(),
            this._scopeParent.SetFunctionParameters(f))
          : this._scopeParent.EvaluateFunctionParameters(f)
        : h && d.GetLocalVarStack().Push();
    }
    RunAsFunctionCall(d, f) {
      let h, g;
      const k = 0 < d.length,
        m = this._eventStack,
        q = this._runtime.GetEventSheetManager(),
        v = 1 < q._IncTriggerDepth();
      this._EvaluateFunctionCallParameters(q, f, v);
      k && q.PushCleanSol(d);
      f = m.Push(this);
      if (this._CheckParentsOKToRun(f)) {
        f.SetCurrentEvent(this);
        const r = this._scopeParent.IsAsync();
        r && ([g, h] = this._scopeParent.StartAsyncFunctionCall());
        this._RunAndBlock(f);
        r && this._scopeParent.MaybeFinishAsyncFunctionCall(g);
      }
      m.Pop();
      v && q.GetLocalVarStack().Pop();
      k && q.PopSol(d);
      q._DecTriggerDepth();
      return h;
    }
    *DebugRunAsFunctionCall(d, f) {
      let h, g;
      if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
        yield this;
      const k = 0 < d.length,
        m = this._eventStack,
        q = this._runtime.GetEventSheetManager(),
        v = 1 < q._IncTriggerDepth();
      this._EvaluateFunctionCallParameters(q, f, v);
      k && q.PushCleanSol(d);
      f = m.Push(this);
      if (yield* this._DebugCheckParentsOKToRun(f)) {
        f.SetCurrentEvent(this);
        const r = this._scopeParent.IsAsync();
        r && ([g, h] = this._scopeParent.StartAsyncFunctionCall());
        yield* this._DebugRunAndBlock(f);
        r && this._scopeParent.MaybeFinishAsyncFunctionCall(g);
      }
      m.Pop();
      v && q.GetLocalVarStack().Pop();
      k && q.PopSol(d);
      q._DecTriggerDepth();
      return h;
    }
    RunAsMappedFunctionCall(d) {
      const f = this.GetSolModifiersIncludingParents(),
        h = 0 < f.length,
        g = this._eventStack,
        k = this._runtime.GetEventSheetManager(),
        m = 1 < k._IncTriggerDepth();
      m && k.GetLocalVarStack().Push();
      this._scopeParent.SetFunctionParameters(d);
      h && k.PushCleanSol(f);
      d = g.Push(this);
      this._CheckParentsOKToRun(d) &&
        (d.SetCurrentEvent(this), this._RunAndBlock(d));
      g.Pop();
      m && k.GetLocalVarStack().Pop();
      h && k.PopSol(f);
      k._DecTriggerDepth();
    }
    *DebugRunAsMappedFunctionCall(d) {
      if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
        yield this;
      const f = this.GetSolModifiersIncludingParents(),
        h = 0 < f.length,
        g = this._eventStack,
        k = this._runtime.GetEventSheetManager(),
        m = 1 < k._IncTriggerDepth();
      m && k.GetLocalVarStack().Push();
      this._scopeParent.SetFunctionParameters(d);
      h && k.PushCleanSol(f);
      d = g.Push(this);
      if (yield* this._DebugCheckParentsOKToRun(d))
        d.SetCurrentEvent(this), yield* this._DebugRunAndBlock(d);
      g.Pop();
      m && k.GetLocalVarStack().Pop();
      h && k.PopSol(f);
      k._DecTriggerDepth();
    }
    RunAsExpressionFunctionCall(d, f, h, ...g) {
      let k, m;
      const q = 0 < d.length,
        v = this._runtime,
        r = this._eventStack,
        n = v.GetEventSheetManager(),
        p = 1 < n._IncTriggerDepth();
      p && n.GetLocalVarStack().Push();
      0 < g.length && this._scopeParent.SetFunctionParameters(g);
      q && n.PushCleanSol(d);
      g = r.Push(this);
      g.InitCallFunctionExpression(f, h);
      r.PushExpFunc(g);
      v.SetDebuggingEnabled(!1);
      this._CheckParentsOKToRun(g) &&
        (g.SetCurrentEvent(this),
        (f = this._scopeParent.IsAsync()) &&
          ([m, k] = this._scopeParent.StartAsyncFunctionCall()),
        this._RunAndBlock(g),
        f && this._scopeParent.MaybeFinishAsyncFunctionCall(m));
      v.SetDebuggingEnabled(!0);
      r.Pop();
      r.PopExpFunc();
      p && n.GetLocalVarStack().Pop();
      q && n.PopSol(d);
      n._DecTriggerDepth();
      return k || g.GetFunctionReturnValue();
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = [];
  let a = !1;
  e.EventScript = class extends e.DefendedBase {
    constructor(c, d, f) {
      super();
      const h = c.GetRuntime(),
        g = c.GetEventSheetManager();
      this._eventSheet = c;
      this._eventSheetManager = g;
      this._runtime = c.GetRuntime();
      this._parent = d;
      this._func = h.GetObjectReference(f[1]);
      this._displayNumber = f[2];
      this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);
      this._debugData = h.IsDebug()
        ? { isBreakpoint: f[3][0], isBreakable: f[3][1] }
        : null;
    }
    static Create(c, d, f) {
      return e.New(e.EventScript, c, d, f);
    }
    _PostInit() {
      const c = this._func,
        d = this._runtime
          .GetEventSheetManager()
          ._GetLocalVariablesScriptInterface(this);
      this._func = c.bind(null, this._runtime.GetIRuntime(), d);
    }
    GetParent() {
      return this._parent;
    }
    GetScopeParent() {
      return this._parent;
    }
    GetEventSheet() {
      return this._eventSheet;
    }
    GetDisplayNumber() {
      return this._displayNumber;
    }
    IsDebugBreakable() {
      return this._debugData && this._debugData.isBreakable;
    }
    IsDebugBreakpoint() {
      return this.IsDebugBreakable() && this._debugData.isBreakpoint;
    }
    _SetDebugBreakpoint(c) {
      this._debugData.isBreakpoint = !!c;
    }
    IsElseBlock() {
      return !1;
    }
    GetSolModifiers() {
      return b;
    }
    GetSolModifiersIncludingParents() {
      return this._parent ? this._parent.GetSolModifiersIncludingParents() : b;
    }
    Run(c) {
      c.SetCurrentEvent(this);
      this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript());
    }
    async _RunUserScript() {
      try {
        await this._func();
      } catch (c) {
        console.error(
          `Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`,
          "font-size: 1.2em; font-weight: bold;",
          c
        ),
          self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
          a ||
            (console.info(
              "%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()",
              "font-weight: bold; text-decoration: underline",
              "",
              "font-weight: bold"
            ),
            (a = !0));
      }
    }
    *DebugRun(c) {
      c.SetCurrentEvent(this);
      if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
        yield this;
      this.Run(c);
    }
    DebugCanRunFast() {
      return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext();
    }
    static HadUserScriptException() {
      return a;
    }
    static SetHadUserScriptException() {
      a = !0;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.FunctionBlock = class extends e.DefendedBase {
    constructor(b, a, c) {
      super();
      this._eventSheet = b;
      this._runtime = b.GetRuntime();
      this._parent = a;
      const d = c[1];
      this._functionName = d[0];
      this._returnType = d[1];
      this._functionParameters = d[2].map((f) =>
        e.EventVariable.Create(b, this, f)
      );
      this._isEnabled = d[3];
      this._innerLocalVariables = [];
      this._isAsync = d[4];
      this._nextAsyncId = 0;
      this._currentAsyncId = -1;
      this._asyncMap = new Map();
      this._eventBlock = e.EventBlock.Create(b, a, c);
      this._eventBlock._SetScopeParent(this);
    }
    static Create(b, a, c) {
      return e.New(e.FunctionBlock, b, a, c);
    }
    _PostInit() {
      for (const b of this._functionParameters) b._PostInit();
      this._eventBlock._PostInit(!1);
    }
    _GetAllLocalVariablesInScope() {
      return this._functionParameters;
    }
    GetFunctionParameters() {
      return this._functionParameters;
    }
    GetFunctionParameterCount() {
      return this._functionParameters.length;
    }
    _RegisterLocalVariable(b) {
      this._innerLocalVariables.push(b);
    }
    _GetAllInnerLocalVariables() {
      return this._innerLocalVariables;
    }
    EvaluateFunctionParameters(b) {
      const a = this._functionParameters;
      for (let c = 0, d = a.length; c < d; ++c) a[c].SetValue(b[c].Get(0));
    }
    SetFunctionParameters(b) {
      const a = this._functionParameters;
      for (let c = 0, d = a.length; c < d; ++c) a[c].SetValue(b[c]);
    }
    CaptureFunctionParameters() {
      return this._functionParameters.map((b) => b.GetValue());
    }
    GetParent() {
      return this._parent;
    }
    GetScopeParent() {
      return this._parent;
    }
    GetFunctionName() {
      return this._functionName;
    }
    GetReturnType() {
      return this._returnType;
    }
    IsEnabled() {
      return this._isEnabled;
    }
    GetDefaultReturnValue() {
      switch (this._returnType) {
        case 0:
          return null;
        case 2:
          return "";
        default:
          return 0;
      }
    }
    GetEventBlock() {
      return this._eventBlock;
    }
    IsAsync() {
      return this._isAsync;
    }
    StartAsyncFunctionCall() {
      const b = this._nextAsyncId++;
      this._currentAsyncId = b;
      let a;
      const c = new Promise((d) => (a = d));
      this._asyncMap.set(b, { resolve: a, pauseCount: 0 });
      return [b, c];
    }
    MaybeFinishAsyncFunctionCall(b) {
      const a = this._asyncMap.get(b);
      0 === a.pauseCount && (a.resolve(), this._asyncMap.delete(b));
      this._currentAsyncId = -1;
    }
    PauseCurrentAsyncFunction() {
      this._asyncMap.get(this._currentAsyncId).pauseCount++;
      return this._currentAsyncId;
    }
    ResumeAsyncFunction(b) {
      this._currentAsyncId = b;
      this._asyncMap.get(b).pauseCount--;
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = [];
  e.EventVariable = class extends e.DefendedBase {
    constructor(a, c, d) {
      super();
      const f = a.GetEventSheetManager();
      this._eventSheet = a;
      this._eventSheetManager = f;
      this._runtime = a.GetRuntime();
      this._parent = c;
      this._localVarStack = f.GetLocalVarStack();
      this._name = d[1];
      this._type = d[2];
      this._initialValue = d[3];
      this._isStatic = !!d[4];
      this._isConstant = !!d[5];
      this._isFunctionParameter = c instanceof e.FunctionBlock;
      this._sid = d[6];
      this._jsPropName = this._runtime.GetJsPropName(d[8]);
      this._scriptSetter = (h) => this.SetValue(h);
      this._scriptGetter = () => this.GetValue();
      this._hasSingleValue =
        !this._parent || this._isStatic || this._isConstant;
      this._value = this._initialValue;
      this._localIndex = -1;
      this.IsBoolean() && (this._value = this._value ? 1 : 0);
      !this.IsLocal() ||
        this.IsStatic() ||
        this.IsConstant() ||
        (this._localIndex = f._GetNextLocalVarIndex(this));
      f._RegisterEventVariable(this);
    }
    static Create(a, c, d) {
      return e.New(e.EventVariable, a, c, d);
    }
    _PostInit() {
      if (
        this.IsLocal() &&
        !this.IsStatic() &&
        !this.IsConstant() &&
        !this.IsFunctionParameter()
      ) {
        const a = this._eventSheetManager.FindFirstFunctionBlockParent(this);
        a && a._RegisterLocalVariable(this);
      }
    }
    GetName() {
      return this._name;
    }
    GetJsPropName() {
      return this._jsPropName;
    }
    GetParent() {
      return this._parent;
    }
    GetScopeParent() {
      return this.GetParent();
    }
    IsGlobal() {
      return !this.GetParent();
    }
    IsLocal() {
      return !this.IsGlobal();
    }
    IsFunctionParameter() {
      return this._isFunctionParameter;
    }
    IsStatic() {
      return this._isStatic;
    }
    IsConstant() {
      return this._isConstant;
    }
    IsNumber() {
      return 0 === this._type;
    }
    IsString() {
      return 1 === this._type;
    }
    IsBoolean() {
      return 2 === this._type;
    }
    IsElseBlock() {
      return !1;
    }
    GetSID() {
      return this._sid;
    }
    GetInitialValue() {
      return this._initialValue;
    }
    GetSolModifiers() {
      return b;
    }
    Run(a) {
      !this.IsLocal() ||
        this.IsStatic() ||
        this.IsConstant() ||
        this.SetValue(this.GetInitialValue());
    }
    DebugCanRunFast() {
      return !0;
    }
    *DebugRun(a) {
      this.Run(a);
    }
    SetValue(a) {
      this.IsNumber()
        ? "number" !== typeof a && (a = parseFloat(a))
        : this.IsString()
        ? "string" !== typeof a && (a = a.toString())
        : this.IsBoolean() && (a = a ? 1 : 0);
      this._hasSingleValue
        ? (this._value = a)
        : (this._localVarStack.GetCurrent()[this._localIndex] = a);
    }
    GetValue() {
      return this._hasSingleValue
        ? this._value
        : this._localVarStack.GetCurrent()[this._localIndex];
    }
    GetTypedValue() {
      let a = this.GetValue();
      this.IsBoolean() && (a = !!a);
      return a;
    }
    ResetToInitialValue() {
      this._value = this._initialValue;
    }
    _GetScriptInterfaceDescriptor() {
      return {
        configurable: !1,
        enumerable: !0,
        get: this._scriptGetter,
        set: this._scriptSetter,
      };
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = [];
  e.EventInclude = class extends e.DefendedBase {
    constructor(a, c, d) {
      super();
      const f = a.GetEventSheetManager();
      this._eventSheet = a;
      this._eventSheetManager = f;
      this._runtime = a.GetRuntime();
      this._parent = c;
      this._includeSheet = null;
      this._includeSheetName = d[1];
      this._isActive = !0;
    }
    static Create(a, c, d) {
      return e.New(e.EventInclude, a, c, d);
    }
    _PostInit() {
      this._includeSheet = this._eventSheetManager.GetEventSheetByName(
        this._includeSheetName
      );
      this._eventSheet._AddShallowInclude(this);
      let a = this.GetParent();
      for (; a; )
        a instanceof e.EventBlock &&
          a.IsGroup() &&
          a._AddContainedInclude(this),
          (a = a.GetParent());
      this.UpdateActive();
      this._runtime.IsDebug() &&
        this._eventSheet
          ._GetPerfRecord()
          .children.push(this._includeSheet._GetPerfRecord());
    }
    GetParent() {
      return this._parent;
    }
    GetSolModifiers() {
      return b;
    }
    GetIncludeSheet() {
      return this._includeSheet;
    }
    Run(a) {
      a = !!this.GetParent();
      const c = this._runtime.GetAllObjectClasses();
      a && this._eventSheetManager.PushCleanSol(c);
      this._includeSheet.Run();
      a && this._eventSheetManager.PopSol(c);
    }
    *DebugRun(a) {
      a = !!this.GetParent();
      const c = this._runtime.GetAllObjectClasses();
      a && this._eventSheetManager.PushCleanSol(c);
      yield* this._includeSheet.DebugRun();
      a && this._eventSheetManager.PopSol(c);
    }
    DebugCanRunFast() {
      return !1;
    }
    IsActive() {
      return this._isActive;
    }
    UpdateActive() {
      let a = this.GetParent();
      for (; a; ) {
        if (a instanceof e.EventBlock && a.IsGroup() && !a.IsGroupActive()) {
          this._isActive = !1;
          return;
        }
        a = a.GetParent();
      }
      this._isActive = !0;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.ExpNode = class extends e.DefendedBase {
    constructor(k) {
      super();
      this._owner = k;
      this._runtime = k.GetRuntime();
    }
    _PostInit() {}
    static CreateNode(k, m) {
      return e.New([h, d, f, g, b, a][m[0]], k, m);
    }
  };
  class b extends e.ExpNode {
    constructor(k, m) {
      super(k);
      this._systemPlugin = this._runtime.GetSystemPlugin();
      this._func = this._runtime.GetObjectReference(m[1]);
      (this._func !== e.Plugins.System.Exps.random &&
        this._func !== e.Plugins.System.Exps.choose) ||
        this._owner.SetVariesPerInstance();
    }
    GetBoundMethod() {
      return this._systemPlugin._GetBoundACEMethod(
        this._func,
        this._systemPlugin
      );
    }
  }
  class a extends e.ExpNode {
    constructor(k, m) {
      super(k);
      this._functionBlock = null;
      this._functionName = m[1];
      this._owner.SetVariesPerInstance();
    }
    _PostInit() {
      const k = this._runtime.GetEventSheetManager();
      this._functionBlock = k.GetFunctionBlockByName(this._functionName);
      this._functionName = null;
      const m = this._owner.GetEventBlock(),
        q = this._functionBlock.GetEventBlock();
      this._combinedSolModifiers = [
        ...new Set([
          ...m.GetSolModifiersIncludingParents(),
          ...q.GetSolModifiersIncludingParents(),
        ]),
      ];
      this._combinedSolModifiers = k._DeduplicateSolModifierList(
        this._combinedSolModifiers
      );
    }
    GetBoundMethod() {
      const k = this._functionBlock;
      if (k.IsEnabled()) {
        const m = k.GetEventBlock();
        return e.EventBlock.prototype.RunAsExpressionFunctionCall.bind(
          m,
          this._combinedSolModifiers,
          k.GetReturnType(),
          k.GetDefaultReturnValue()
        );
      }
      {
        const m = k.GetDefaultReturnValue();
        return () => m;
      }
    }
  }
  function c(k, m) {
    if (k >= m) return k % m;
    0 > k && (k <= -m && (k %= m), 0 > k && (k += m));
    return k;
  }
  class d extends e.ExpNode {
    constructor(k, m) {
      super(k);
      this._objectClass = this._runtime.GetObjectClassByIndex(m[1]);
      this._func = this._runtime.GetObjectReference(m[2]);
      this._returnsString = !!m[3];
      this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
      this._owner._MaybeVaryFor(this._objectClass);
    }
    GetBoundMethod() {
      return this._objectClass
        .GetPlugin()
        ._GetBoundACEMethod(
          this._func,
          this._objectClass.GetSingleGlobalInstance().GetSdkInstance()
        );
    }
    ExpObject(...k) {
      const m = this._objectClass,
        q = m.GetCurrentSol().GetExpressionInstances();
      var v = q.length;
      if (0 === v) return this._returnsString ? "" : 0;
      v = c(this._owner.GetSolIndex(), v);
      this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(m);
      return this._func.apply(q[v].GetSdkInstance(), k);
    }
    ExpObject_InstExpr(k, ...m) {
      const q = this._objectClass,
        v = q.GetInstances(),
        r = v.length;
      if (0 === r) return this._returnsString ? "" : 0;
      k = c(k, r);
      this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(q);
      return this._func.apply(v[k].GetSdkInstance(), m);
    }
  }
  class f extends e.ExpNode {
    constructor(k, m) {
      super(k);
      this._objectClass = this._runtime.GetObjectClassByIndex(m[1]);
      this._varIndex = m[3];
      this._returnsString = !!m[2];
      this._owner._MaybeVaryFor(this._objectClass);
    }
    ExpInstVar() {
      const k = this._objectClass.GetCurrentSol().GetExpressionInstances();
      var m = k.length;
      if (0 === m) return this._returnsString ? "" : 0;
      m = c(this._owner.GetSolIndex(), m);
      return k[m]._GetInstanceVariableValueUnchecked(this._varIndex);
    }
    ExpInstVar_Family() {
      var k = this._objectClass,
        m = k.GetCurrentSol().GetExpressionInstances(),
        q = m.length;
      if (0 === q) return this._returnsString ? "" : 0;
      q = c(this._owner.GetSolIndex(), q);
      m = m[q];
      k = m
        .GetObjectClass()
        .GetFamilyInstanceVariableOffset(k.GetFamilyIndex());
      return m._GetInstanceVariableValueUnchecked(this._varIndex + k);
    }
    ExpInstVar_InstExpr(k) {
      const m = this._objectClass;
      var q = m.GetInstances();
      const v = q.length;
      if (0 === v) return this._returnsString ? "" : 0;
      k = c(k, v);
      q = q[k];
      k = 0;
      m.IsFamily() &&
        (k = q
          .GetObjectClass()
          .GetFamilyInstanceVariableOffset(m.GetFamilyIndex()));
      return q._GetInstanceVariableValueUnchecked(this._varIndex + k);
    }
  }
  class h extends e.ExpNode {
    constructor(k, m) {
      super(k);
      this._objectClass = this._runtime.GetObjectClassByIndex(m[1]);
      this._behaviorType = this._objectClass.GetBehaviorTypeByName(m[2]);
      this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(m[2]);
      this._func = this._runtime.GetObjectReference(m[3]);
      this._returnsString = !!m[4];
      this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
      this._owner._MaybeVaryFor(this._objectClass);
    }
    ExpBehavior(...k) {
      const m = this._objectClass;
      var q = m.GetCurrentSol().GetExpressionInstances(),
        v = q.length;
      if (0 === v) return this._returnsString ? "" : 0;
      v = c(this._owner.GetSolIndex(), v);
      this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(m);
      q = q[v];
      v = 0;
      m.IsFamily() &&
        (v = q.GetObjectClass().GetFamilyBehaviorOffset(m.GetFamilyIndex()));
      return this._func.apply(
        q.GetBehaviorInstances()[this._behaviorIndex + v].GetSdkInstance(),
        k
      );
    }
    ExpBehavior_InstExpr(k, ...m) {
      const q = this._objectClass;
      var v = q.GetInstances();
      const r = v.length;
      if (0 === r) return this._returnsString ? "" : 0;
      k = c(k, r);
      this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(q);
      v = v[k];
      k = 0;
      q.IsFamily() &&
        (k = v.GetObjectClass().GetFamilyBehaviorOffset(q.GetFamilyIndex()));
      return this._func.apply(
        v.GetBehaviorInstances()[this._behaviorIndex + k].GetSdkInstance(),
        m
      );
    }
  }
  class g extends e.ExpNode {
    constructor(k, m) {
      super(k);
      this._eventVar = null;
      this._eventVarSid = m[1];
    }
    _PostInit() {
      this._eventVar = this._runtime
        .GetEventSheetManager()
        .GetEventVariableBySID(this._eventVarSid);
    }
    GetVar() {
      return this._eventVar;
    }
  }
}
{
  ("use strict");
  const e = self.C3;
  e.Parameter = class extends e.DefendedBase {
    constructor(B, E, z) {
      super();
      this._owner = B;
      this._index = z;
      this._type = E;
      this.Get = null;
      this._isConstant = this._variesPerInstance = !1;
    }
    static Create(B, E, z) {
      const D = E[0];
      return e.New(
        [a, c, q, f, g, d, k, a, f, f, v, r, q, p, c, m, h, n, u, w, y][D],
        B,
        D,
        z,
        E
      );
    }
    _PostInit() {}
    SetVariesPerInstance() {
      this._variesPerInstance = !0;
    }
    _MaybeVaryFor(B) {
      this._variesPerInstance ||
        !B ||
        B.GetPlugin().IsSingleGlobal() ||
        (this._variesPerInstance = !0);
    }
    VariesPerInstance() {
      return this._variesPerInstance;
    }
    GetIndex() {
      return this._index;
    }
    GetRuntime() {
      return this._owner.GetRuntime();
    }
    GetEventBlock() {
      return this._owner.GetEventBlock();
    }
    IsConstant() {
      return this._isConstant;
    }
  };
  function b(B) {
    B = self.C3_ExpressionFuncs[B];
    if (!B) throw Error("invalid expression number");
    return B;
  }
  class a extends e.Parameter {
    constructor(B, E, z, D) {
      super(B, E, z);
      this._solIndex = 0;
      B = D[1];
      this._expressionNumber = B[0];
      this._numberedNodes = [];
      this._expressionFunc = null;
      for (let J = 1, C = B.length; J < C; ++J)
        this._numberedNodes.push(e.ExpNode.CreateNode(this, B[J]));
      this._numberedNodes.length
        ? (this.Get = this.GetExpression)
        : ((this.Get = b(this._expressionNumber)), (this._isConstant = !0));
    }
    _GetNode(B) {
      if (0 > B || B >= this._numberedNodes.length)
        throw new RangeError("invalid numbered node");
      return this._numberedNodes[B];
    }
    _PostInit() {
      for (var B of this._numberedNodes) B._PostInit();
      B = b(this._expressionNumber);
      this._expressionFunc = this._numberedNodes.length ? B(this) : B;
    }
    GetSolIndex() {
      return this._solIndex;
    }
    GetExpression(B) {
      this._solIndex = B;
      return this._expressionFunc();
    }
  }
  class c extends a {
    constructor(B, E, z, D) {
      super(B, E, z, D);
      this.Get = this.GetStringExpression;
      14 === E &&
        (this.GetEventBlock().SetAllSolModifiers(),
        this._owner instanceof e.Action &&
          this.GetEventBlock().SetSolWriterAfterCnds());
    }
    GetStringExpression(B) {
      this._solIndex = B;
      B = this._expressionFunc();
      return "string" === typeof B ? B : "";
    }
    _GetFastTriggerValue() {
      return b(this._expressionNumber)();
    }
  }
  class d extends a {
    constructor(B, E, z, D) {
      super(B, E, z, D);
      this.Get = this.GetLayer;
      this._isConstant = !1;
    }
    GetLayer(B) {
      this._solIndex = B;
      B = this._expressionFunc();
      return this.GetRuntime().GetCurrentLayout().GetLayer(B);
    }
  }
  class f extends e.Parameter {
    constructor(B, E, z, D) {
      super(B, E, z);
      this._combo = D[1];
      this.Get = this.GetCombo;
      this._isConstant = !0;
    }
    GetCombo() {
      return this._combo;
    }
  }
  class h extends e.Parameter {
    constructor(B, E, z, D) {
      super(B, E, z);
      this._bool = D[1];
      this.Get = this.GetBoolean;
      this._isConstant = !0;
    }
    GetBoolean() {
      return this._bool;
    }
  }
  class g extends e.Parameter {
    constructor(B, E, z, D) {
      super(B, E, z);
      this._objectClass = this.GetRuntime().GetObjectClassByIndex(D[1]);
      this.Get = this.GetObjectClass;
      B = this.GetEventBlock();
      B._AddSolModifier(this._objectClass);
      this._owner instanceof e.Action
        ? B.SetSolWriterAfterCnds()
        : B.GetParent() && B.GetParent().SetSolWriterAfterCnds();
      this._isConstant = !0;
    }
    GetObjectClass() {
      return this._objectClass;
    }
  }
  class k extends e.Parameter {
    constructor(B, E, z, D) {
      super(B, E, z);
      this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(D[1]);
      this.Get = this.GetLayout;
      this._isConstant = !0;
    }
    GetLayout() {
      return this._layout;
    }
  }
  class m extends e.Parameter {
    constructor(B, E, z, D) {
      super(B, E, z);
      this._timeline = this.GetRuntime()
        .GetTimelineManager()
        .GetTimelineByName(D[1]);
      this.Get = this.GetTimeline;
      this._isConstant = !0;
    }
    GetTimeline() {
      return this._timeline;
    }
  }
  class q extends e.Parameter {
    constructor(B, E, z, D) {
      super(B, E, z);
      this._fileInfo = D[1];
      this.Get = this.GetFile;
      this._isConstant = !0;
    }
    GetFile() {
      return this._fileInfo;
    }
  }
  class v extends e.Parameter {
    constructor(B, E, z, D) {
      super(B, E, z);
      this._instVarIndex = D[1];
      (B = this._owner.GetObjectClass()) && B.IsFamily()
        ? ((this.Get = this.GetFamilyInstanceVariable),
          this.SetVariesPerInstance())
        : ((this.Get = this.GetInstanceVariable), (this._isConstant = !0));
    }
    GetInstanceVariable() {
      return this._instVarIndex;
    }
    GetFamilyInstanceVariable(B) {
      B = B || 0;
      const E = this._owner.GetObjectClass();
      var z = E.GetCurrentSol();
      const D = z.GetInstances();
      if (D.length) B = D[B % D.length].GetObjectClass();
      else if (z.HasAnyElseInstances())
        (z = z.GetElseInstances()), (B = z[B % z.length].GetObjectClass());
      else if (0 < E.GetInstanceCount())
        (z = E.GetInstances()), (B = z[B % z.length].GetObjectClass());
      else return 0;
      return (
        this._instVarIndex +
        B.GetFamilyInstanceVariableOffset(E.GetFamilyIndex())
      );
    }
  }
  class r extends e.Parameter {
    constructor(B, E, z, D) {
      super(B, E, z);
      this._eventVarSid = D[1];
      this._eventVar = null;
      this.Get = this.GetEventVariable;
      this._isConstant = !0;
    }
    _PostInit() {
      this._eventVar = this.GetRuntime()
        .GetEventSheetManager()
        .GetEventVariableBySID(this._eventVarSid);
    }
    GetEventVariable() {
      return this._eventVar;
    }
  }
  class n extends e.Parameter {
    constructor(B, E, z, D) {
      super(B, E, z);
      this._functionBlockName = D[1];
      this._functionBlock = null;
      this.Get = this.GetFunction;
      this._isConstant = !0;
    }
    _PostInit() {
      this._functionBlock = this.GetRuntime()
        .GetEventSheetManager()
        .GetFunctionBlockByName(this._functionBlockName);
      this._functionBlockName = null;
    }
    GetFunction() {
      return this._functionBlock;
    }
  }
  class p extends e.Parameter {
    constructor(B, E, z, D) {
      super(B, E, z);
      this._subParams = [];
      this._variadicRet = [];
      this._isConstant = !0;
      for (let J = 1, C = D.length; J < C; ++J)
        (B = e.Parameter.Create(this._owner, D[J], 0)),
          this._subParams.push(B),
          this._variadicRet.push(0),
          B.IsConstant() || (this._isConstant = !1);
      this.Get = this.GetVariadic;
    }
    _PostInit() {
      for (const B of this._subParams) B._PostInit();
    }
    GetVariadic() {
      const B = this._subParams,
        E = this._variadicRet;
      for (let z = 0, D = B.length; z < D; ++z) E[z] = B[z].Get(0);
      return E;
    }
  }
  class u extends e.Parameter {
    constructor(B, E, z, D) {
      super(B, E, z);
      this._easeIndex = D[1];
      this.Get = this.GetEase;
      this._isConstant = !0;
    }
    GetEase() {
      return this._easeIndex;
    }
  }
  class w extends e.Parameter {
    constructor(B, E, z, D) {
      super(B, E, z);
      this._brushIndex = D[1];
      this.Get = this.GetTilemapBrush;
      this._isConstant = !0;
    }
    GetTilemapBrush() {
      return this._brushIndex;
    }
  }
  class y extends a {
    constructor(B, E, z, D) {
      super(B, E, z, D);
      this.Get = this.GetTemplateName;
      this._isConstant = !1;
    }
    GetTemplateName() {
      return this._expressionFunc();
    }
  }
}
{
  ("use strict");
  const e = self.C3;
  function b(d, f) {
    for (let h = 0, g = d.length; h < g; ++h) f[h] = d[h].Get(0);
  }
  const a = [],
    c = function () {};
  e.Condition = class extends e.DefendedBase {
    constructor(d, f, h) {
      super();
      this._eventBlock = d;
      this._runtime = d.GetRuntime();
      this._index = h;
      this._func = this._runtime.GetObjectReference(f[1]);
      this._isTrigger = 0 < f[3];
      this._isFastTrigger = 2 === f[3];
      this._isLooping = !!f[4];
      this._isInverted = !!f[5];
      this._isStatic = !!f[6];
      this._sid = f[7];
      this._isInOrBlock = this._eventBlock.IsOrBlock();
      this._behaviorType = this._objectClass = null;
      this._behaviorIndex = -1;
      this._systemPlugin = null;
      this.DebugRun = this.Run = c;
      this._parameters = [];
      this._results = [];
      this._anyParamVariesPerInstance = !1;
      this._unsavedData = this._savedData = null;
      this._debugData = this._runtime.IsDebug()
        ? { isBreakpoint: f[8][0], canDebug: f[8][1] }
        : null;
      -1 === f[0]
        ? (this._systemPlugin = this._runtime.GetSystemPlugin())
        : ((this._objectClass = this._runtime.GetObjectClassByIndex(f[0])),
          f[2] &&
            ((this._behaviorType = this._objectClass.GetBehaviorTypeByName(
              f[2]
            )),
            (this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(
              f[2]
            ))),
          this._eventBlock.GetParent() &&
            this._eventBlock.GetParent().SetSolWriterAfterCnds());
      if (10 === f.length) {
        d = f[9];
        for (let g of d)
          this._parameters.push(
            e.Parameter.Create(this, g, this._parameters.length)
          ),
            this._results.push(0);
      }
      0 === this._parameters.length && (this._results = this._parameters = a);
      this._eventBlock.GetEventSheetManager()._RegisterCondition(this);
    }
    static Create(d, f, h) {
      return e.New(e.Condition, d, f, h);
    }
    _PostInit() {
      for (const d of this._parameters)
        d._PostInit(),
          d.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
      this._isFastTrigger
        ? ((this.Run = this._RunFastTrigger),
          (this.DebugRun = this._DebugRunFastTrigger))
        : this._systemPlugin
        ? (this._SetSystemRunMethod(), (this.DebugRun = this._DebugRunSystem))
        : this._objectClass.GetPlugin().IsSingleGlobal()
        ? (this._SetSingleGlobalRunMethod(),
          (this.DebugRun = this._DebugRunSingleGlobal))
        : this._isStatic
        ? ((this.Run = this._RunStatic), (this.DebugRun = this._DebugRunStatic))
        : ((this.Run = this._RunObject),
          (this.DebugRun = this._DebugRunObject));
    }
    _SetSystemRunMethod() {
      this._SetRunMethodForBoundFunc(
        this._systemPlugin,
        this._systemPlugin,
        this._RunSystem
      );
    }
    _SetSingleGlobalRunMethod() {
      const d = this._objectClass.GetPlugin(),
        f = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
      this._SetRunMethodForBoundFunc(d, f, this._RunSingleGlobal);
    }
    _SetRunMethodForBoundFunc(d, f, h) {
      const g = this._func,
        k = this._isInverted,
        m = this._parameters;
      if (0 === m.length) {
        const q = d._GetBoundACEMethod(g, f);
        this.Run = k
          ? function () {
              return e.xor(q(), k);
            }
          : q;
      } else if (1 === m.length) {
        const q = m[0];
        if (!k && q.IsConstant())
          this.Run = d._GetBoundACEMethod_1param(g, f, q.Get(0));
        else {
          const v = d._GetBoundACEMethod(g, f);
          this.Run = function () {
            return e.xor(v(q.Get(0)), k);
          };
        }
      } else if (2 === m.length) {
        const q = m[0],
          v = m[1];
        if (!k && q.IsConstant() && v.IsConstant())
          this.Run = d._GetBoundACEMethod_2params(g, f, q.Get(0), v.Get(0));
        else {
          const r = d._GetBoundACEMethod(g, f);
          this.Run = function () {
            return e.xor(r(q.Get(0), v.Get(0)), k);
          };
        }
      } else if (3 === m.length) {
        const q = m[0],
          v = m[1],
          r = m[2];
        if (!k && q.IsConstant() && v.IsConstant() && r.IsConstant())
          this.Run = d._GetBoundACEMethod_3params(
            g,
            f,
            q.Get(0),
            v.Get(0),
            r.Get(0)
          );
        else {
          const n = d._GetBoundACEMethod(g, f);
          this.Run = function () {
            return e.xor(n(q.Get(0), v.Get(0), r.Get(0)), k);
          };
        }
      } else this.Run = h;
    }
    GetSID() {
      return this._sid;
    }
    _GetFunc() {
      return this._func;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetBehaviorType() {
      return this._behaviorType;
    }
    GetEventBlock() {
      return this._eventBlock;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetIndex() {
      return this._index;
    }
    GetDebugIndex() {
      return this.GetIndex();
    }
    IsTrigger() {
      return this._isTrigger;
    }
    IsFastTrigger() {
      return this._isFastTrigger;
    }
    IsInverted() {
      return this._isInverted;
    }
    IsLooping() {
      return this._isLooping;
    }
    IsBreakpoint() {
      return this._debugData.isBreakpoint;
    }
    _SetBreakpoint(d) {
      this._debugData.isBreakpoint = !!d;
      this._eventBlock._UpdateCanRunFastRecursive();
    }
    _DebugReturnsGenerator() {
      return this._debugData.canDebug;
    }
    DebugCanRunFast() {
      return (
        !this.IsBreakpoint() &&
        !this._runtime.DebugBreakNext() &&
        !this._DebugReturnsGenerator()
      );
    }
    GetSavedDataMap() {
      this._savedData || (this._savedData = new Map());
      return this._savedData;
    }
    GetUnsavedDataMap() {
      this._unsavedData || (this._unsavedData = new Map());
      return this._unsavedData;
    }
    _RunSystem() {
      const d = this._results;
      b(this._parameters, d);
      return e.xor(this._func.apply(this._systemPlugin, d), this._isInverted);
    }
    *_DebugRunSystem() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      if (this._DebugReturnsGenerator()) {
        var d = this._results;
        b(this._parameters, d);
        d = this._func.apply(this._systemPlugin, d);
        e.IsIterator(d) && (d = yield* d);
        return e.xor(d, this._isInverted);
      }
      return this.Run();
    }
    _RunSingleGlobal() {
      const d = this._results;
      b(this._parameters, d);
      const f = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
      return e.xor(this._func.apply(f, d), this._isInverted);
    }
    *_DebugRunSingleGlobal() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      if (this._DebugReturnsGenerator()) {
        var d = this._results;
        b(this._parameters, d);
        const f = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
        d = this._func.apply(f, d);
        e.IsIterator(d) && (d = yield* d);
        return e.xor(d, this._isInverted);
      }
      return this.Run();
    }
    _RunFastTrigger() {
      return !0;
    }
    *_DebugRunFastTrigger() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      return !0;
    }
    _RunStatic() {
      var d = this._results;
      b(this._parameters, d);
      d = this._func.apply(this._behaviorType || this._objectClass, d);
      this._objectClass.ApplySolToContainer();
      return d;
    }
    *_DebugRunStatic() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      if (this._DebugReturnsGenerator()) {
        var d = this._results;
        b(this._parameters, d);
        d = this._func.apply(this._behaviorType || this._objectClass, d);
        e.IsIterator(d) && (d = yield* d);
        this._objectClass.ApplySolToContainer();
        return d;
      }
      return this.Run();
    }
    _RunObject() {
      const d = this._parameters,
        f = this._results,
        h = this._objectClass.GetCurrentSol();
      for (let g = 0, k = d.length; g < k; ++g) {
        const m = d[g];
        m.VariesPerInstance() || (f[g] = m.Get(0));
      }
      return h.IsSelectAll()
        ? this._RunObject_FirstFilter(h)
        : this._RunObject_NextFilter(h);
    }
    *_DebugRunObject() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      return this._RunObject();
    }
    _EvaluateVaryingParameters(d) {
      const f = this._parameters,
        h = this._results;
      for (let g = 0, k = f.length; g < k; ++g) {
        const m = f[g];
        m.VariesPerInstance() && (h[g] = m.Get(d));
      }
    }
    _RunObject_FirstFilter(d) {
      const f = this._objectClass,
        h = f.IsFamily(),
        g = f.GetFamilyIndex(),
        k = this._behaviorIndex,
        m = 0 <= k,
        q = f.GetInstances(),
        v = this._anyParamVariesPerInstance,
        r = this._results,
        n = this._func,
        p = this._isInverted,
        u = this._isInOrBlock && !this._isTrigger;
      d.ClearArrays();
      for (let y = 0, B = q.length; y < B; ++y) {
        const E = q[y];
        v && this._EvaluateVaryingParameters(y);
        var w = void 0;
        m
          ? ((w = h ? E.GetObjectClass().GetFamilyBehaviorOffset(g) : 0),
            (w = n.apply(E.GetBehaviorInstances()[k + w].GetSdkInstance(), r)))
          : (w = n.apply(E.GetSdkInstance(), r));
        e.xor(w, p) ? d._PushInstance(E) : u && d._PushElseInstance(E);
      }
      f.FinishCondition(!0);
      d._SetSelectAll(!1);
      f.ApplySolToContainer();
      return d.HasAnyInstances();
    }
    _RunObject_NextFilter(d) {
      const f = this._objectClass;
      var h = f.IsFamily();
      const g = f.GetFamilyIndex(),
        k = f.IsInContainer(),
        m = this._behaviorIndex,
        q = 0 <= m,
        v = this._anyParamVariesPerInstance,
        r = this._results,
        n = this._func,
        p = this._isInverted,
        u = this._isInOrBlock && !this._isTrigger,
        w = d._GetOwnInstances(),
        y = d._GetOwnElseInstances(),
        B = u && !this._eventBlock.IsFirstConditionOfType(this),
        E = B ? y : w;
      let z = 0,
        D = !1;
      for (let C = 0, H = E.length; C < H; ++C) {
        const K = E[C];
        v && this._EvaluateVaryingParameters(C);
        var J = void 0;
        q
          ? ((J = h ? K.GetObjectClass().GetFamilyBehaviorOffset(g) : 0),
            (J = n.apply(K.GetBehaviorInstances()[m + J].GetSdkInstance(), r)))
          : (J = n.apply(K.GetSdkInstance(), r));
        e.xor(J, p)
          ? ((D = !0),
            B
              ? (w.push(K), k && K._PushSiblingsToSolInstances())
              : ((E[z] = K), k && K._SetSiblingsToSolInstancesIndex(z), ++z))
          : B
          ? ((E[z] = K), k && K._SetSiblingsToSolElseInstancesIndex(z), ++z)
          : u && (y.push(K), k && K._PushSiblingsToSolElseInstances());
      }
      e.truncateArray(E, z);
      k && f._TruncateContainerSols(B, z);
      h = D;
      B && !D && (D = this._OrBlockCheckInstances(w));
      f.FinishCondition(h || u);
      return u ? D : d.HasAnyInstances();
    }
    _OrBlockCheckInstances(d) {
      var f = this._objectClass;
      const h = f.IsFamily();
      f = f.GetFamilyIndex();
      const g = this._anyParamVariesPerInstance,
        k = this._behaviorIndex,
        m = 0 <= k,
        q = this._results,
        v = this._func,
        r = this._isInverted;
      for (let p = 0, u = d.length; p < u; ++p) {
        var n = d[p];
        g && this._EvaluateVaryingParameters(p);
        if (m) {
          const w = h ? n.GetObjectClass().GetFamilyBehaviorOffset(f) : 0;
          n = v.apply(n.GetBehaviorInstances()[k + w].GetSdkInstance(), q);
        } else n = v.apply(n.GetSdkInstance(), q);
        if (e.xor(n, r)) return !0;
      }
      return !1;
    }
    ReevaluateParameter(d, f) {
      return this._parameters[d].Get(f);
    }
    GetFastTriggerValue() {
      const d = this._parameters;
      if (!d.length) throw Error("no parameters");
      return d[0]._GetFastTriggerValue();
    }
    _SaveToJson() {
      if (!this._savedData || !this._savedData.size) return null;
      const d = {};
      for (const [f, h] of this._savedData.entries()) {
        let g = h;
        "collmemory" === f &&
          (g = [...h.entries()].map((k) => [
            k[0].GetUID(),
            k[1].GetUID(),
            k[2],
          ]));
        d[f] = g;
      }
      return { ex: d };
    }
    _LoadFromJson(d) {
      this._savedData && (this._savedData.clear(), (this._savedData = null));
      if (d) {
        var f = this._runtime,
          h = d.ex;
        if (h) {
          d = this.GetSavedDataMap();
          d.clear();
          for (const [g, k] of Object.entries(h))
            (h = k),
              "collmemory" === g &&
                (h = e.New(
                  e.PairMap,
                  k
                    .map((m) => [
                      f.GetInstanceByUID(m[0]),
                      f.GetInstanceByUID(m[1]),
                      m[2],
                    ])
                    .filter((m) => m[0] && m[1])
                )),
              d.set(g, h);
        }
      }
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  function b(f, h) {
    for (let g = 0, k = f.length; g < k; ++g) h[g] = f[g].Get(0);
  }
  const a = [],
    c = function () {},
    d = function* () {};
  e.Action = class extends e.DefendedBase {
    constructor(f, h, g) {
      super();
      this._eventBlock = f;
      this._runtime = f = f.GetRuntime();
      this._index = g;
      this._sid = 4 <= h.length ? h[3] : -1;
      this._actionType = 5 <= h.length ? h[4] : 0;
      this._behaviorType = this._objectClass = this._func = null;
      this._behaviorIndex = -1;
      this._systemPlugin = null;
      this._callFunctionName = "";
      this._combinedSolModifiers = this._callEventBlock = null;
      this.DebugRun = this.Run = c;
      this._parameters = [];
      this._results = [];
      this._anyParamVariesPerInstance = !1;
      this._unsavedData = this._savedData = null;
      const k = (g = -3 === h[0]) ? h[2] : h[5];
      this._debugData =
        f.IsDebug() || g
          ? { isBreakpoint: k[0], canDebug: k[1], index: k[2] }
          : null;
      -1 === h[0]
        ? ((this._systemPlugin = f.GetSystemPlugin()),
          (this._func = f.GetObjectReference(h[1])))
        : -2 === h[0]
        ? (this._callFunctionName = h[1])
        : g
        ? ((this._func = f.GetObjectReference(h[1])),
          (this.Run = this.RunUserScript),
          (this.DebugRun = this.DebugRunUserScript),
          (this._actionType = 1))
        : ((this._func = f.GetObjectReference(h[1])),
          (this._objectClass = f.GetObjectClassByIndex(h[0])),
          h[2] &&
            ((this._behaviorType = this._objectClass.GetBehaviorTypeByName(
              h[2]
            )),
            (this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(
              h[2]
            ))));
      if (7 === h.length) {
        h = h[6];
        for (const m of h)
          this._parameters.push(
            e.Parameter.Create(this, m, this._parameters.length)
          ),
            this._results.push(0);
      }
      0 === this._parameters.length && (this._results = this._parameters = a);
      this._eventBlock.GetEventSheetManager()._RegisterAction(this);
    }
    static Create(f, h, g) {
      return e.New(e.Action, f, h, g);
    }
    _PostInit() {
      for (var f of this._parameters)
        f._PostInit(),
          f.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
      if (this._systemPlugin)
        this._SetSystemRunMethod(), (this.DebugRun = this._DebugRunSystem);
      else if (this._callFunctionName)
        this._SetCallFunctionRunMethod(), (this._callFunctionName = "");
      else if (this.Run === this.RunUserScript) {
        f = this._func;
        const h = this._runtime
          .GetEventSheetManager()
          ._GetLocalVariablesScriptInterface(this._eventBlock);
        this._func = f.bind(null, this._runtime.GetIRuntime(), h);
      } else
        this._behaviorType
          ? this.IsAsync()
            ? ((this.Run = this._RunBehavior_Async),
              (this.DebugRun = this._DebugRunBehavior_Async))
            : ((this.Run = this._RunBehavior),
              (this.DebugRun = this._DebugRunBehavior))
          : this._objectClass.GetPlugin().IsSingleGlobal()
          ? (this._SetSingleGlobalRunMethod(),
            (this.DebugRun = this._DebugRunSingleGlobal))
          : this.IsAsync()
          ? ((this.Run = this._RunObject_Async),
            (this.DebugRun = this._DebugRunObject_Async))
          : this.CallBeforeAfterHooks()
          ? ((this.Run = this._RunObject_BeforeAfterHooks),
            (this.DebugRun = this._DebugRunObject_BeforeAfterHooks))
          : this._parameters.length
          ? this._parameters.every((h) => h.VariesPerInstance())
            ? ((this.Run = this._RunObject_AllParamsVary),
              (this.DebugRun = this._DebugRunObject_AllParamsVary))
            : this._anyParamVariesPerInstance
            ? ((this.Run = this._RunObject_SomeParamsVary),
              (this.DebugRun = this._DebugRunObject_SomeParamsVary))
            : this._parameters.every((h) => h.IsConstant())
            ? (b(this._parameters, this._results),
              (this.Run = this._RunObject_ParamsConst),
              (this.DebugRun = this._DebugRunObject_ParamsConst))
            : ((this.Run = this._RunObject_ParamsDontVary),
              (this.DebugRun = this._DebugRunObject_ParamsDontVary))
          : ((this.Run = this._RunObject_ParamsConst),
            (this.DebugRun = this._DebugRunObject_ParamsConst));
    }
    _SetSystemRunMethod() {
      this._SetRunMethodForBoundFunc(
        this._systemPlugin,
        this._systemPlugin,
        this._RunSystem
      );
    }
    _SetSingleGlobalRunMethod() {
      const f = this._objectClass.GetPlugin(),
        h = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
      this._SetRunMethodForBoundFunc(f, h, this._RunSingleGlobal);
    }
    _SetCallFunctionRunMethod() {
      const f = this._eventBlock.GetEventSheetManager(),
        h = f.GetFunctionBlockByName(this._callFunctionName);
      h.IsEnabled()
        ? ((this._callEventBlock = h.GetEventBlock()),
          (this._combinedSolModifiers = [
            ...new Set([
              ...this._eventBlock.GetSolModifiersIncludingParents(),
              ...this._callEventBlock.GetSolModifiersIncludingParents(),
            ]),
          ]),
          (this._combinedSolModifiers = f._DeduplicateSolModifierList(
            this._combinedSolModifiers
          )),
          (this.Run = e.EventBlock.prototype.RunAsFunctionCall.bind(
            this._callEventBlock,
            this._combinedSolModifiers,
            this._parameters
          )),
          (this.DebugRun = this._DebugRunCallFunction))
        : ((this.Run = c), (this.DebugRun = d));
    }
    _SetRunMethodForBoundFunc(f, h, g) {
      const k = this._func,
        m = this._parameters;
      if (0 === m.length) this.Run = f._GetBoundACEMethod(k, h);
      else if (1 === m.length) {
        const q = m[0];
        if (q.IsConstant())
          this.Run = f._GetBoundACEMethod_1param(k, h, q.Get(0));
        else {
          const v = f._GetBoundACEMethod(k, h);
          this.Run = function () {
            return v(q.Get(0));
          };
        }
      } else if (2 === m.length) {
        const q = m[0],
          v = m[1];
        if (q.IsConstant() && v.IsConstant())
          this.Run = f._GetBoundACEMethod_2params(k, h, q.Get(0), v.Get(0));
        else {
          const r = f._GetBoundACEMethod(k, h);
          this.Run = function () {
            return r(q.Get(0), v.Get(0));
          };
        }
      } else if (3 === m.length) {
        const q = m[0],
          v = m[1],
          r = m[2];
        if (q.IsConstant() && v.IsConstant() && r.IsConstant())
          this.Run = f._GetBoundACEMethod_3params(
            k,
            h,
            q.Get(0),
            v.Get(0),
            r.Get(0)
          );
        else {
          const n = f._GetBoundACEMethod(k, h);
          this.Run = function () {
            return n(q.Get(0), v.Get(0), r.Get(0));
          };
        }
      } else this.Run = g;
    }
    GetSID() {
      return this._sid;
    }
    IsAsync() {
      return 1 === this._actionType;
    }
    CanBailOut() {
      return 2 === this._actionType;
    }
    CallBeforeAfterHooks() {
      return 3 === this._actionType;
    }
    HasReturnType() {
      return this.IsAsync() || this.CanBailOut();
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetEventBlock() {
      return this._eventBlock;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetIndex() {
      return this._index;
    }
    GetDebugIndex() {
      return this._debugData.index;
    }
    GetCombinedSolModifiers() {
      return this._combinedSolModifiers;
    }
    IsBreakpoint() {
      return this._debugData.isBreakpoint;
    }
    _SetBreakpoint(f) {
      this._debugData.isBreakpoint = !!f;
      this._eventBlock._UpdateCanRunFastRecursive();
    }
    _DebugReturnsGenerator() {
      return this._debugData.canDebug;
    }
    DebugCanRunFast() {
      return (
        !this.IsBreakpoint() &&
        !this._runtime.DebugBreakNext() &&
        !this._DebugReturnsGenerator()
      );
    }
    GetSavedDataMap() {
      this._savedData || (this._savedData = new Map());
      return this._savedData;
    }
    GetUnsavedDataMap() {
      this._unsavedData || (this._unsavedData = new Map());
      return this._unsavedData;
    }
    _RunSystem() {
      const f = this._results;
      b(this._parameters, f);
      return this._func.apply(this._systemPlugin, f);
    }
    *_DebugRunSystem() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      if (this._DebugReturnsGenerator()) {
        const f = this._results;
        b(this._parameters, f);
        return yield* this._func.apply(this._systemPlugin, f);
      }
      return this.Run();
    }
    *_DebugRunCallFunction() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      return yield* this._callEventBlock.DebugRunAsFunctionCall(
        this._combinedSolModifiers,
        this._parameters
      );
    }
    _RunSingleGlobal() {
      const f = this._results;
      b(this._parameters, f);
      return this._func.apply(
        this._objectClass.GetSingleGlobalInstance().GetSdkInstance(),
        f
      );
    }
    *_DebugRunSingleGlobal() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      if (this._DebugReturnsGenerator()) {
        const f = this._results;
        b(this._parameters, f);
        return yield* this._func.apply(
          this._objectClass.GetSingleGlobalInstance().GetSdkInstance(),
          f
        );
      }
      return this.Run();
    }
    _RunObject_ParamsConst() {
      const f = this._results,
        h = this._objectClass.GetCurrentSol().GetInstances();
      for (let g = 0, k = h.length; g < k; ++g)
        this._func.apply(h[g].GetSdkInstance(), f);
    }
    *_DebugRunObject_ParamsConst() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      if (this._DebugReturnsGenerator()) {
        const f = this._results,
          h = this._objectClass.GetCurrentSol().GetInstances();
        for (let g = 0, k = h.length; g < k; ++g)
          yield* this._func.apply(h[g].GetSdkInstance(), f);
      } else this._RunObject_ParamsConst();
    }
    _RunObject_ParamsDontVary() {
      const f = this._results;
      b(this._parameters, f);
      const h = this._objectClass.GetCurrentSol().GetInstances();
      for (let g = 0, k = h.length; g < k; ++g)
        this._func.apply(h[g].GetSdkInstance(), f);
    }
    *_DebugRunObject_ParamsDontVary() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      if (this._DebugReturnsGenerator()) {
        const f = this._results;
        b(this._parameters, f);
        const h = this._objectClass.GetCurrentSol().GetInstances();
        for (let g = 0, k = h.length; g < k; ++g)
          yield* this._func.apply(h[g].GetSdkInstance(), f);
      } else this._RunObject_ParamsDontVary();
    }
    _RunObject_AllParamsVary() {
      const f = this._parameters,
        h = this._results,
        g = this._func,
        k = this._objectClass.GetCurrentSol().GetInstances();
      for (let m = 0, q = k.length; m < q; ++m) {
        const v = k[m];
        for (let r = 0, n = f.length; r < n; ++r) h[r] = f[r].Get(m);
        g.apply(v.GetSdkInstance(), h);
      }
    }
    *_DebugRunObject_AllParamsVary() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      if (this._DebugReturnsGenerator()) {
        const f = this._parameters,
          h = this._results,
          g = this._func,
          k = this._objectClass.GetCurrentSol().GetInstances();
        for (let m = 0, q = k.length; m < q; ++m) {
          const v = k[m];
          for (let r = 0, n = f.length; r < n; ++r) h[r] = f[r].Get(m);
          yield* g.apply(v.GetSdkInstance(), h);
        }
      } else this._RunObject_AllParamsVary();
    }
    _RunObject_SomeParamsVary() {
      const f = this._parameters,
        h = this._results,
        g = this._func,
        k = this._objectClass.GetCurrentSol().GetInstances();
      for (let q = 0, v = f.length; q < v; ++q) {
        var m = f[q];
        m.VariesPerInstance() || (h[q] = m.Get(0));
      }
      for (let q = 0, v = k.length; q < v; ++q) {
        m = k[q];
        for (let r = 0, n = f.length; r < n; ++r) {
          const p = f[r];
          p.VariesPerInstance() && (h[r] = p.Get(q));
        }
        g.apply(m.GetSdkInstance(), h);
      }
    }
    *_DebugRunObject_SomeParamsVary() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      if (this._DebugReturnsGenerator()) {
        const h = this._parameters,
          g = this._results,
          k = this._func,
          m = this._objectClass.GetCurrentSol().GetInstances();
        for (let q = 0, v = h.length; q < v; ++q) {
          var f = h[q];
          f.VariesPerInstance() || (g[q] = f.Get(0));
        }
        for (let q = 0, v = m.length; q < v; ++q) {
          f = m[q];
          for (let r = 0, n = h.length; r < n; ++r) {
            const p = h[r];
            p.VariesPerInstance() && (g[r] = p.Get(q));
          }
          yield* k.apply(f.GetSdkInstance(), g);
        }
      } else this._RunObject_SomeParamsVary();
    }
    _RunObject_BeforeAfterHooks() {
      const f = this._parameters,
        h = this._results,
        g = this._func;
      var k = this._objectClass;
      const m = k.GetSdkType();
      k = k.GetCurrentSol().GetInstances();
      m.BeforeRunAction(g);
      for (let q = 0, v = k.length; q < v; ++q) {
        const r = k[q];
        for (let n = 0, p = f.length; n < p; ++n) h[n] = f[n].Get(q);
        g.apply(r.GetSdkInstance(), h);
      }
      m.AfterRunAction(g);
    }
    *_DebugRunObject_BeforeAfterHooks() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      if (this._DebugReturnsGenerator()) {
        const h = this._parameters,
          g = this._results,
          k = this._func;
        var f = this._objectClass;
        const m = f.GetSdkType();
        f = f.GetCurrentSol().GetInstances();
        m.BeforeRunAction(k);
        for (let q = 0, v = f.length; q < v; ++q) {
          const r = f[q];
          for (let n = 0, p = h.length; n < p; ++n) g[n] = h[n].Get(q);
          yield* k.apply(r.GetSdkInstance(), g);
        }
        m.AfterRunAction(k);
      } else this._RunObject_BeforeAfterHooks();
    }
    _RunBehavior() {
      var f = this._objectClass;
      const h = f.IsFamily(),
        g = f.GetFamilyIndex(),
        k = this._parameters,
        m = this._anyParamVariesPerInstance,
        q = this._results,
        v = this._func,
        r = this._behaviorIndex;
      f = f.GetCurrentSol().GetInstances();
      for (let u = 0, w = k.length; u < w; ++u) {
        var n = k[u];
        n.VariesPerInstance() || (q[u] = n.Get(0));
      }
      for (let u = 0, w = f.length; u < w; ++u) {
        n = f[u];
        if (m)
          for (let y = 0, B = k.length; y < B; ++y) {
            var p = k[y];
            p.VariesPerInstance() && (q[y] = p.Get(u));
          }
        p = h ? n.GetObjectClass().GetFamilyBehaviorOffset(g) : 0;
        v.apply(n.GetBehaviorInstances()[r + p].GetSdkInstance(), q);
      }
    }
    *_DebugRunBehavior() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      if (this._DebugReturnsGenerator()) {
        var f = this._objectClass;
        const k = f.IsFamily(),
          m = f.GetFamilyIndex(),
          q = this._parameters,
          v = this._anyParamVariesPerInstance,
          r = this._results,
          n = this._func,
          p = this._behaviorIndex;
        f = f.GetCurrentSol().GetInstances();
        for (let u = 0, w = q.length; u < w; ++u) {
          var h = q[u];
          h.VariesPerInstance() || (r[u] = h.Get(0));
        }
        for (let u = 0, w = f.length; u < w; ++u) {
          h = f[u];
          if (v)
            for (let y = 0, B = q.length; y < B; ++y) {
              var g = q[y];
              g.VariesPerInstance() && (r[y] = g.Get(u));
            }
          g = k ? h.GetObjectClass().GetFamilyBehaviorOffset(m) : 0;
          yield* n.apply(h.GetBehaviorInstances()[p + g].GetSdkInstance(), r);
        }
      } else this._RunBehavior();
    }
    _RunObject_Async() {
      const f = this._parameters,
        h = this._results,
        g = this._func,
        k = this._objectClass.GetCurrentSol().GetInstances(),
        m = [];
      for (let q = 0, v = k.length; q < v; ++q) {
        const r = k[q];
        for (let n = 0, p = f.length; n < p; ++n) h[n] = f[n].Get(q);
        m.push(g.apply(r.GetSdkInstance(), h));
      }
      return Promise.all(m);
    }
    *_DebugRunObject_Async() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      if (this._DebugReturnsGenerator()) {
        const f = this._parameters,
          h = this._results,
          g = this._func,
          k = this._objectClass.GetCurrentSol().GetInstances(),
          m = [];
        for (let q = 0, v = k.length; q < v; ++q) {
          const r = k[q];
          for (let n = 0, p = f.length; n < p; ++n) h[n] = f[n].Get(q);
          m.push(yield* g.apply(r.GetSdkInstance(), h));
        }
        return Promise.all(m);
      }
      return this._RunObject_Async();
    }
    _RunBehavior_Async() {
      var f = this._objectClass;
      const h = f.IsFamily(),
        g = f.GetFamilyIndex(),
        k = this._parameters,
        m = this._results,
        q = this._func,
        v = this._behaviorIndex;
      f = f.GetCurrentSol().GetInstances();
      const r = [];
      for (let n = 0, p = f.length; n < p; ++n) {
        const u = f[n];
        for (let y = 0, B = k.length; y < B; ++y) m[y] = k[y].Get(n);
        const w = h ? u.GetObjectClass().GetFamilyBehaviorOffset(g) : 0;
        r.push(q.apply(u.GetBehaviorInstances()[v + w].GetSdkInstance(), m));
      }
      return Promise.all(r);
    }
    *_DebugRunBehavior_Async() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      if (this._DebugReturnsGenerator()) {
        var f = this._objectClass;
        const h = f.IsFamily(),
          g = f.GetFamilyIndex(),
          k = this._parameters,
          m = this._results,
          q = this._func,
          v = this._behaviorIndex;
        f = f.GetCurrentSol().GetInstances();
        const r = [];
        for (let n = 0, p = f.length; n < p; ++n) {
          const u = f[n];
          for (let y = 0, B = k.length; y < B; ++y) m[y] = k[y].Get(n);
          const w = h ? u.GetObjectClass().GetFamilyBehaviorOffset(g) : 0;
          r.push(
            yield* q.apply(u.GetBehaviorInstances()[v + w].GetSdkInstance(), m)
          );
        }
        return Promise.all(r);
      }
      return this._RunBehavior_Async();
    }
    async RunUserScript() {
      try {
        await this._func();
      } catch (f) {
        console.error(
          `Unhandled exception running script %c${this._eventBlock
            .GetEventSheet()
            .GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${
            this.GetDebugIndex() + 1
          }:`,
          "font-size: 1.2em; font-weight: bold;",
          f
        ),
          self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
          e.EventScript.HadUserScriptException() ||
            (console.info(
              "%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()",
              "font-weight: bold; text-decoration: underline",
              "",
              "font-weight: bold"
            ),
            e.EventScript.SetHadUserScriptException());
      }
    }
    *DebugRunUserScript() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
      return this.RunUserScript();
    }
    _SaveToJson() {
      return this._savedData && this._savedData.size
        ? { ex: e.ToSuperJSON(this._savedData) }
        : null;
    }
    _LoadFromJson(f) {
      this._savedData && (this._savedData.clear(), (this._savedData = null));
      f && (f = f.ex) && (this._savedData = e.FromSuperJSON(f));
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = new e.Color();
  function a(N, Q) {
    return e.compare(this.GetWorldInfo().GetX(), N, Q);
  }
  function c(N, Q) {
    return e.compare(this.GetWorldInfo().GetY(), N, Q);
  }
  function d() {
    const N = this.GetWorldInfo(),
      Q = N.GetLayer();
    return Q.Has3DCamera()
      ? N.IsInViewport3D(Q._GetViewFrustum())
      : N.IsInViewport(
          Q.GetViewport(),
          N.GetLayout().HasVanishingPointOutsideViewport(),
          N.GetLayout().IsOrthographicProjection()
        );
  }
  function f() {
    var N = this.GetWorldInfo();
    const Q = N.GetLayout();
    N = N.GetBoundingBox();
    return (
      0 > N.getRight() ||
      0 > N.getBottom() ||
      N.getLeft() > Q.GetWidth() ||
      N.getTop() > Q.GetHeight()
    );
  }
  function h(N, Q, W) {
    const Z = this.GetCurrentSol(),
      da = Z.GetInstances();
    if (!da.length) return !1;
    let ea = da[0];
    var ia = ea.GetWorldInfo();
    let oa = ea,
      ja = e.distanceSquared(ia.GetX(), ia.GetY(), Q, W);
    for (let wa = 1, Ka = da.length; wa < Ka; ++wa)
      if (
        ((ea = da[wa]),
        (ia = ea.GetWorldInfo()),
        (ia = e.distanceSquared(ia.GetX(), ia.GetY(), Q, W)),
        (0 === N && ia < ja) || (1 === N && ia > ja))
      )
        (ja = ia), (oa = ea);
    Z.PickOne(oa);
    return !0;
  }
  function g(N) {
    const Q = this.GetWorldInfo();
    Q.GetX() !== N && (Q.SetX(N), Q.SetBboxChanged());
  }
  function k(N) {
    const Q = this.GetWorldInfo();
    Q.GetY() !== N && (Q.SetY(N), Q.SetBboxChanged());
  }
  function m(N, Q) {
    const W = this.GetWorldInfo();
    W.EqualsXY(N, Q) || (W.SetXY(N, Q), W.SetBboxChanged());
  }
  function q(N, Q) {
    if (N && (N = N.GetPairedInstance(this._inst))) {
      var [W, Z] = N.GetImagePoint(Q);
      Q = this.GetWorldInfo();
      if (Q.GetX() !== W || Q.GetY() !== Z) Q.SetXY(W, Z), Q.SetBboxChanged();
    }
  }
  function v(N) {
    if (0 !== N) {
      var Q = this.GetWorldInfo();
      Q.OffsetXY(Q.GetCosAngle() * N, Q.GetSinAngle() * N);
      Q.SetBboxChanged();
    }
  }
  function r(N, Q) {
    if (0 !== Q) {
      var W = this.GetWorldInfo();
      N = e.toRadians(N);
      W.OffsetXY(Math.cos(N) * Q, Math.sin(N) * Q);
      W.SetBboxChanged();
    }
  }
  function n() {
    return this.GetWorldInfo().GetX();
  }
  function p() {
    return this.GetWorldInfo().GetY();
  }
  function u() {
    return this._runtime.GetDt(this._inst);
  }
  function w(N, Q) {
    return e.compare(this.GetWorldInfo().GetWidth(), N, Q);
  }
  function y(N, Q) {
    return e.compare(this.GetWorldInfo().GetHeight(), N, Q);
  }
  function B(N) {
    const Q = this.GetWorldInfo();
    Q.GetWidth() !== N && (Q.SetWidth(N), Q.SetBboxChanged());
  }
  function E(N) {
    const Q = this.GetWorldInfo();
    Q.GetHeight() !== N && (Q.SetHeight(N), Q.SetBboxChanged());
  }
  function z(N, Q) {
    const W = this.GetWorldInfo();
    if (W.GetWidth() !== N || W.GetHeight() !== Q)
      W.SetSize(N, Q), W.SetBboxChanged();
  }
  function D() {
    return this.GetWorldInfo().GetWidth();
  }
  function J() {
    return this.GetWorldInfo().GetHeight();
  }
  function C() {
    return this.GetWorldInfo().GetBoundingBox().getLeft();
  }
  function H() {
    return this.GetWorldInfo().GetBoundingBox().getTop();
  }
  function K() {
    return this.GetWorldInfo().GetBoundingBox().getRight();
  }
  function P() {
    return this.GetWorldInfo().GetBoundingBox().getBottom();
  }
  function S(N, Q) {
    return (
      e.angleDiff(this.GetWorldInfo().GetAngle(), e.toRadians(Q)) <=
      e.toRadians(N)
    );
  }
  function U(N) {
    return e.angleClockwise(this.GetWorldInfo().GetAngle(), e.toRadians(N));
  }
  function V(N, Q) {
    N = e.toRadians(N);
    Q = e.toRadians(Q);
    const W = this.GetWorldInfo().GetAngle();
    return e.angleClockwise(Q, N)
      ? e.angleClockwise(W, N) && !e.angleClockwise(W, Q)
      : !(!e.angleClockwise(W, N) && e.angleClockwise(W, Q));
  }
  function aa(N) {
    const Q = this.GetWorldInfo();
    N = e.clampAngle(e.toRadians(N));
    isNaN(N) || Q.GetAngle() === N || (Q.SetAngle(N), Q.SetBboxChanged());
  }
  function ma(N) {
    if (!isNaN(N) && 0 !== N) {
      var Q = this.GetWorldInfo();
      Q.SetAngle(Q.GetAngle() + e.toRadians(N));
      Q.SetBboxChanged();
    }
  }
  function va(N) {
    if (!isNaN(N) && 0 !== N) {
      var Q = this.GetWorldInfo();
      Q.SetAngle(Q.GetAngle() - e.toRadians(N));
      Q.SetBboxChanged();
    }
  }
  function Na(N, Q) {
    const W = this.GetWorldInfo(),
      Z = W.GetAngle();
    N = e.angleRotate(Z, e.toRadians(Q), e.toRadians(N));
    isNaN(N) || Z === N || (W.SetAngle(N), W.SetBboxChanged());
  }
  function Ea(N, Q, W) {
    const Z = this.GetWorldInfo(),
      da = Z.GetAngle();
    Q -= Z.GetX();
    W -= Z.GetY();
    N = e.angleRotate(da, Math.atan2(W, Q), e.toRadians(N));
    isNaN(N) || da === N || (Z.SetAngle(N), Z.SetBboxChanged());
  }
  function Ia(N, Q) {
    const W = this.GetWorldInfo(),
      Z = W.GetAngle();
    N -= W.GetX();
    Q -= W.GetY();
    Q = Math.atan2(Q, N);
    isNaN(Q) || Z === Q || (W.SetAngle(Q), W.SetBboxChanged());
  }
  function Ma() {
    return e.toDegrees(this.GetWorldInfo().GetAngle());
  }
  function Fa(N, Q) {
    return e.compare(e.round6dp(100 * this.GetWorldInfo().GetOpacity()), N, Q);
  }
  function ya() {
    return this.GetWorldInfo().IsVisible();
  }
  function na(N) {
    const Q = this.GetWorldInfo();
    N = 2 === N ? !Q.IsVisible() : 0 !== N;
    Q.IsVisible() !== N && (Q.SetVisible(N), this._runtime.UpdateRender());
  }
  function Va(N) {
    N = e.clamp(N / 100, 0, 1);
    const Q = this.GetWorldInfo();
    Q.GetOpacity() !== N && (Q.SetOpacity(N), this._runtime.UpdateRender());
  }
  function xa(N) {
    b.setFromRgbValue(N);
    N = this.GetWorldInfo();
    N.GetUnpremultipliedColor().equalsIgnoringAlpha(b) ||
      (N.SetUnpremultipliedColor(b), this._runtime.UpdateRender());
  }
  function Ga() {
    const N = this.GetWorldInfo().GetUnpremultipliedColor();
    return e.PackRGBAEx(N.getR(), N.getG(), N.getB(), N.getA());
  }
  function bb() {
    return e.round6dp(100 * this.GetWorldInfo().GetOpacity());
  }
  function Xa(N) {
    return N ? this.GetWorldInfo().GetLayer() === N : !1;
  }
  function ob(N) {
    const Q = this.GetCurrentSol(),
      W = Q.GetInstances();
    if (!W.length) return !1;
    let Z = W[0];
    for (let da = 1, ea = W.length; da < ea; ++da) {
      const ia = W[da],
        oa = ia.GetWorldInfo(),
        ja = Z.GetWorldInfo(),
        wa = oa.GetLayer().GetIndex(),
        Ka = ja.GetLayer().GetIndex();
      if (0 === N) {
        if (wa > Ka || (wa === Ka && oa.GetZIndex() > ja.GetZIndex())) Z = ia;
      } else if (wa < Ka || (wa === Ka && oa.GetZIndex() < ja.GetZIndex()))
        Z = ia;
    }
    Q.PickOne(Z);
    return !0;
  }
  function pb(N, Q, W) {
    const Z = this.GetWorldInfo();
    N = 0 === N ? Z.GetZElevation() : Z.GetTotalZElevation();
    return e.compare(N, Q, W);
  }
  function cb() {
    this.GetWorldInfo().ZOrderMoveToTop();
  }
  function qb() {
    this.GetWorldInfo().ZOrderMoveToBottom();
  }
  function rb(N) {
    N && this.GetWorldInfo().ZOrderMoveToLayer(N);
  }
  function sb(N, Q) {
    N = 0 === N;
    Q &&
      (Q = Q.GetFirstPicked(this.GetInstance())) &&
      this.GetWorldInfo().ZOrderMoveAdjacentToInstance(Q, N);
  }
  function tb(N) {
    const Q = this.GetWorldInfo();
    Q.GetZElevation() !== N &&
      (Q.SetZElevation(N), this._runtime.UpdateRender());
  }
  function ub() {
    return this.GetWorldInfo().GetLayer().GetIndex();
  }
  function vb() {
    return this.GetWorldInfo().GetLayer().GetName();
  }
  function wb() {
    return this.GetWorldInfo().GetZIndex();
  }
  function db() {
    return this.GetWorldInfo().GetZElevation();
  }
  function xb() {
    return this.GetWorldInfo().GetTotalZElevation();
  }
  function yb(N, Q) {
    if ((Q = this.GetObjectClass().GetEffectList().GetEffectTypeByName(Q))) {
      Q = Q.GetIndex();
      N = 1 === N;
      var W = this.GetWorldInfo().GetInstanceEffectList();
      W.IsEffectIndexActive(Q) !== N &&
        (W.SetEffectIndexActive(Q, N),
        W.UpdateActiveEffects(),
        this._runtime.UpdateRender());
    }
  }
  function zb(N, Q, W) {
    if ((N = this.GetObjectClass().GetEffectList().GetEffectTypeByName(N))) {
      Q = Math.floor(Q);
      var Z = N.GetShaderProgram().GetParameterType(Q);
      Z &&
        ("color" === Z
          ? (b.setFromRgbValue(W), (W = b))
          : "percent" === Z && (W /= 100),
        (N = N.GetIndex()),
        (Z = this.GetWorldInfo().GetInstanceEffectList()),
        Z.SetEffectParameter(N, Q, W) &&
          Z.IsEffectIndexActive(N) &&
          this._runtime.UpdateRender());
    }
  }
  const eb = e.New(e.Rect),
    Wa = [],
    fb = [];
  let gb = !1,
    Ya = null,
    hb = !1;
  const Ta = new Set();
  function ib(N, Q, W, Z) {
    const da = Q.GetUID(),
      ea = W.GetUID();
    da < ea ? N.Set(Q, W, Z) : N.Set(W, Q, Z);
  }
  function jb(N, Q, W) {
    const Z = Q.GetUID(),
      da = W.GetUID();
    Z < da ? N.Delete(Q, W) : N.Delete(W, Q);
  }
  function sa(N, Q) {
    N.DeleteEither(Q);
  }
  function Sa(N, Q, W) {
    const Z = Q.GetUID(),
      da = W.GetUID();
    return Z < da ? N.Get(Q, W) : N.Get(W, Q);
  }
  function Ab(N, Q, W, Z) {
    if (!Q) return !1;
    N = N.GetInstance();
    const da = 0 !== W || 0 !== Z,
      ea = N.GetWorldInfo(),
      ia = N.GetRuntime(),
      oa = ia.GetCollisionEngine();
    var ja = ia.GetCurrentCondition();
    const wa = ja.GetEventBlock().IsOrBlock();
    var Ka = ja.GetObjectClass();
    ja = ja.IsInverted();
    const Oa = Q.GetCurrentSol();
    Ka = Ka !== Q;
    Ya = Q;
    gb = Ka && !ja;
    hb = !1;
    let Za = 0,
      La = 0,
      la = !1;
    Oa.IsSelectAll()
      ? (eb.copy(ea.GetBoundingBox()),
        eb.offset(W, Z),
        oa.GetCollisionCandidates(ea.GetLayer(), Q, eb, fb),
        (Q = fb))
      : wa
      ? ia.IsCurrentConditionFirst() &&
        !Oa._GetOwnElseInstances().length &&
        Oa._GetOwnInstances().length
        ? (Q = Oa._GetOwnInstances())
        : ((Q = Oa._GetOwnElseInstances()), (hb = !0))
      : (Q = Oa._GetOwnInstances());
    da &&
      ((Za = ea.GetX()),
      (La = ea.GetY()),
      ea.OffsetXY(W, Z),
      ea.SetBboxChanged());
    for (const ca of Q)
      if (oa.TestOverlap(N, ca)) {
        la = !0;
        if (ja) break;
        Ka && Ta.add(ca);
      }
    da && (ea.SetXY(Za, La), ea.SetBboxChanged());
    e.clearArray(fb);
    return la;
  }
  function Db(N) {
    N = N.GetRuntime().GetCurrentEvent().IsOrBlock();
    const Q = Ya.GetCurrentSol(),
      W = Q._GetOwnInstances(),
      Z = Q._GetOwnElseInstances();
    Q.IsSelectAll()
      ? (Q.SetSetPicked(Ta),
        N && (e.clearArray(Z), Q.AddElseInstances(Ta, Ya.GetInstances())))
      : N
      ? hb
        ? Q.TransferElseInstancesToOwn(Ta)
        : (Q.AddElseInstances(Ta, W), Q.SetSetPicked(Ta))
      : Q.SetSetPicked(Ta);
    Ya.ApplySolToContainer();
  }
  function Eb(N, Q) {
    gb && (Q && Db(N), Ta.clear(), (Ya = null), (gb = !1));
  }
  function Fb(N) {
    if (this._runtime.IsDebugging()) return Gb.call(this, N);
    if (!N) return !1;
    var Q = this._runtime;
    const W = Q.GetCollisionEngine(),
      Z = Q.GetEventSheetManager(),
      da = Z.GetEventStack();
    var ea = Z.GetCurrentCondition();
    const ia = ea.GetObjectClass();
    var oa = ea.GetSavedDataMap(),
      ja = ea.GetUnsavedDataMap();
    ea = da.GetCurrentStackFrame();
    const wa = Q.GetTickCount(),
      Ka = wa - 1,
      Oa = ea.GetCurrentEvent(),
      Za = da.Push(Oa);
    let La = oa.get("collmemory");
    La || ((La = e.New(e.PairMap)), oa.set("collmemory", La));
    ja.get("collisionCreatedDestroyCallback") ||
      (ja.set("collisionCreatedDestroyCallback", !0),
      Q.Dispatcher().addEventListener("instancedestroy", (Ua) =>
        sa(La, Ua.instance)
      ));
    oa = ia.GetCurrentSol();
    Q = N.GetCurrentSol();
    oa = oa.GetInstances();
    ja = null;
    for (let Ua = 0; Ua < oa.length; ++Ua) {
      const Ha = oa[Ua];
      Q.IsSelectAll()
        ? (W.GetCollisionCandidates(
            Ha.GetWorldInfo().GetLayer(),
            N,
            Ha.GetWorldInfo().GetBoundingBox(),
            Wa
          ),
          (ja = Wa),
          W.AddRegisteredCollisionCandidates(Ha, N, ja))
        : (ja = Q.GetInstances());
      for (let ab = 0; ab < ja.length; ++ab) {
        const Ra = ja[ab];
        if (W.TestOverlap(Ha, Ra) || W.CheckRegisteredCollision(Ha, Ra)) {
          var la = Sa(La, Ha, Ra),
            ca = !1,
            pa = -2;
          "number" === typeof la && ((ca = !0), (pa = la));
          la = !ca || pa < Ka;
          ib(La, Ha, Ra, wa);
          la &&
            ((la = Oa.GetSolModifiers()),
            Z.PushCopySol(la),
            (pa = ia.GetCurrentSol()),
            (ca = N.GetCurrentSol()),
            pa._SetSelectAll(!1),
            ca._SetSelectAll(!1),
            ia === N
              ? ((ca = pa._GetOwnInstances()),
                e.clearArray(ca),
                ca.push(Ha),
                ca.push(Ra),
                ia.ApplySolToContainer())
              : ((pa = pa._GetOwnInstances()),
                (ca = ca._GetOwnInstances()),
                e.clearArray(pa),
                e.clearArray(ca),
                pa.push(Ha),
                ca.push(Ra),
                ia.ApplySolToContainer(),
                N.ApplySolToContainer()),
            Oa.Retrigger(ea, Za),
            Z.PopSol(la));
        } else jb(La, Ha, Ra);
      }
      e.clearArray(Wa);
    }
    da.Pop();
    return !1;
  }
  function* Gb(N) {
    if (!N) return !1;
    var Q = this._runtime;
    const W = Q.GetCollisionEngine(),
      Z = Q.GetEventSheetManager(),
      da = Z.GetEventStack();
    var ea = Z.GetCurrentCondition();
    const ia = ea.GetObjectClass();
    var oa = ea.GetSavedDataMap(),
      ja = ea.GetUnsavedDataMap();
    ea = da.GetCurrentStackFrame();
    const wa = Q.GetTickCount(),
      Ka = wa - 1,
      Oa = ea.GetCurrentEvent(),
      Za = da.Push(Oa);
    let La = oa.get("collmemory");
    La || ((La = e.New(e.PairMap)), oa.set("collmemory", La));
    ja.get("collisionCreatedDestroyCallback") ||
      (ja.set("collisionCreatedDestroyCallback", !0),
      Q.Dispatcher().addEventListener("instancedestroy", (Ua) =>
        sa(La, Ua.instance)
      ));
    oa = ia.GetCurrentSol();
    Q = N.GetCurrentSol();
    oa = oa.GetInstances();
    ja = null;
    for (let Ua = 0; Ua < oa.length; ++Ua) {
      const Ha = oa[Ua];
      Q.IsSelectAll()
        ? (W.GetCollisionCandidates(
            Ha.GetWorldInfo().GetLayer(),
            N,
            Ha.GetWorldInfo().GetBoundingBox(),
            Wa
          ),
          (ja = Wa),
          W.AddRegisteredCollisionCandidates(Ha, N, ja))
        : (ja = Q.GetInstances());
      for (let ab = 0; ab < ja.length; ++ab) {
        const Ra = ja[ab];
        if (W.TestOverlap(Ha, Ra) || W.CheckRegisteredCollision(Ha, Ra)) {
          var la = Sa(La, Ha, Ra),
            ca = !1,
            pa = -2;
          "number" === typeof la && ((ca = !0), (pa = la));
          la = !ca || pa < Ka;
          ib(La, Ha, Ra, wa);
          la &&
            ((la = Oa.GetSolModifiers()),
            Z.PushCopySol(la),
            (pa = ia.GetCurrentSol()),
            (ca = N.GetCurrentSol()),
            pa._SetSelectAll(!1),
            ca._SetSelectAll(!1),
            ia === N
              ? ((ca = pa._GetOwnInstances()),
                e.clearArray(ca),
                ca.push(Ha),
                ca.push(Ra),
                ia.ApplySolToContainer())
              : ((pa = pa._GetOwnInstances()),
                (ca = ca._GetOwnInstances()),
                e.clearArray(pa),
                e.clearArray(ca),
                pa.push(Ha),
                ca.push(Ra),
                ia.ApplySolToContainer(),
                N.ApplySolToContainer()),
            yield* Oa.DebugRetrigger(ea, Za),
            Z.PopSol(la));
        } else jb(La, Ha, Ra);
      }
      e.clearArray(Wa);
    }
    da.Pop();
    return !1;
  }
  function Hb(N) {
    return Ab(this, N, 0, 0);
  }
  function kb(N, Q, W) {
    return Ab(this, N, Q, W);
  }
  function lb() {
    return this.GetWorldInfo().HasParent();
  }
  function mb() {
    return this.GetWorldInfo().HasChildren();
  }
  function nb(N, Q) {
    const W = this.GetCurrentSol().GetInstances();
    if (0 === W.length) return !1;
    const Z = N.GetCurrentSol();
    var da = Z.GetInstances();
    if (0 === da.length) return !1;
    da = new Set(da);
    const ea = new Set();
    for (let oa = 0, ja = W.length; oa < ja; ++oa) {
      var ia = W[oa];
      if (1 === Q)
        for (const wa of ia.parents())
          wa.BelongsToObjectClass(N) && da.has(wa) && ea.add(wa);
      else {
        if (0 === Q) {
          if (((ia = ia.GetParent()), null === ia)) continue;
        } else ia = ia.GetTopParent();
        ia.BelongsToObjectClass(N) && da.has(ia) && ea.add(ia);
      }
    }
    if (0 === ea.size) return !1;
    Z.SetSetPicked(ea);
    N.ApplySolToContainer();
    return !0;
  }
  function $a(N, Q) {
    const W = this.GetCurrentSol().GetInstances();
    if (0 === W.length) return !1;
    const Z = N.GetCurrentSol();
    var da = Z.GetInstances();
    if (Z.IsSelectAll()) {
      var ea = [...this._runtime.instancesPendingCreateForObjectClass(N)];
      0 < ea.length && (da = da.concat(ea));
    }
    if (0 === da.length) return !1;
    da = new Set(da);
    ea = new Set();
    for (let ia = 0, oa = W.length; ia < oa; ++ia) {
      const ja = W[ia];
      2 === Q &&
        !ja.HasChildren() &&
        ja.BelongsToObjectClass(N) &&
        da.has(ja) &&
        ea.add(ja);
      for (const wa of 0 === Q ? ja.children() : ja.allChildren())
        (2 === Q && wa.HasChildren()) ||
          (wa.BelongsToObjectClass(N) && da.has(wa) && ea.add(wa));
    }
    if (0 === ea.size) return !1;
    Z.SetSetPicked(ea);
    N.ApplySolToContainer();
    return !0;
  }
  function l(N, Q) {
    const W = this.GetCurrentSol().GetInstances();
    if (0 === W.length) return !1;
    const Z = N.GetCurrentSol();
    var da = Z.GetInstances();
    if (Z.IsSelectAll()) {
      var ea = [...this._runtime.instancesPendingCreateForObjectClass(N)];
      0 < ea.length && (da = da.concat(ea));
    }
    if (0 === da.length) return !1;
    da = new Set(da);
    ea = [];
    for (let ia = 0, oa = W.length; ia < oa; ++ia) {
      const ja = W[ia].GetChildAt(Q);
      null !== ja && ja.BelongsToObjectClass(N) && da.has(ja) && ea.push(ja);
    }
    if (0 === ea.length) return !1;
    Z.SetArrayPicked(ea);
    N.ApplySolToContainer();
    return !0;
  }
  function t(N, Q) {
    return e.compare(this._inst.GetChildCount(), N, Q);
  }
  function x(N, Q, W, Z, da, ea, ia, oa) {
    const ja = this._inst,
      wa = this._runtime.GetCurrentAction().GetObjectClass();
    for (const Ka of N.allCorrespondingInstances(ja, wa)) {
      if (!Ka.GetPlugin().SupportsSceneGraph()) break;
      ja.AddChild(Ka, {
        transformX: Q,
        transformY: W,
        transformWidth: Z,
        transformHeight: da,
        transformAngle: ea,
        transformZElevation: ia,
        destroyWithParent: oa,
      });
    }
  }
  function A(N) {
    const Q = this._inst,
      W = this._runtime.GetCurrentAction().GetObjectClass();
    for (const Z of N.allCorrespondingInstances(Q, W)) Q.RemoveChild(Z);
  }
  function F() {
    this._inst.HasParent() && this._inst.GetParent().RemoveChild(this._inst);
  }
  function G() {
    return this._inst.GetChildCount();
  }
  function I(N, Q) {
    N = Math.floor(N);
    Q = Math.floor(Q);
    const W = this.GetWorldInfo();
    2 > N || 2 > Q || !isFinite(N) || !isFinite(Q)
      ? (W.ReleaseMesh(), W.SetBboxChanged())
      : W.CreateMesh(N, Q);
  }
  function L(N, Q, W, Z, da, ea, ia, oa) {
    const ja = this.GetWorldInfo();
    ja.SetMeshPoint(N, Q, {
      mode: 0 === W ? "absolute" : "relative",
      x: Z,
      y: da,
      zElevation: ea,
      u: ia,
      v: oa,
    }) && ja.SetBboxChanged();
  }
  function M() {
    const N = this.GetWorldInfo();
    return N.HasMesh() ? N.GetSourceMesh().GetHSize() : 0;
  }
  function O() {
    const N = this.GetWorldInfo();
    return N.HasMesh() ? N.GetSourceMesh().GetVSize() : 0;
  }
  function R(N) {
    const Q = this.GetWorldInfo();
    N = 2 === N ? !Q.IsVisible() : 0 !== N;
    Q.IsVisible() !== N && Q.SetVisible(N);
  }
  function T(N, Q) {
    this.SetElementCSSStyle(N, Q);
  }
  function Y(N, Q) {
    this.SetElementAttribute(N, "" + Q);
  }
  function X(N) {
    this.RemoveElementAttribute(N);
  }
  function fa() {
    this.FocusElement();
  }
  function ha() {
    this.BlurElement();
  }
  function ba() {
    return this.IsElementFocused();
  }
  function qa(N) {
    this._SetEnabled(0 !== N);
  }
  function ka() {
    return this._IsEnabled();
  }
  function ta(N, Q, W) {
    return e.compare(this.GetInstance().GetInstanceVariableValue(N), Q, W);
  }
  function ua(N) {
    return !!this.GetInstance().GetInstanceVariableValue(N);
  }
  function ra(N, Q) {
    const W = this.GetCurrentSol(),
      Z = W.GetInstances();
    if (!Z.length) return !1;
    let da = Z[0],
      ea = da,
      ia = da.GetInstanceVariableValue(Q);
    for (let oa = 1, ja = Z.length; oa < ja; ++oa) {
      da = Z[oa];
      const wa = da.GetInstanceVariableValue(Q);
      if ((0 === N && wa < ia) || (1 === N && wa > ia)) (ia = wa), (ea = da);
    }
    W.PickOne(ea);
    return !0;
  }
  function za(N) {
    return this._runtime.GetCurrentCondition().IsInverted()
      ? Ba(this, N)
      : Aa(this, N);
  }
  function Aa(N, Q) {
    Q = N.GetRuntime().GetInstanceByUID(Q);
    if (!Q) return !1;
    const W = N.GetCurrentSol();
    if (!W.IsSelectAll() && !W._GetOwnInstances().includes(Q)) return !1;
    if (N.IsFamily()) {
      if (Q.GetObjectClass().BelongsToFamily(N))
        return W.PickOne(Q), N.ApplySolToContainer(), !0;
    } else if (Q.GetObjectClass() === N)
      return W.PickOne(Q), N.ApplySolToContainer(), !0;
    return !1;
  }
  function Ba(N, Q) {
    const W = N.GetCurrentSol();
    if (W.IsSelectAll()) {
      W._SetSelectAll(!1);
      W.ClearArrays();
      var Z = N.GetInstances();
      for (let ea = 0, ia = Z.length; ea < ia; ++ea) {
        var da = Z[ea];
        da.GetUID() === Q ? W._PushElseInstance(da) : W._PushInstance(da);
      }
      N.ApplySolToContainer();
      return !!W._GetOwnInstances().length;
    }
    Z = W._GetOwnInstances();
    da = 0;
    for (let ea = 0, ia = Z.length; ea < ia; ++ea) {
      const oa = Z[ea];
      Z[da] = oa;
      oa.GetUID() === Q ? W._PushElseInstance(oa) : ++da;
    }
    e.truncateArray(Z, da);
    N.ApplySolToContainer();
    return !!Z.length;
  }
  function Ca() {
    this._runtime.DestroyInstance(this._inst);
  }
  function Ja() {
    return !0;
  }
  function Pa() {
    return !0;
  }
  function Qa(N, Q) {
    this.GetInstance().SetInstanceVariableValue(N, Q);
  }
  function Da(N, Q) {
    const W = this.GetInstance(),
      Z = W.GetInstanceVariableValue(N);
    "number" === typeof Z && "number" !== typeof Q
      ? (Q = parseFloat(Q))
      : "string" === typeof Z && "string" !== typeof Q && (Q = Q.toString());
    W.SetInstanceVariableValue(N, Z + Q);
  }
  function Bb(N, Q) {
    const W = this.GetInstance(),
      Z = W.GetInstanceVariableValue(N);
    "number" === typeof Z &&
      ("number" !== typeof Q && (Q = parseFloat(Q)),
      W.SetInstanceVariableValue(N, Z - Q));
  }
  function Cb(N, Q) {
    this.GetInstance().SetInstanceVariableValue(N, Q ? 1 : 0);
  }
  function Ib(N) {
    const Q = this.GetInstance();
    Q.SetInstanceVariableValue(N, 0 === Q.GetInstanceVariableValue(N) ? 1 : 0);
  }
  function Jb(N) {
    try {
      var Q = JSON.parse(N);
    } catch (W) {
      console.error("Failed to load from JSON string: ", W);
      return;
    }
    N = this.GetInstance();
    N._OnBeforeLoad("state");
    N.LoadFromJson(Q, "state");
    Q = e.New(e.Event, "afterloadinstance");
    Q.instance = N;
    this._runtime.Dispatcher().dispatchEvent(Q);
  }
  function Kb() {
    return JSON.stringify(this.GetInstance().SaveToJson("state"));
  }
  function Lb() {
    return this.GetInstance().GetObjectClass().GetName();
  }
  function Mb() {
    const N = this._runtime
      .GetCurrentEventStackFrame()
      .GetExpressionObjectClass();
    let Q = N.GetInstanceCount();
    for (const W of this._runtime.instancesPendingCreateForObjectClass(N)) ++Q;
    return Q;
  }
  function Nb() {
    return this._runtime
      .GetCurrentEventStackFrame()
      .GetExpressionObjectClass()
      .GetCurrentSol()
      .GetInstances().length;
  }
  function Ob() {
    return this._inst.GetIID();
  }
  function Pb() {
    return this._inst.GetUID();
  }
  e.AddCommonACEs = function (N, Q) {
    const W = N[1],
      Z = N[4],
      da = N[5],
      ea = N[6],
      ia = N[7],
      oa = N[8],
      ja = N[10],
      wa = N[11],
      Ka = N[12],
      Oa = N[13],
      Za = N[14],
      La = N[15],
      la = Q.Cnds,
      ca = Q.Acts,
      pa = Q.Exps;
    N[3] &&
      ((la.CompareX = a),
      (la.CompareY = c),
      (la.IsOnScreen = d),
      (la.IsOutsideLayout = f),
      (la.PickDistance = h),
      (ca.SetX = g),
      (ca.SetY = k),
      (ca.SetPos = m),
      (ca.SetPosToObject = q),
      (ca.MoveForward = v),
      (ca.MoveAtAngle = r),
      (pa.X = n),
      (pa.Y = p),
      (pa.dt = u));
    Z &&
      ((la.CompareWidth = w),
      (la.CompareHeight = y),
      (ca.SetWidth = B),
      (ca.SetHeight = E),
      (ca.SetSize = z),
      (pa.Width = D),
      (pa.Height = J),
      (pa.BBoxLeft = C),
      (pa.BBoxTop = H),
      (pa.BBoxRight = K),
      (pa.BBoxBottom = P));
    da &&
      ((la.AngleWithin = S),
      (la.IsClockwiseFrom = U),
      (la.IsBetweenAngles = V),
      (ca.SetAngle = aa),
      (ca.RotateClockwise = ma),
      (ca.RotateCounterclockwise = va),
      (ca.RotateTowardAngle = Na),
      (ca.RotateTowardPosition = Ea),
      (ca.SetTowardPosition = Ia),
      (pa.Angle = Ma));
    ea &&
      ((la.IsVisible = ya),
      (la.CompareOpacity = Fa),
      (ca.SetVisible = na),
      (ca.SetOpacity = Va),
      (ca.SetDefaultColor = xa),
      (pa.Opacity = bb),
      (pa.ColorValue = Ga));
    ia &&
      ((la.IsOnLayer = Xa),
      (la.PickTopBottom = ob),
      (la.CompareZElevation = pb),
      (ca.MoveToTop = cb),
      (ca.MoveToBottom = qb),
      (ca.MoveToLayer = rb),
      (ca.ZMoveToObject = sb),
      (ca.SetZElevation = tb),
      (pa.LayerNumber = ub),
      (pa.LayerName = vb),
      (pa.ZIndex = wb),
      (pa.ZElevation = db),
      (pa.TotalZElevation = xb));
    oa && ((ca.SetEffectEnabled = yb), (ca.SetEffectParam = zb));
    Oa &&
      ((la.HasParent = lb),
      (la.HasChildren = mb),
      (la.PickParent = nb),
      (la.PickChildren = $a),
      (la.PickNthChild = l),
      (la.CompareChildCount = t),
      (ca.AddChild = x),
      (ca.RemoveChild = A),
      (ca.RemoveFromParent = F),
      (pa.ChildCount = G));
    Za &&
      ((ca.SetMeshSize = I),
      (ca.SetMeshPoint = L),
      (pa.MeshColumns = M),
      (pa.MeshRows = O));
    ja &&
      ((la.IsVisible = ya),
      (ca.SetVisible = R),
      (ca.SetCSSStyle = T),
      (ca.SetElemAttribute = Y),
      (ca.RemoveElemAttribute = X));
    wa && ((la.IsFocused = ba), (ca.SetFocus = fa), (ca.SetBlur = ha));
    Ka && ((la.IsEnabled = ka), (ca.SetEnabled = qa));
    La &&
      ((la.OnCollision = Fb),
      (la.IsOverlapping = Hb),
      (la.IsOverlappingOffset = kb),
      (Q.FinishCollisionCondition = Eb));
    W ||
      ((la.CompareInstanceVar = ta),
      (la.IsBoolInstanceVarSet = ua),
      (la.PickInstVarHiLow = ra),
      (la.PickByUID = za),
      (ca.SetInstanceVar = Qa),
      (ca.AddInstanceVar = Da),
      (ca.SubInstanceVar = Bb),
      (ca.SetBoolInstanceVar = Cb),
      (ca.ToggleBoolInstanceVar = Ib),
      (la.OnCreated = Ja),
      (la.OnDestroyed = Pa),
      (ca.Destroy = Ca),
      ca.LoadFromJsonString || (ca.LoadFromJsonString = Jb),
      pa.AsJSON || (pa.AsJSON = Kb),
      (pa.Count = Mb),
      (pa.PickedCount = Nb),
      (pa.IID = Ob),
      (pa.UID = Pb),
      (pa.ObjectTypeName = Lb));
  };
}
{
  ("use strict");
  const e = self.C3;
  e.ScheduledWait = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._eventSheetManager = b;
      this._type = "";
      this._time = -1;
      this._signalTag = "";
      this._isSignalled = !1;
      this._event = null;
      this._actIndex = 0;
      this._solModifiers = [];
      this._sols = new Map();
      this._callingFunctionBlock = null;
      this._asyncId = -1;
      this._functionInnerLocalVars = this._functionParameters = null;
      this._shouldRelease = !1;
    }
    Release() {
      this._type = "";
      this._time = -1;
      this._signalTag = "";
      this._functionInnerLocalVars =
        this._functionParameters =
        this._callingFunctionBlock =
        this._event =
          null;
      this._asyncId = -1;
      e.clearArray(this._solModifiers);
      for (const b of this._sols.values()) b.Release();
      this._sols.clear();
    }
    _Init() {
      var b = this._eventSheetManager,
        a = b.GetRuntime().GetAllObjectClasses();
      const c = b.GetCurrentEventStackFrame();
      this._event = c.GetCurrentEvent();
      this._actIndex = c.GetActionIndex() + 1;
      if ((b = b.FindFirstFunctionBlockParent(this._event)))
        (this._callingFunctionBlock = b),
          (this._functionParameters = b.CaptureFunctionParameters()),
          (this._functionInnerLocalVars = b
            ._GetAllInnerLocalVariables()
            .map((d) => d.GetValue())),
          b.IsAsync() && (this._asyncId = b.PauseCurrentAsyncFunction());
      for (const d of a)
        if (
          ((a = d.GetCurrentSol()),
          !a.IsSelectAll() || this._event.HasSolModifier(d))
        )
          this._solModifiers.push(d), this._sols.set(d, e.New(e.SolState, a));
    }
    InitTimer(b) {
      this._type = "timer";
      this._Init();
      this._time = this._eventSheetManager.GetRuntime().GetGameTime() + b;
    }
    InitSignal(b) {
      this._type = "signal";
      this._Init();
      this._signalTag = b.toLowerCase();
    }
    InitPromise(b) {
      this._type = "promise";
      this._Init();
      b.then(() => this.SetSignalled()).catch((a) => {
        console.warn(
          "[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ",
          a
        );
        this.SetSignalled();
      });
    }
    IsTimer() {
      return "timer" === this._type;
    }
    IsSignal() {
      return "signal" === this._type;
    }
    IsPromise() {
      return "promise" === this._type;
    }
    GetSignalTag() {
      return this._signalTag;
    }
    IsSignalled() {
      return this._isSignalled;
    }
    SetSignalled() {
      this._isSignalled = !0;
    }
    _ShouldRun() {
      return this.IsTimer()
        ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime()
        : this.IsSignalled();
    }
    _RestoreState(b) {
      b._Restore(this._event, this._actIndex);
      for (const [a, c] of this._sols.entries())
        (b = a.GetCurrentSol()), c._Restore(b);
      if ((b = this._callingFunctionBlock))
        b.SetFunctionParameters(this._functionParameters),
          b
            ._GetAllInnerLocalVariables()
            .map((a, c) => a.SetValue(this._functionInnerLocalVars[c])),
          b.IsAsync() && b.ResumeAsyncFunction(this._asyncId);
    }
    _Run(b) {
      this._RestoreState(b);
      this._event._ResumeActionsAndSubEvents(b);
      this._callingFunctionBlock &&
        this._callingFunctionBlock.IsAsync() &&
        this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);
      this._eventSheetManager.ClearSol(this._solModifiers);
      this._shouldRelease = !0;
    }
    async _DebugRun(b) {
      this._RestoreState(b);
      for (const a of this._event._DebugResumeActionsAndSubEvents(b))
        await this._eventSheetManager.GetRuntime().DebugBreak(a);
      this._callingFunctionBlock &&
        this._callingFunctionBlock.IsAsync() &&
        this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);
      this._eventSheetManager.ClearSol(this._solModifiers);
      this._shouldRelease = !0;
    }
    ShouldRelease() {
      return this._shouldRelease;
    }
    RemoveInstances(b) {
      for (const a of this._sols.values()) a.RemoveInstances(b);
    }
    _SaveToJson() {
      const b = {},
        a = {
          t: this._time,
          st: this._signalTag,
          s: this._isSignalled,
          ev: this._event.GetSID(),
          sm: this._solModifiers.map((c) => c.GetSID()),
          sols: b,
        };
      this._event._HasActionIndex(this._actIndex) &&
        (a.act = this._event.GetActionAt(this._actIndex).GetSID());
      for (const [c, d] of this._sols)
        b[c.GetSID().toString()] = d._SaveToJson();
      return a;
    }
    static _CreateFromJson(b, a) {
      const c = b.GetRuntime();
      var d = b.GetEventBlockBySID(a.ev);
      if (!d) return null;
      let f = 0;
      if (a.hasOwnProperty("act")) {
        var h = b.GetActionBySID(a.act);
        if (!h) return null;
        f = h.GetIndex();
      }
      h = e.New(e.ScheduledWait, b);
      h._time = a.t;
      h._type = -1 === h._time ? "signal" : "timer";
      h._signalTag = a.st;
      h._isSignalled = a.s;
      h._event = d;
      h._actIndex = f;
      for (var g of a.sm)
        (d = c.GetObjectClassBySID(g)) && h._solModifiers.push(d);
      for (const [k, m] of Object.entries(a.sols))
        if (((a = parseInt(k, 10)), (a = c.GetObjectClassBySID(a))))
          (g = e.New(e.SolState, null)),
            g._LoadFromJson(b, m),
            h._sols.set(a, g);
      return h;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.SolState = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._objectClass = null;
      this._isSelectAll = !0;
      this._instances = [];
      b &&
        ((this._objectClass = b.GetObjectClass()),
        (this._isSelectAll = b.IsSelectAll()),
        e.shallowAssignArray(this._instances, b._GetOwnInstances()));
    }
    Release() {
      this._objectClass = null;
      e.clearArray(this._instances);
    }
    _Restore(b) {
      b._SetSelectAll(this._isSelectAll);
      e.shallowAssignArray(b._GetOwnInstances(), this._instances);
    }
    RemoveInstances(b) {
      e.arrayRemoveAllInSet(this._instances, b);
    }
    _SaveToJson() {
      return {
        sa: this._isSelectAll,
        insts: this._instances.map((b) => b.GetUID()),
      };
    }
    _LoadFromJson(b, a) {
      b = b.GetRuntime();
      this._isSelectAll = !!a.sa;
      e.clearArray(this._instances);
      for (const c of a.insts)
        (a = b.GetInstanceByUID(c)) && this._instances.push(a);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  function b(a, c) {
    let d = a.get(c);
    d || ((d = new Map()), a.set(c, d));
    return d;
  }
  e.SDKPluginBase = class extends e.DefendedBase {
    constructor(a) {
      super();
      this._runtime = a.runtime;
      this._isSingleGlobal = !!a.isSingleGlobal;
      this._isWorldType = !!a.isWorld;
      this._isRotatable = !!a.isRotatable;
      this._mustPredraw = !!a.mustPredraw;
      this._hasEffects = !!a.hasEffects;
      this._supportsSceneGraph = !!a.supportsSceneGraph;
      this._supportsMesh = !!a.supportsMesh;
      this._singleGlobalObjectClass = null;
      this._boundACEMethodCache = new Map();
      this._boundACEMethodCache_1param = new Map();
      this._boundACEMethodCache_2params = new Map();
      this._boundACEMethodCache_3params = new Map();
    }
    Release() {
      this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    OnCreate() {}
    IsSingleGlobal() {
      return this._isSingleGlobal;
    }
    IsWorldType() {
      return this._isWorldType;
    }
    IsRotatable() {
      return this._isRotatable;
    }
    MustPreDraw() {
      return this._mustPredraw;
    }
    HasEffects() {
      return this._hasEffects;
    }
    SupportsSceneGraph() {
      return this._supportsSceneGraph;
    }
    SupportsMesh() {
      return this._supportsMesh;
    }
    _GetBoundACEMethod(a, c) {
      if (!c) throw Error("missing 'this' binding");
      let d = this._boundACEMethodCache.get(a);
      if (d) return d;
      d = a.bind(c);
      this._boundACEMethodCache.set(a, d);
      return d;
    }
    _GetBoundACEMethod_1param(a, c, d) {
      if (!c) throw Error("missing 'this' binding");
      const f = b(this._boundACEMethodCache_1param, a);
      let h = f.get(d);
      if (h) return h;
      h = a.bind(c, d);
      f.set(d, h);
      return h;
    }
    _GetBoundACEMethod_2params(a, c, d, f) {
      if (!c) throw Error("missing 'this' binding");
      var h = b(this._boundACEMethodCache_2params, a);
      h = b(h, d);
      let g = h.get(f);
      if (g) return g;
      g = a.bind(c, d, f);
      h.set(f, g);
      return g;
    }
    _GetBoundACEMethod_3params(a, c, d, f, h) {
      if (!c) throw Error("missing 'this' binding");
      var g = b(this._boundACEMethodCache_3params, a);
      g = b(g, d);
      g = b(g, f);
      let k = g.get(h);
      if (k) return k;
      k = a.bind(c, d, f, h);
      g.set(h, k);
      return k;
    }
    _SetSingleGlobalObjectClass(a) {
      if (!this.IsSingleGlobal()) throw Error("must be single-global plugin");
      this._singleGlobalObjectClass = a;
    }
    GetSingleGlobalObjectClass() {
      if (!this.IsSingleGlobal()) throw Error("must be single-global plugin");
      return this._singleGlobalObjectClass;
    }
    GetSingleGlobalInstance() {
      if (!this.IsSingleGlobal()) throw Error("must be single-global plugin");
      return this._singleGlobalObjectClass.GetSingleGlobalInstance();
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.SDKDOMPluginBase = class extends e.SDKPluginBase {
    constructor(b, a) {
      super(b);
      this._domComponentId = a;
      this._nextElementId = 0;
      this._instMap = new Map();
      this.AddElementMessageHandler("elem-focused", (c) => c._OnElemFocused());
      this.AddElementMessageHandler("elem-blurred", (c) => {
        c && c._OnElemBlurred();
      });
    }
    Release() {
      super.Release();
    }
    _AddElement(b) {
      const a = this._nextElementId++;
      this._instMap.set(a, b);
      return a;
    }
    _RemoveElement(b) {
      this._instMap.delete(b);
    }
    AddElementMessageHandler(b, a) {
      this._runtime.AddDOMComponentMessageHandler(
        this._domComponentId,
        b,
        (c) => {
          const d = this._instMap.get(c.elementId);
          a(d, c);
        }
      );
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.SDKTypeBase = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._objectClass = b;
      this._runtime = b.GetRuntime();
      this._plugin = b.GetPlugin();
    }
    Release() {
      this._plugin = this._runtime = this._objectClass = null;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetPlugin() {
      return this._plugin;
    }
    GetImageInfo() {
      return this._objectClass.GetImageInfo();
    }
    FinishCondition(b) {}
    BeforeRunAction(b) {}
    AfterRunAction(b) {}
    LoadTextures(b) {}
    ReleaseTextures() {}
    OnDynamicTextureLoadComplete() {}
    PreloadTexturesWithInstances(b) {}
    LoadTilemapData() {}
    GetScriptInterfaceClass() {
      return null;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.SDKInstanceBase = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._inst = b;
      this._domComponentId = a;
      this._runtime = b.GetRuntime();
      this._objectClass = this._inst.GetObjectClass();
      this._sdkType = this._objectClass.GetSdkType();
      this._tick2Func = this._tickFunc = null;
      this._isTicking2 = this._isTicking = !1;
      this._disposables = null;
      this._wasReleased = !1;
    }
    Release() {
      this._wasReleased = !0;
      this._StopTicking();
      this._StopTicking2();
      this._tick2Func = this._tickFunc = null;
      this._disposables &&
        (this._disposables.Release(), (this._disposables = null));
      this._sdkType = this._objectClass = this._runtime = this._inst = null;
    }
    WasReleased() {
      return this._wasReleased;
    }
    GetInstance() {
      return this._inst;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetPlugin() {
      return this._sdkType.GetPlugin();
    }
    GetSdkType() {
      return this._sdkType;
    }
    GetScriptInterface() {
      return this._inst.GetInterfaceClass();
    }
    Trigger(b) {
      return this._runtime.Trigger(b, this._inst, null);
    }
    DebugTrigger(b) {
      return this._runtime.DebugTrigger(b, this._inst, null);
    }
    TriggerAsync(b) {
      return this._runtime.TriggerAsync(b, this._inst, null);
    }
    FastTrigger(b, a) {
      return this._runtime.FastTrigger(b, this._inst, a);
    }
    DebugFastTrigger(b, a) {
      return this._runtime.DebugFastTrigger(b, this._inst, a);
    }
    ScheduleTriggers(b) {
      return this._runtime.ScheduleTriggers(b);
    }
    AddDOMMessageHandler(b, a) {
      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, b, a);
    }
    AddDOMMessageHandlers(b) {
      for (const [a, c] of b) this.AddDOMMessageHandler(a, c);
    }
    PostToDOM(b, a) {
      this._runtime.PostComponentMessageToDOM(this._domComponentId, b, a);
    }
    PostToDOMAsync(b, a) {
      return this._runtime.PostComponentMessageToDOMAsync(
        this._domComponentId,
        b,
        a
      );
    }
    _PostToDOMMaybeSync(b, a) {
      if (this._runtime.IsInWorker()) this.PostToDOM(b, a);
      else
        return window.c3_runtimeInterface._OnMessageFromRuntime({
          type: "event",
          component: this._domComponentId,
          handler: b,
          data: a,
          responseId: null,
        });
    }
    Tick() {}
    Tick2() {}
    _StartTicking() {
      this._isTicking ||
        (this._tickFunc || (this._tickFunc = () => this.Tick()),
        this._runtime.Dispatcher().addEventListener("tick", this._tickFunc),
        (this._isTicking = !0));
    }
    _StopTicking() {
      this._isTicking &&
        (this._runtime.Dispatcher().removeEventListener("tick", this._tickFunc),
        (this._isTicking = !1));
    }
    IsTicking() {
      return this._isTicking;
    }
    _StartTicking2() {
      this._isTicking2 ||
        (this._tick2Func || (this._tick2Func = () => this.Tick2()),
        this._runtime.Dispatcher().addEventListener("tick2", this._tick2Func),
        (this._isTicking2 = !0));
    }
    _StopTicking2() {
      this._isTicking2 &&
        (this._runtime
          .Dispatcher()
          .removeEventListener("tick2", this._tick2Func),
        (this._isTicking2 = !1));
    }
    IsTicking2() {
      return this._isTicking2;
    }
    GetDebuggerProperties() {
      return [];
    }
    SaveToJson() {
      return null;
    }
    LoadFromJson(b) {}
    GetPropertyValueByIndex(b) {}
    SetPropertyValueByIndex(b, a) {}
    OffsetPropertyValueByIndex(b, a) {
      if (0 !== a) {
        var c = this.GetPropertyValueByIndex(b);
        if ("number" !== typeof c) throw Error("expected number");
        this.SetPropertyValueByIndex(b, c + a);
      }
    }
    SetPropertyColorOffsetValueByIndex(b, a, c, d) {}
    CallAction(b, ...a) {
      b.call(this, ...a);
    }
    CallExpression(b, ...a) {
      return b.call(this, ...a);
    }
    GetScriptInterfaceClass() {
      return null;
    }
    DispatchScriptEvent(b, a, c) {
      const d = this.GetScriptInterface();
      b = e.New(e.Event, b, a);
      b.instance = d;
      c && Object.assign(b, c);
      d.dispatchEvent(b);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.SDKWorldInstanceBase = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b, a);
      this._worldInfo = b.GetWorldInfo();
      this._webglcontextrestored_handler = this._webglcontextlost_handler =
        null;
    }
    Release() {
      if (this._webglcontextlost_handler) {
        const b = this._runtime.Dispatcher();
        b.removeEventListener(
          "webglcontextlost",
          this._webglcontextlost_handler
        );
        b.removeEventListener(
          "webglcontextrestored",
          this._webglcontextrestored_handler
        );
        this._webglcontextrestored_handler = this._webglcontextlost_handler =
          null;
      }
      this._worldInfo = null;
      super.Release();
    }
    HandleWebGLContextLoss() {
      if (!this._webglcontextlost_handler) {
        this._webglcontextlost_handler = () => this.OnWebGLContextLost();
        this._webglcontextrestored_handler = () =>
          this.OnWebGLContextRestored();
        var b = this._runtime.Dispatcher();
        b.addEventListener("webglcontextlost", this._webglcontextlost_handler);
        b.addEventListener(
          "webglcontextrestored",
          this._webglcontextrestored_handler
        );
      }
    }
    OnWebGLContextLost() {}
    OnWebGLContextRestored() {}
    GetWorldInfo() {
      return this._worldInfo;
    }
    IsOriginalSizeKnown() {
      return !1;
    }
    GetOriginalWidth() {
      if (!this.IsOriginalSizeKnown()) throw Error("original size not known");
      const b = this.GetCurrentImageInfo();
      if (b) return b.GetWidth();
    }
    GetOriginalHeight() {
      if (!this.IsOriginalSizeKnown()) throw Error("original size not known");
      const b = this.GetCurrentImageInfo();
      if (b) return b.GetHeight();
    }
    GetCurrentImageInfo() {
      return null;
    }
    GetCurrentSurfaceSize() {
      var b = this.GetCurrentImageInfo();
      return b && (b = b.GetTexture())
        ? [b.GetWidth(), b.GetHeight()]
        : [100, 100];
    }
    GetCurrentTexRect() {
      const b = this.GetCurrentImageInfo();
      return b ? b.GetTexRect() : null;
    }
    GetCurrentTexQuad() {
      const b = this.GetCurrentImageInfo();
      return b ? b.GetTexQuad() : null;
    }
    IsCurrentTexRotated() {
      const b = this.GetCurrentImageInfo();
      return b ? b.IsRotated() : !1;
    }
    GetImagePoint(b) {
      b = this._inst.GetWorldInfo();
      return [b.GetX(), b.GetY()];
    }
    LoadTilemapData(b, a, c) {}
    TestPointOverlapTile(b, a) {}
    RendersToOwnZPlane() {
      return !0;
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = e.New(e.Rect);
  e.SDKDOMInstanceBase = class extends e.SDKWorldInstanceBase {
    constructor(a, c) {
      super(a, c);
      this._elementId = this.GetPlugin()._AddElement(this);
      this._isElementShowing = !0;
      this._autoFontSize = this._elemHasFocus = !1;
      this._autoFontSizeOffset = -0.2;
      this._lastRect = e.New(e.Rect, 0, 0, -1, -1);
      a = this._runtime.GetCanvasManager();
      this._lastWindowWidth = a.GetLastWidth();
      this._lastWindowHeight = a.GetLastHeight();
      this._isPendingUpdateState = !1;
      this._StartTicking();
    }
    Release() {
      this.GetPlugin()._RemoveElement(this._elementId);
      this.PostToDOMElement("destroy");
      this._elementId = -1;
      super.Release();
    }
    _GetElementInDOMMode() {
      if (this._runtime.IsInWorker()) throw Error("not valid in worker mode");
      return this._PostToDOMElementMaybeSync("get-element");
    }
    PostToDOMElement(a, c) {
      c || (c = {});
      c.elementId = this._elementId;
      this.PostToDOM(a, c);
    }
    _PostToDOMElementMaybeSync(a, c) {
      c || (c = {});
      c.elementId = this._elementId;
      return this._PostToDOMMaybeSync(a, c);
    }
    PostToDOMElementAsync(a, c) {
      c || (c = {});
      c.elementId = this._elementId;
      return this.PostToDOMAsync(a, c);
    }
    CreateElement(a) {
      a || (a = {});
      const c = this.GetWorldInfo().IsVisible();
      a.elementId = this._elementId;
      a.isVisible = c;
      Object.assign(a, this.GetElementState());
      this._isElementShowing = !!a.isVisible;
      this._PostToDOMMaybeSync("create", a);
      this._UpdatePosition(!0);
    }
    SetElementVisible(a) {
      a = !!a;
      this._isElementShowing !== a &&
        ((this._isElementShowing = a),
        this.PostToDOMElement("set-visible", { isVisible: a }));
    }
    Tick() {
      this._UpdatePosition(!1);
    }
    _ShouldPreserveElement() {
      const a = this._runtime.GetCanvasManager().GetFullscreenMode();
      return (
        "Android" === e.Platform.OS &&
        ("scale-inner" === a || "scale-outer" === a || "crop" === a)
      );
    }
    _UpdatePosition(a) {
      var c = this.GetWorldInfo();
      const d = c.GetLayer();
      var f = c.GetX(),
        h = c.GetY();
      let [g, k] = d.LayerToCanvasCss(f, h),
        [m, q] = d.LayerToCanvasCss(f + c.GetWidth(), h + c.GetHeight());
      f = this._runtime.GetCanvasManager();
      h = f.GetCssWidth();
      const v = f.GetCssHeight();
      if (c.IsVisible() && d.IsVisible()) {
        if (!this._ShouldPreserveElement()) {
          if (0 >= m || 0 >= q || g >= h || k >= v) {
            this.SetElementVisible(!1);
            return;
          }
          1 > g && (g = 1);
          1 > k && (k = 1);
          m >= h && (m = h - 1);
          q >= v && (q = v - 1);
        }
        b.set(g, k, m, q);
        c = f.GetLastWidth();
        h = f.GetLastHeight();
        !a &&
        b.equals(this._lastRect) &&
        this._lastWindowWidth === c &&
        this._lastWindowHeight === h
          ? this.SetElementVisible(!0)
          : (this._lastRect.copy(b),
            (this._lastWindowWidth = c),
            (this._lastWindowHeight = h),
            this.SetElementVisible(!0),
            (a = null),
            this._autoFontSize &&
              (a = d.GetDisplayScale() + this._autoFontSizeOffset),
            this.PostToDOMElement("update-position", {
              left: Math.round(this._lastRect.getLeft()) + f.GetCanvasClientX(),
              top: Math.round(this._lastRect.getTop()) + f.GetCanvasClientY(),
              width: Math.round(this._lastRect.width()),
              height: Math.round(this._lastRect.height()),
              fontSize: a,
            }));
      } else this.SetElementVisible(!1);
    }
    FocusElement() {
      this._PostToDOMElementMaybeSync("focus", { focus: !0 });
    }
    BlurElement() {
      this._PostToDOMElementMaybeSync("focus", { focus: !1 });
    }
    _OnElemFocused() {
      this._elemHasFocus = !0;
    }
    _OnElemBlurred() {
      this._elemHasFocus = !1;
    }
    IsElementFocused() {
      return this._elemHasFocus;
    }
    SetElementCSSStyle(a, c) {
      this.PostToDOMElement("set-css-style", {
        prop: e.CSSToCamelCase(a),
        val: c,
      });
    }
    SetElementAttribute(a, c) {
      this.PostToDOMElement("set-attribute", { name: a, val: c });
    }
    RemoveElementAttribute(a) {
      this.PostToDOMElement("remove-attribute", { name: a });
    }
    UpdateElementState() {
      this._isPendingUpdateState ||
        ((this._isPendingUpdateState = !0),
        Promise.resolve().then(() => {
          this._isPendingUpdateState = !1;
          this.PostToDOMElement("update-state", this.GetElementState());
        }));
    }
    GetElementState() {}
    GetElementId() {
      return this._elementId;
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.IBehavior;
  e.SDKBehaviorBase = class extends e.DefendedBase {
    constructor(a) {
      super();
      this._runtime = a.runtime;
      this._myObjectClasses = e.New(e.ArraySet);
      this._myInstances = e.New(e.ArraySet);
      this._iBehavior = null;
      this._scriptInterfaceClass = a.scriptInterfaceClass || null;
    }
    Release() {
      this._myInstances.Release();
      this._myObjectClasses.Release();
      this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    OnCreate() {}
    _AddObjectClass(a) {
      this._myObjectClasses.Add(a);
    }
    GetObjectClasses() {
      return this._myObjectClasses.GetArray();
    }
    _AddInstance(a) {
      this._myInstances.Add(a);
    }
    _RemoveInstance(a) {
      this._myInstances.Delete(a);
    }
    GetInstances() {
      return this._myInstances.GetArray();
    }
    GetIBehavior() {
      if (null === this._iBehavior) {
        const a = this._scriptInterfaceClass;
        if (a) {
          if (
            ((this._iBehavior = new a(this)), !(this._iBehavior instanceof b))
          )
            throw new TypeError(
              "script interface class must derive from IBehavior"
            );
        } else this._iBehavior = new b(this);
      }
      return this._iBehavior;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.SDKBehaviorTypeBase = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._runtime = b.GetRuntime();
      this._behaviorType = b;
      this._objectClass = b.GetObjectClass();
      this._behavior = b.GetBehavior();
      this._behavior._AddObjectClass(this._objectClass);
    }
    Release() {
      this._behavior =
        this._objectClass =
        this._behaviorType =
        this._runtime =
          null;
    }
    GetBehaviorType() {
      return this._behaviorType;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetBehavior() {
      return this._behavior;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.SDKBehaviorInstanceBase = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._behInst = b;
      this._domComponentId = a;
      this._inst = b.GetObjectInstance();
      this._runtime = b.GetRuntime();
      this._behaviorType = b.GetBehaviorType();
      this._sdkType = this._behaviorType.GetSdkType();
      this._isPostTicking = this._isTicking2 = this._isTicking = !1;
      this._disposables = null;
    }
    Release() {
      this._StopTicking();
      this._StopTicking2();
      this._StopPostTicking();
      this._disposables &&
        (this._disposables.Release(), (this._disposables = null));
      this._sdkType =
        this._behaviorType =
        this._runtime =
        this._inst =
        this._behInst =
          null;
    }
    GetBehavior() {
      return this._behaviorType.GetBehavior();
    }
    GetBehaviorInstance() {
      return this._behInst;
    }
    GetObjectInstance() {
      return this._inst;
    }
    GetObjectClass() {
      return this._inst.GetObjectClass();
    }
    GetWorldInfo() {
      return this._inst.GetWorldInfo();
    }
    GetRuntime() {
      return this._runtime;
    }
    GetBehaviorType() {
      return this._behaviorType;
    }
    GetSdkType() {
      return this._sdkType;
    }
    GetScriptInterface() {
      return this._behInst.GetScriptInterface();
    }
    Trigger(b) {
      return this._runtime.Trigger(b, this._inst, this._behaviorType);
    }
    DebugTrigger(b) {
      return this._runtime.DebugTrigger(b, this._inst, this._behaviorType);
    }
    TriggerAsync(b) {
      return this._runtime.TriggerAsync(b, this._inst, this._behaviorType);
    }
    PostCreate() {}
    Tick() {}
    Tick2() {}
    PostTick() {}
    _StartTicking() {
      this._isTicking ||
        (this._runtime._AddBehInstToTick(this), (this._isTicking = !0));
    }
    _StopTicking() {
      this._isTicking &&
        (this._runtime._RemoveBehInstToTick(this), (this._isTicking = !1));
    }
    IsTicking() {
      return this._isTicking;
    }
    _StartTicking2() {
      this._isTicking2 ||
        (this._runtime._AddBehInstToTick2(this), (this._isTicking2 = !0));
    }
    _StopTicking2() {
      this._isTicking2 &&
        (this._runtime._RemoveBehInstToTick2(this), (this._isTicking2 = !1));
    }
    IsTicking2() {
      return this._isTicking2;
    }
    _StartPostTicking() {
      this._isPostTicking ||
        (this._runtime._AddBehInstToPostTick(this), (this._isPostTicking = !0));
    }
    _StopPostTicking() {
      this._isPostTicking &&
        (this._runtime._RemoveBehInstToPostTick(this),
        (this._isPostTicking = !1));
    }
    IsPostTicking() {
      return this._isPostTicking;
    }
    GetDebuggerProperties() {
      return [];
    }
    AddDOMMessageHandler(b, a) {
      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, b, a);
    }
    OnSpriteFrameChanged(b, a) {}
    SaveToJson() {
      return null;
    }
    LoadFromJson(b) {}
    GetPropertyValueByIndex(b) {}
    SetPropertyValueByIndex(b, a) {}
    OffsetPropertyValueByIndex(b, a) {
      if (0 !== a) {
        var c = this.GetPropertyValueByIndex(b);
        if ("number" !== typeof c) throw Error("expected number");
        this.SetPropertyValueByIndex(b, c + a);
      }
    }
    SetPropertyColorOffsetValueByIndex(b, a, c, d) {}
    CallAction(b, ...a) {
      b.call(this, ...a);
    }
    CallExpression(b, ...a) {
      return b.call(this, ...a);
    }
    GetScriptInterfaceClass() {
      return null;
    }
    DispatchScriptEvent(b, a, c) {
      const d = this.GetScriptInterface();
      b = e.New(e.Event, b, a);
      b.behaviorInstance = d;
      b.instance = d.instance;
      c && Object.assign(b, c);
      d.dispatchEvent(b);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Plugins = {};
  e.Behaviors = {};
  e.PluginManager = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._runtime = b;
      this._allPlugins = [];
      this._pluginsByCtor = new Map();
      this._systemPlugin = null;
      this._allBehaviors = [];
      this._behaviorsByCtor = new Map();
      this._jumpthruBehavior = this._solidBehavior = null;
    }
    CreatePlugin(b) {
      const a = this._runtime.GetObjectReference(b[0]);
      if (!a) throw Error("missing plugin");
      e.AddCommonACEs(b, a);
      b = e.New(a, {
        runtime: this._runtime,
        isSingleGlobal: b[1],
        isWorld: b[2],
        isRotatable: b[5],
        hasEffects: b[8],
        mustPredraw: b[9],
        supportsSceneGraph: b[13],
        supportsMesh: b[14],
      });
      b.OnCreate();
      this._allPlugins.push(b);
      this._pluginsByCtor.set(a, b);
    }
    CreateSystemPlugin() {
      this._systemPlugin = e.New(e.Plugins.System, {
        runtime: this._runtime,
        isSingleGlobal: !0,
      });
      this._systemPlugin.OnCreate();
    }
    CreateBehavior(b) {
      b = this._runtime.GetObjectReference(b[1]);
      if (!b) throw Error("missing behavior");
      const a = e.New(b, { runtime: this._runtime });
      a.OnCreate();
      this._allBehaviors.push(a);
      this._behaviorsByCtor.set(b, a);
      !this._solidBehavior &&
      e.Behaviors.solid &&
      a instanceof e.Behaviors.solid
        ? (this._solidBehavior = a)
        : !this._jumpthruBehavior &&
          e.Behaviors.jumpthru &&
          a instanceof e.Behaviors.jumpthru &&
          (this._jumpthruBehavior = a);
    }
    GetPluginByConstructorFunction(b) {
      return this._pluginsByCtor.get(b) || null;
    }
    HasBehaviorByConstructorFunction(b) {
      return this._behaviorsByCtor.has(b);
    }
    GetBehaviorByConstructorFunction(b) {
      return this._behaviorsByCtor.get(b) || null;
    }
    GetSystemPlugin() {
      return this._systemPlugin;
    }
    GetSolidBehavior() {
      return this._solidBehavior;
    }
    GetJumpthruBehavior() {
      return this._jumpthruBehavior;
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = new Set();
  e.ImageInfo = class extends e.DefendedBase {
    constructor() {
      super();
      this._url = "";
      this._height =
        this._width =
        this._offsetY =
        this._offsetX =
        this._size =
          0;
      this._hasMetaData = this._isRotated = !1;
      this._imageAsset = null;
      this._textureState = "";
      this._rcTex = e.New(e.Rect);
      this._quadTex = e.New(e.Quad);
      this._iImageInfo = new self.IImageInfo(this);
      b.add(this);
    }
    Release() {
      this.ReleaseTexture();
      this._imageAsset = null;
      b.delete(this);
    }
    static OnWebGLContextLost() {
      for (const a of b)
        (a._textureState = ""),
          a._rcTex.set(0, 0, 0, 0),
          a._quadTex.setFromRect(a._rcTex);
    }
    LoadData(a) {
      this._url = a[0];
      this._size = a[1];
      this._offsetX = a[2];
      this._offsetY = a[3];
      this._width = a[4];
      this._height = a[5];
      this._isRotated = a[6];
      this._hasMetaData = !0;
    }
    LoadDynamicAsset(a, c) {
      if (this._imageAsset) throw Error("already loaded asset");
      this._url = c;
      const d = {};
      e.IsAbsoluteURL(c) && (d.loadPolicy = "remote");
      this.LoadAsset(a, d);
      return this._imageAsset.Load();
    }
    ReplaceWith(a) {
      if (a === this) throw Error("cannot replace with self");
      this.ReleaseTexture();
      this._url = a._url;
      this._size = a._size;
      this._offsetX = a._offsetX;
      this._offsetY = a._offsetY;
      this._width = a._width;
      this._height = a._height;
      this._isRotated = a._isRotated;
      this._hasMetaData = a._hasMetaData;
      this._imageAsset = a._imageAsset;
      this._textureState = a._textureState;
      this._rcTex = a._rcTex;
      this._quadTex = a._quadTex;
    }
    GetURL() {
      return this._url;
    }
    GetSize() {
      return this._size;
    }
    GetOffsetX() {
      return this._offsetX;
    }
    GetOffsetY() {
      return this._offsetY;
    }
    IsRotated() {
      return this._isRotated;
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    GetSheetWidth() {
      return this._imageAsset.GetWidth();
    }
    GetSheetHeight() {
      return this._imageAsset.GetHeight();
    }
    LoadAsset(a, c) {
      if (this._imageAsset) throw Error("already got asset");
      c = Object.assign({}, c, { url: this.GetURL(), size: this.GetSize() });
      this._imageAsset = a.LoadImage(c);
    }
    IsLoaded() {
      return this._imageAsset && this._imageAsset.IsLoaded();
    }
    async LoadStaticTexture(a, c) {
      if (!this._imageAsset) throw Error("no asset");
      if (this._textureState) throw Error("already loaded texture");
      this._textureState = "loading";
      a = await this._imageAsset.LoadStaticTexture(a, c);
      if (!a) return (this._textureState = ""), null;
      this._textureState = "loaded";
      this._hasMetaData ||
        ((this._width = a.GetWidth()),
        (this._height = a.GetHeight()),
        (this._hasMetaData = !0));
      this._rcTex.set(
        this._offsetX,
        this._offsetY,
        this._offsetX + (this._isRotated ? this._height : this._width),
        this._offsetY + (this._isRotated ? this._width : this._height)
      );
      this._rcTex.divide(a.GetWidth(), a.GetHeight());
      this._quadTex.setFromRect(this._rcTex);
      this._isRotated && this._quadTex.rotatePointsAnticlockwise();
      return a;
    }
    ReleaseTexture() {
      this._textureState &&
        (this._imageAsset && this._imageAsset.ReleaseTexture(),
        (this._textureState = ""),
        this._rcTex.set(0, 0, 0, 0),
        this._quadTex.setFromRect(this._rcTex));
    }
    GetTexture() {
      return this._imageAsset ? this._imageAsset.GetTexture() : null;
    }
    GetTexRect() {
      return this._rcTex;
    }
    GetTexQuad() {
      return this._quadTex;
    }
    GetIImageInfo() {
      return this._iImageInfo;
    }
    async ExtractImageToCanvas() {
      const a = await this._imageAsset.LoadToDrawable(),
        c = e.CreateCanvas(this._width, this._height);
      c.getContext("2d").drawImage(
        a,
        this._offsetX,
        this._offsetY,
        this._width,
        this._height,
        0,
        0,
        this._width,
        this._height
      );
      return c;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.AnimationInfo = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._name = b[0];
      this._speed = b[1];
      this._isLooping = !!b[2];
      this._repeatCount = b[3];
      this._repeatTo = b[4];
      this._isPingPong = !!b[5];
      this._sid = b[6];
      this._frames = b[7].map((a) => e.New(e.AnimationFrameInfo, a));
      this._iAnimation = new self.IAnimation(this);
    }
    Release() {
      for (const b of this._frames) b.Release();
      e.clearArray(this._frames);
    }
    LoadAllAssets(b) {
      for (const a of this._frames) a.GetImageInfo().LoadAsset(b);
    }
    LoadAllTextures(b, a) {
      return Promise.all(
        this._frames.map((c) => c.GetImageInfo().LoadStaticTexture(b, a))
      );
    }
    ReleaseAllTextures() {
      for (const b of this._frames) b.GetImageInfo().ReleaseTexture();
    }
    GetName() {
      return this._name;
    }
    GetSID() {
      return this._sid;
    }
    GetFrameCount() {
      return this._frames.length;
    }
    GetFrames() {
      return this._frames;
    }
    GetFrameAt(b) {
      b = Math.floor(b);
      if (0 > b || b >= this._frames.length)
        throw new RangeError("invalid frame");
      return this._frames[b];
    }
    GetSpeed() {
      return this._speed;
    }
    IsLooping() {
      return this._isLooping;
    }
    GetRepeatCount() {
      return this._repeatCount;
    }
    GetRepeatTo() {
      return this._repeatTo;
    }
    IsPingPong() {
      return this._isPingPong;
    }
    GetIAnimation() {
      return this._iAnimation;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.AnimationFrameInfo = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._imageInfo = e.New(e.ImageInfo);
      this._imageInfo.LoadData(b);
      this._duration = b[7];
      this._origin = e.New(e.Vector2, b[8], b[9]);
      this._imagePoints = b[10].map((a) => e.New(e.ImagePoint, this, a));
      this._imagePointsByName = new Map();
      for (const a of this._imagePoints)
        this._imagePointsByName.set(a.GetName().toLowerCase(), a);
      this._collisionPoly = null;
      b = b[11];
      6 <= b.length && (this._collisionPoly = e.New(e.CollisionPoly, b));
      this._iAnimationFrame = new self.IAnimationFrame(this);
    }
    Release() {
      this._collisionPoly &&
        (this._collisionPoly.Release(), (this._collisionPoly = null));
      this._imageInfo.Release();
      this._imageInfo = null;
    }
    GetImageInfo() {
      return this._imageInfo;
    }
    GetDuration() {
      return this._duration;
    }
    GetOriginX() {
      return this._origin.getX();
    }
    GetOriginY() {
      return this._origin.getY();
    }
    GetCollisionPoly() {
      return this._collisionPoly;
    }
    GetImagePointByName(b) {
      return this._imagePointsByName.get(b.toLowerCase()) || null;
    }
    GetImagePointByIndex(b) {
      b = Math.floor(b);
      return 0 > b || b >= this._imagePoints.length
        ? null
        : this._imagePoints[b];
    }
    GetImagePointCount() {
      return this._imagePoints.length;
    }
    GetIAnimationFrame() {
      return this._iAnimationFrame;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.ImagePoint = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._afi = b;
      this._name = a[0];
      this._pos = e.New(e.Vector2, a[1], a[2]);
    }
    Release() {}
    GetName() {
      return this._name;
    }
    GetX() {
      return this._pos.getX();
    }
    GetY() {
      return this._pos.getY();
    }
    GetVec2() {
      return this._pos;
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.C3Debugger,
    a = self.IObjectClass;
  e.ObjectClass = class extends e.DefendedBase {
    constructor(c, d, f) {
      super();
      const h = c.GetObjectReference(f[1]);
      this._runtime = c;
      this._plugin = c.GetPluginManager().GetPluginByConstructorFunction(h);
      this._sdkType = null;
      this._instSdkCtor = h.Instance;
      this._index = d;
      this._sid = f[11];
      this._name = f[0];
      this._jsPropName = this._runtime.GetJsPropName(f[14]);
      this._isGlobal = !!f[9];
      this._isFamily = !!f[2];
      this._isOnLoaderLayout = !!f[10];
      this._instVars = f[3].map((g) => ({
        sid: g[0],
        type: g[1],
        name: g[2],
        jsPropName: c.GetJsPropName(g[3]),
      }));
      this._behaviorsCount = f[4];
      this._effectsCount = f[5];
      this._isWorldType = this._plugin.IsWorldType();
      this._effectList = null;
      this._collisionGrid = e.New(
        e.SparseGrid,
        c.GetOriginalViewportWidth(),
        c.GetOriginalViewportHeight()
      );
      this._anyCollisionCellChanged = !0;
      this._anyInstanceParallaxed = !1;
      this._familyMembersSet = this._familyMembers = null;
      this._familyIndex = -1;
      this._familyEffectMap =
        this._familyBehaviorMap =
        this._familyInstVarMap =
        this._familiesSet =
        this._families =
          null;
      this._isInContainer = !1;
      this._container = null;
      this._behaviorTypes = f[8].map((g) => e.BehaviorType.Create(this, g));
      this._behaviorTypesIncludingInherited = [];
      this._behaviorsByName = new Map();
      this._behaviorNameToIndex = new Map();
      this._usedBehaviorCtors = new Set();
      this._solStack = e.New(e.SolStack, this);
      this._defaultInstanceData = null;
      this._defaultLayerIndex = 0;
      this._isContained = !1;
      this._animationsBySid =
        this._animationsByName =
        this._animations =
        this._imageInfo =
        this._container =
          null;
      this._textureRefCount = 0;
      this._savedData = new Map();
      this._unsavedData = new Map();
      this._instances = [];
      this._iidsStale = !0;
      this._plugin.HasEffects() &&
        (this._effectList = e.New(e.EffectList, this, f[12]));
      f[6] &&
        ((this._imageInfo = e.New(e.ImageInfo)),
        this._imageInfo.LoadData(f[6]));
      if (f[7]) {
        this._animations = f[7].map((g) => e.New(e.AnimationInfo, g));
        this._animationsByName = new Map();
        this._animationsBySid = new Map();
        for (const g of this._animations)
          this._animationsByName.set(g.GetName().toLowerCase(), g),
            this._animationsBySid.set(g.GetSID(), g);
      }
      this._isFamily
        ? ((this._familyMembers = []),
          (this._familyMembersSet = new Set()),
          (this._familyIndex = this._runtime._GetNextFamilyIndex()))
        : ((this._families = []),
          (this._familiesSet = new Set()),
          (this._familyInstVarMap = []),
          (this._familyBehaviorMap = []),
          (this._familyEffectMap = []));
      this._sdkType = e.New(h.Type, this, f[15]);
      this._instanceUserScriptClass = this._iObjectClass = null;
      this._userScriptDispatcher = e.New(e.Event.Dispatcher);
      if ((d = this._sdkType.GetScriptInterfaceClass())) {
        if (
          ((this._iObjectClass = new d(this)),
          !(this._iObjectClass instanceof a))
        )
          throw new TypeError(
            "script interface class must derive from IObjectClass"
          );
      } else this._iObjectClass = new a(this);
      f[13] && (d = f[13]) && this._sdkType.LoadTilemapData(d[0], d[1], d[2]);
      (this._runtime.UsesLoaderLayout() &&
        !this._isFamily &&
        !this._isOnLoaderLayout &&
        this._isWorldType) ||
        this.OnCreate();
      this._plugin.IsSingleGlobal() &&
        (this._plugin._SetSingleGlobalObjectClass(this),
        this._CreateSingleGlobalInstance(f));
    }
    static Create(c, d, f) {
      return e.New(e.ObjectClass, c, d, f);
    }
    Release() {
      this._imageInfo && (this._imageInfo.Release(), (this._imageInfo = null));
      if (this._animations) {
        for (const c of this._animations) c.Release();
        e.clearArray(this._animations);
        this._animationsByName.clear();
        this._animationsBySid.clear();
      }
      this._solStack.Release();
      this._solStack = null;
      this._savedData.clear();
      this._unsavedData.clear();
      this._runtime = this._container = null;
    }
    _LoadFamily(c) {
      for (let d = 1, f = c.length; d < f; ++d) {
        const h = this._runtime.GetObjectClassByIndex(c[d]);
        this._familyMembers.push(h);
        this._familyMembersSet.add(h);
        h._families.push(this);
        h._familiesSet.add(this);
      }
    }
    _SetContainer(c) {
      this._isInContainer = !0;
      this._container = c;
    }
    IsInContainer() {
      return this._isInContainer;
    }
    GetContainer() {
      return this._container;
    }
    _OnAfterCreate() {
      var c = 0;
      if (!this._isFamily)
        for (var d of this._families)
          for (var f of d.GetBehaviorTypes()) {
            const k = f.GetName().toLowerCase();
            this._behaviorsByName.set(k, f);
            this._behaviorNameToIndex.set(k, c);
            this._behaviorTypesIncludingInherited.push(f);
            ++c;
          }
      for (var h of this.GetBehaviorTypes())
        (d = h.GetName().toLowerCase()),
          this._behaviorsByName.set(d, h),
          this._behaviorNameToIndex.set(d, c),
          this._behaviorTypesIncludingInherited.push(h),
          ++c;
      for (var g of this._behaviorTypesIncludingInherited)
        this._usedBehaviorCtors.add(g.GetBehavior().constructor);
      if (!this._isFamily && this._families.length) {
        c = this._runtime.GetFamilyCount();
        e.extendArray(this._familyInstVarMap, c, 0);
        e.extendArray(this._familyBehaviorMap, c, 0);
        e.extendArray(this._familyEffectMap, c, 0);
        c = [];
        d = g = h = 0;
        for (const k of this._families)
          if (
            ((f = k.GetFamilyIndex()),
            (this._familyInstVarMap[f] = h),
            (h += k.GetInstanceVariablesCount()),
            (this._familyBehaviorMap[f] = g),
            (g += k.GetBehaviorTypesCount()),
            (this._familyEffectMap[f] = d),
            (d += k.GetEffectTypesCount()),
            (f = k.GetEffectList()) && this._effectList)
          )
            for (const m of f.GetAllEffectTypes())
              c.push(m.Clone(this._effectList));
        this._effectList && this._effectList.PrependEffectTypes(c);
      }
    }
    _CreateSingleGlobalInstance(c) {
      const d = this._runtime._GetNewUID(),
        f = e.New(e.Instance, {
          runtime: this._runtime,
          objectType: this,
          uid: d,
        });
      f._CreateSdkInstance(c[16], []);
      this._runtime._MapInstanceByUID(d, f);
      this._instances.push(f);
    }
    GetSdkType() {
      return this._sdkType;
    }
    IsOnLoaderLayout() {
      return this._isOnLoaderLayout;
    }
    OnCreate() {
      this._isFamily || this._sdkType.OnCreate();
    }
    HasLoadedTextures() {
      return 0 < this._textureRefCount;
    }
    LoadTextures(c) {
      if (this._isFamily) return Promise.resolve();
      this._textureRefCount++;
      return 1 === this._textureRefCount
        ? this._sdkType.LoadTextures(c) || Promise.resolve()
        : Promise.resolve();
    }
    ReleaseTextures() {
      if (!this._isFamily) {
        this._textureRefCount--;
        if (0 > this._textureRefCount)
          throw Error("released textures too many times");
        0 === this._textureRefCount && this._sdkType.ReleaseTextures();
      }
    }
    OnDynamicTextureLoadComplete() {
      if (this._isFamily) throw Error("not applicable to family");
      this._sdkType.OnDynamicTextureLoadComplete();
    }
    PreloadTexturesWithInstances(c) {
      return this._isFamily
        ? Promise.resolve()
        : this._sdkType.PreloadTexturesWithInstances(c);
    }
    GetRuntime() {
      return this._runtime;
    }
    GetPlugin() {
      return this._plugin;
    }
    GetInstanceSdkCtor() {
      return this._instSdkCtor;
    }
    GetName() {
      return this._name;
    }
    GetJsPropName() {
      return this._jsPropName;
    }
    GetIndex() {
      return this._index;
    }
    GetSID() {
      return this._sid;
    }
    IsFamily() {
      return this._isFamily;
    }
    IsGlobal() {
      return this._isGlobal;
    }
    IsWorldType() {
      return this._isWorldType;
    }
    GetFamilyIndex() {
      return this._familyIndex;
    }
    GetBehaviorTypes() {
      return this._behaviorTypes;
    }
    GetBehaviorTypesCount() {
      return this._behaviorsCount;
    }
    UsesBehaviorByCtor(c) {
      return c && this._usedBehaviorCtors.has(c);
    }
    GetInstanceVariablesCount() {
      return this._instVars.length;
    }
    GetInstanceVariableSIDs() {
      return this._instVars.map((c) => c.sid);
    }
    GetInstanceVariableIndexBySID(c) {
      return this._instVars.findIndex((d) => d.sid === c);
    }
    GetInstanceVariableIndexByName(c) {
      return this._instVars.findIndex((d) => d.name === c);
    }
    _GetAllInstanceVariableNames() {
      return this._instVars.map((c) => c.name);
    }
    _GetAllInstanceVariableJsPropNames() {
      return this._instVars.map((c) => c.jsPropName);
    }
    GetInstanceVariableType(c) {
      c = Math.floor(c);
      if (0 > c || c >= this._instVars.length)
        throw new RangeError("invalid instance variable index");
      return this._instVars[c].type;
    }
    GetInstanceVariableName(c) {
      c = Math.floor(c);
      if (0 > c || c >= this._instVars.length)
        throw new RangeError("invalid instance variable index");
      return this._instVars[c].name;
    }
    GetEffectTypesCount() {
      return this._effectsCount;
    }
    GetBehaviorTypesIncludingInherited() {
      return this._behaviorTypesIncludingInherited;
    }
    GetBehaviorTypeByName(c) {
      return this._behaviorsByName.get(c.toLowerCase()) || null;
    }
    GetBehaviorIndexByName(c) {
      c = this._behaviorNameToIndex.get(c.toLowerCase());
      return "undefined" === typeof c ? -1 : c;
    }
    GetEffectList() {
      return this._effectList;
    }
    HasEffects() {
      return this._plugin.HasEffects();
    }
    UsesEffects() {
      return this._effectList && this._effectList.HasAnyEffectType();
    }
    GetSolStack() {
      return this._solStack;
    }
    GetCurrentSol() {
      return this._solStack.GetCurrentSol();
    }
    GetImageInfo() {
      return this._imageInfo;
    }
    SetDefaultInstanceData(c) {
      this._defaultInstanceData = c;
    }
    GetDefaultInstanceData() {
      return this._defaultInstanceData;
    }
    _SetDefaultLayerIndex(c) {
      this._defaultLayerIndex = c;
    }
    GetDefaultLayerIndex() {
      return this._defaultLayerIndex;
    }
    GetAnimations() {
      return this._animations;
    }
    GetAnimationCount() {
      return this._animations.length;
    }
    GetFamilies() {
      return this._families;
    }
    BelongsToFamily(c) {
      return this._familiesSet.has(c);
    }
    GetFamilyMembers() {
      return this._familyMembers;
    }
    FamilyHasMember(c) {
      return this._familyMembersSet.has(c);
    }
    GetFamilyBehaviorOffset(c) {
      return this._familyBehaviorMap[c];
    }
    GetFamilyInstanceVariableOffset(c) {
      return this._familyInstVarMap[c];
    }
    GetAnimationByName(c) {
      if (!this._animations) throw Error("no animations");
      return this._animationsByName.get(c.toLowerCase()) || null;
    }
    GetAnimationBySID(c) {
      if (!this._animations) throw Error("no animations");
      return this._animationsBySid.get(c) || null;
    }
    GetFirstAnimationFrame() {
      if (!this._animations) throw Error("no animations");
      return this._animations[0].GetFrameAt(0);
    }
    GetDefaultInstanceSize() {
      if (this._animations) {
        const c = this.GetFirstAnimationFrame().GetImageInfo();
        return [c.GetWidth(), c.GetHeight()];
      }
      return this._imageInfo
        ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()]
        : [100, 100];
    }
    GetSingleGlobalInstance() {
      if (!this._plugin.IsSingleGlobal())
        throw Error("not a single-global plugin");
      return this._instances[0];
    }
    GetInstances() {
      return this._instances;
    }
    *instances() {
      yield* this._instances;
    }
    *instancesIncludingPendingCreate() {
      yield* this._instances;
      yield* this._runtime.instancesPendingCreateForObjectClass(this);
    }
    GetInstanceCount() {
      return this._instances.length;
    }
    _AddInstance(c) {
      this._instances.push(c);
    }
    _SetIIDsStale() {
      this._iidsStale = !0;
    }
    _UpdateIIDs() {
      if (this._iidsStale && !this._isFamily) {
        var c = this._instances,
          d = 0;
        for (let f = c.length; d < f; ++d) c[d]._SetIID(d);
        c = this._runtime._GetInstancesPendingCreate();
        for (const f of c) f.GetObjectClass() === this && f._SetIID(d++);
        this._iidsStale = !1;
      }
    }
    GetInstanceByIID(c) {
      var d = this._instances;
      if (c < d.length) return d[c];
      c -= d.length;
      d = this._runtime._GetInstancesPendingCreate();
      for (const f of d)
        if (f.GetObjectClass() === this) {
          if (0 === c) return f;
          --c;
        }
      return null;
    }
    GetFirstPicked(c) {
      if (c && c.IsInContainer() && c.GetObjectClass() !== this)
        for (const d of c.siblings()) if (d.GetObjectClass() === this) return d;
      c = this.GetCurrentSol().GetInstances();
      return c.length ? c[0] : null;
    }
    GetPairedInstance(c) {
      const d = this.GetCurrentSol().GetInstances();
      return 0 < d.length ? d[c.GetIID() % d.length] : null;
    }
    *allCorrespondingInstances(c, d) {
      const f = this.GetCurrentSol().GetInstances();
      var h = f.length;
      const g = d.GetCurrentSol(),
        k = d.GetCurrentSol().GetInstances(),
        m = k.length;
      var q = c.GetIID();
      if (d.IsFamily() || !g.IsSelectAll()) q = k.indexOf(c);
      c = Math.ceil(h / m);
      h %= m;
      0 === h || q < h
        ? ((q *= c), (h = c))
        : ((q = h * c + (q - h) * (c - 1)), (h = c - 1));
      for (let v = q, r = q + h; v < r; ++v) yield f[v];
    }
    FinishCondition(c) {
      this._sdkType.FinishCondition(c);
    }
    ApplySolToContainer() {
      if (this._isInContainer && !this._isFamily) {
        this._UpdateIIDs();
        var c = this.GetCurrentSol(),
          d = c._GetOwnInstances(),
          f = c.IsSelectAll(),
          h = this._runtime.GetCurrentEventStackFrame();
        h = h && h.GetCurrentEvent() && h.GetCurrentEvent().IsOrBlock();
        for (const m of this._container.objectTypes())
          if (m !== this) {
            m._UpdateIIDs();
            var g = m.GetCurrentSol();
            g._SetSelectAll(f);
            if (!f) {
              var k = g._GetOwnInstances();
              e.clearArray(k);
              for (const q of d) k.push(m.GetInstanceByIID(q.GetIID()));
              if (h) {
                k = c._GetOwnElseInstances();
                g = g._GetOwnElseInstances();
                e.clearArray(g);
                for (const q of k) g.push(m.GetInstanceByIID(q.GetIID()));
              }
            }
          }
      }
    }
    _TruncateContainerSols(c, d) {
      for (const f of this.GetContainer().objectTypes()) {
        const h = f.GetCurrentSol();
        c
          ? e.truncateArray(h._GetOwnElseInstances(), d)
          : e.truncateArray(h._GetOwnInstances(), d);
      }
    }
    _GetCollisionCellGrid() {
      return this._collisionGrid;
    }
    _SetAnyCollisionCellChanged(c) {
      this._anyCollisionCellChanged = !!c;
    }
    _SetAnyInstanceParallaxed(c) {
      this._anyInstanceParallaxed = !!c;
    }
    IsAnyInstanceParallaxed() {
      return this._anyInstanceParallaxed;
    }
    _UpdateAllCollisionCells() {
      if (this._anyCollisionCellChanged && this._isWorldType) {
        for (const c of this._instances)
          c.GetWorldInfo()._UpdateCollisionCell();
        for (const c of this._runtime._GetInstancesPendingCreate())
          c.GetObjectClass() === this &&
            c.GetWorldInfo()._UpdateCollisionCell();
        this._anyCollisionCellChanged = !1;
      }
    }
    GetSavedDataMap() {
      this._savedData || (this._savedData = new Map());
      return this._savedData;
    }
    GetUnsavedDataMap() {
      this._unsavedData || (this._unsavedData = new Map());
      return this._unsavedData;
    }
    HasSolidBehavior() {
      return this.UsesBehaviorByCtor(e.Behaviors.solid);
    }
    HasJumpthruBehavior() {
      return this.UsesBehaviorByCtor(e.Behaviors.jumpthru);
    }
    HasNoSaveBehavior() {
      return this.UsesBehaviorByCtor(e.Behaviors.NoSave);
    }
    HasPersistBehavior() {
      return this.UsesBehaviorByCtor(e.Behaviors.Persist);
    }
    _SaveToJson() {
      const c = { instances: this._instances.map((d) => d.SaveToJson()) };
      this._savedData &&
        this._savedData.size &&
        (c.ex = e.ToSuperJSON(this._savedData));
      return c;
    }
    _LoadFromJson(c) {
      this._savedData && (this._savedData.clear(), (this._savedData = null));
      var d = c.ex;
      d && (this._savedData = e.FromSuperJSON(d));
      d = this._instances;
      c = c.instances;
      for (let f = 0, h = Math.min(d.length, c.length); f < h; ++f)
        d[f].LoadFromJson(c[f]);
      for (let f = c.length, h = d.length; f < h; ++f)
        this._runtime.DestroyInstance(d[f]);
      for (let f = d.length, h = c.length; f < h; ++f) {
        d = c[f];
        let g = null;
        if (
          this.IsWorldType() &&
          ((g = this._runtime.GetMainRunningLayout().GetLayerBySID(d.w.l)), !g)
        )
          continue;
        this._runtime
          .CreateInstanceFromData(
            this._defaultInstanceData || this,
            g,
            !1,
            0,
            0,
            !0
          )
          .LoadFromJson(d);
      }
      this._SetIIDsStale();
    }
    GetIObjectClass() {
      return this._iObjectClass;
    }
    UserScriptDispatcher() {
      return this._userScriptDispatcher;
    }
    _GetUserScriptInstanceClass() {
      return this._instanceUserScriptClass;
    }
    _SetUserScriptInstanceClass(c) {
      this._instanceUserScriptClass = c;
    }
    DispatchUserScriptEvent(c) {
      var d = this._runtime;
      (d = d.IsDebug() && !d.GetEventSheetManager().IsInEventEngine()) &&
        b.StartMeasuringScriptTime();
      this._userScriptDispatcher.dispatchEvent(c);
      d && b.AddScriptTime();
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Container = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._runtime = b;
      this._objectTypes = a;
      for (const c of this._objectTypes) c._SetContainer(this);
    }
    Release() {
      this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetObjectTypes() {
      return this._objectTypes;
    }
    objectTypes() {
      return this._objectTypes;
    }
    HasAnyWorldType() {
      return this._objectTypes.some((b) => b.IsWorldType());
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.C3Debugger,
    a = self.IInstance,
    c = [];
  let d = 0;
  const f = new WeakMap(),
    h = new WeakMap();
  e.Instance = class extends e.DefendedBase {
    constructor(g) {
      super();
      this._runtime = g.runtime;
      this._objectType = g.objectType;
      this._iScriptInterface = this._sdkInst = this._worldInfo = null;
      this._iid = 0;
      this._uid = g.uid;
      this._puid = d++;
      this._flags = 0;
      this._behaviorInstances = this._instVarValues = c;
      var k = this._objectType.GetBehaviorTypesIncludingInherited();
      0 < k.length &&
        (this._behaviorInstances = k.map((m, q) =>
          e.New(e.BehaviorInstance, {
            runtime: this._runtime,
            behaviorType: m,
            instance: this,
            index: q,
          })
        ));
      this._siblings = this._objectType.IsInContainer() ? [] : null;
      this._timeScale = -1;
      this._dispatcher = null;
      k = this.GetPlugin();
      k.MustPreDraw() && (this._flags |= 4);
      if (k.IsWorldType())
        if (
          ((this._worldInfo = e.New(e.WorldInfo, this, g.layer)), g.worldData)
        )
          this._worldInfo.Init(g.worldData);
        else {
          this._worldInfo.InitNoData();
          const [m, q] = this._objectType.GetDefaultInstanceSize();
          this._worldInfo.SetSize(m, q);
          this.GetObjectClass().UsesEffects() &&
            this._worldInfo
              .GetInstanceEffectList()
              .LoadDefaultEffectParameters();
        }
      g.instVarData
        ? this._LoadInstanceVariableData(g.instVarData)
        : this._LoadDefaultInstanceVariables();
    }
    Release() {
      this._iScriptInterface &&
        (this._iScriptInterface._Release(), (this._iScriptInterface = null));
      if (0 < this._behaviorInstances.length) {
        for (var g of this._behaviorInstances) g.Release();
        e.clearArray(this._behaviorInstances);
      }
      this._sdkInst.Release();
      this._sdkInst = null;
      if ((g = f.get(this))) g.clear(), f.delete(this);
      if ((g = h.get(this))) g.clear(), h.delete(this);
      this._siblings && e.clearArray(this._siblings);
      this._dispatcher &&
        (this._dispatcher.Release(), (this._dispatcher = null));
      this._objectType = this._runtime = null;
      0 < this._instVarValues.length && e.clearArray(this._instVarValues);
      this._worldInfo && (this._worldInfo.Release(), (this._worldInfo = null));
    }
    _LoadInstanceVariableData(g) {
      0 < g.length &&
        ((this._instVarValues = []),
        e.shallowAssignArray(this._instVarValues, g));
    }
    _LoadDefaultInstanceVariables() {
      const g = this._objectType.GetInstanceVariablesCount();
      if (0 !== g) {
        this._instVarValues = [];
        var k = [0, 0, ""];
        for (let m = 0; m < g; ++m)
          this._instVarValues.push(
            k[this._objectType.GetInstanceVariableType(m)]
          );
      }
    }
    _CreateSdkInstance(g, k) {
      if (this._sdkInst) throw Error("already got sdk instance");
      for (let m = 0, q = this._behaviorInstances.length; m < q; ++m)
        this._behaviorInstances[m]._CreateSdkInstance(k ? k[m] : null);
      this._sdkInst = e.New(this._objectType.GetInstanceSdkCtor(), this, g);
      if (!(this._sdkInst instanceof e.SDKInstanceBase))
        throw Error("sdk type must derive from SDKInstanceBase");
      for (let m = 0, q = this._behaviorInstances.length; m < q; ++m)
        this._behaviorInstances[m].PostCreate();
      this._objectType._GetUserScriptInstanceClass() &&
        this._InitUserScriptInterface();
    }
    GetSdkInstance() {
      return this._sdkInst;
    }
    GetWorldInfo() {
      return this._worldInfo;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetTimeScale() {
      return this._timeScale;
    }
    GetActiveTimeScale() {
      const g = this._timeScale;
      return -1 === g ? this.GetRuntime().GetTimeScale() : g;
    }
    SetTimeScale(g) {
      g = +g;
      if (0 > g || !isFinite(g)) g = 0;
      this._timeScale = g;
      this.GetObjectClass().UsesEffects() &&
        this._runtime._SetTrackingInstanceTime(this, !0);
    }
    RestoreTimeScale() {
      this._timeScale = -1;
      this.GetObjectClass().UsesEffects() &&
        this._runtime._SetTrackingInstanceTime(this, !1);
    }
    GetInstanceGameTime() {
      return this._runtime._GetInstanceGameTime(this);
    }
    Dispatcher() {
      this._dispatcher || (this._dispatcher = e.New(e.Event.Dispatcher));
      return this._dispatcher;
    }
    Draw(g) {
      this._sdkInst.Draw(g);
    }
    OnCreate(g) {
      this._sdkInst.OnCreate(g);
    }
    _SetHasTilemap() {
      this._flags |= 2;
    }
    HasTilemap() {
      return 0 !== (this._flags & 2);
    }
    _MarkDestroyed() {
      this._flags |= 1;
    }
    IsDestroyed() {
      return 0 !== (this._flags & 1);
    }
    MustPreDraw() {
      return 0 !== (this._flags & 4);
    }
    SetMustMitigateZFighting() {
      this._flags |= 32;
    }
    MustMitigateZFighting() {
      return 0 !== (this._flags & 32);
    }
    _IsSolidEnabled() {
      return 0 !== (this._flags & 8);
    }
    _SetSolidEnabled(g) {
      this._flags = g ? this._flags | 8 : this._flags & -9;
    }
    _IsJumpthruEnabled() {
      return 0 !== (this._flags & 16);
    }
    _SetJumpthruEnabled(g) {
      this._flags = g ? this._flags | 16 : this._flags & -17;
    }
    _IsDrawingWithEffects() {
      return 0 !== (this._flags & 64);
    }
    _SetIsDrawingWithEffects(g) {
      this._flags = g ? this._flags | 64 : this._flags & -65;
    }
    SetFlag(g, k) {
      g <<= 16;
      this._flags = k ? this._flags | g : this._flags & ~g;
    }
    GetFlag(g) {
      return 0 !== (this._flags & (g << 16));
    }
    GetCurrentImageInfo() {
      return this._sdkInst.GetCurrentImageInfo();
    }
    GetCurrentSurfaceSize() {
      return this._sdkInst.GetCurrentSurfaceSize();
    }
    GetCurrentTexRect() {
      return this._sdkInst.GetCurrentTexRect();
    }
    GetCurrentTexQuad() {
      return this._sdkInst.GetCurrentTexQuad();
    }
    IsCurrentTexRotated() {
      return this._sdkInst.IsCurrentTexRotated();
    }
    GetImagePoint(g) {
      return this._sdkInst.GetImagePoint(g);
    }
    GetObjectClass() {
      return this._objectType;
    }
    RendersToOwnZPlane() {
      return this._sdkInst.RendersToOwnZPlane();
    }
    BelongsToObjectClass(g) {
      return g.IsFamily()
        ? g.FamilyHasMember(this.GetObjectClass())
        : this.GetObjectClass() === g;
    }
    VerifySupportsSceneGraph() {
      if (!this.GetPlugin().SupportsSceneGraph())
        throw Error("object does not support scene graph");
    }
    HasParent() {
      return null !== this.GetParent();
    }
    GetParent() {
      var g = this.GetWorldInfo();
      return g ? ((g = g.GetParent()) ? g.GetInstance() : null) : null;
    }
    GetTopParent() {
      var g = this.GetWorldInfo();
      return g ? ((g = g.GetTopParent()) ? g.GetInstance() : null) : null;
    }
    *parents() {
      const g = this.GetWorldInfo();
      if (g) for (const k of g.parents()) yield k.GetInstance();
    }
    HasChild(g) {
      if (!g) return !1;
      for (const k of this.children()) if (k === g) return !0;
      return !1;
    }
    HasChildren() {
      const g = this.GetWorldInfo();
      return g ? g.HasChildren() : !1;
    }
    GetChildren() {
      const g = this.GetWorldInfo();
      return g ? g.GetChildren().map((k) => k.GetInstance()) : [];
    }
    *children() {
      const g = this.GetWorldInfo();
      if (g) for (const k of g.children()) yield k.GetInstance();
    }
    *allChildren() {
      const g = this.GetWorldInfo();
      if (g) for (const k of g.allChildren()) yield k.GetInstance();
    }
    GetChildCount() {
      const g = this.GetWorldInfo();
      return g ? g.GetChildCount() : 0;
    }
    GetChildAt(g) {
      const k = this.GetWorldInfo();
      return k ? ((g = k.GetChildAt(g)) ? g.GetInstance() : null) : null;
    }
    AddChild(g, k) {
      this.VerifySupportsSceneGraph();
      g.VerifySupportsSceneGraph();
      this.GetWorldInfo().AddChild(g.GetWorldInfo(), k || {});
    }
    RemoveChild(g) {
      const k = this.GetWorldInfo();
      k && k.RemoveChild(g.GetWorldInfo());
    }
    GetDestroyWithParent() {
      const g = this.GetWorldInfo();
      return g ? g.GetDestroyWithParent() : !1;
    }
    SetupInitialSceneGraphConnections() {
      var g = this.GetWorldInfo();
      if (g && (g = g.GetSceneGraphChildrenExportData()))
        for (const k of g)
          if ((g = this._runtime.GetInstanceByUID(k[2]))) {
            const m = k[3];
            this.AddChild(g, {
              transformX: !!((m >> 0) & 1),
              transformY: !!((m >> 1) & 1),
              transformWidth: !!((m >> 2) & 1),
              transformHeight: !!((m >> 3) & 1),
              transformAngle: !!((m >> 4) & 1),
              destroyWithParent: !!((m >> 5) & 1),
              transformZElevation: !!((m >> 6) & 1),
            });
          }
    }
    IsInContainer() {
      return null !== this._siblings;
    }
    _AddSibling(g) {
      this._siblings.push(g);
    }
    GetSiblings() {
      return this._siblings;
    }
    HasSibling(g) {
      return !!this.GetSibling(g);
    }
    GetSibling(g) {
      const k = this.siblings();
      if (null === k || 0 === k.length) return !1;
      for (const m of k) if (m.GetObjectClass() === g) return m;
      return null;
    }
    siblings() {
      return this._siblings;
    }
    SetSiblingsSinglePicked() {
      for (const g of this.siblings())
        g.GetObjectClass().GetCurrentSol().SetSinglePicked(g);
    }
    _PushSiblingsToSolInstances() {
      for (const g of this.siblings())
        g.GetObjectClass().GetCurrentSol()._PushInstance(g);
    }
    _SetSiblingsToSolInstancesIndex(g) {
      for (const k of this.siblings())
        k.GetObjectClass().GetCurrentSol()._GetOwnInstances()[g] = k;
    }
    _PushSiblingsToSolElseInstances() {
      for (const g of this.siblings())
        g.GetObjectClass().GetCurrentSol()._PushElseInstance(g);
    }
    _SetSiblingsToSolElseInstancesIndex(g) {
      for (const k of this.siblings())
        k.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[g] = k;
    }
    GetPlugin() {
      return this._objectType.GetPlugin();
    }
    _SetIID(g) {
      this._iid = g;
    }
    GetIID() {
      this._objectType._UpdateIIDs();
      return this._iid;
    }
    GetUID() {
      return this._uid;
    }
    GetPUID() {
      return this._puid;
    }
    GetBehaviorInstances() {
      return this._behaviorInstances;
    }
    GetBehaviorInstanceFromCtor(g) {
      if (!g) return null;
      for (const k of this._behaviorInstances)
        if (k.GetBehavior() instanceof g) return k;
      return null;
    }
    GetBehaviorSdkInstanceFromCtor(g) {
      return g
        ? (g = this.GetBehaviorInstanceFromCtor(g))
          ? g.GetSdkInstance()
          : null
        : null;
    }
    GetBehaviorIndexBySID(g) {
      const k = this._behaviorInstances;
      for (let m = 0, q = k.length; m < q; ++m)
        if (k[m].GetBehaviorType().GetSID() === g) return m;
      return -1;
    }
    GetAllInstanceVariableValues() {
      return this._instVarValues;
    }
    _GetAllInstanceVariableNames() {
      return this._objectType._GetAllInstanceVariableNames();
    }
    GetInstanceVariableCount() {
      return this._instVarValues.length;
    }
    GetInstanceVariableValue(g) {
      g |= 0;
      const k = this._instVarValues;
      if (0 > g || g >= k.length)
        throw new RangeError("invalid instance variable");
      return k[g];
    }
    _GetInstanceVariableValueUnchecked(g) {
      return this._instVarValues[g];
    }
    _GetInstanceVariableTypedValue(g) {
      const k = this._instVarValues[g];
      return 0 === this._objectType.GetInstanceVariableType(g) ? !!k : k;
    }
    SetInstanceVariableValue(g, k) {
      g |= 0;
      const m = this._instVarValues;
      if (0 > g || g >= m.length)
        throw new RangeError("invalid instance variable");
      switch (this._objectType.GetInstanceVariableType(g)) {
        case 0:
          m[g] = k ? 1 : 0;
          break;
        case 1:
          m[g] = "number" === typeof k ? k : parseFloat(k);
          break;
        case 2:
          m[g] = "string" === typeof k ? k : k.toString();
          break;
        default:
          throw Error("unknown instance variable type");
      }
    }
    SetInstanceVariableOffset(g, k) {
      if (0 !== k) {
        g |= 0;
        var m = this._instVarValues;
        if (0 > g || g >= m.length)
          throw new RangeError("invalid instance variable");
        var q = m[g];
        if ("number" === typeof q)
          m[g] = "number" === typeof k ? m[g] + k : m[g] + parseFloat(k);
        else {
          if ("boolean" === typeof q)
            throw Error("can not set offset of boolean variable");
          if ("string" === typeof q)
            throw Error("can not set offset of string variable");
          throw Error("unknown instance variable type");
        }
      }
    }
    GetSavedDataMap() {
      let g = f.get(this);
      if (g) return g;
      g = new Map();
      f.set(this, g);
      return g;
    }
    GetUnsavedDataMap() {
      let g = h.get(this);
      if (g) return g;
      g = new Map();
      h.set(this, g);
      return g;
    }
    _HasAnyCreateDestroyHandler(g) {
      const k = this.GetObjectClass();
      if (k.UserScriptDispatcher().HasAnyHandlerFor(g)) return !0;
      for (const m of k.GetFamilies())
        if (m.UserScriptDispatcher().HasAnyHandlerFor(g)) return !0;
      return this._runtime.UserScriptDispatcher().HasAnyHandlerFor(g) ? !0 : !1;
    }
    _TriggerOnCreatedOnSelfAndRelated() {
      const g = new Set();
      g.add(this);
      const k = this.GetWorldInfo();
      if (k && k.HasChildren())
        for (const m of this.allChildren())
          if ((g.add(m), m.IsInContainer()))
            for (const q of m.siblings()) g.add(q);
      if (this.IsInContainer()) for (const m of this.siblings()) g.add(m);
      for (const m of g.values()) m._TriggerOnCreated();
    }
    _TriggerOnCreated() {
      if (this._HasAnyCreateDestroyHandler("instancecreate")) {
        const g = this.GetObjectClass(),
          k = new e.Event("instancecreate");
        k.instance = this.GetInterfaceClass();
        g.DispatchUserScriptEvent(k);
        for (const m of g.GetFamilies()) m.DispatchUserScriptEvent(k);
        this._runtime.DispatchUserScriptEvent(k);
      }
      this._runtime.Trigger(
        this.GetPlugin().constructor.Cnds.OnCreated,
        this,
        null
      );
    }
    _TriggerOnDestroyed() {
      this._runtime.Trigger(
        this.GetPlugin().constructor.Cnds.OnDestroyed,
        this,
        null
      );
    }
    _FireDestroyedScriptEvents(g) {
      if (this._iScriptInterface) {
        var k = new e.Event("destroy");
        k.isEndingLayout = g;
        this.DispatchUserScriptEvent(k);
      }
      if (this._HasAnyCreateDestroyHandler("instancedestroy")) {
        k = this.GetObjectClass();
        var m = new e.Event("instancedestroy");
        m.instance = this.GetInterfaceClass();
        m.isEndingLayout = g;
        k.DispatchUserScriptEvent(m);
        for (const q of k.GetFamilies()) q.DispatchUserScriptEvent(m);
        this._runtime.DispatchUserScriptEvent(m);
      }
    }
    _GetDebuggerProperties() {
      return this._sdkInst.GetDebuggerProperties();
    }
    SaveToJson(g = "full") {
      const k = {};
      "full" === g ? (k.uid = this.GetUID()) : (k.c3 = !0);
      if ("visual-state" !== g) {
        var m = f.get(this);
        m && m.size && (k.ex = e.ToSuperJSON(m));
        -1 !== this.GetTimeScale() && (k.mts = this.GetTimeScale());
        if (0 < this._objectType.GetInstanceVariablesCount()) {
          m = {};
          var q = this._objectType.GetInstanceVariableSIDs();
          for (let v = 0, r = this._instVarValues.length; v < r; ++v)
            m[q[v].toString()] = this._instVarValues[v];
          k.ivs = m;
        }
        if (this._behaviorInstances.length) {
          m = {};
          for (const v of this._behaviorInstances)
            (q = v.SaveToJson()) &&
              (m[v.GetBehaviorType().GetSID().toString()] = q);
          k.behs = m;
        }
      }
      this._worldInfo && (k.w = this._worldInfo._SaveToJson(g));
      (g = this._sdkInst.SaveToJson()) && (k.data = g);
      return k;
    }
    _OnBeforeLoad(g = "full") {
      this._worldInfo && this._worldInfo._OnBeforeLoad(g);
    }
    LoadFromJson(g, k = "full") {
      if ("full" === k) this._uid = g.uid;
      else if (!g.c3) return;
      if ("visual-state" !== k) {
        var m = f.get(this);
        m && (m.clear(), f.delete(this));
        if ((m = g.ex)) (m = e.FromSuperJSON(m)), f.set(this, m);
        this._timeScale = g.hasOwnProperty("mts") ? g.mts : -1;
        if ((m = g.ivs))
          for (const [r, n] of Object.entries(m))
            if (
              ((m = parseInt(r, 10)),
              (m = this._objectType.GetInstanceVariableIndexBySID(m)),
              !(0 > m || m >= this._instVarValues.length))
            ) {
              var q = n;
              null === q && (q = NaN);
              this._instVarValues[m] = q;
            }
      }
      if (this.GetPlugin().IsWorldType()) {
        m = g.w;
        var v = m.l;
        this._worldInfo.GetLayer().GetSID() !== v &&
          ((q = this._worldInfo.GetLayer()),
          (v = q.GetLayout().GetLayerBySID(v))
            ? (this._worldInfo._SetLayer(v),
              q._RemoveInstance(this, !0),
              v._AddInstance(this, !0),
              v.SetZIndicesChanged(),
              this._worldInfo.SetBboxChanged())
            : "full" === k && this._runtime.DestroyInstance(this));
        this._worldInfo._LoadFromJson(m, k);
      }
      if ("visual-state" !== k && (k = g.behs))
        for (const [r, n] of Object.entries(k))
          (k = parseInt(r, 10)),
            (k = this.GetBehaviorIndexBySID(k)),
            0 > k ||
              k >= this._behaviorInstances.length ||
              this._behaviorInstances[k].LoadFromJson(n);
      (g = g.data) && this._sdkInst.LoadFromJson(g);
    }
    GetInterfaceClass() {
      return this._iScriptInterface || this._InitUserScriptInterface();
    }
    _InitUserScriptInterface() {
      var g = this._worldInfo ? self.IWorldInstance : a;
      const k = this._sdkInst.GetScriptInterfaceClass(),
        m = this._objectType._GetUserScriptInstanceClass(),
        q = m || k || g;
      a._Init(this);
      this._iScriptInterface = new q();
      a._Init(null);
      if (k && !(this._iScriptInterface instanceof g))
        throw new TypeError(
          `script interface class '${k.name}' does not extend the right base class '${g.name}'`
        );
      if (m && ((g = k || g), !(this._iScriptInterface instanceof g)))
        throw new TypeError(
          `setInstanceClass(): class '${m.name}' does not extend the right base class '${g.name}'`
        );
      return this._iScriptInterface;
    }
    _GetInstVarsScriptDescriptor(g) {
      if (0 !== this._instVarValues.length) {
        var k = {},
          m = this._objectType._GetAllInstanceVariableJsPropNames();
        for (let q = 0, v = m.length; q < v; ++q)
          k[m[q]] = {
            configurable: !1,
            enumerable: !0,
            get: e.Instance.prototype._GetInstanceVariableTypedValue.bind(
              this,
              q
            ),
            set: e.Instance.prototype.SetInstanceVariableValue.bind(this, q),
          };
        k = Object.create(Object.prototype, k);
        g.instVars = { value: k, writable: !1 };
      }
    }
    _GetBehaviorsScriptDescriptor(g) {
      var k = this._behaviorInstances;
      if (0 !== k.length) {
        var m = {};
        for (const q of k)
          m[q.GetBehaviorType().GetJsPropName()] = {
            value: q.GetScriptInterface(),
            writable: !1,
          };
        k = Object.create(Object.prototype, m);
        g.behaviors = { value: k, writable: !1 };
      }
    }
    DispatchUserScriptEvent(g) {
      g.instance = this.GetInterfaceClass();
      var k = this._runtime;
      (k = k.IsDebug() && !k.GetEventSheetManager().IsInEventEngine()) &&
        b.StartMeasuringScriptTime();
      this.GetInterfaceClass().dispatchEvent(g);
      k && b.AddScriptTime();
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.SceneGraphInfo = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._owner = b;
      this._parent = null;
      this._children = [];
      this._startWidth = b.GetWidth();
      this._startHeight = b.GetHeight();
      this._startScaleY = this._startScaleX = 1;
      this._parentStartAngle = 0;
    }
    Release() {
      this._parent = null;
      e.clearArray(this._children);
    }
    SetParent(b) {
      this._parentStartAngle = (this._parent = b) ? b.GetAngle() : 0;
    }
    GetParent() {
      return this._parent;
    }
    HasChildren() {
      return 0 < this._children.length;
    }
    GetChildren() {
      return this._children;
    }
    GetStartScaleX() {
      return this._startScaleX;
    }
    SetStartScaleX(b) {
      this._startScaleX = b;
    }
    GetStartScaleY() {
      return this._startScaleY;
    }
    SetStartScaleY(b) {
      this._startScaleY = b;
    }
    _GetStartWidth() {
      return this._startWidth;
    }
    _GetStartHeight() {
      return this._startHeight;
    }
    GetParentScaleX() {
      return this._owner.GetTransformWithParentWidth()
        ? this._parent.GetWidth() /
            this._parent._GetSceneGraphInfo()._GetStartWidth()
        : 1;
    }
    GetParentScaleY() {
      return this._owner.GetTransformWithParentHeight()
        ? this._parent.GetHeight() /
            this._parent._GetSceneGraphInfo()._GetStartHeight()
        : 1;
    }
    GetParentStartAngle() {
      return this._parentStartAngle;
    }
    _SaveToJson(b) {
      return {
        sw: this._startWidth,
        sh: this._startHeight,
        sx: this._startScaleX,
        sy: this._startScaleY,
        psa: this._parentStartAngle,
        p: this._GetParentJson(b),
        c: this._GetChildrenJson(b),
      };
    }
    _GetFlagsString(b) {
      let a = "";
      b.GetTransformWithParentX() && (a += "x");
      b.GetTransformWithParentY() && (a += "y");
      b.GetTransformWithParentWidth() && (a += "w");
      b.GetTransformWithParentHeight() && (a += "h");
      b.GetTransformWithParentAngle() && (a += "a");
      b.GetTransformWithParentZElevation() && (a += "z");
      b.GetDestroyWithParent() && (a += "d");
      return a;
    }
    _GetParentJson(b) {
      return this._parent &&
        this._parent.GetInstance() &&
        !this._parent.GetInstance().IsDestroyed()
        ? this._GetInstanceJson(this._parent, this._owner, b)
        : null;
    }
    _GetChildrenJson(b) {
      return this._children.map((a) => this._GetInstanceJson(a, a, b));
    }
    _GetInstanceJson(b, a, c) {
      b = b.GetInstance();
      const d = {};
      d.uid = b.GetUID();
      d.f = this._GetFlagsString(a);
      d.offsets = a._SaveSceneGraphPropertiesToJson();
      "state" === c &&
        ((d.oci = b.GetObjectClass().GetIndex()), (d.inst = b.SaveToJson()));
      return d;
    }
    _LoadFromJson(b) {
      this._startWidth = b.sw;
      this._startHeight = b.sh;
      this._startScaleX = b.sx;
      this._startScaleY = b.sy;
      this._parentStartAngle = b.psa;
    }
    _OnAfterLoad(b, a) {
      a = this._owner;
      const c = a.GetRuntime();
      if (b.p && !this._parent) {
        var d = c.GetInstanceByUID(b.p.uid);
        if (d) {
          const f = d.GetWorldInfo();
          d.HasChild(this._owner.GetInstance())
            ? (this._parent = f)
            : (d.AddChild(this._owner.GetInstance(), this._GetFlagsObj(b.p.f)),
              this._owner._LoadSceneGraphPropertiesFromJson(b.p.offsets));
        } else
          e.IsFiniteNumber(b.p.oci) &&
            ((d = c.GetObjectClassByIndex(b.p.oci)),
            c.GetSystemPlugin(),
            (d = c.CreateInstance(d, a.GetLayer(), 0, 0, !0))) &&
            (d.LoadFromJson(b.p.inst),
            d.GetWorldInfo().GetLayer().SortAndAddInstancesByZIndex(d),
            d.AddChild(a.GetInstance(), this._GetFlagsObj(b.p.f)));
      }
      for (const f of b.c)
        (b = c.GetInstanceByUID(f.uid))
          ? ((b = b.GetWorldInfo()),
            a.AddChild(b, this._GetFlagsObj(f.f)),
            b._LoadSceneGraphPropertiesFromJson(f.offsets))
          : e.IsFiniteNumber(f.oci) &&
            ((b = c.GetObjectClassByIndex(f.oci)),
            c.GetSystemPlugin(),
            (b = c.CreateInstance(b, a.GetLayer(), 0, 0, !0))) &&
            (b.LoadFromJson(f.inst),
            (d = b.GetWorldInfo()),
            d.GetLayer().SortAndAddInstancesByZIndex(b),
            a.AddChild(d, this._GetFlagsObj(f.f)));
    }
    _GetFlagsObj(b) {
      const a = {};
      a.transformX = b.includes("x");
      a.transformY = b.includes("y");
      a.transformWidth = b.includes("w");
      a.transformHeight = b.includes("h");
      a.transformAngle = b.includes("a");
      a.transformZElevation = b.includes("z");
      a.destroyWithParent = b.includes("d");
      return a;
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = e.New(e.Rect),
    a = e.New(e.Quad),
    c = e.New(e.Event, "bboxchange", !1),
    d = e.New(e.Color, 0, 0, 0, 0),
    f = e.New(e.CollisionPoly),
    h = e.New(e.Color, 1, 1, 1, 1),
    g = e.New(e.Rect, 0, 0, -1, -1),
    k = e.New(e.Rect, 0, 0, -1, -1),
    m = new Set(["absolute", "relative"]),
    q = [];
  let v = !0;
  const r = new WeakMap(),
    n = new WeakMap();
  e.WorldInfo = class extends e.DefendedBase {
    constructor(p, u) {
      super();
      this._inst = p;
      this._objectClass = p.GetObjectClass();
      this._runtime = p.GetRuntime();
      this._layer = u;
      this._zIndex = -1;
      this._flags = 196635;
      this._objectClass.GetPlugin().IsRotatable() && (this._flags |= 128);
      this._oy =
        this._ox =
        this._cosA =
        this._sinA =
        this._a =
        this._depth =
        this._h =
        this._w =
        this._zElevation =
        this._y =
        this._x =
          NaN;
      this._boundingBox = e.New(e.Rect);
      this._boundingQuad = e.New(e.Quad);
      this._collisionCells = k;
      this._renderCells = g;
      this._solidFilterTags =
        this._transformedPolyInfo =
        this._sourceCollisionPoly =
          null;
      this._colorPremultiplied = this._color = h;
      this._instanceEffectList = this._stateGroup = null;
      this._inst.GetObjectClass().UsesEffects() &&
        (this._instanceEffectList = e.New(
          e.InstanceEffectList,
          this._inst,
          this
        ));
      this._meshInfo = this._sceneGraphInfo = null;
    }
    _MarkDestroyed() {
      this._flags |= 256;
    }
    Release() {
      this._stateGroup &&
        (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup),
        (this._stateGroup = null));
      this._sourceCollisionPoly = null;
      this._transformedPolyInfo &&
        (this._transformedPolyInfo.poly.Release(),
        (this._transformedPolyInfo = null));
      this._solidFilterTags &&
        (this._solidFilterTags.clear(), (this._solidFilterTags = null));
      this.ReleaseMesh();
      this.HasParent() && this.GetParent().RemoveChild(this);
      if (this.HasChildren()) {
        const p = [...this.GetChildren()];
        for (const u of p) this.RemoveChild(u);
      }
      this._ReleaseSceneGraphInfo();
      this._layer = this._runtime = this._objectClass = this._inst = null;
    }
    Init(p) {
      v = !1;
      this.SetXY(p[0], p[1]);
      this.SetZElevation(p[2]);
      this.SetSize(p[3], p[4]);
      this._depth = 0;
      this.IsRotatable() ? this.SetAngle(p[6]) : (this._a = 0);
      d.setFromJSON(p[7]);
      this._SetColor(d);
      this.SetOriginX(p[8]);
      this.SetOriginY(p[9]);
      this.SetBlendMode(p[10]);
      this._instanceEffectList &&
        this._instanceEffectList._LoadEffectParameters(p[12]);
      p[14] && r.set(this, { childrenData: p[14][1], zIndexData: p[14][2] });
      if (p[15]) {
        var u = p[15];
        this.CreateMesh(u[0], u[1]);
        p = this.GetSourceMesh();
        u = u[2];
        for (let w = 0, y = u.length; w < y; ++w) {
          const B = u[w];
          for (let E = 0, z = B.length; E < z; ++E) {
            const D = B[E],
              J = p.GetMeshPointAt(E, w);
            J.SetX(D[0]);
            J.SetY(D[1]);
            J.SetZElevation(D[2]);
            J.SetU(D[3]);
            J.SetV(D[4]);
          }
        }
      }
      v = !0;
      this._UpdateRendererStateGroup();
    }
    InitNoData() {
      this._sinA =
        this._a =
        this._depth =
        this._h =
        this._w =
        this._zElevation =
        this._y =
        this._x =
          0;
      this._cosA = 1;
      this._oy = this._ox = 0;
      this._UpdateRendererStateGroup();
    }
    GetRuntime() {
      return this._runtime;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetInstance() {
      return this._inst;
    }
    _GetParentOffsetAngle() {
      return this.GetTransformWithParentAngle()
        ? this.GetParent().GetAngle() -
            this._sceneGraphInfo.GetParentStartAngle()
        : 0;
    }
    SetX(p) {
      p = +p;
      if (this.GetTransformWithParentX()) {
        const u = this._sceneGraphInfo;
        p -= this.GetX();
        const w = -this._GetParentOffsetAngle();
        0 === w
          ? (this._x += p / u.GetParentScaleX())
          : ((this._x += (Math.cos(w) * p) / u.GetParentScaleX()),
            this.GetTransformWithParentY() &&
              (this._y += (Math.sin(w) * p) / u.GetParentScaleY()));
      } else this._x = p;
    }
    OffsetX(p) {
      p = +p;
      this.GetTransformWithParentX()
        ? this.SetX(this.GetX() + p)
        : (this._x += p);
    }
    GetX() {
      if (this.GetTransformWithParentX()) {
        let p = this._x;
        const u = this._sceneGraphInfo,
          w = this.GetParent(),
          y = this._GetParentOffsetAngle();
        0 === y
          ? (p *= u.GetParentScaleX())
          : ((p = p * u.GetParentScaleX() * Math.cos(y)),
            this.GetTransformWithParentY() &&
              (p -= this._y * u.GetParentScaleY() * Math.sin(y)));
        return w.GetX() + p;
      }
      return this._x;
    }
    SetY(p) {
      p = +p;
      if (this.GetTransformWithParentY()) {
        const u = this._sceneGraphInfo;
        p -= this.GetY();
        const w = -this._GetParentOffsetAngle();
        0 === w
          ? (this._y += p / u.GetParentScaleY())
          : (this.GetTransformWithParentX() &&
              (this._x -= (Math.sin(w) * p) / u.GetParentScaleX()),
            (this._y += (Math.cos(w) * p) / u.GetParentScaleY()));
      } else this._y = p;
    }
    OffsetY(p) {
      p = +p;
      this.GetTransformWithParentY()
        ? this.SetY(this.GetY() + p)
        : (this._y += p);
    }
    GetY() {
      if (this.GetTransformWithParentY()) {
        let p = this._y;
        const u = this._sceneGraphInfo,
          w = this.GetParent(),
          y = this._GetParentOffsetAngle();
        0 === y
          ? (p *= u.GetParentScaleY())
          : ((p = p * u.GetParentScaleY() * Math.cos(y)),
            this.GetTransformWithParentX() &&
              (p += this._x * u.GetParentScaleX() * Math.sin(y)));
        return w.GetY() + p;
      }
      return this._y;
    }
    SetXY(p, u) {
      p = +p;
      u = +u;
      if (this.GetTransformWithParentXOrY()) {
        const y = this.GetTransformWithParentX(),
          B = this.GetTransformWithParentY(),
          E = this._sceneGraphInfo,
          z = p - this.GetX(),
          D = u - this.GetY();
        var w = -this._GetParentOffsetAngle();
        if (0 === w)
          (this._x = y ? this._x + z / E.GetParentScaleX() : p),
            (this._y = B ? this._y + D / E.GetParentScaleY() : u);
        else {
          const J = Math.sin(w);
          w = Math.cos(w);
          this._x = y
            ? B
              ? this._x + (w * z - J * D) / E.GetParentScaleX()
              : this._x + (w * z) / E.GetParentScaleX()
            : p;
          this._y = B
            ? y
              ? this._y + (J * z + w * D) / E.GetParentScaleY()
              : this._y + (w * D) / E.GetParentScaleY()
            : u;
        }
      } else (this._x = p), (this._y = u);
    }
    OffsetXY(p, u) {
      p = +p;
      u = +u;
      this.GetTransformWithParentXOrY()
        ? this.SetXY(this.GetX() + p, this.GetY() + u)
        : ((this._x += p), (this._y += u));
    }
    EqualsXY(p, u) {
      return this.GetX() === p && this.GetY() === u;
    }
    SetZElevation(p) {
      p = +p;
      this.GetTransformWithParentZElevation() &&
        (p -= this.GetParent().GetZElevation());
      this._zElevation !== p &&
        ((this._zElevation = p),
        this._UpdateZElevation(),
        (p = this.GetLayer()),
        0 !== this._zElevation && p._SetAnyInstanceZElevated(),
        p.SetZIndicesChanged());
    }
    _UpdateZElevation() {
      this._UpdateRendererStateGroup();
      if (this.HasChildren()) {
        const p = this.GetChildren();
        for (let u = 0, w = p.length; u < w; u++) {
          const y = p[u];
          y.GetTransformWithParentZElevation() && y._UpdateZElevation();
        }
      }
    }
    OffsetZElevation(p) {
      this.SetZElevation(this.GetZElevation() + p);
    }
    GetZElevation() {
      return this.GetTransformWithParentZElevation()
        ? this.GetParent().GetZElevation() + this._zElevation
        : this._zElevation;
    }
    GetTotalZElevation() {
      return this.GetLayer().GetZElevation() + this.GetZElevation();
    }
    SetWidth(p) {
      p = +p;
      if (this.GetTransformWithParentWidth()) {
        const u = this.GetWidth();
        this._w = 0 === u ? 1e-6 : (p / u) * this._w;
      } else this._w = p;
    }
    OffsetWidth(p) {
      p = +p;
      this.GetTransformWithParentWidth()
        ? this.SetWidth(this.GetWidth() + p)
        : (this._w += p);
    }
    GetWidth() {
      return this.GetTransformWithParentWidth()
        ? this.GetParent().GetWidth() * this._w
        : this._w;
    }
    SetHeight(p) {
      p = +p;
      if (this.GetTransformWithParentHeight()) {
        const u = this.GetHeight();
        this._h = 0 === u ? 1e-6 : (p / u) * this._h;
      } else this._h = p;
    }
    OffsetHeight(p) {
      p = +p;
      this.GetTransformWithParentHeight()
        ? this.SetHeight(this.GetHeight() + p)
        : (this._h += p);
    }
    GetHeight() {
      return this.GetTransformWithParentHeight()
        ? this.GetParent().GetHeight() * this._h
        : this._h;
    }
    SetSize(p, u) {
      p = +p;
      u = +u;
      if (this.GetTransformWithParentWidth()) {
        const w = this.GetWidth();
        this._w = 0 === w ? 1e-6 : (p / w) * this._w;
      } else this._w = p;
      this.GetTransformWithParentHeight()
        ? ((p = this.GetHeight()),
          (this._h = 0 === p ? 1e-6 : (u / p) * this._h))
        : (this._h = u);
    }
    GetDepth() {
      return this._depth;
    }
    SetDepth(p) {
      if (0 > p) throw new RangeError("invalid depth");
      this._depth = p;
    }
    GetSceneGraphScale() {
      if (this.HasParent()) {
        const p = this._sceneGraphInfo;
        return Math.min(p.GetParentScaleX(), p.GetParentScaleY());
      }
      return 1;
    }
    IsRotatable() {
      return 0 !== (this._flags & 128);
    }
    SetAngle(p) {
      p = +p;
      this.IsRotatable() &&
        (this.GetTransformWithParentAngle() &&
          (p -= this.GetParent().GetAngle()),
        (p = e.clampAngle(p)),
        this._a !== p && ((this._a = p), this._MarkSinCosAngleChanged()));
    }
    OffsetAngle(p) {
      p = +p;
      0 !== p &&
        this.IsRotatable() &&
        ((this._a = e.clampAngle(this._a + p)), this._MarkSinCosAngleChanged());
    }
    _MarkSinCosAngleChanged() {
      this._flags |= 262144;
      if (this.HasChildren()) {
        const p = this.GetChildren();
        for (let u = 0, w = p.length; u < w; u++)
          p[u]._MarkSinCosAngleChanged();
      }
    }
    GetAngle() {
      return this.GetTransformWithParentAngle()
        ? e.clampAngle(this.GetParent().GetAngle() + this._a)
        : this._a;
    }
    _MaybeUpdateSinCosAngle() {
      const p = this._flags;
      if (0 !== (p & 262144)) {
        var u = this.GetAngle();
        this._sinA = Math.sin(u);
        this._cosA = Math.cos(u);
        this._flags = p & -262145;
      }
    }
    GetSinAngle() {
      this._MaybeUpdateSinCosAngle();
      return this._sinA;
    }
    GetCosAngle() {
      this._MaybeUpdateSinCosAngle();
      return this._cosA;
    }
    SetOriginX(p) {
      this._ox = +p;
    }
    OffsetOriginX(p) {
      this._ox += +p;
    }
    GetOriginX() {
      return this._ox;
    }
    SetOriginY(p) {
      this._oy = +p;
    }
    OffsetOriginY(p) {
      this._oy += +p;
    }
    GetOriginY() {
      return this._oy;
    }
    _SetColor(p) {
      this._color.equals(p) ||
        (this._color === h
          ? ((this._color = e.New(e.Color, p)),
            (this._colorPremultiplied = e.New(e.Color, p)),
            this._colorPremultiplied.premultiply())
          : p.equalsRgba(1, 1, 1, 1)
          ? (this._colorPremultiplied = this._color = h)
          : (this._color.set(p),
            this._colorPremultiplied.set(p),
            this._colorPremultiplied.premultiply()),
        this._UpdateRendererStateGroup());
    }
    SetOpacity(p) {
      p = e.clamp(+p, 0, 1);
      this._color.a !== p &&
        (d.copyRgb(this._color), (d.a = p), this._SetColor(d));
    }
    OffsetOpacity(p) {
      this.SetOpacity(this.GetOpacity() + p);
    }
    GetOpacity() {
      return this._color.a;
    }
    SetUnpremultipliedColor(p) {
      this._color.equalsIgnoringAlpha(p) ||
        (d.copyRgb(p), (d.a = this._color.a), this._SetColor(d));
    }
    SetUnpremultipliedColorRGB(p, u, w) {
      d.setRgb(p, u, w);
      this.SetUnpremultipliedColor(d);
    }
    OffsetUnpremultipliedColorRGB(p, u, w) {
      if (0 !== p || 0 !== u || 0 !== w)
        d.copyRgb(this._color),
          (d.r += p),
          (d.g += u),
          (d.b += w),
          this.SetUnpremultipliedColor(d);
    }
    GetUnpremultipliedColor() {
      return this._color;
    }
    GetPremultipliedColor() {
      return this._colorPremultiplied;
    }
    GetDestroyWithParent() {
      return 0 !== (this._flags & 512);
    }
    SetDestroyWithParent(p) {
      this._SetFlag(512, p);
    }
    GetTransformWithParentX() {
      return 0 !== (this._flags & 1024);
    }
    SetTransformWithParentX(p) {
      this._SetFlag(1024, p);
    }
    GetTransformWithParentY() {
      return 0 !== (this._flags & 2048);
    }
    GetTransformWithParentXOrY() {
      return 0 !== (this._flags & 3072);
    }
    SetTransformWithParentY(p) {
      this._SetFlag(2048, p);
    }
    GetTransformWithParentWidth() {
      return 0 !== (this._flags & 4096);
    }
    SetTransformWithParentWidth(p) {
      this._SetFlag(4096, p);
    }
    GetTransformWithParentHeight() {
      return 0 !== (this._flags & 8192);
    }
    SetTransformWithParentHeight(p) {
      this._SetFlag(8192, p);
    }
    GetTransformWithParentAngle() {
      return 0 !== (this._flags & 16384);
    }
    SetTransformWithParentAngle(p) {
      this._SetFlag(16384, p);
    }
    GetTransformWithParentZElevation() {
      return 0 !== (this._flags & 32768);
    }
    SetTransformWithParentZElevation(p) {
      this._SetFlag(32768, p);
    }
    _ClearAllSceneGraphFlags() {
      this._flags &= -65025;
    }
    AddChild(p, u) {
      if (
        p !== this &&
        !p.HasParent() &&
        !this._HasChildRecursive(p) &&
        !this._HasAnyParent(p)
      ) {
        var w = p.GetX(),
          y = p.GetY(),
          B = p.GetWidth(),
          E = p.GetHeight(),
          z = p.GetAngle(),
          D = p.GetZElevation();
        p._SetParent(this);
        p.SetTransformWithParentX(u.transformX);
        p.SetTransformWithParentY(u.transformY);
        p.SetTransformWithParentWidth(u.transformWidth);
        p.SetTransformWithParentHeight(u.transformHeight);
        p.SetTransformWithParentAngle(u.transformAngle);
        p.SetTransformWithParentZElevation(u.transformZElevation);
        p.SetDestroyWithParent(u.destroyWithParent);
        u.transformX &&
          ((p._x = w - this.GetX()),
          u.transformWidth &&
            (p._x /= this.GetWidth() / this._sceneGraphInfo._GetStartWidth()));
        u.transformY &&
          ((p._y = y - this.GetY()),
          u.transformHeight &&
            (p._y /=
              this.GetHeight() / this._sceneGraphInfo._GetStartHeight()));
        u.transformWidth &&
          ((p._w = B / this.GetWidth()),
          p._sceneGraphInfo.SetStartScaleX(p._w));
        u.transformHeight &&
          ((p._h = E / this.GetHeight()),
          p._sceneGraphInfo.SetStartScaleY(p._h));
        u.transformAngle && (p._a = z - this.GetAngle());
        u.transformZElevation && (p._zElevation = D - this.GetZElevation());
        this._AddChildToSceneGraphInfo(p);
        this.SetBboxChanged();
      }
    }
    RemoveChild(p) {
      if (p.GetParent() === this) {
        var u = p.GetX(),
          w = p.GetY(),
          y = p.GetWidth(),
          B = p.GetHeight(),
          E = p.GetAngle(),
          z = p.GetZElevation();
        p._SetParent(null);
        p._ClearAllSceneGraphFlags();
        p.SetXY(u, w);
        p.SetSize(y, B);
        p.SetAngle(E);
        p.SetZElevation(z);
        this._RemoveChildFromSceneGraphInfo(p);
        this.SetBboxChanged();
      }
    }
    _ResetAllSceneGraphState() {
      for (var p of this.children()) this.RemoveChild(p);
      (p = this.GetParent()) && p.RemoveChild(this);
      this._ClearAllSceneGraphFlags();
    }
    HasParent() {
      return null !== this.GetParent();
    }
    GetParent() {
      const p = this._sceneGraphInfo;
      return null !== p ? p.GetParent() : null;
    }
    GetTopParent() {
      let p = this;
      for (; p.HasParent(); ) p = p.GetParent();
      return p;
    }
    *parents() {
      let p = this.GetParent();
      for (; p; ) yield p, (p = p.GetParent());
    }
    HasChild(p) {
      return this.GetChildren().includes(p);
    }
    HasChildren() {
      const p = this._sceneGraphInfo;
      return null !== p ? p.HasChildren() : !1;
    }
    GetChildren() {
      const p = this._sceneGraphInfo;
      return null !== p ? p.GetChildren() : q;
    }
    children() {
      return this.GetChildren();
    }
    *allChildren() {
      for (const p of this.children()) yield p, yield* p.allChildren();
    }
    GetChildCount() {
      return this.GetChildren().length;
    }
    GetChildAt(p) {
      const u = this.GetChildren();
      p = Math.floor(+p);
      return 0 > p || p >= u.length ? null : u[p];
    }
    _CreateSceneGraphInfo(p) {
      this._sceneGraphInfo ||
        (this._sceneGraphInfo = e.New(e.SceneGraphInfo, this));
      p && this._sceneGraphInfo.SetParent(p);
    }
    _GetSceneGraphInfo() {
      return this._sceneGraphInfo;
    }
    _ReleaseSceneGraphInfo() {
      this._sceneGraphInfo &&
        (this._sceneGraphInfo.Release(), (this._sceneGraphInfo = null));
    }
    _SetParent(p) {
      p
        ? (p._CreateSceneGraphInfo(null), this._CreateSceneGraphInfo(p))
        : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null),
          this.HasChildren() || this._ReleaseSceneGraphInfo());
    }
    _HasAnyParent(p) {
      if (!this.HasParent()) return !1;
      const u = this.GetParent();
      return u === p ? !0 : u._HasAnyParent(p);
    }
    _HasChildRecursive(p) {
      if (this.HasChild(p)) return !0;
      for (const u of this.GetChildren())
        if (u._HasChildRecursive(p)) return !0;
      return !1;
    }
    _AddChildToSceneGraphInfo(p) {
      this._sceneGraphInfo.GetChildren().push(p);
    }
    _RemoveChildFromSceneGraphInfo(p) {
      const u = this._sceneGraphInfo.GetChildren(),
        w = u.indexOf(p);
      -1 !== w && u.splice(w, 1);
      0 !== u.length || this.HasParent() || this._ReleaseSceneGraphInfo();
      p.HasChildren() || p._ReleaseSceneGraphInfo();
    }
    GetSceneGraphChildrenExportData() {
      const p = r.get(this);
      return p ? p.childrenData : null;
    }
    GetSceneGraphZIndexExportData() {
      const p = r.get(this);
      return p ? p.zIndexData : NaN;
    }
    GetSceneGraphZIndex() {
      const p = n.get(this);
      return e.IsFiniteNumber(p) ? p : NaN;
    }
    SetSceneGraphZIndex(p) {
      n.set(this, p);
    }
    SetUsePointsShaderProgram() {
      this._SetFlag(524288, !0);
      this._UpdateRendererStateGroup();
    }
    _UpdateRendererStateGroup() {
      if (v) {
        var p = this._runtime.GetRenderer();
        this._stateGroup && p.ReleaseStateGroup(this._stateGroup);
        var u =
          0 !== (this._flags & 524288)
            ? p.GetPointsRenderingProgram() || "<point>"
            : p.GetTextureFillShaderProgram() || "<default>";
        this._stateGroup = p.AcquireStateGroup(
          u,
          this.GetBlendMode(),
          this._colorPremultiplied,
          this.GetZElevation()
        );
      }
    }
    GetRendererStateGroup() {
      return this._stateGroup;
    }
    HasDefaultColor() {
      return this._color === h;
    }
    SetBlendMode(p) {
      p |= 0;
      if (0 > p || 31 < p) throw new RangeError("invalid blend mode");
      this.GetBlendMode() !== p &&
        ((this._flags = (this._flags & -2080374785) | (p << 26)),
        this._UpdateRendererStateGroup());
    }
    GetBlendMode() {
      return (this._flags & 2080374784) >> 26;
    }
    _SetLayer(p) {
      this._layer = p;
      0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated();
    }
    GetLayer() {
      return this._layer;
    }
    GetLayout() {
      return this.GetLayer().GetLayout();
    }
    _SetZIndex(p) {
      this._zIndex = p | 0;
    }
    GetZIndex() {
      this._layer._UpdateZIndices();
      return this._zIndex;
    }
    _GetLastCachedZIndex() {
      return this._zIndex;
    }
    _SetFlag(p, u) {
      this._flags = u ? this._flags | p : this._flags & ~p;
    }
    IsVisible() {
      return 0 !== (this._flags & 1);
    }
    SetVisible(p) {
      this._SetFlag(1, p);
    }
    IsCollisionEnabled() {
      return 0 !== (this._flags & 8);
    }
    SetCollisionEnabled(p) {
      p = !!p;
      this.IsCollisionEnabled() !== p &&
        (this._SetFlag(8, p),
        p ? this.SetBboxChanged() : this._RemoveFromCollisionCells());
    }
    SetSolidCollisionFilter(p, u) {
      this._SetFlag(32, p);
      this._solidFilterTags && this._solidFilterTags.clear();
      if (u.trim()) {
        this._solidFilterTags || (this._solidFilterTags = new Set());
        for (const w of u.split(" "))
          w && this._solidFilterTags.add(w.toLowerCase());
      } else this._solidFilterTags = null;
    }
    IsSolidCollisionAllowed(p) {
      const u = 0 !== (this._flags & 32),
        w = this._solidFilterTags;
      if (!p || !w) return !u;
      for (const y of w) if (p.has(y)) return u;
      return !u;
    }
    SetBboxChanged() {
      this._flags |= 65554;
      this._objectClass._SetAnyCollisionCellChanged(!0);
      this._runtime.UpdateRender();
      this._layer.UsesRenderCells() &&
        (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0),
        (this._flags &= -3),
        this._UpdateRenderCell());
      0 !== (this._flags & 4) && this._inst.Dispatcher().dispatchEvent(c);
      if (null !== this._sceneGraphInfo) {
        const p = this._sceneGraphInfo.GetChildren();
        for (let u = 0, w = p.length; u < w; ++u) p[u].SetBboxChanged();
      }
    }
    CalculateBbox(p, u, w) {
      const y = this.GetX(),
        B = this.GetY(),
        E = this.GetWidth(),
        z = this.GetHeight(),
        D = this.GetAngle();
      p.setWH(y - this._ox * E, B - this._oy * z, E, z);
      w && this.HasMesh() && this._ExpandBboxForMesh(p);
      0 === D
        ? u.setFromRect(p)
        : (p.offset(-y, -B),
          u.setFromRotatedRectPrecalc(
            p,
            this.GetSinAngle(),
            this.GetCosAngle()
          ),
          u.offset(y, B),
          u.getBoundingBox(p));
      p.normalize();
    }
    _UpdateBbox() {
      const p = this._flags;
      0 !== (p & 2) &&
        (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0),
        (this._flags = p & -3));
    }
    GetBoundingBox() {
      this._UpdateBbox();
      return this._boundingBox;
    }
    GetBoundingQuad() {
      this._UpdateBbox();
      return this._boundingQuad;
    }
    PixelRoundQuad(p) {
      var u = this.GetX(),
        w = this.GetY();
      u = Math.round(u) - u;
      w = Math.round(w) - w;
      if (0 === u && 0 === w) return p;
      a.copy(p);
      a.offset(u, w);
      return a;
    }
    OverwriteBoundingBox(p) {
      this._boundingBox.copy(p);
      this._boundingQuad.setFromRect(this._boundingBox);
      this._flags &= -3;
      this._UpdateCollisionCell();
      this._UpdateRenderCell();
    }
    SetBboxChangeEventEnabled(p) {
      this._SetFlag(4, p);
    }
    IsBboxChangeEventEnabled() {
      return 0 !== (this._flags & 4);
    }
    IsInViewport(p, u, w) {
      return u && 0 !== this.GetDepth()
        ? this.IsInViewport3D(this.GetLayer()._GetViewFrustum())
        : 0 === this.GetZElevation() || w
        ? p.intersectsRect(this.GetBoundingBox())
        : this._IsInViewport_ZElevated();
    }
    _IsInViewport_ZElevated() {
      const p = this.GetLayer(),
        u = this.GetTotalZElevation();
      if (u >= p.GetCameraZ()) return !1;
      p.GetViewportForZ(u, b);
      return b.intersectsRect(this.GetBoundingBox());
    }
    IsInViewport3D(p) {
      var u = this.GetBoundingBox();
      const w = u.getLeft(),
        y = u.getRight(),
        B = u.getTop();
      u = u.getBottom();
      const E = this.GetTotalZElevation(),
        z = E + this.GetDepth();
      return p.ContainsAABB(w, B, E, y, u, z);
    }
    _SetDrawBackFaceOnly(p) {
      this._SetFlag(1048576, p);
    }
    _SetDrawNonBackFacesOnly(p) {
      this._SetFlag(2097152, p);
    }
    IsDrawBackFaceOnly() {
      return 0 !== (this._flags & 1048576);
    }
    IsDrawNonBackFacesOnly() {
      return 0 !== (this._flags & 2097152);
    }
    SetSourceCollisionPoly(p) {
      this._sourceCollisionPoly = p;
      this._DiscardTransformedCollisionPoly();
      this.HasMesh() && (this._meshInfo.meshPoly = null);
    }
    GetSourceCollisionPoly() {
      return this._sourceCollisionPoly;
    }
    HasOwnCollisionPoly() {
      return null !== this._sourceCollisionPoly || this.HasMesh();
    }
    GetTransformedCollisionPoly() {
      return this._GetCustomTransformedCollisionPolyPrecalc(
        this.GetWidth(),
        this.GetHeight(),
        this.GetAngle(),
        this.GetSinAngle(),
        this.GetCosAngle()
      );
    }
    GetCustomTransformedCollisionPoly(p, u, w) {
      let y = 0,
        B = 1;
      0 !== w && ((y = Math.sin(w)), (B = Math.cos(w)));
      return this._GetCustomTransformedCollisionPolyPrecalc(p, u, w, y, B);
    }
    _GetCustomTransformedCollisionPolyPrecalc(p, u, w, y, B) {
      let E = this._transformedPolyInfo;
      null === E &&
        (this._transformedPolyInfo = E =
          {
            poly: e.New(e.CollisionPoly),
            width: NaN,
            height: NaN,
            angle: NaN,
          });
      const z = E.poly;
      if (E.width === p && E.height === u && E.angle === w) return z;
      const D = this._sourceCollisionPoly;
      if (this.HasMesh()) {
        const J = this.GetOriginX(),
          C = this.GetOriginY(),
          H = this.GetSourceMesh();
        let K = this._meshInfo.meshPoly;
        K ||
          (D ? (f.copy(D), f.offset(J, C)) : f.setDefaultPoints(),
          (K = H.InsertPolyMeshVertices(f)),
          (this._meshInfo.meshPoly = K));
        H.TransformCollisionPoly(K, z);
        z.offset(-J, -C);
        z.transformPrecalc(p, u, y, B);
      } else
        D
          ? (z.copy(D), z.transformPrecalc(p, u, y, B))
          : z.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY());
      E.width = p;
      E.height = u;
      E.angle = w;
      return z;
    }
    _DiscardTransformedCollisionPoly() {
      this.SetPhysicsBodyChanged(!0);
      const p = this._transformedPolyInfo;
      null !== p && (p.width = NaN);
    }
    CreateMesh(p, u) {
      p = Math.floor(p);
      u = Math.floor(u);
      if (!this.GetInstance().GetPlugin().SupportsMesh())
        throw Error("object does not support mesh");
      this.ReleaseMesh();
      this._meshInfo = {
        sourceMesh: e.New(e.Gfx.Mesh, p, u),
        transformedMesh: e.New(e.Gfx.Mesh, p, u),
        meshPoly: null,
      };
    }
    HasMesh() {
      return null !== this._meshInfo;
    }
    GetSourceMesh() {
      if (!this.HasMesh()) throw Error("no mesh");
      return this._meshInfo.sourceMesh;
    }
    GetTransformedMesh() {
      if (!this.HasMesh()) throw Error("no mesh");
      return this._meshInfo.transformedMesh;
    }
    SetMeshChanged(p) {
      this._SetFlag(65536, p);
    }
    IsMeshChanged() {
      return 0 !== (this._flags & 65536);
    }
    SetPhysicsBodyChanged(p) {
      this._SetFlag(131072, p);
    }
    IsPhysicsBodyChanged() {
      return 0 !== (this._flags & 131072);
    }
    _ExpandBboxForMesh(p) {
      const u = this._meshInfo.sourceMesh,
        w = Math.min(u.GetMinX(), 0),
        y = Math.min(u.GetMinY(), 0),
        B = Math.max(u.GetMaxX(), 1),
        E = Math.max(u.GetMaxY(), 1),
        z = p.width(),
        D = p.height();
      p.offsetLeft(w * z);
      p.offsetTop(y * D);
      p.offsetRight((B - 1) * z);
      p.offsetBottom((E - 1) * D);
      this._depth = u.GetMaxZ();
    }
    ReleaseMesh() {
      this._meshInfo &&
        (this._meshInfo.sourceMesh.Release(),
        this._meshInfo.transformedMesh.Release(),
        (this._meshInfo = null),
        this._DiscardTransformedCollisionPoly());
    }
    SetMeshPoint(p, u, w) {
      p = Math.floor(p);
      u = Math.floor(u);
      var y = w.mode || "absolute";
      if (!m.has(y)) throw Error("invalid mode");
      y = "relative" === y;
      let B = w.x,
        E = w.y;
      const z = w.zElevation;
      let D = "number" === typeof w.u ? w.u : y ? 0 : -1;
      w = "number" === typeof w.v ? w.v : y ? 0 : -1;
      if (!this.HasMesh()) return !1;
      const J = this.GetSourceMesh(),
        C = J.GetMeshPointAt(p, u);
      if (null === C) return !1;
      let H = !1;
      "number" === typeof z &&
        C.GetZElevation() !== z &&
        (C.SetZElevation(z), (H = !0));
      y && ((B += p / (J.GetHSize() - 1)), (E += u / (J.GetVSize() - 1)));
      -1 !== D || y
        ? (y && (D += p / (J.GetHSize() - 1)), (D = e.clamp(D, 0, 1)))
        : (D = C.GetU());
      -1 !== w || y
        ? (y && (w += u / (J.GetVSize() - 1)), (w = e.clamp(w, 0, 1)))
        : (w = C.GetV());
      if (C.GetX() === B && C.GetY() === E && C.GetU() === D && C.GetV() === w)
        return H;
      C.SetX(B);
      C.SetY(E);
      C.SetU(D);
      C.SetV(w);
      this._DiscardTransformedCollisionPoly();
      return !0;
    }
    HasTilemap() {
      return this._inst.HasTilemap();
    }
    ContainsPoint(p, u) {
      return this.GetBoundingBox().containsPoint(p, u) &&
        this.GetBoundingQuad().containsPoint(p, u)
        ? this.HasTilemap()
          ? this._inst.GetSdkInstance().TestPointOverlapTile(p, u)
          : this.HasOwnCollisionPoly()
          ? this.GetTransformedCollisionPoly().containsPoint(
              p - this.GetX(),
              u - this.GetY()
            )
          : !0
        : !1;
    }
    _IsCollisionCellChanged() {
      return 0 !== (this._flags & 16);
    }
    _UpdateCollisionCell() {
      if (
        this._IsCollisionCellChanged() &&
        this.IsCollisionEnabled() &&
        0 === (this._flags & 256)
      ) {
        var p = this.GetBoundingBox(),
          u = this._objectClass._GetCollisionCellGrid(),
          w = this._collisionCells;
        b.set(
          u.XToCell(p.getLeft()),
          u.YToCell(p.getTop()),
          u.XToCell(p.getRight()),
          u.YToCell(p.getBottom())
        );
        w.equals(b) ||
          ((p = this._inst),
          w === k
            ? (u.Update(p, null, b), (this._collisionCells = e.New(e.Rect, b)))
            : (u.Update(p, w, b), w.copy(b)),
          (this._flags &= -17));
      }
    }
    _RemoveFromCollisionCells() {
      const p = this._collisionCells;
      p !== k &&
        (this._objectClass._GetCollisionCellGrid().Update(this._inst, p, null),
        (this._collisionCells = k));
    }
    _UpdateRenderCell() {
      const p = this.GetLayer();
      if (p.UsesRenderCells() && 0 === (this._flags & 256)) {
        var u = p.GetRenderGrid(),
          w = this.GetBoundingBox(),
          y = this._renderCells;
        b.set(
          u.XToCell(w.getLeft()),
          u.YToCell(w.getTop()),
          u.XToCell(w.getRight()),
          u.YToCell(w.getBottom())
        );
        y.equals(b) ||
          ((w = this._inst),
          y === g
            ? (u.Update(w, null, b), (this._renderCells = e.New(e.Rect, b)))
            : (u.Update(w, y, b), y.copy(b)),
          p.SetRenderListStale());
      }
    }
    _RemoveFromRenderCells() {
      const p = this._renderCells;
      p !== g &&
        (this.GetLayer().GetRenderGrid().Update(this._inst, p, null),
        (this._renderCells = g));
    }
    GetRenderCellRange() {
      return this._renderCells;
    }
    ZOrderMoveToTop() {
      const p = this._inst,
        u = this._layer,
        w = u._GetInstances();
      (w.length && w.at(-1) === p) ||
        (u._RemoveInstance(p, !1),
        u._AddInstance(p, !1),
        this._runtime.UpdateRender());
    }
    ZOrderMoveToBottom() {
      const p = this._inst,
        u = this._layer,
        w = u._GetInstances();
      (w.length && w[0] === p) ||
        (u._RemoveInstance(p, !1),
        u._PrependInstance(p, !1),
        this._runtime.UpdateRender());
    }
    ZOrderMoveToLayer(p) {
      const u = this._inst,
        w = this._layer;
      if (w.GetLayout() !== p.GetLayout())
        throw Error("layer from different layout");
      p !== w &&
        (w._RemoveInstance(u, !0),
        this._SetLayer(p),
        p._AddInstance(u, !0),
        this._runtime.UpdateRender());
    }
    ZOrderMoveAdjacentToInstance(p, u) {
      const w = this._inst;
      let y = !1;
      const B = this._layer;
      if (p.GetUID() !== w.GetUID()) {
        var E = p.GetWorldInfo();
        if (!E) throw Error("expected world instance");
        E = E.GetLayer();
        B.GetIndex() !== E.GetIndex() &&
          (B._RemoveInstance(w, !0),
          this._SetLayer(E),
          E._AddInstance(w, !0),
          (y = !0));
        p = E.MoveInstanceAdjacent(w, p, !!u);
        (y || p) && this._runtime.UpdateRender();
      }
    }
    GetInstanceEffectList() {
      return this._instanceEffectList;
    }
    _SetHasAnyActiveEffect(p) {
      this._SetFlag(64, p);
    }
    HasAnyActiveEffect() {
      return 0 !== (this._flags & 64);
    }
    _SaveToJson(p) {
      const u = {
        x: this.GetX(),
        y: this.GetY(),
        w: this.GetWidth(),
        h: this.GetHeight(),
        l: this.GetLayer().GetSID(),
        zi: this.GetZIndex(),
      };
      0 !== this.GetZElevation() && (u.ze = this.GetZElevation());
      0 !== this.GetAngle() && (u.a = this.GetAngle());
      this.HasDefaultColor() || (u.c = this._color.toJSON());
      0.5 !== this.GetOriginX() && (u.oX = this.GetOriginX());
      0.5 !== this.GetOriginY() && (u.oY = this.GetOriginY());
      0 !== this.GetBlendMode() && (u.bm = this.GetBlendMode());
      this.IsVisible() || (u.v = this.IsVisible());
      this.IsCollisionEnabled() || (u.ce = this.IsCollisionEnabled());
      this.IsBboxChangeEventEnabled() &&
        (u.be = this.IsBboxChangeEventEnabled());
      this._instanceEffectList &&
        (u.fx = this._instanceEffectList._SaveToJson());
      const w = 0 !== (this._flags & 32);
      w && (u.sfi = w);
      this._solidFilterTags && (u.sft = [...this._solidFilterTags].join(" "));
      this._sceneGraphInfo &&
        "visual-state" !== p &&
        ((u.sgi = this._sceneGraphInfo._SaveToJson(p)),
        r.has(this) &&
          ((u.sgcd = r.get(this).childrenData),
          (u.sgzid = r.get(this).zIndexData)));
      this.HasMesh() && (u.mesh = this.GetSourceMesh().SaveToJson());
      return u;
    }
    _SaveSceneGraphPropertiesToJson() {
      return {
        x: this._x,
        y: this._y,
        z: this._zElevation,
        w: this._w,
        h: this._h,
        a: this._a,
        sa: this._sinA,
        ca: this._cosA,
      };
    }
    _LoadSceneGraphPropertiesFromJson(p) {
      p &&
        ((this._x = p.x),
        (this._y = p.y),
        (this._zElevation = p.z),
        (this._w = p.w),
        (this._h = p.h),
        (this._a = p.a),
        (this._sinA = p.sa),
        (this._cosA = p.ca),
        this.SetBboxChanged());
    }
    _OnBeforeLoad(p) {
      "visual-state" !== p && this._ResetAllSceneGraphState();
    }
    _LoadFromJson(p, u) {
      v = !1;
      this.SetX(p.x);
      this.SetY(p.y);
      this.SetWidth(p.w);
      this.SetHeight(p.h);
      this._SetZIndex(p.zi);
      this.SetZElevation(p.hasOwnProperty("ze") ? p.ze : 0);
      this.SetAngle(p.hasOwnProperty("a") ? p.a : 0);
      p.hasOwnProperty("c")
        ? d.setFromJSON(p.c)
        : p.hasOwnProperty("o")
        ? (d.copyRgb(this._color), (d.a = p.o))
        : d.setRgba(1, 1, 1, 1);
      this._SetColor(d);
      this.SetOriginX(p.hasOwnProperty("oX") ? p.oX : 0.5);
      this.SetOriginY(p.hasOwnProperty("oY") ? p.oY : 0.5);
      this.SetBlendMode(p.hasOwnProperty("bm") ? p.bm : 0);
      this.SetVisible(p.hasOwnProperty("v") ? p.v : !0);
      this.SetCollisionEnabled(p.hasOwnProperty("ce") ? p.ce : !0);
      this.SetBboxChangeEventEnabled(p.hasOwnProperty("be") ? p.be : !1);
      this.SetSolidCollisionFilter(
        p.hasOwnProperty("sfi") ? p.sfi : !1,
        p.hasOwnProperty("sft") ? p.sft : ""
      );
      this._instanceEffectList &&
        p.hasOwnProperty("fx") &&
        this._instanceEffectList._LoadFromJson(p.fx);
      if (p.hasOwnProperty("sgi") && "visual-state" !== u) {
        this._CreateSceneGraphInfo(null);
        const w = this._sceneGraphInfo,
          y = p.sgi;
        w._LoadFromJson(y);
        const B = this.GetRuntime().Dispatcher(),
          E = (D, J) => {
            B.removeEventListener("afterload", E);
            B.removeEventListener("afterloadinstance", z);
            0 === (this._flags & 256) && w._OnAfterLoad(y, J);
          },
          z = (D) => {
            D.instance === this.GetInstance() &&
              E(D, { ignoreMissingInstances: !0 });
          };
        B.addEventListener("afterload", E);
        B.addEventListener("afterloadinstance", z);
        p.sgcd &&
          e.IsFiniteNumber(p.sgzid) &&
          r.set(this, { childrenData: p.sgcd, zIndexData: p.sgzid });
      }
      p.hasOwnProperty("mesh")
        ? ((p = p.mesh),
          this.CreateMesh(p.cols, p.rows),
          this.GetSourceMesh().LoadFromJson(p))
        : this.ReleaseMesh();
      this.SetBboxChanged();
      v = !0;
      this._UpdateRendererStateGroup();
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.BehaviorType = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      const c = b.GetRuntime(),
        d = c.GetPluginManager(),
        f = c.GetObjectReference(a[1]);
      d.HasBehaviorByConstructorFunction(f) || d.CreateBehavior(a);
      this._runtime = c;
      this._objectClass = b;
      this._behavior = d.GetBehaviorByConstructorFunction(f);
      this._sdkType = null;
      this._instSdkCtor = f.Instance;
      this._sid = a[2];
      this._name = a[0];
      this._jsPropName = this._runtime.GetJsPropName(a[3]);
      this._sdkType = e.New(f.Type, this);
      this.OnCreate();
    }
    static Create(b, a) {
      return e.New(e.BehaviorType, b, a);
    }
    Release() {
      this._behavior = this._runtime = null;
      this._sdkType.Release();
      this._instSdkCtor = this._sdkType = null;
    }
    GetSdkType() {
      return this._sdkType;
    }
    OnCreate() {
      this._sdkType.OnCreate();
    }
    GetRuntime() {
      return this._runtime;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetBehavior() {
      return this._behavior;
    }
    GetInstanceSdkCtor() {
      return this._instSdkCtor;
    }
    GetName() {
      return this._name;
    }
    GetSID() {
      return this._sid;
    }
    GetJsPropName() {
      return this._jsPropName;
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.IBehaviorInstance;
  e.BehaviorInstance = class extends e.DefendedBase {
    constructor(a) {
      super();
      this._runtime = a.runtime;
      this._behaviorType = a.behaviorType;
      this._behavior = this._behaviorType.GetBehavior();
      this._inst = a.instance;
      this._index = a.index;
      this._iScriptInterface = this._sdkInst = null;
      this._behavior._AddInstance(this._inst);
    }
    Release() {
      this._iScriptInterface &&
        (this._iScriptInterface._Release(), (this._iScriptInterface = null));
      this._behavior._RemoveInstance(this._inst);
      this._sdkInst.Release();
      this._inst =
        this._behavior =
        this._behaviorType =
        this._runtime =
        this._iScriptInterface =
        this._sdkInst =
          null;
    }
    _CreateSdkInstance(a) {
      if (this._sdkInst) throw Error("already got sdk instance");
      this._sdkInst = e.New(this._behaviorType.GetInstanceSdkCtor(), this, a);
      this._InitScriptInterface();
    }
    GetSdkInstance() {
      return this._sdkInst;
    }
    GetObjectInstance() {
      return this._inst;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetBehaviorType() {
      return this._behaviorType;
    }
    GetBehavior() {
      return this._behavior;
    }
    _GetIndex() {
      return this._index;
    }
    PostCreate() {
      this._sdkInst.PostCreate();
    }
    OnSpriteFrameChanged(a, c) {
      this._sdkInst.OnSpriteFrameChanged(a, c);
    }
    _GetDebuggerProperties() {
      return this._sdkInst.GetDebuggerProperties();
    }
    SaveToJson() {
      return this._sdkInst.SaveToJson();
    }
    LoadFromJson(a) {
      return this._sdkInst.LoadFromJson(a);
    }
    static SortByTickSequence(a, c) {
      var d = a.GetObjectInstance(),
        f = c.GetObjectInstance();
      const h = d.GetObjectClass().GetIndex(),
        g = f.GetObjectClass().GetIndex();
      if (h !== g) return h - g;
      d = d.GetPUID();
      f = f.GetPUID();
      return d !== f
        ? d - f
        : a.GetBehaviorInstance()._GetIndex() -
            c.GetBehaviorInstance()._GetIndex();
    }
    _InitScriptInterface() {
      const a = this._sdkInst.GetScriptInterfaceClass(),
        c = a || b;
      b._Init(this);
      this._iScriptInterface = new c();
      b._Init(null);
      if (a && !(this._iScriptInterface instanceof b))
        throw new TypeError(
          `script interface class '${a.name}' does not extend the right base class '${b.name}'`
        );
    }
    GetScriptInterface() {
      return this._iScriptInterface;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.EffectList = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._owner = b;
      this._allEffectTypes = [];
      this._activeEffectTypes = [];
      this._effectTypesByName = new Map();
      this._effectParams = [];
      this._effectParamBuffers = [];
      this._preservesOpaqueness = !0;
      for (const c of a)
        (b = e.New(e.EffectType, this, c, this._allEffectTypes.length)),
          this._allEffectTypes.push(b),
          this._effectTypesByName.set(b.GetName().toLowerCase(), b),
          3 <= c.length &&
            this._effectParams.push(this._LoadSingleEffectParameters(c[2]));
      this.GetRuntime()._AddEffectList(this);
    }
    Release() {
      for (const b of this._effectParamBuffers) b.Release();
      e.clearArray(this._effectParamBuffers);
      e.clearArray(this._allEffectTypes);
      e.clearArray(this._activeEffectTypes);
      this._effectTypesByName.clear();
      e.clearArray(this._effectParams);
      this._owner = null;
    }
    _InitRenderer(b) {
      b.IsWebGPU() &&
        ((this._effectParamBuffers = this._allEffectTypes.map((a) => {
          a = a.GetShaderProgram();
          return 0 < a.GetCustomParametersByteSize()
            ? e.New(e.Gfx.WebGPUEffectCustomParamsBuffer, a)
            : null;
        })),
        this._UpdateAllEffectParamBuffers());
    }
    PrependEffectTypes(b) {
      if (b.length) {
        this._allEffectTypes = b.concat(this._allEffectTypes);
        for (const a of b)
          this._effectTypesByName.set(a.GetName().toLowerCase(), a);
        for (let a = 0, c = this._allEffectTypes.length; a < c; ++a)
          this._allEffectTypes[a]._SetIndex(a);
      }
    }
    _LoadSingleEffectParameters(b) {
      b = b.slice(0);
      for (let a = 0, c = b.length; a < c; ++a) {
        const d = b[a];
        if (Array.isArray(d)) {
          const f = e.New(e.Color);
          f.setFromJSON(d);
          b[a] = f;
        }
      }
      return b;
    }
    GetOwner() {
      return this._owner;
    }
    GetRuntime() {
      return this._owner.GetRuntime();
    }
    UpdateActiveEffects() {
      e.clearArray(this._activeEffectTypes);
      let b = !0;
      for (const a of this._allEffectTypes)
        a.IsActive() &&
          (this._activeEffectTypes.push(a),
          a.GetShaderProgram().PreservesOpaqueness() || (b = !1));
      this._preservesOpaqueness = b;
    }
    GetAllEffectTypes() {
      return this._allEffectTypes;
    }
    HasAnyEffectType() {
      return 0 < this._allEffectTypes.length;
    }
    GetEffectTypeByName(b) {
      return this._effectTypesByName.get(b.toLowerCase()) || null;
    }
    GetEffectTypeByIndex(b) {
      b = Math.floor(+b);
      if (0 > b || b >= this._allEffectTypes.length)
        throw new RangeError("invalid effect type index");
      return this._allEffectTypes[b];
    }
    IsEffectIndexActive(b) {
      return this.GetEffectTypeByIndex(b).IsActive();
    }
    SetEffectIndexActive(b, a) {
      this.GetEffectTypeByIndex(b).SetActive(a);
    }
    GetActiveEffectTypes() {
      return this._activeEffectTypes;
    }
    HasAnyActiveEffect() {
      return 0 < this._activeEffectTypes.length;
    }
    PreservesOpaqueness() {
      return this._preservesOpaqueness;
    }
    GetEffectParametersForIndex(b) {
      return this._effectParams[b];
    }
    _GetEffectChainShaderParametersForIndex(b) {
      return b < this._effectParamBuffers.length
        ? this._effectParamBuffers[b]
        : this._effectParams[b];
    }
    GetEffectParameter(b, a) {
      if (0 > b || b >= this._effectParams.length) return null;
      b = this._effectParams[b];
      return 0 > a || a >= b.length ? null : b[a];
    }
    SetEffectParameter(b, a, c) {
      if (0 > b || b >= this._effectParams.length) return !1;
      const d = this._effectParams[b];
      if (0 > a || a >= d.length) return !1;
      const f = d[a];
      if (f instanceof e.Color) {
        if (f.equalsIgnoringAlpha(c)) return !1;
        f.copyRgb(c);
      } else {
        if (f === c) return !1;
        d[a] = c;
      }
      b < this._effectParamBuffers.length &&
        this._effectParamBuffers[b].SetParameterValue(a, c);
      return !0;
    }
    _UpdateAllEffectParamBuffers() {
      const b = this._effectParams,
        a = this._effectParamBuffers;
      for (let c = 0, d = Math.min(b.length, a.length); c < d; ++c) {
        const f = a[c],
          h = b[c];
        for (let g = 0, k = h.length; g < k; ++g) f.SetParameterValue(g, h[g]);
      }
    }
    static SaveFxParamToJson(b) {
      return b && b instanceof e.Color ? { t: "color", v: b.toJSON() } : b;
    }
    static LoadFxParamFromJson(b) {
      if ("object" === typeof b) {
        if ("color" === b.t) {
          const a = e.New(e.Color);
          a.setFromJSON(b.v);
          return a;
        }
        throw Error("invalid effect parameter type");
      }
      return b;
    }
    static SaveFxParamsToJson(b) {
      return b.map(e.EffectList.SaveFxParamToJson);
    }
    static LoadFxParamsFromJson(b) {
      return b.map(e.EffectList.LoadFxParamFromJson);
    }
    SaveToJson() {
      return this._allEffectTypes.map((b) => ({
        name: b.GetName(),
        active: b.IsActive(),
        params: e.EffectList.SaveFxParamsToJson(
          this._effectParams[b.GetIndex()]
        ),
      }));
    }
    LoadFromJson(b) {
      for (const a of b)
        if ((b = this.GetEffectTypeByName(a.name)))
          b.SetActive(a.active),
            (this._effectParams[b.GetIndex()] =
              e.EffectList.LoadFxParamsFromJson(a.params));
      this.UpdateActiveEffects();
      this._UpdateAllEffectParamBuffers();
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.EffectType = class extends e.DefendedBase {
    constructor(b, a, c) {
      super();
      this._effectList = b;
      this._id = a[0];
      this._name = a[1];
      this._index = c;
      this._shaderProgram = null;
      this._isActive = !0;
    }
    Release() {
      this._shaderProgram = this._effectList = null;
    }
    Clone(b) {
      b = e.New(e.EffectType, b, [this._id, this._name], -1);
      b._shaderProgram = this._shaderProgram;
      b._isActive = this._isActive;
      return b;
    }
    _InitRenderer(b) {
      b = b.GetShaderProgramByName(this._id);
      if (!b) throw Error("failed to find shader program '" + this._id + "'");
      this._shaderProgram = b;
    }
    GetEffectList() {
      return this._effectList;
    }
    GetName() {
      return this._name;
    }
    _SetIndex(b) {
      this._index = b;
    }
    GetIndex() {
      return this._index;
    }
    GetOwner() {
      return this._effectList.GetOwner();
    }
    GetRuntime() {
      return this._effectList.GetRuntime();
    }
    SetActive(b) {
      this._isActive = !!b;
    }
    IsActive() {
      return this._isActive;
    }
    GetShaderProgram() {
      return this._shaderProgram;
    }
    GetDefaultParameterValues() {
      const b = [];
      for (let a = 0, c = this._shaderProgram.GetParameterCount(); a < c; ++a) {
        const d = this._shaderProgram.GetParameterType(a);
        if ("float" === d || "percent" === d) b.push(0);
        else if ("color" === d) b.push(e.New(e.Color, 1, 1, 1, 1));
        else throw new TypeError("unknown effect parameter type");
      }
      return b;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.InstanceEffectList = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._inst = b;
      this._wi = a;
      this._effectList = b.GetObjectClass().GetEffectList();
      this._wasDefaultColor = this._needsRebuildSteps = !0;
      this._wasTexRotated = this._wasRotatedOrNegativeSize = this._was3D = !1;
      this._effectChain = e.New(
        e.Gfx.EffectChain,
        b.GetRuntime().GetCanvasManager().GetEffectChainManager(),
        {
          drawContent: (c, d) => {
            d = d.GetContentObject();
            const f = d.GetWorldInfo();
            c.SetColor(f.GetPremultipliedColor());
            c.SetCurrentZ(f.GetTotalZElevation());
            d.Draw(c);
            c.SetCurrentZ(0);
          },
          getSourceTextureInfo: (c) => {
            const d = c.GetCurrentTexRect(),
              [f, h] = c.GetCurrentSurfaceSize();
            return { srcTexRect: d, srcWidth: f, srcHeight: h };
          },
          getShaderParameters: (c) =>
            this._GetEffectChainShaderParametersForIndex(c),
        }
      );
      this._activeEffectFlags = [];
      this._activeEffectTypes = [];
      this._preservesOpaqueness = !0;
      this._effectParams = [];
      this._effectParamBuffers = [];
      b.GetRuntime().GetRenderer().IsWebGPU() &&
        (this._effectParamBuffers = this._effectList
          .GetAllEffectTypes()
          .map((c) => {
            c = c.GetShaderProgram();
            return 0 < c.GetCustomParametersByteSize()
              ? e.New(e.Gfx.WebGPUEffectCustomParamsBuffer, c)
              : null;
          }));
      for (
        let c = 0, d = this._effectList.GetAllEffectTypes().length;
        c < d;
        ++c
      )
        this._activeEffectFlags.push(!0);
      this.UpdateActiveEffects();
    }
    Release() {
      for (const b of this._effectParamBuffers) b.Release();
      e.clearArray(this._effectParamBuffers);
      this._effectChain.Release();
      this._effectChain = null;
      e.clearArray(this._activeEffectFlags);
      e.clearArray(this._activeEffectTypes);
      e.clearArray(this._effectParams);
      this._effectList = this._inst = null;
    }
    _LoadEffectParameters(b) {
      for (const a of b)
        this._effectParams.push(this._LoadSingleEffectParameters(a));
      this._UpdateAllEffectParamBuffers();
    }
    _LoadSingleEffectParameters(b) {
      b = b.slice(0);
      for (let a = 0, c = b.length; a < c; ++a) {
        const d = b[a];
        if (Array.isArray(d)) {
          const f = e.New(e.Color);
          f.setFromJSON(d);
          b[a] = f;
        }
      }
      return b;
    }
    LoadDefaultEffectParameters() {
      for (const b of this._effectList.GetAllEffectTypes())
        this._effectParams.push(b.GetDefaultParameterValues());
      this._UpdateAllEffectParamBuffers();
    }
    GetOwner() {
      return this._owner;
    }
    GetEffectList() {
      return this._effectList;
    }
    GetEffectChain() {
      this._MaybeRebuildEffectChainSteps();
      return this._effectChain;
    }
    GetRuntime() {
      return this._inst.GetRuntime();
    }
    UpdateActiveEffects() {
      e.clearArray(this._activeEffectTypes);
      const b = this._wi,
        a = this._effectList.GetAllEffectTypes(),
        c = this._activeEffectTypes,
        d = this._activeEffectFlags;
      let f = !0;
      for (let h = 0, g = a.length; h < g; ++h)
        if (d[h]) {
          const k = a[h];
          c.push(k);
          k.GetShaderProgram().PreservesOpaqueness() || (f = !1);
        }
      this._preservesOpaqueness = f;
      b._SetHasAnyActiveEffect(!!c.length);
      this._needsRebuildSteps = !0;
    }
    _MaybeRebuildEffectChainSteps() {
      const b = this._inst;
      var a = this._wi;
      const c = a.HasDefaultColor(),
        d = 0 < a.GetDepth();
      a = 0 !== a.GetAngle() || 0 > a.GetWidth() || 0 > a.GetHeight();
      const f = b.IsCurrentTexRotated();
      if (
        this._needsRebuildSteps ||
        c !== this._wasDefaultColor ||
        d !== this._was3D ||
        a !== this._wasRotatedOrNegativeSize ||
        f !== this._wasTexRotated
      )
        this._effectChain.BuildSteps(
          this._activeEffectTypes.map((h) => h.GetShaderProgram()),
          {
            indexMap: this._activeEffectTypes.map((h) => h.GetIndex()),
            forcePreDraw: !c || b.MustPreDraw(),
            is3D: d,
            isSourceTextureRotated: f,
            isRotatedOrNegativeSizeInstance: a,
          }
        ),
          (this._needsRebuildSteps = !1),
          (this._wasDefaultColor = c),
          (this._was3D = d),
          (this._wasRotatedOrNegativeSize = a),
          (this._wasTexRotated = f);
    }
    GetActiveEffectTypes() {
      return this._activeEffectTypes;
    }
    GetEffectParametersForIndex(b) {
      return this._effectParams[b];
    }
    _GetEffectChainShaderParametersForIndex(b) {
      return b < this._effectParamBuffers.length
        ? this._effectParamBuffers[b]
        : this._effectParams[b];
    }
    GetEffectParameter(b, a) {
      if (0 > b || b >= this._effectParams.length) return null;
      b = this._effectParams[b];
      return 0 > a || a >= b.length ? null : b[a];
    }
    SetEffectParameter(b, a, c) {
      if (0 > b || b >= this._effectParams.length) return !1;
      const d = this._effectParams[b];
      if (0 > a || a >= d.length) return !1;
      const f = d[a];
      if (f instanceof e.Color) {
        if (f.equalsIgnoringAlpha(c)) return !1;
        f.copyRgb(c);
      } else {
        if (f === c) return !1;
        d[a] = c;
      }
      b < this._effectParamBuffers.length &&
        this._effectParamBuffers[b].SetParameterValue(a, c);
      return !0;
    }
    _UpdateAllEffectParamBuffers() {
      const b = this._effectParams,
        a = this._effectParamBuffers;
      for (let c = 0, d = a.length; c < d; ++c) {
        const f = a[c],
          h = b[c];
        for (let g = 0, k = h.length; g < k; ++g) f.SetParameterValue(g, h[g]);
      }
    }
    PreservesOpaqueness() {
      return this._preservesOpaqueness;
    }
    HasAnyActiveBackgroundBlendingEffect() {
      return this._activeEffectTypes.some((b) =>
        b.GetShaderProgram().BlendsBackground()
      );
    }
    IsEffectIndexActive(b) {
      return this._activeEffectFlags[b];
    }
    SetEffectIndexActive(b, a) {
      this._activeEffectFlags[b] = !!a;
    }
    GetAllEffectTypes() {
      return this._effectList.GetAllEffectTypes();
    }
    _SaveToJson() {
      return this._effectList
        .GetAllEffectTypes()
        .map((b) => ({
          name: b.GetName(),
          active: this._activeEffectFlags[b.GetIndex()],
          params: e.EffectList.SaveFxParamsToJson(
            this._effectParams[b.GetIndex()]
          ),
        }));
    }
    _LoadFromJson(b) {
      for (const a of b)
        if ((b = this._effectList.GetEffectTypeByName(a.name)))
          (this._activeEffectFlags[b.GetIndex()] = a.active),
            (this._effectParams[b.GetIndex()] =
              e.EffectList.LoadFxParamsFromJson(a.params));
      this.UpdateActiveEffects();
      this._UpdateAllEffectParamBuffers();
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = [],
    a = [],
    c = [],
    d = e.New(e.CollisionPoly),
    f = e.New(e.CollisionPoly),
    h = e.New(e.Quad),
    g = e.New(e.Rect),
    k = e.New(e.Rect);
  let m = null,
    q = null,
    v = null;
  e.CollisionEngine = class extends e.DefendedBase {
    constructor(r) {
      super();
      this._runtime = r;
      this._registeredCollisions = [];
      this._polyCheckSec =
        this._polyCheckCount =
        this._collisionCheckSec =
        this._collisionCheckCount =
          0;
    }
    Release() {
      this._runtime = null;
    }
    _Update1sStats() {
      this._collisionCheckSec = this._collisionCheckCount;
      this._collisionCheckCount = 0;
      this._polyCheckSec = this._polyCheckCount;
      this._polyCheckCount = 0;
    }
    Get1secCollisionChecks() {
      return this._collisionCheckSec;
    }
    Get1secPolyChecks() {
      return this._polyCheckSec;
    }
    RegisterCollision(r, n) {
      const p = r.GetWorldInfo(),
        u = n.GetWorldInfo();
      p &&
        u &&
        p.IsCollisionEnabled() &&
        u.IsCollisionEnabled() &&
        this._registeredCollisions.push([r, n]);
    }
    AddRegisteredCollisionCandidates(r, n, p) {
      for (const [u, w] of this._registeredCollisions) {
        let y;
        if (r === u) y = w;
        else if (r === w) y = u;
        else continue;
        y.BelongsToObjectClass(n) && (p.includes(y) || p.push(y));
      }
    }
    CheckRegisteredCollision(r, n) {
      if (!this._registeredCollisions.length) return !1;
      for (const [p, u] of this._registeredCollisions)
        if ((r === p && n === u) || (r === u && n === p)) return !0;
      return !1;
    }
    ClearRegisteredCollisions() {
      e.clearArray(this._registeredCollisions);
    }
    TestOverlap(r, n) {
      if (!r || !n || r === n) return !1;
      r = r.GetWorldInfo();
      n = n.GetWorldInfo();
      if (!r.IsCollisionEnabled() || !n.IsCollisionEnabled()) return !1;
      this._collisionCheckCount++;
      const p = r.GetLayer(),
        u = n.GetLayer();
      return p.IsTransformCompatibleWith(u)
        ? this._TestOverlap_SameLayers(r, n)
        : this._TestOverlap_DifferentLayers(r, n);
    }
    _TestOverlap_SameLayers(r, n) {
      if (!r.GetBoundingBox().intersectsRect(n.GetBoundingBox())) return !1;
      this._polyCheckCount++;
      if (
        !r.GetBoundingQuad().intersectsQuad(n.GetBoundingQuad()) ||
        (r.HasTilemap() && n.HasTilemap())
      )
        return !1;
      if (r.HasTilemap()) return this.TestTilemapOverlap(r, n);
      if (n.HasTilemap()) return this.TestTilemapOverlap(n, r);
      if (!r.HasOwnCollisionPoly() && !n.HasOwnCollisionPoly()) return !0;
      const p = r.GetTransformedCollisionPoly(),
        u = n.GetTransformedCollisionPoly();
      return p.intersectsPoly(u, n.GetX() - r.GetX(), n.GetY() - r.GetY());
    }
    _TestOverlap_DifferentLayers(r, n) {
      var p = r.HasTilemap(),
        u = n.HasTilemap();
      if (p && !u) return this.TestTilemapOverlapDifferentLayers(r, n);
      if (u && !p) return this.TestTilemapOverlapDifferentLayers(n, r);
      if (u || p) return !1;
      u = r.GetLayer();
      p = n.GetLayer();
      d.copy(r.GetTransformedCollisionPoly());
      f.copy(n.GetTransformedCollisionPoly());
      var w = d.pointsArr();
      for (let y = 0, B = w.length; y < B; y += 2) {
        const E = y + 1,
          z = w[E],
          [D, J] = u.LayerToCanvasCss(w[y] + r.GetX(), z + r.GetY());
        w[y] = D;
        w[E] = J;
      }
      r = f.pointsArr();
      for (let y = 0, B = r.length; y < B; y += 2) {
        u = y + 1;
        w = r[u];
        const [E, z] = p.LayerToCanvasCss(r[y] + n.GetX(), w + n.GetY());
        r[y] = E;
        r[u] = z;
      }
      d.setBboxChanged();
      f.setBboxChanged();
      this._polyCheckCount++;
      return d.intersectsPoly(f, 0, 0);
    }
    TestTilemapOverlapDifferentLayers(r, n) {
      var p = r.GetLayer(),
        u = n.GetLayer();
      m || (m = e.New(e.CollisionPoly));
      q || (q = e.New(e.Rect));
      v || (v = e.New(e.Quad));
      var w = n.GetX(),
        y = n.GetY();
      const [B, E] = u.LayerToCanvasCss(w, y),
        [z, D] = p.CanvasCssToLayer(B, E);
      p = z - w;
      y = D - y;
      q.copy(n.GetBoundingBox());
      q.offset(p, y);
      if (!r.GetBoundingBox().intersectsRect(q)) return !1;
      v.copy(n.GetBoundingQuad());
      v.offset(p, y);
      this._polyCheckCount++;
      if (!r.GetBoundingQuad().intersectsQuad(v)) return !1;
      m.copy(n.GetTransformedCollisionPoly());
      u = m.pointsArr();
      for (let J = 0, C = u.length; J < C; J += 2)
        (w = J + 1), (u[J] += p), (u[w] += y);
      m.setBboxChanged();
      return this.TestTilemapOverlap(r, n, z, D, m, q, v);
    }
    TestTilemapOverlap(r, n, p, u, w, y, B) {
      y = void 0 !== y ? y : n.GetBoundingBox();
      const E = r.GetX(),
        z = r.GetY();
      var D = r.GetInstance().GetSdkInstance();
      p = void 0 !== p ? p : n.GetX();
      u = void 0 !== u ? u : n.GetY();
      r = n.HasOwnCollisionPoly();
      B = void 0 !== B ? B : n.GetBoundingQuad();
      D.GetCollisionRectCandidates(y, a);
      for (let H = 0, K = a.length; H < K; ++H) {
        var J = a[H];
        D = J.GetRect();
        this._collisionCheckCount++;
        if (
          y.intersectsRectOffset(D, E, z) &&
          (h.setFromRect(D), h.offset(E, z), h.intersectsQuad(B))
        )
          if (r) {
            var C = void 0 !== w ? w : n.GetTransformedCollisionPoly();
            if ((J = J.GetPoly())) {
              if (
                (this._polyCheckCount++,
                J.intersectsPoly(
                  C,
                  p - (E + D.getLeft()),
                  u - (z + D.getTop())
                ))
              )
                return e.clearArray(a), !0;
            } else if ((d.setFromQuad(h, 0, 0), d.intersectsPoly(C, p, u)))
              return e.clearArray(a), !0;
          } else if ((C = J.GetPoly())) {
            if (
              (d.setFromQuad(B, 0, 0),
              C.intersectsPoly(d, -(E + D.getLeft()), -(z + D.getTop())))
            )
              return e.clearArray(a), !0;
          } else return e.clearArray(a), !0;
      }
      e.clearArray(a);
      return !1;
    }
    TestAndSelectCanvasPointOverlap(r, n, p, u) {
      const w = r.GetCurrentSol();
      var y = this._runtime.GetCurrentEvent();
      if (!y) throw Error("cannot call outside event");
      y = y.IsOrBlock();
      if (w.IsSelectAll()) {
        u || (w._SetSelectAll(!1), e.clearArray(w._GetOwnInstances()));
        for (var B of r.GetInstances()) {
          var E = B.GetWorldInfo(),
            z = E.GetLayer();
          const [D, J] = z.CanvasCssToLayer(n, p, E.GetTotalZElevation());
          if (z.IsSelfAndParentsInteractive() && E.ContainsPoint(D, J)) {
            if (u) return !1;
            w._PushInstance(B);
          } else y && w._PushElseInstance(B);
        }
      } else {
        E = !1;
        y
          ? this._runtime.IsCurrentConditionFirst() &&
            !w._GetOwnElseInstances().length &&
            w._GetOwnInstances().length
            ? (B = w._GetOwnInstances())
            : ((B = w._GetOwnElseInstances()), (E = !0))
          : (B = w._GetOwnInstances());
        z = 0;
        for (let D = 0, J = B.length; D < J; ++D) {
          const C = B[D],
            H = C.GetWorldInfo(),
            K = H.GetLayer(),
            [P, S] = K.CanvasCssToLayer(n, p, H.GetTotalZElevation());
          if (K.IsSelfAndParentsInteractive() && H.ContainsPoint(P, S)) {
            if (u) return !1;
            E ? w._PushInstance(C) : (B[z++] = C);
          } else E ? (B[z++] = C) : y && w._PushElseInstance(C);
        }
        u || (B.length = z);
      }
      r.ApplySolToContainer();
      return u ? !0 : w.HasAnyInstances();
    }
    GetCollisionCandidates(r, n, p, u) {
      r = r ? 1 !== r.GetParallaxX() || 1 !== r.GetParallaxY() : !1;
      if (n.IsFamily())
        for (const w of n.GetFamilyMembers())
          r || w.IsAnyInstanceParallaxed()
            ? e.appendArray(u, w.GetInstances())
            : (w._UpdateAllCollisionCells(),
              w._GetCollisionCellGrid().QueryRange(p, u));
      else
        r || n.IsAnyInstanceParallaxed()
          ? e.appendArray(u, n.GetInstances())
          : (n._UpdateAllCollisionCells(),
            n._GetCollisionCellGrid().QueryRange(p, u));
    }
    GetObjectClassesCollisionCandidates(r, n, p, u) {
      for (const w of n) this.GetCollisionCandidates(r, w, p, u);
    }
    GetSolidCollisionCandidates(r, n, p) {
      const u = this._runtime.GetSolidBehavior();
      u &&
        this.GetObjectClassesCollisionCandidates(r, u.GetObjectClasses(), n, p);
    }
    GetJumpthruCollisionCandidates(r, n, p) {
      const u = this._runtime.GetJumpthruBehavior();
      u &&
        this.GetObjectClassesCollisionCandidates(r, u.GetObjectClasses(), n, p);
    }
    IsSolidCollisionAllowed(r, n) {
      return (
        r._IsSolidEnabled() &&
        (!n ||
          n
            .GetWorldInfo()
            .IsSolidCollisionAllowed(r.GetSavedDataMap().get("solidTags")))
      );
    }
    TestOverlapSolid(r) {
      const n = r.GetWorldInfo();
      this.GetSolidCollisionCandidates(n.GetLayer(), n.GetBoundingBox(), b);
      for (const p of b)
        if (this.IsSolidCollisionAllowed(p, r) && this.TestOverlap(r, p))
          return e.clearArray(b), p;
      e.clearArray(b);
      return null;
    }
    TestRectOverlapSolid(r, n) {
      this.GetSolidCollisionCandidates(null, r, b);
      for (const p of b)
        if (this.IsSolidCollisionAllowed(p, n) && this.TestRectOverlap(r, p))
          return e.clearArray(b), p;
      e.clearArray(b);
      return null;
    }
    TestOverlapJumpthru(r, n) {
      let p = null;
      n && ((p = c), e.clearArray(p));
      const u = r.GetWorldInfo();
      this.GetJumpthruCollisionCandidates(u.GetLayer(), u.GetBoundingBox(), b);
      for (const w of b)
        if (w._IsJumpthruEnabled() && this.TestOverlap(r, w))
          if (n) p.push(w);
          else return e.clearArray(b), w;
      e.clearArray(b);
      return p;
    }
    PushOut(r, n, p, u, w) {
      u = u || 50;
      const y = r.GetWorldInfo(),
        B = y.GetX(),
        E = y.GetY();
      for (let z = 0; z < u; ++z)
        if (
          (y.SetXY(B + n * z, E + p * z),
          y.SetBboxChanged(),
          !this.TestOverlap(r, w))
        )
          return !0;
      y.SetXY(B, E);
      y.SetBboxChanged();
      return !1;
    }
    PushOutSolid(r, n, p, u, w, y) {
      u = u || 50;
      const B = r.GetWorldInfo(),
        E = B.GetX(),
        z = B.GetY();
      let D = null,
        J = null;
      for (let C = 0; C < u; ++C)
        if (
          (B.SetXY(E + n * C, z + p * C),
          B.SetBboxChanged(),
          !this.TestOverlap(r, D))
        )
          if ((D = this.TestOverlapSolid(r))) J = D;
          else if (
            (w &&
              (D = y
                ? this.TestOverlap(r, y)
                  ? y
                  : null
                : this.TestOverlapJumpthru(r)) &&
              (J = D),
            !D)
          )
            return J && this.PushInFractional(r, n, p, J, 16, !0), !0;
      B.SetXY(E, z);
      B.SetBboxChanged();
      return !1;
    }
    PushOutSolidAxis(r, n, p, u) {
      u = u || 50;
      const w = r.GetWorldInfo(),
        y = w.GetX(),
        B = w.GetY();
      let E = null,
        z = null;
      for (let D = 0; D < u; ++D)
        for (let J = 0; 2 > J; ++J) {
          const C = 2 * J - 1;
          w.SetXY(y + n * D * C, B + p * D * C);
          w.SetBboxChanged();
          if (!this.TestOverlap(r, E))
            if ((E = this.TestOverlapSolid(r))) z = E;
            else
              return z && this.PushInFractional(r, n * C, p * C, z, 16, !0), !0;
        }
      w.SetXY(y, B);
      w.SetBboxChanged();
      return !1;
    }
    PushInFractional(r, n, p, u, w, y) {
      let B = 2,
        E = !1;
      var z = !1;
      const D = r.GetWorldInfo();
      let J = D.GetX(),
        C = D.GetY();
      for (; B <= w; )
        (z = 1 / B),
          (B *= 2),
          D.OffsetXY(n * z * (E ? 1 : -1), p * z * (E ? 1 : -1)),
          D.SetBboxChanged(),
          this.TestOverlap(r, u) || (y && this.TestOverlapSolid(r))
            ? (z = E = !0)
            : ((z = E = !1), (J = D.GetX()), (C = D.GetY()));
      z && (D.SetXY(J, C), D.SetBboxChanged());
    }
    PushOutSolidNearest(r, n = 100) {
      let p = 0;
      const u = r.GetWorldInfo(),
        w = u.GetX(),
        y = u.GetY();
      let B = 0,
        E = this.TestOverlapSolid(r);
      if (!E) return !0;
      for (; p <= n; ) {
        let z = 0,
          D = 0;
        switch (B) {
          case 0:
            z = 0;
            D = -1;
            p++;
            break;
          case 1:
            z = 1;
            D = -1;
            break;
          case 2:
            z = 1;
            D = 0;
            break;
          case 3:
            D = z = 1;
            break;
          case 4:
            z = 0;
            D = 1;
            break;
          case 5:
            z = -1;
            D = 1;
            break;
          case 6:
            z = -1;
            D = 0;
            break;
          case 7:
            D = z = -1;
        }
        B = (B + 1) % 8;
        u.SetXY(Math.floor(w + z * p), Math.floor(y + D * p));
        u.SetBboxChanged();
        if (!this.TestOverlap(r, E) && ((E = this.TestOverlapSolid(r)), !E))
          return !0;
      }
      u.SetXY(w, y);
      u.SetBboxChanged();
      return !1;
    }
    CalculateBounceAngle(r, n, p, u) {
      const w = r.GetWorldInfo(),
        y = w.GetX(),
        B = w.GetY(),
        E = Math.max(10, e.distanceTo(n, p, y, B));
      var z = e.angleTo(n, p, y, B),
        D = u || this.TestOverlapSolid(r);
      if (!D) return e.clampAngle(z + Math.PI);
      let J = D;
      var C = 0,
        H = 0;
      const K = e.toRadians(5);
      let P;
      for (P = 1; 36 > P; ++P) {
        const S = z - P * K;
        w.SetXY(n + Math.cos(S) * E, p + Math.sin(S) * E);
        w.SetBboxChanged();
        if (
          !this.TestOverlap(r, J) &&
          ((J = u ? null : this.TestOverlapSolid(r)), !J)
        ) {
          C = S;
          break;
        }
      }
      36 === P && (C = e.clampAngle(z + Math.PI));
      J = D;
      for (P = 1; 36 > P; ++P)
        if (
          ((D = z + P * K),
          w.SetXY(n + Math.cos(D) * E, p + Math.sin(D) * E),
          w.SetBboxChanged(),
          !this.TestOverlap(r, J) &&
            ((J = u ? null : this.TestOverlapSolid(r)), !J))
        ) {
          H = D;
          break;
        }
      36 === P && (H = e.clampAngle(z + Math.PI));
      w.SetXY(y, B);
      w.SetBboxChanged();
      if (H === C) return H;
      r = e.angleDiff(H, C) / 2;
      r = e.angleClockwise(H, C)
        ? e.clampAngle(C + r + Math.PI)
        : e.clampAngle(H + r);
      C = Math.cos(z);
      z = Math.sin(z);
      H = Math.cos(r);
      r = Math.sin(r);
      n = C * H + z * r;
      return e.angleTo(0, 0, C - 2 * n * H, z - 2 * n * r);
    }
    TestSegmentOverlap(r, n, p, u, w) {
      if (!w) return !1;
      const y = w.GetWorldInfo();
      if (!y.IsCollisionEnabled()) return !1;
      this._collisionCheckCount++;
      g.set(Math.min(r, p), Math.min(n, u), Math.max(r, p), Math.max(n, u));
      if (!y.GetBoundingBox().intersectsRect(g)) return !1;
      if (w.HasTilemap())
        return this._TestSegmentOverlapTilemap(r, n, p, u, w, y);
      this._polyCheckCount++;
      return y.GetBoundingQuad().intersectsSegment(r, n, p, u)
        ? y.HasOwnCollisionPoly()
          ? y
              .GetTransformedCollisionPoly()
              .intersectsSegment(y.GetX(), y.GetY(), r, n, p, u)
          : !0
        : !1;
    }
    _TestSegmentOverlapTilemap(r, n, p, u, w, y) {
      const B = y.GetX();
      y = y.GetY();
      w = w.GetSdkInstance();
      k.set(r, n, p, u);
      k.normalize();
      w.GetCollisionRectCandidates(k, a);
      for (let z = 0, D = a.length; z < D; ++z) {
        var E = a[z];
        w = E.GetRect();
        this._collisionCheckCount++;
        if (
          g.intersectsRectOffset(w, B, y) &&
          (h.setFromRect(w), h.offset(B, y), h.intersectsSegment(r, n, p, u))
        )
          if ((E = E.GetPoly())) {
            if (
              (this._polyCheckCount++,
              E.intersectsSegment(B + w.getLeft(), y + w.getTop(), r, n, p, u))
            )
              return e.clearArray(a), !0;
          } else return e.clearArray(a), !0;
      }
      e.clearArray(a);
      return !1;
    }
    TestRectOverlap(r, n) {
      if (!n) return !1;
      const p = n.GetWorldInfo();
      if (!p.IsCollisionEnabled()) return !1;
      this._collisionCheckCount++;
      if (!p.GetBoundingBox().intersectsRect(r)) return !1;
      if (n.HasTilemap()) return this._TestRectOverlapTilemap(r, n, p);
      this._polyCheckCount++;
      h.setFromRect(r);
      if (!p.GetBoundingQuad().intersectsQuad(h)) return !1;
      if (!p.HasOwnCollisionPoly()) return !0;
      d.setFromRect(r, p.GetX(), p.GetY());
      r = p.GetTransformedCollisionPoly();
      return d.intersectsPoly(r, 0, 0);
    }
    _TestRectOverlapTilemap(r, n, p) {
      const u = p.GetX();
      p = p.GetY();
      n.GetSdkInstance().GetCollisionRectCandidates(r, a);
      for (let y = 0, B = a.length; y < B; ++y) {
        var w = a[y];
        n = w.GetRect();
        this._collisionCheckCount++;
        if (r.intersectsRectOffset(n, u, p))
          if ((w = w.GetPoly())) {
            if (
              (this._polyCheckCount++,
              d.setFromRect(r, 0, 0),
              w.intersectsPoly(d, -(u + n.getLeft()), -(p + n.getTop())))
            )
              return e.clearArray(a), !0;
          } else return e.clearArray(a), !0;
      }
      e.clearArray(a);
      return !1;
    }
    TestRayIntersectsInstance(r, n) {
      if (r) {
        var p = r.GetWorldInfo();
        p.IsCollisionEnabled() &&
          (this._collisionCheckCount++,
          p.GetBoundingBox().intersectsRect(n.rect) &&
            (r.HasTilemap()
              ? this._TestRayIntersectsTilemap(r, p, n)
              : (this._polyCheckCount++,
                p.HasOwnCollisionPoly()
                  ? n.TestInstancePoly(
                      r,
                      p.GetX(),
                      p.GetY(),
                      p.GetTransformedCollisionPoly()
                    )
                  : n.TestInstanceQuad(r, p.GetBoundingQuad()))));
      }
    }
    _TestRayIntersectsTilemap(r, n, p) {
      const u = n.GetX(),
        w = n.GetY();
      r.GetSdkInstance().GetCollisionRectCandidates(p.rect, a);
      for (let B = 0, E = a.length; B < E; B++) {
        var y = a[B];
        const z = y.GetRect();
        this._collisionCheckCount++;
        p.rect.intersectsRectOffset(z, u, w) &&
          ((y = y.GetPoly()),
          this._polyCheckCount++,
          y
            ? p.TestInstancePoly(r, u + z.getLeft(), w + z.getTop(), y)
            : p.TestInstanceRect(r, n.GetX(), n.GetY(), z));
      }
      e.clearArray(a);
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.SparseGrid = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._cellWidth = b;
      this._cellHeight = a;
      this._cells = e.New(e.PairMap);
    }
    Release() {
      this._cells.Release();
      this._cells = null;
    }
    GetCell(b, a, c) {
      let d = this._cells.Get(b, a);
      return d
        ? d
        : c
        ? ((d = e.New(e.GridCell, this, b, a)), this._cells.Set(b, a, d), d)
        : null;
    }
    XToCell(b) {
      b = Math.floor(b / this._cellWidth);
      return isFinite(b) ? b : 0;
    }
    YToCell(b) {
      b = Math.floor(b / this._cellHeight);
      return isFinite(b) ? b : 0;
    }
    Update(b, a, c) {
      if (a)
        for (let d = a.getLeft(), f = a.getRight(); d <= f; ++d)
          for (let h = a.getTop(), g = a.getBottom(); h <= g; ++h) {
            if (c && c.containsPoint(d, h)) continue;
            const k = this.GetCell(d, h, !1);
            k && (k.Remove(b), k.IsEmpty() && this._cells.Delete(d, h));
          }
      if (c)
        for (let d = c.getLeft(), f = c.getRight(); d <= f; ++d)
          for (let h = c.getTop(), g = c.getBottom(); h <= g; ++h)
            (a && a.containsPoint(d, h)) || this.GetCell(d, h, !0).Insert(b);
    }
    QueryRange(b, a) {
      let c = this.XToCell(b.getLeft());
      const d = this.YToCell(b.getTop()),
        f = this.XToCell(b.getRight());
      b = this.YToCell(b.getBottom());
      if (isFinite(f) && isFinite(b))
        for (; c <= f; ++c)
          for (let h = d; h <= b; ++h) {
            const g = this.GetCell(c, h, !1);
            g && g.Dump(a);
          }
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.GridCell = class extends e.DefendedBase {
    constructor(b, a, c) {
      super();
      this._grid = b;
      this._x = a;
      this._y = c;
      this._instances = e.New(e.ArraySet);
    }
    Release() {
      this._instances.Release();
      this._grid = this._instances = null;
    }
    IsEmpty() {
      return this._instances.IsEmpty();
    }
    Insert(b) {
      this._instances.Add(b);
    }
    Remove(b) {
      this._instances.Delete(b);
    }
    Dump(b) {
      e.appendArray(b, this._instances.GetArray());
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Ray = class {
    constructor() {
      this.dy = this.dx = this.y2 = this.x2 = this.y1 = this.x1 = 0;
      this.rect = new e.Rect();
      this.hitFraction = 2;
      this.hitUid = null;
      this.distance =
        this.hitY =
        this.hitX =
        this.hitNormalDy =
        this.hitNormalDx =
        this.hitNormal =
          0;
      this.normalX = 1;
      this.normalY = 0;
      this.reflectionX = 1;
      this.reflectionY = 0;
    }
    DidCollide() {
      return 1.000001 > this.hitFraction;
    }
    Set(b, a, c, d) {
      this.x1 = b;
      this.y1 = a;
      this.x2 = c;
      this.y2 = d;
      this.dx = c - b;
      this.dy = d - a;
      this.rect.set(b, a, c, d);
      this.rect.normalize();
      this.hitFraction = 2;
      this.hitUid = null;
      this.distance =
        this.hitY =
        this.hitX =
        this.hitNormalDy =
        this.hitNormalDx =
        this.hitNormal =
          0;
      this.normalX = 1;
      this.normalY = 0;
      this.reflectionX = 1;
      this.reflectionY = 0;
      return this;
    }
    Complete() {
      if (!1 !== this.DidCollide()) {
        var b = this.dx * this.hitFraction,
          a = this.dy * this.hitFraction,
          c = Math.sqrt(b * b + a * a);
        b /= c;
        a /= c;
        this.distance = c - 1e-6;
        this.hitX = this.x1 + b * this.distance;
        this.hitY = this.y1 + a * this.distance;
        this.hitNormal =
          Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2;
        this.normalX = Math.cos(this.hitNormal);
        this.normalY = Math.sin(this.hitNormal);
        c = b * this.normalX + a * this.normalY;
        this.reflectionX = b - 2 * this.normalX * c;
        this.reflectionY = a - 2 * this.normalY * c;
        0 < c &&
          ((this.hitNormal = e.clampAngle(this.hitNormal + Math.PI)),
          (this.normalX = -this.normalX),
          (this.normalY = -this.normalY));
      }
    }
    TestInstanceSegment(b, a, c, d, f) {
      const h = e.rayIntersect(this.x1, this.y1, this.x2, this.y2, a, c, d, f);
      0 <= h &&
        h < this.hitFraction &&
        ((this.hitFraction = h),
        (this.hitUid = b.GetUID()),
        (this.hitNormalDx = a - d),
        (this.hitNormalDy = c - f));
    }
    TestInstanceRect(b, a, c, d) {
      const f = a + d.getLeft();
      a += d.getRight();
      const h = c + d.getTop();
      c += d.getBottom();
      this.TestInstanceSegment(b, f, h, a, h);
      this.TestInstanceSegment(b, a, h, a, c);
      this.TestInstanceSegment(b, a, c, f, c);
      this.TestInstanceSegment(b, f, c, f, h);
    }
    TestInstanceQuad(b, a) {
      const c = a.getTlx(),
        d = a.getTly(),
        f = a.getTrx(),
        h = a.getTry(),
        g = a.getBrx(),
        k = a.getBry(),
        m = a.getBlx();
      a = a.getBly();
      this.TestInstanceSegment(b, c, d, f, h);
      this.TestInstanceSegment(b, f, h, g, k);
      this.TestInstanceSegment(b, g, k, m, a);
      this.TestInstanceSegment(b, m, a, c, d);
    }
    TestInstancePoly(b, a, c, d) {
      d = d.pointsArr();
      for (let f = 0, h = d.length; f < h; f += 2) {
        const g = (f + 2) % h;
        this.TestInstanceSegment(
          b,
          d[f] + a,
          d[f + 1] + c,
          d[g] + a,
          d[g + 1] + c
        );
      }
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = new Set(
      "off crop scale-inner scale-outer letterbox-scale letterbox-integer-scale".split(
        " "
      )
    ),
    a = new Set(["high", "low"]),
    c = self.glMatrix.mat4,
    d = c.create(),
    f = e.New(e.Quad),
    h = e.New(e.Rect);
  e.CanvasManager = class extends e.DefendedBase {
    constructor(g) {
      super();
      this._runtime = g;
      this._canvas = null;
      this._isWebGPUEnabled = !1;
      this._webgpuRenderer = this._webglRenderer = null;
      this._gpuPreference = "high-performance";
      this._canvasCssOffsetY =
        this._canvasCssOffsetX =
        this._canvasDeviceHeight =
        this._canvasDeviceWidth =
        this._canvasCssHeight =
        this._canvasCssWidth =
        this._windowInnerHeight =
        this._windowInnerWidth =
          0;
      this._zAxisScale = "normalized";
      this._fieldOfView = 0;
      this._enableMipmaps = !0;
      this._drawHeight = this._drawWidth = this._textureAnisotropy = 0;
      this._documentFullscreenMode = this._fullscreenMode = "letterbox-scale";
      this._deviceTransformOffY = this._deviceTransformOffX = 0;
      this._defaultProjectionMatrix = c.create();
      this._fullscreenScalingQuality = this._wantFullscreenScalingQuality =
        "high";
      this._isDocumentFullscreen = !1;
      this._availableAdditionalRenderTargets = [];
      this._usedAdditionalRenderTargets = new Set();
      this._shaderData = self.C3_Shaders;
      this._effectChainManager = e.New(e.Gfx.EffectChainManager, {
        getDrawSize: () => [this.GetDrawWidth(), this.GetDrawHeight()],
        getRenderTarget: () => this.GetEffectCompositorRenderTarget(),
        releaseRenderTarget: (k) => this.ReleaseEffectCompositorRenderTarget(k),
        getTime: () => this.GetRuntime().GetGameTime(),
        redraw: () => this.GetRuntime().UpdateRender(),
      });
      this._gpuTimeEndFrame = this._gpuTimeStartFrame = 0;
      this._gpuLastUtilisation = NaN;
      this._gpuFrameTimingsBuffer = null;
      this._layersGpuProfile = new Map();
      this._gpuCurUtilisation = NaN;
      this._webgpuFrameTimings = new Map();
      this._snapshotFormat = "";
      this._snapshotQuality = 1;
      this._snapshotArea = e.New(e.Rect);
      this._snapshotUrl = "";
      this._snapshotResolve = this._snapshotPromise = null;
      this._loaderStartTime = this._isPastingToDrawingCanvas = 0;
      this._rafId = -1;
      this._loadingProgress = 0;
      this._loadingprogress_handler = (k) =>
        (this._loadingProgress = k.progress);
      this._percentText = null;
      this._splashTextures = { logo: null, powered: null, website: null };
      this._splashFadeOutStartTime =
        this._splashFadeInFinishTime =
        this._splashFrameNumber =
          0;
      this._splashState = "fade-in";
      this._splashDoneResolve = null;
      this._splashDonePromise = new Promise(
        (k) => (this._splashDoneResolve = k)
      );
    }
    _SetGPUPowerPreference(g) {
      this._gpuPreference = g;
    }
    _SetWebGPUEnabled(g) {
      this._isWebGPUEnabled = !!g;
    }
    _SetZAxisScale(g) {
      this._zAxisScale = g;
    }
    _SetFieldOfView(g) {
      this._fieldOfView = g;
    }
    async CreateCanvas(g) {
      this._canvas = g.canvas;
      this._runtime.AddDOMComponentMessageHandler(
        "runtime",
        "window-resize",
        (q) => this._OnWindowResize(q)
      );
      this._runtime.AddDOMComponentMessageHandler(
        "runtime",
        "fullscreenchange",
        (q) => this._OnFullscreenChange(q)
      );
      this._runtime.AddDOMComponentMessageHandler(
        "runtime",
        "fullscreenerror",
        (q) => this._OnFullscreenError(q)
      );
      this._canvas.addEventListener("webglcontextlost", (q) =>
        this._OnWebGLContextLost(q)
      );
      this._canvas.addEventListener("webglcontextrestored", (q) =>
        this._OnWebGLContextRestored(q)
      );
      this._isDocumentFullscreen = !!g.isFullscreen;
      var k = navigator.gpu && this._isWebGPUEnabled;
      let m = !1;
      if (k)
        try {
          await this._InitWebGPUContext(!0);
        } catch (q) {
          this._webgpuRenderer = null;
        }
      if (!this.GetRenderer())
        try {
          await this._InitWebGLContext(!0);
        } catch (q) {
          this._webglRenderer = null;
        }
      this.GetRenderer() || (m = !0);
      if (!this.GetRenderer() && k)
        try {
          await this._InitWebGPUContext(!1);
        } catch (q) {
          this._webgpuRenderer = null;
        }
      if (!this.GetRenderer())
        try {
          await this._InitWebGLContext(!1);
        } catch (q) {
          this._webglRenderer = null;
        }
      k = this.GetRenderer();
      if (!k)
        throw Error(
          "failed to acquire a renderer - check WebGL or WebGPU is supported"
        );
      k.SetHasMajorPerformanceCaveat(m);
      "normalized" === this._zAxisScale
        ? k.SetZAxisScaleNormalized()
        : (k.SetZAxisScaleRegular(), k.SetFovY(this._fieldOfView));
      this.SetSize(g.windowInnerWidth, g.windowInnerHeight, !0);
      this._webgpuRenderer
        ? await this._InitWebGPU()
        : this._webglRenderer && (await this._InitWebGL());
      k.SetMipmapsEnabled(this._enableMipmaps);
      k.SupportsGPUProfiling() && (this._gpuLastUtilisation = 0);
      for (const q of this._runtime._GetAllEffectLists()) {
        for (const v of q.GetAllEffectTypes()) v._InitRenderer(k);
        q._InitRenderer(k);
        q.UpdateActiveEffects();
      }
    }
    async _InitWebGPUContext(g) {
      g = {
        powerPreference: this._gpuPreference,
        depth: this._runtime.Uses3DFeatures(),
        failIfMajorPerformanceCaveat: g,
        usesBackgroundBlending: this._runtime.UsesAnyBackgroundBlending(),
        canSampleBackbuffer: this._runtime.UsesAnyCrossSampling(),
        canSampleDepth: this._runtime.UsesAnyDepthSampling(),
      };
      this._webgpuRenderer = e.New(e.Gfx.WebGPURenderer);
      await this._webgpuRenderer.Create(this._canvas, g);
    }
    async _InitWebGLContext(g) {
      g = {
        powerPreference: this._gpuPreference,
        enableGpuProfiling: !0,
        depth: this._runtime.Uses3DFeatures(),
        canSampleDepth: this._runtime.UsesAnyDepthSampling(),
        failIfMajorPerformanceCaveat: g,
      };
      "Android" === e.Platform.OS &&
        "Chromium" === e.Platform.BrowserEngine &&
        75 > e.Platform.BrowserVersionNumber &&
        (console.warn(
          "[Construct 3] Disabling WebGL 2 because this device appears to be affected by crbug.com/934823. Install software updates to avoid this."
        ),
        (g.maxWebGLVersion = 1));
      "standard" === this._runtime.GetCompositingMode()
        ? (g.alpha = !0)
        : ((g.alpha = !1), (g.lowLatency = !0));
      this._webglRenderer = e.New(e.Gfx.WebGLRenderer, this._canvas, g);
      await this._webglRenderer.InitState();
    }
    async _InitWebGPU() {
      if (this._shaderData) {
        const g = [];
        for (const [k, m] of Object.entries(this._shaderData)) {
          m.src = m.wgsl;
          const q = e.Gfx.WebGPUShaderProgram.GetDefaultVertexShaderSource();
          g.push(this._webgpuRenderer.CreateShaderProgram(m, q, k));
        }
        await Promise.all(g);
      }
    }
    async _InitWebGL() {
      if (this._shaderData) {
        const g = [];
        for (const [k, m] of Object.entries(this._shaderData)) {
          m.src = m.glsl;
          const q = e.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource();
          g.push(this._webglRenderer.CreateShaderProgram(m, q, k));
        }
        await Promise.all(g);
        this._webglRenderer.ResetLastProgram();
        this._webglRenderer.SetTextureFillMode();
      }
      this._webglRenderer.SupportsGPUProfiling() &&
        (this._gpuFrameTimingsBuffer = e.New(
          e.Gfx.WebGLQueryResultBuffer,
          this._webglRenderer
        ));
    }
    Release() {
      this._canvas = this._webglRenderer = this._runtime = null;
    }
    _OnWindowResize(g) {
      const k = this._runtime;
      if (!k.IsExportToVideo()) {
        var m = g.devicePixelRatio;
        k.IsInWorker() && (self.devicePixelRatio = m);
        k._SetDevicePixelRatio(m);
        this._isDocumentFullscreen = !!g.isFullscreen;
        this.SetSize(g.innerWidth, g.innerHeight);
        k.UpdateRender();
        k.IsDebug() &&
          (k.HitBreakpoint() || self.C3Debugger.IsDebuggerPaused()) &&
          k.Render();
      }
    }
    _OnFullscreenChange(g) {
      this._isDocumentFullscreen = !!g.isFullscreen;
      this.SetSize(g.innerWidth, g.innerHeight, !0);
      this._runtime.UpdateRender();
    }
    _OnFullscreenError(g) {
      this._isDocumentFullscreen = !!g.isFullscreen;
      this.SetSize(g.innerWidth, g.innerHeight, !0);
      this._runtime.UpdateRender();
    }
    SetSize(g, k, m = !1) {
      g = Math.floor(g);
      k = Math.floor(k);
      if (0 >= g || 0 >= k) throw Error("invalid size");
      if (this._windowInnerWidth !== g || this._windowInnerHeight !== k || m) {
        this._windowInnerWidth = g;
        this._windowInnerHeight = k;
        m = this.GetCurrentFullscreenMode();
        "letterbox-scale" === m
          ? this._CalculateLetterboxScale(g, k)
          : "letterbox-integer-scale" === m
          ? this._CalculateLetterboxIntegerScale(g, k)
          : "off" === m
          ? this._CalculateFixedSizeCanvas(g, k)
          : this._CalculateFullsizeCanvas(g, k);
        this._UpdateFullscreenScalingQuality(m);
        this._canvas.width = this._canvasDeviceWidth;
        this._canvas.height = this._canvasDeviceHeight;
        this._runtime.PostComponentMessageToDOM("canvas", "update-size", {
          marginLeft: this._canvasCssOffsetX,
          marginTop: this._canvasCssOffsetY,
          styleWidth: this._canvasCssWidth,
          styleHeight: this._canvasCssHeight,
        });
        g = this.GetRenderer();
        g.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, !0);
        for (var q of this._availableAdditionalRenderTargets)
          g.DeleteRenderTarget(q);
        e.clearArray(this._availableAdditionalRenderTargets);
        g.CalculatePerspectiveMatrix(
          this._defaultProjectionMatrix,
          this.GetDrawWidth() / this.GetDrawHeight()
        );
        q = this._runtime.GetLayoutManager();
        q.SetAllLayerProjectionChanged();
        q.SetAllLayerMVChanged();
      }
    }
    GetDefaultProjectionMatrix() {
      return this._defaultProjectionMatrix;
    }
    _CalculateLetterboxScale(g, k) {
      const m = this._runtime.GetDevicePixelRatio(),
        q = this._runtime.GetOriginalViewportWidth(),
        v = this._runtime.GetOriginalViewportHeight(),
        r = q / v;
      g / k > r
        ? ((this._canvasCssWidth = Math.round(k * r)),
          (this._canvasCssHeight = k),
          (this._canvasCssOffsetX = Math.floor((g - this._canvasCssWidth) / 2)),
          (this._canvasCssOffsetY = 0))
        : ((this._canvasCssWidth = g),
          (this._canvasCssHeight = Math.round(g / r)),
          (this._canvasCssOffsetX = 0),
          (this._canvasCssOffsetY = Math.floor(
            (k - this._canvasCssHeight) / 2
          )));
      this._canvasDeviceWidth = Math.round(this._canvasCssWidth * m);
      this._canvasDeviceHeight = Math.round(this._canvasCssHeight * m);
      this._runtime.SetViewportSize(q, v);
    }
    _CalculateLetterboxIntegerScale(g, k) {
      const m = this._runtime.GetDevicePixelRatio();
      1 !== m && ((g += 1), (k += 1));
      const q = this._runtime.GetOriginalViewportWidth(),
        v = this._runtime.GetOriginalViewportHeight();
      var r = q / v;
      r = g / k > r ? (k * r * m) / q : ((g / r) * m) / v;
      1 < r ? (r = Math.floor(r)) : 1 > r && (r = 1 / Math.ceil(1 / r));
      this._canvasDeviceWidth = Math.round(q * r);
      this._canvasDeviceHeight = Math.round(v * r);
      this._canvasCssWidth = this._canvasDeviceWidth / m;
      this._canvasCssHeight = this._canvasDeviceHeight / m;
      this._canvasCssOffsetX = Math.max(
        Math.floor((g - this._canvasCssWidth) / 2),
        0
      );
      this._canvasCssOffsetY = Math.max(
        Math.floor((k - this._canvasCssHeight) / 2),
        0
      );
      this._runtime.SetViewportSize(q, v);
    }
    _CalculateFullsizeCanvas(g, k) {
      const m = this._runtime.GetDevicePixelRatio();
      this._canvasCssWidth = g;
      this._canvasCssHeight = k;
      this._canvasDeviceWidth = Math.round(this._canvasCssWidth * m);
      this._canvasDeviceHeight = Math.round(this._canvasCssHeight * m);
      this._canvasCssOffsetY = this._canvasCssOffsetX = 0;
      g = this.GetDisplayScale();
      this._runtime.SetViewportSize(
        this._canvasCssWidth / g,
        this._canvasCssHeight / g
      );
    }
    _CalculateFixedSizeCanvas(g, k) {
      const m = this._runtime.GetDevicePixelRatio();
      this._canvasCssWidth = this._runtime.GetViewportWidth();
      this._canvasCssHeight = this._runtime.GetViewportHeight();
      this._canvasDeviceWidth = Math.round(this._canvasCssWidth * m);
      this._canvasDeviceHeight = Math.round(this._canvasCssHeight * m);
      this.IsDocumentFullscreen()
        ? ((this._canvasCssOffsetX = Math.floor(
            (g - this._canvasCssWidth) / 2
          )),
          (this._canvasCssOffsetY = Math.floor(
            (k - this._canvasCssHeight) / 2
          )))
        : (this._canvasCssOffsetY = this._canvasCssOffsetX = 0);
      this._runtime.SetViewportSize(
        this._runtime.GetViewportWidth(),
        this._runtime.GetViewportHeight()
      );
    }
    _UpdateFullscreenScalingQuality(g) {
      if ("high" === this._wantFullscreenScalingQuality)
        (this._drawWidth = this._canvasDeviceWidth),
          (this._drawHeight = this._canvasDeviceHeight),
          (this._fullscreenScalingQuality = "high");
      else {
        let m;
        if ("off" === this.GetCurrentFullscreenMode()) {
          var k = this._runtime.GetViewportWidth();
          m = this._runtime.GetViewportHeight();
        } else
          (k = this._runtime.GetOriginalViewportWidth()),
            (m = this._runtime.GetOriginalViewportHeight());
        this._canvasDeviceWidth < k || this._canvasDeviceHeight < m
          ? ((this._drawWidth = this._canvasDeviceWidth),
            (this._drawHeight = this._canvasDeviceHeight),
            (this._fullscreenScalingQuality = "high"))
          : ((this._drawWidth = k),
            (this._drawHeight = m),
            (this._fullscreenScalingQuality = "low"),
            "scale-inner" === g
              ? ((g = k / m),
                (k = this._windowInnerWidth / this._windowInnerHeight),
                k < g
                  ? (this._drawWidth = this._drawHeight * k)
                  : k > g && (this._drawHeight = this._drawWidth / k))
              : "scale-outer" === g &&
                ((g = k / m),
                (k = this._windowInnerWidth / this._windowInnerHeight),
                k > g
                  ? (this._drawWidth = this._drawHeight * k)
                  : k < g && (this._drawHeight = this._drawWidth / k)));
      }
    }
    GetRuntime() {
      return this._runtime;
    }
    GetCanvas() {
      return this._canvas;
    }
    GetEffectChainManager() {
      return this._effectChainManager;
    }
    IsDocumentFullscreen() {
      return this._isDocumentFullscreen;
    }
    SetFullscreenMode(g) {
      if (!b.has(g)) throw Error("invalid fullscreen mode");
      this._fullscreenMode = g;
      g = this._runtime.GetLayoutManager();
      g.SetAllLayerProjectionChanged();
      g.SetAllLayerMVChanged();
    }
    GetFullscreenMode() {
      return this._fullscreenMode;
    }
    SetDocumentFullscreenMode(g) {
      if (!b.has(g)) throw Error("invalid fullscreen mode");
      this._documentFullscreenMode = g;
      g = this._runtime.GetLayoutManager();
      g.SetAllLayerProjectionChanged();
      g.SetAllLayerMVChanged();
    }
    GetDocumentFullscreenMode() {
      return this._documentFullscreenMode;
    }
    GetCurrentFullscreenMode() {
      return this.IsDocumentFullscreen()
        ? this.GetDocumentFullscreenMode()
        : this.GetFullscreenMode();
    }
    SetFullscreenScalingQuality(g) {
      if (!a.has(g)) throw Error("invalid fullscreen scaling quality");
      this._wantFullscreenScalingQuality = g;
      this._runtime.GetLayoutManager().SetAllLayerProjectionChanged();
    }
    GetSetFullscreenScalingQuality() {
      return this._wantFullscreenScalingQuality;
    }
    GetCurrentFullscreenScalingQuality() {
      return this._fullscreenScalingQuality;
    }
    static _FullscreenModeNumberToString(g) {
      switch (g) {
        case 0:
          return "off";
        case 1:
          return "crop";
        case 2:
          return "scale-inner";
        case 3:
          return "scale-outer";
        case 4:
          return "letterbox-scale";
        case 5:
          return "letterbox-integer-scale";
        default:
          throw Error("invalid fullscreen mode");
      }
    }
    GetLastWidth() {
      return this._windowInnerWidth;
    }
    GetLastHeight() {
      return this._windowInnerHeight;
    }
    GetDrawWidth() {
      return this._drawWidth;
    }
    GetDrawHeight() {
      return this._drawHeight;
    }
    SetMipmapsEnabled(g) {
      this._enableMipmaps = !!g;
    }
    _SetTextureAnisotropy(g) {
      this._textureAnisotropy = g;
    }
    GetTextureAnisotropy() {
      return this._textureAnisotropy;
    }
    IsRendererContextLost() {
      return this.GetRenderer().IsContextLost();
    }
    _OnWebGLContextLost(g) {
      console.log("[Construct 3] WebGL context lost");
      g.preventDefault();
      this._availableAdditionalRenderTargets = [];
      this._usedAdditionalRenderTargets.clear();
      this._webglRenderer.OnContextLost();
      this._runtime._OnWebGLContextLost();
    }
    async _OnWebGLContextRestored(g) {
      await this._webglRenderer.OnContextRestored();
      await this._LoadWebGLShaderPrograms();
      for (const k of this._runtime._GetAllEffectLists()) {
        for (const m of k.GetAllEffectTypes())
          m._InitRenderer(this._webglRenderer);
        k._InitRenderer(this._webglRenderer);
      }
      await this._runtime._OnWebGLContextRestored();
      console.log("[Construct 3] WebGL context restored");
    }
    GetWebGLRenderer() {
      return this._webglRenderer;
    }
    GetWebGPURenderer() {
      return this._webgpuRenderer;
    }
    GetRenderer() {
      return this._webgpuRenderer || this._webglRenderer;
    }
    GetRenderScale() {
      return "low" === this._fullscreenScalingQuality
        ? 1 / this._runtime.GetDevicePixelRatio()
        : this.GetDisplayScale();
    }
    GetDisplayScale() {
      const g = this.GetCurrentFullscreenMode();
      if ("off" === g || "crop" === g) return 1;
      const k = this._runtime.GetOriginalViewportWidth(),
        m = this._runtime.GetOriginalViewportHeight(),
        q = k / m,
        v = this._canvasDeviceWidth / this._canvasDeviceHeight;
      return ("scale-inner" !== g && v > q) || ("scale-inner" === g && v < q)
        ? this._canvasCssHeight / m
        : this._canvasCssWidth / k;
    }
    GetEffectLayerScaleParam() {
      return "low" === this.GetCurrentFullscreenScalingQuality()
        ? 1
        : this.GetDisplayScale();
    }
    GetEffectDevicePixelRatioParam() {
      return "low" === this.GetCurrentFullscreenScalingQuality()
        ? 1
        : this._runtime.GetDevicePixelRatio();
    }
    SetDeviceTransformOffset(g, k) {
      this._deviceTransformOffX = g;
      this._deviceTransformOffY = k;
    }
    SetDeviceTransform(g, k, m, q = !0) {
      k = k || this._drawWidth;
      m = m || this._drawHeight;
      const v = k / 2 + this._deviceTransformOffX,
        r = m / 2 + this._deviceTransformOffY;
      if (q) {
        q = this.GetDefaultProjectionMatrix();
        if (k !== this._drawWidth || m !== this._drawHeight)
          g.CalculatePerspectiveMatrix(d, k / m), (q = d);
        g.SetProjectionMatrix(q);
      }
      k = g.CalculateLookAtModelView2(v, r, g.GetDefaultCameraZ(m), v, r, 0, m);
      g.SetModelViewMatrix(k);
    }
    SetCssTransform(g, k = !0) {
      var m = this.GetCssWidth();
      const q = this.GetCssHeight();
      m /= 2;
      const v = q / 2;
      k && g.SetProjectionMatrix(this.GetDefaultProjectionMatrix());
      k = g.CalculateLookAtModelView2(m, v, g.GetDefaultCameraZ(q), m, v, 0, q);
      g.SetModelViewMatrix(k);
    }
    GetDeviceWidth() {
      return this._canvasDeviceWidth;
    }
    GetDeviceHeight() {
      return this._canvasDeviceHeight;
    }
    GetCssWidth() {
      return this._canvasCssWidth;
    }
    GetCssHeight() {
      return this._canvasCssHeight;
    }
    GetCanvasClientX() {
      return this._canvasCssOffsetX;
    }
    GetCanvasClientY() {
      return this._canvasCssOffsetY;
    }
    GetAdditionalRenderTarget(g) {
      g.depth = this._runtime.Uses3DFeatures();
      const k = this._availableAdditionalRenderTargets,
        m = k.findIndex((v) => v.IsCompatibleWithOptions(g));
      let q;
      -1 !== m
        ? ((q = k[m]), k.splice(m, 1))
        : (q = this.GetRenderer().CreateRenderTarget(g));
      this._usedAdditionalRenderTargets.add(q);
      return q;
    }
    ReleaseAdditionalRenderTarget(g) {
      if (!this._usedAdditionalRenderTargets.has(g))
        throw Error("render target not in use");
      this._usedAdditionalRenderTargets.delete(g);
      this._availableAdditionalRenderTargets.push(g);
    }
    GetEffectCompositorRenderTarget() {
      const g = { sampling: this._runtime.GetSampling() };
      "low" === this.GetCurrentFullscreenScalingQuality() &&
        ((g.width = this.GetDrawWidth()), (g.height = this.GetDrawHeight()));
      return this.GetAdditionalRenderTarget(g);
    }
    ReleaseEffectCompositorRenderTarget(g) {
      this.ReleaseAdditionalRenderTarget(g);
    }
    *activeLayersGpuProfiles() {
      for (const g of this._runtime.GetLayoutManager().runningLayouts())
        for (const k of g.GetLayers()) {
          const m = this._layersGpuProfile.get(k);
          m && (yield m);
        }
    }
    GetLayerTimingsBuffer(g) {
      if (!this.GetRenderer().SupportsGPUProfiling()) return null;
      let k = this._layersGpuProfile.get(g);
      k ||
        ((k = {
          name: g.GetName(),
          timingsBuffer: e.New(
            e.Gfx.WebGLQueryResultBuffer,
            this._webglRenderer
          ),
          curUtilisation: 0,
          lastUtilisation: 0,
        }),
        this._layersGpuProfile.set(g, k));
      return k.timingsBuffer;
    }
    _Update1sFrameRange() {
      const g = this.GetRenderer();
      if (g.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {
        this._gpuTimeEndFrame = g.GetFrameNumber();
        this._gpuCurUtilisation = NaN;
        for (const k of this.activeLayersGpuProfiles()) k.curUtilisation = NaN;
      }
    }
    _UpdateTick() {
      this._webglRenderer &&
        this._webglRenderer.SupportsGPUProfiling() &&
        this._UpdateTick_WebGL();
      this._webgpuRenderer &&
        this._webgpuRenderer.SupportsGPUProfiling() &&
        this._UpdateTick_WebGPU();
    }
    _UpdateTick_WebGL() {
      if (
        isNaN(this._gpuCurUtilisation) &&
        ((this._gpuCurUtilisation =
          this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(
            this._gpuTimeStartFrame,
            this._gpuTimeEndFrame
          )),
        !isNaN(this._gpuCurUtilisation))
      ) {
        if (this._runtime.IsDebug())
          for (const g of this.activeLayersGpuProfiles())
            if (
              ((g.curUtilisation = g.timingsBuffer.GetFrameRangeResultSum(
                this._gpuTimeStartFrame,
                this._gpuTimeEndFrame
              )),
              isNaN(g.curUtilisation))
            )
              return;
        this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(
          this._gpuTimeEndFrame
        );
        this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1);
        if (this._runtime.IsDebug()) {
          for (const g of this.activeLayersGpuProfiles())
            g.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame),
              (g.lastUtilisation = Math.min(g.curUtilisation, 1));
          self.C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, [
            ...this.activeLayersGpuProfiles(),
          ]);
        }
        this._gpuTimeStartFrame = this._gpuTimeEndFrame;
        this._gpuTimeEndFrame = 0;
      }
    }
    GetGPUFrameTimingsBuffer() {
      return this._gpuFrameTimingsBuffer;
    }
    _UpdateTick_WebGPU() {
      if (0 !== this._gpuTimeEndFrame) {
        for (var g = this._gpuTimeStartFrame; g < this._gpuTimeEndFrame; ++g) {
          var k = this._webgpuFrameTimings.get(g);
          if (k && !k.HasResult()) return;
        }
        k = this._runtime.GetMainRunningLayout();
        g = e.MakeFilledArray(k.GetLayerCount() + 1, 0);
        for (var m = this._gpuTimeStartFrame; m < this._gpuTimeEndFrame; ++m) {
          var q = this._webgpuFrameTimings.get(m);
          if (q) {
            q = q.GetResult();
            for (let v = 0, r = Math.min(g.length, q.length / 2); v < r; ++v) {
              const n = q[2 * v],
                p = q[2 * v + 1];
              g[v] =
                0 === Number(n) || 0 === Number(p)
                  ? NaN
                  : g[v] + Number(p - n) / 1e9;
            }
          }
        }
        this._gpuLastUtilisation = e.clamp(g[0], 0, 1);
        if (this._runtime.IsDebug()) {
          m = [];
          k = k.GetLayers();
          for (let v = 0, r = Math.min(k.length, g.length - 1); v < r; ++v)
            m.push({
              name: k[v].GetName(),
              lastUtilisation: e.clamp(g[v + 1], 0, 1),
            });
          self.C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, m);
        }
        for (g = this._gpuTimeStartFrame; g < this._gpuTimeEndFrame; ++g)
          this._webgpuFrameTimings.delete(g);
        this._gpuTimeStartFrame = this._gpuTimeEndFrame;
        this._gpuTimeEndFrame = 0;
      }
    }
    _AddWebGPUFrameTiming(g) {
      this._webgpuFrameTimings.set(this._webgpuRenderer.GetFrameNumber(), g);
    }
    GetGPUUtilisation() {
      return this._gpuLastUtilisation;
    }
    SnapshotCanvas(g, k, m, q, v, r) {
      this._snapshotFormat = g;
      this._snapshotQuality = k;
      this._snapshotArea.setWH(m, q, v, r);
      return this._snapshotPromise
        ? this._snapshotPromise
        : (this._snapshotPromise = new Promise((n) => {
            this._snapshotResolve = n;
          }));
    }
    _MaybeTakeSnapshot() {
      if (this._snapshotFormat) {
        var g = this._canvas,
          k = this._snapshotArea,
          m = e.clamp(Math.floor(k.getLeft()), 0, g.width),
          q = e.clamp(Math.floor(k.getTop()), 0, g.height),
          v = k.width();
        v = 0 === v ? g.width - m : e.clamp(Math.floor(v), 0, g.width - m);
        k = k.height();
        k = 0 === k ? g.height - q : e.clamp(Math.floor(k), 0, g.height - q);
        (0 !== m || 0 !== q || v !== g.width || k !== g.height) &&
          0 < v &&
          0 < k &&
          ((g = e.CreateCanvas(v, k)),
          g.getContext("2d").drawImage(this._canvas, m, q, v, k, 0, 0, v, k));
        e.CanvasToBlob(g, this._snapshotFormat, this._snapshotQuality).then(
          (r) => {
            this._snapshotUrl = URL.createObjectURL(r);
            this._snapshotPromise = null;
            this._snapshotResolve(this._snapshotUrl);
          }
        );
        this._snapshotFormat = "";
        this._snapshotQuality = 1;
      }
    }
    GetCanvasSnapshotUrl() {
      return this._snapshotUrl;
    }
    SetIsPastingToDrawingCanvas(g) {
      g ? this._isPastingToDrawingCanvas++ : this._isPastingToDrawingCanvas--;
    }
    IsPastingToDrawingCanvas() {
      return 0 < this._isPastingToDrawingCanvas;
    }
    InitLoadingScreen(g) {
      this._webglRenderer &&
        (2 === g
          ? ((this._percentText = e.New(
              e.Gfx.RendererText,
              this.GetRenderer()
            )),
            this._percentText.SetIsAsync(!1),
            this._percentText.SetFontName("Arial"),
            this._percentText.SetFontSize(16),
            this._percentText.SetHorizontalAlignment("center"),
            this._percentText.SetVerticalAlignment("center"),
            this._percentText.SetSize(300, 200))
          : 0 === g
          ? (g = this._runtime.GetLoadingLogoAsset()) &&
            g
              .LoadStaticTexture(this._webglRenderer)
              .catch((k) =>
                console.warn(
                  "[C3 runtime] Failed to create texture for loading logo: ",
                  k
                )
              )
          : 4 === g &&
            (this._LoadSvgSplashImage("splash-images/splash-logo.svg")
              .then((k) => {
                "done" === this._splashState
                  ? this._webglRenderer.DeleteTexture(k)
                  : (this._splashTextures.logo = k);
              })
              .catch((k) => console.warn("Failed to load splash image: ", k)),
            this._LoadBitmapSplashImage(
              "splash-images/splash-poweredby-512.png"
            )
              .then((k) => {
                "done" === this._splashState
                  ? this._webglRenderer.DeleteTexture(k)
                  : (this._splashTextures.powered = k);
              })
              .catch((k) => console.warn("Failed to load splash image: ", k)),
            this._LoadBitmapSplashImage("splash-images/splash-website-512.png")
              .then((k) => {
                "done" === this._splashState
                  ? this._webglRenderer.DeleteTexture(k)
                  : (this._splashTextures.website = k);
              })
              .catch((k) => console.warn("Failed to load splash image: ", k))));
    }
    async _LoadSvgSplashImage(g) {
      g = new URL(g, this._runtime.GetRuntimeBaseURL()).toString();
      g = await e.FetchBlob(g);
      g = await this._runtime.RasterSvgImage(g, 2048, 2048);
      return await this._webglRenderer.CreateStaticTextureAsync(g, {
        mipMapQuality: "high",
      });
    }
    async _LoadBitmapSplashImage(g) {
      g = new URL(g, this._runtime.GetRuntimeBaseURL()).toString();
      g = await e.FetchBlob(g);
      return await this._webglRenderer.CreateStaticTextureAsync(g, {
        mipMapQuality: "high",
      });
    }
    HideCordovaSplashScreen() {
      this._runtime.PostComponentMessageToDOM("runtime", "hide-cordova-splash");
    }
    StartLoadingScreen() {
      this._loaderStartTime = Date.now();
      this._runtime
        .Dispatcher()
        .addEventListener("loadingprogress", this._loadingprogress_handler);
      this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());
      3 !== this._runtime.GetLoaderStyle() && this.HideCordovaSplashScreen();
    }
    async EndLoadingScreen() {
      if (this._webglRenderer) {
        this._loadingProgress = 1;
        var g = this._runtime.GetLoaderStyle();
        4 === g && (await this._splashDonePromise);
        this._splashDonePromise = this._splashDoneResolve = null;
        -1 !== this._rafId &&
          (cancelAnimationFrame(this._rafId), (this._rafId = -1));
        this._runtime
          .Dispatcher()
          .removeEventListener(
            "loadingprogress",
            this._loadingprogress_handler
          );
        this._loadingprogress_handler = null;
        this._percentText &&
          (this._percentText.Release(), (this._percentText = null));
        this._runtime.ReleaseLoadingLogoAsset();
        this._webglRenderer.Start();
        this._splashTextures.logo &&
          (this._webglRenderer.DeleteTexture(this._splashTextures.logo),
          (this._splashTextures.logo = null));
        this._splashTextures.powered &&
          (this._webglRenderer.DeleteTexture(this._splashTextures.powered),
          (this._splashTextures.powered = null));
        this._splashTextures.website &&
          (this._webglRenderer.DeleteTexture(this._splashTextures.website),
          (this._splashTextures.website = null));
        this._webglRenderer.ClearRgba(0, 0, 0, 0);
        this._webglRenderer.Finish();
        this._splashState = "done";
        this._gpuTimeStartFrame = this._webglRenderer.GetFrameNumber();
        3 === g && this.HideCordovaSplashScreen();
      }
    }
    _DrawLoadingScreen() {
      if (-1 !== this._rafId) {
        var g = this._webglRenderer;
        if (g) {
          g.Start();
          this._rafId = -1;
          var k = this._runtime.GetAssetManager().HasHadErrorLoading(),
            m = this._runtime.GetLoaderStyle();
          3 !== m &&
            (this.SetCssTransform(g),
            g.ClearRgba(0, 0, 0, 0),
            g.ResetColor(),
            g.SetTextureFillMode(),
            g.SetTexture(null));
          if (0 === m) this._DrawProgressBarAndLogoLoadingScreen(k);
          else if (1 === m) this._DrawProgressBarLoadingScreen(k, 120, 0);
          else if (2 === m) this._DrawPercentTextLoadingScreen(k);
          else if (3 === m) e.noop();
          else if (4 === m) this._DrawSplashLoadingScreen(k);
          else throw Error("invalid loader style");
          g.Finish();
          this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());
        }
      }
    }
    _DrawPercentTextLoadingScreen(g) {
      g
        ? this._percentText.SetColorRgb(1, 0, 0)
        : this._percentText.SetColorRgb(0.6, 0.6, 0.6);
      this._percentText.SetText(Math.round(100 * this._loadingProgress) + "%");
      g = this._canvasCssWidth / 2;
      const k = this._canvasCssHeight / 2;
      f.setRect(g - 150, k - 100, g + 150, k + 100);
      this._webglRenderer.SetTexture(this._percentText.GetTexture());
      this._webglRenderer.Quad3(f, this._percentText.GetTexRect());
    }
    _DrawProgressBarLoadingScreen(g, k, m) {
      const q = this._webglRenderer;
      q.SetColorFillMode();
      g ? q.SetColorRgba(1, 0, 0, 1) : q.SetColorRgba(0.118, 0.565, 1, 1);
      g = this._canvasCssWidth / 2;
      const v = this._canvasCssHeight / 2,
        r = k / 2;
      h.setWH(g - r, v - 4 + m, Math.floor(k * this._loadingProgress), 8);
      q.Rect(h);
      h.setWH(g - r, v - 4 + m, k, 8);
      h.offset(-0.5, -0.5);
      h.inflate(0.5, 0.5);
      q.SetColorRgba(0, 0, 0, 1);
      q.LineRect2(h);
      h.inflate(1, 1);
      q.SetColorRgba(1, 1, 1, 1);
      q.LineRect2(h);
    }
    _DrawProgressBarAndLogoLoadingScreen(g) {
      var k = this._runtime.GetLoadingLogoAsset();
      if (k)
        if ((k = k.GetTexture())) {
          var m = k.GetWidth(),
            q = k.GetHeight(),
            v = this._canvasCssWidth / 2,
            r = this._canvasCssHeight / 2,
            n = m / 2;
          q /= 2;
          f.setRect(v - n, r - q, v + n, r + q);
          this._webglRenderer.SetTexture(k);
          this._webglRenderer.Quad(f);
          this._DrawProgressBarLoadingScreen(g, m, q + 16);
        } else this._DrawProgressBarLoadingScreen(g, 120, 0);
      else this._DrawProgressBarLoadingScreen(g, 120, 0);
    }
    _DrawSplashLoadingScreen(g) {
      const k = this._webglRenderer,
        m = this._splashTextures.logo,
        q = this._splashTextures.powered,
        v = this._splashTextures.website,
        r = Date.now();
      0 === this._splashFrameNumber && (this._loaderStartTime = r);
      const n =
          this._runtime.IsPreview() ||
          (this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova()),
        p = n ? 0 : 200,
        u = n ? 0 : 3e3;
      let w = 1;
      "fade-in" === this._splashState
        ? (w = Math.min((r - this._loaderStartTime) / 300, 1))
        : "fade-out" === this._splashState &&
          (w = Math.max(1 - (r - this._splashFadeOutStartTime) / 300, 0));
      k.SetColorFillMode();
      k.SetColorRgba(0.231 * w, 0.251 * w, 0.271 * w, w);
      h.set(0, 0, this._canvasCssWidth, this._canvasCssHeight);
      k.Rect(h);
      const y = Math.ceil(this._canvasCssWidth),
        B = Math.ceil(this._canvasCssHeight);
      let E;
      256 < this._canvasCssHeight
        ? (k.SetColorRgba(0.302 * w, 0.334 * w, 0.365 * w, w),
          (E = Math.max(0.005 * B, 2)),
          h.setWH(0, 0.8 * B - E / 2, y, E),
          k.Rect(h),
          g
            ? k.SetColorRgba(w, 0, 0, w)
            : k.SetColorRgba(0.161 * w, 0.953 * w, 0.816 * w, w),
          (g = y * this._loadingProgress),
          h.setWH(0.5 * y - g / 2, 0.8 * B - E / 2, g, E),
          k.Rect(h),
          k.SetColorRgba(w, w, w, w),
          k.SetTextureFillMode(),
          q &&
            ((g = 1.5 * e.clamp(0.22 * B, 105, 0.6 * y)),
            (E = g / 8),
            h.setWH(0.5 * y - g / 2, 0.2 * B - E / 2, g, E),
            k.SetTexture(q),
            k.Rect(h)),
          m &&
            ((E = g = Math.min(0.395 * B, 0.95 * y)),
            h.setWH(0.5 * y - g / 2, 0.485 * B - E / 2, g, E),
            k.SetTexture(m),
            k.Rect(h)),
          v &&
            ((g = 1.5 * e.clamp(0.22 * B, 105, 0.6 * y)),
            (E = g / 8),
            h.setWH(0.5 * y - g / 2, 0.868 * B - E / 2, g, E),
            k.SetTexture(v),
            k.Rect(h)))
        : (k.SetColorRgba(0.302 * w, 0.334 * w, 0.365 * w, w),
          (E = Math.max(0.005 * B, 2)),
          h.setWH(0, 0.85 * B - E / 2, y, E),
          k.Rect(h),
          g
            ? k.SetColorRgba(w, 0, 0, w)
            : k.SetColorRgba(0.161 * w, 0.953 * w, 0.816 * w, w),
          (g = y * this._loadingProgress),
          h.setWH(0.5 * y - g / 2, 0.85 * B - E / 2, g, E),
          k.Rect(h),
          k.SetColorRgba(w, w, w, w),
          k.SetTextureFillMode(),
          m &&
            ((E = g = 0.55 * B),
            h.setWH(0.5 * y - g / 2, 0.45 * B - E / 2, g, E),
            k.SetTexture(m),
            k.Rect(h)));
      this._splashFrameNumber++;
      "fade-in" === this._splashState &&
        300 <= r - this._loaderStartTime &&
        2 <= this._splashFrameNumber &&
        ((this._splashState = "wait"), (this._splashFadeInFinishTime = r));
      "wait" === this._splashState &&
        r - this._splashFadeInFinishTime >= u &&
        1 <= this._loadingProgress &&
        ((this._splashState = "fade-out"), (this._splashFadeOutStartTime = r));
      (("fade-out" === this._splashState &&
        r - this._splashFadeOutStartTime >= 300 + p) ||
        (n && 1 <= this._loadingProgress && 500 > r - this._loaderStartTime)) &&
        this._splashDoneResolve();
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = self.C3Debugger,
    a = {
      messagePort: null,
      runtimeBaseUrl: "",
      headless: !1,
      hasDom: !0,
      isInWorker: !1,
      useAudio: !0,
      projectData: "",
      exportType: "",
    };
  let c = !0;
  e.Runtime = class extends e.DefendedBase {
    constructor(d) {
      d = Object.assign({}, a, d);
      super();
      this._messagePort = d.messagePort;
      this._runtimeBaseUrl = d.runtimeBaseUrl;
      this._previewUrl = d.previewUrl;
      this._isHeadless = !!d.headless;
      this._hasDom = !!d.hasDom;
      this._isInWorker = !!d.isInWorker;
      c = d.ife;
      this._useAudio = !!d.useAudio;
      this._exportType = d.exportType;
      this._isiOSCordova = !!d.isiOSCordova;
      this._isiOSWebView = !!d.isiOSWebView;
      this._isFBInstantAvailable = !!d.isFBInstantAvailable;
      this._opusWasmScriptUrl = d.opusWasmScriptUrl;
      this._opusWasmBinaryUrl = d.opusWasmBinaryUrl;
      this._isDebugging =
        this._breakpointsEnabled =
        this._isDebug =
          !("preview" !== this._exportType || !d.isDebug);
      this._debuggingDisabled = 0;
      this._additionalLoadPromises = [];
      this._additionalCreatePromises = [];
      this._isUsingCreatePromises = !1;
      this._appId =
        this._projectUniqueId =
        this._projectVersion =
        this._projectName =
          "";
      this._originalViewportHeight = this._originalViewportWidth = 0;
      this._devicePixelRatio = self.devicePixelRatio;
      this._loaderStyle =
        this._viewportHeight =
        this._viewportWidth =
        this._parallaxYorigin =
        this._parallaxXorigin =
          0;
      this._usesLoaderLayout = !1;
      this._isLoading = !0;
      this._usesAnyDepthSampling =
        this._usesAnyCrossSampling =
        this._usesAnyBackgroundBlending =
          !1;
      this._loadingLogoAsset = null;
      this._assetManager = e.New(e.AssetManager, this, d);
      this._layoutManager = e.New(e.LayoutManager, this);
      this._eventSheetManager = e.New(e.EventSheetManager, this);
      this._pluginManager = e.New(e.PluginManager, this);
      this._collisionEngine = e.New(e.CollisionEngine, this);
      this._timelineManager = e.New(e.TimelineManager, this);
      this._transitionManager = e.New(e.TransitionManager, this);
      this._templateManager = e.New(e.TemplateManager, this);
      this._allObjectClasses = [];
      this._objectClassesByName = new Map();
      this._objectClassesBySid = new Map();
      this._familyCount = 0;
      this._allContainers = [];
      this._allEffectLists = [];
      this._currentLayoutStack = [];
      this._instancesPendingCreate = [];
      this._instancesPendingDestroy = new Map();
      this._isFlushingPendingInstances = this._hasPendingInstances = !1;
      this._nextUid = this._objectCount = 0;
      this._instancesByUid = new Map();
      this._instancesToReleaseAtEndOfTick = new Set();
      this._instancesToReleaseAffectedObjectClasses = new Set();
      this._objectReferenceTable = [];
      this._jsPropNameTable = [];
      this._canvasManager = null;
      this._uses3dFeatures = !1;
      this._framerateMode = "vsync";
      this._compositingMode = "standard";
      this._sampling = "trilinear";
      this._isPixelRoundingEnabled = !1;
      this._needRender = !0;
      this._isPausedOnBlur = this._pauseOnBlur = !1;
      this._exportToVideo = null;
      this._tickCallbacks = {
        normal: (f) => {
          this._ruafId = this._rafId = -1;
          this.Tick(f);
        },
        tickOnly: (f) => {
          this._ruafId = -1;
          this.Tick(f, !1, "skip-render");
        },
        renderOnly: () => {
          this._rafId = -1;
          this.Render();
        },
      };
      this._ruafId = this._rafId = -1;
      this._tickCountNoSave = this._tickCount = 0;
      this._hasStartedTicking = this._isInTick = this._hasStarted = !1;
      this._isLayoutFirstTick = !0;
      this._suspendCount = 0;
      this._scheduleTriggersThrottle = new e.PromiseThrottle(1);
      this._randomNumberCallback = () => Math.random();
      this._dt = this._dt1 = this._lastTickTime = this._startTime = 0;
      this._timeScale = 1;
      this._minimumFramerate = 30;
      this._gameTime = e.New(e.KahanSum);
      this._gameTimeRaw = e.New(e.KahanSum);
      this._wallTime = e.New(e.KahanSum);
      this._instanceTimes = new Map();
      this._fpsFrameCount = -1;
      this._mainThreadTime =
        this._mainThreadTimeCounter =
        this._fps =
        this._fpsLastTime =
          0;
      this._isLoadingState = !1;
      this._loadFromSlotName = this._saveToSlotName = "";
      this._loadFromJson = null;
      this._lastSaveJson = "";
      this._savegamesStorage = this._projectStorage = null;
      this._dispatcher = e.New(e.Event.Dispatcher);
      this._domEventHandlers = new Map();
      this._pendingResponsePromises = new Map();
      this._nextDomResponseId = 0;
      this._isReadyToHandleEvents =
        this._didRequestDeviceMotionEvent =
        this._didRequestDeviceOrientationEvent =
          !1;
      this._waitingToHandleEvents = [];
      this._eventObjects = {
        pretick: e.New(e.Event, "pretick", !1),
        tick: e.New(e.Event, "tick", !1),
        tick2: e.New(e.Event, "tick2", !1),
        instancedestroy: e.New(e.Event, "instancedestroy", !1),
        beforelayoutchange: e.New(e.Event, "beforelayoutchange", !1),
        layoutchange: e.New(e.Event, "layoutchange", !1),
      };
      this._eventObjects.instancedestroy.instance = null;
      this._userScriptDispatcher = e.New(e.Event.Dispatcher);
      this._userScriptEventObjects = null;
      this._behInstsToTick = e.New(
        e.RedBlackSet,
        e.BehaviorInstance.SortByTickSequence
      );
      this._behInstsToPostTick = e.New(
        e.RedBlackSet,
        e.BehaviorInstance.SortByTickSequence
      );
      this._behInstsToTick2 = e.New(
        e.RedBlackSet,
        e.BehaviorInstance.SortByTickSequence
      );
      this._jobScheduler = e.New(e.JobSchedulerRuntime, this, d.jobScheduler);
      d.canvas && (this._canvasManager = e.New(e.CanvasManager, this));
      this._messagePort.onmessage = (f) => this._OnMessageFromDOM(f.data);
      this.AddDOMComponentMessageHandler("runtime", "visibilitychange", (f) =>
        this._OnVisibilityChange(f)
      );
      this.AddDOMComponentMessageHandler("runtime", "opus-decode", (f) =>
        this._WasmDecodeWebMOpus(f.arrayBuffer)
      );
      this.AddDOMComponentMessageHandler(
        "runtime",
        "get-remote-preview-status-info",
        () => this._GetRemotePreviewStatusInfo()
      );
      this.AddDOMComponentMessageHandler("runtime", "js-invoke-function", (f) =>
        this._InvokeFunctionFromJS(f)
      );
      this.AddDOMComponentMessageHandler(
        "runtime",
        "go-to-last-error-script",
        self.goToLastErrorScript
      );
      this.AddDOMComponentMessageHandler(
        "runtime",
        "offline-audio-render-completed",
        (f) => this._OnOfflineAudioRenderCompleted(f)
      );
      this._dispatcher.addEventListener("window-blur", (f) =>
        this._OnWindowBlur(f)
      );
      this._dispatcher.addEventListener("window-focus", () =>
        this._OnWindowFocus()
      );
      this._timelineManager.AddRuntimeListeners();
      this._iRuntime = null;
      this._interfaceMap = new WeakMap();
      this._commonScriptInterfaces = {
        keyboard: null,
        mouse: null,
        touch: null,
      };
    }
    static Create(d) {
      return e.New(e.Runtime, d);
    }
    Release() {
      e.clearArray(this._allObjectClasses);
      this._objectClassesByName.clear();
      this._objectClassesBySid.clear();
      this._layoutManager.Release();
      this._layoutManager = null;
      this._eventSheetManager.Release();
      this._eventSheetManager = null;
      this._pluginManager.Release();
      this._pluginManager = null;
      this._assetManager.Release();
      this._assetManager = null;
      this._collisionEngine.Release();
      this._collisionEngine = null;
      this._timelineManager.Release();
      this._timelineManager = null;
      this._transitionManager.Release();
      this._transitionManager = null;
      this._templateManager.Release();
      this._templateManager = null;
      this._canvasManager &&
        (this._canvasManager.Release(), (this._canvasManager = null));
      this._dispatcher.Release();
      this._tickEvent = this._dispatcher = null;
    }
    ["_OnMessageFromDOM"](d) {
      const f = d.type;
      if ("event" === f) this._OnEventFromDOM(d);
      else if ("result" === f) this._OnResultFromDOM(d);
      else throw Error(`unknown message '${f}'`);
    }
    _OnEventFromDOM(d) {
      if (this._isReadyToHandleEvents) {
        var f = d.component,
          h = d.handler,
          g = d.data,
          k = d.dispatchOpts,
          m = !(!k || !k.dispatchRuntimeEvent);
        k = !(!k || !k.dispatchUserScriptEvent);
        var q = d.responseId;
        if (
          "runtime" === f &&
          (m &&
            ((d = new e.Event(h)),
            (d.data = g),
            this._dispatcher.dispatchEventAndWaitAsyncSequential(d)),
          k)
        ) {
          d = new e.Event(h, !0);
          for (const [v, r] of Object.entries(g)) d[v] = r;
          this.DispatchUserScriptEvent(d);
        }
        if ((d = this._domEventHandlers.get(f)))
          if ((d = d.get(h))) {
            m = null;
            try {
              m = d(g);
            } catch (v) {
              console.error(`Exception in '${f}' handler '${h}':`, v);
              null !== q && this._PostResultToDOM(q, !1, "" + v);
              return;
            }
            null !== q &&
              (m && m.then
                ? m
                    .then((v) => this._PostResultToDOM(q, !0, v))
                    .catch((v) => {
                      console.error(`Rejection from '${f}' handler '${h}':`, v);
                      this._PostResultToDOM(q, !1, "" + v);
                    })
                : this._PostResultToDOM(q, !0, m));
          } else
            m ||
              k ||
              console.warn(
                `[Runtime] No DOM handler '${h}' for component '${f}'`
              );
        else
          m ||
            k ||
            console.warn(
              `[Runtime] No DOM event handlers for component '${f}'`
            );
      } else this._waitingToHandleEvents.push(d);
    }
    _PostResultToDOM(d, f, h) {
      this._messagePort.postMessage({
        type: "result",
        responseId: d,
        isOk: f,
        result: h,
      });
    }
    _OnResultFromDOM(d) {
      const f = d.responseId,
        h = d.isOk;
      d = d.result;
      const g = this._pendingResponsePromises.get(f);
      h ? g.resolve(d) : g.reject(d);
      this._pendingResponsePromises.delete(f);
    }
    AddDOMComponentMessageHandler(d, f, h) {
      let g = this._domEventHandlers.get(d);
      g || ((g = new Map()), this._domEventHandlers.set(d, g));
      if (g.has(f))
        throw Error(`[Runtime] Component '${d}' already has handler '${f}'`);
      g.set(f, h);
    }
    PostComponentMessageToDOM(d, f, h) {
      this._messagePort.postMessage({
        type: "event",
        component: d,
        handler: f,
        data: h,
        responseId: null,
      });
    }
    PostComponentMessageToDOMAsync(d, f, h) {
      const g = this._nextDomResponseId++,
        k = new Promise((m, q) => {
          this._pendingResponsePromises.set(g, { resolve: m, reject: q });
        });
      this._messagePort.postMessage({
        type: "event",
        component: d,
        handler: f,
        data: h,
        responseId: g,
      });
      return k;
    }
    PostToDebugger(d) {
      if (!this.IsDebug()) throw Error("not in debug mode");
      this.PostComponentMessageToDOM("runtime", "post-to-debugger", d);
    }
    async Init(d) {
      this.IsDebug()
        ? await b.Init(this)
        : self.C3Debugger && self.C3Debugger.InitPreview(this);
      var [f] = await Promise.all([
        this._assetManager.FetchJson("data.json"),
        this._MaybeLoadOpusDecoder(),
        this._jobScheduler.Init(),
      ]);
      await this._LoadDataJson(f);
      await this._InitialiseCanvas(d);
      this.IsPreview() ||
        console.info(
          "Made with Construct 3, the game and app creator :: https://www.construct.net"
        );
      this.GetWebGLRenderer()
        ? ((f = this.GetWebGLRenderer()),
          console.info(
            `[C3 runtime] Hosted in ${
              this.IsInWorker() ? "worker" : "DOM"
            }, rendering with WebGL ${f.GetWebGLVersionNumber()} [${f.GetUnmaskedRenderer()}] (${
              f.IsDesynchronized() ? "desynchronized" : "standard"
            } compositing)`
          ))
        : this.GetWebGPURenderer() &&
          console.info(
            `[C3 runtime] Hosted in ${
              this.IsInWorker() ? "worker" : "DOM"
            }, rendering with experimental WebGPU`
          );
      this.GetRenderer().HasMajorPerformanceCaveat() &&
        console.warn(
          "[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance."
        );
      this._isReadyToHandleEvents = !0;
      for (const h of this._waitingToHandleEvents) this._OnEventFromDOM(h);
      e.clearArray(this._waitingToHandleEvents);
      this._canvasManager && this._canvasManager.StartLoadingScreen();
      for (const h of d.runOnStartupFunctions)
        this._additionalLoadPromises.push(this._RunOnStartupFunction(h));
      await Promise.all([
        this._assetManager.WaitForAllToLoad(),
        ...this._additionalLoadPromises,
      ]);
      e.clearArray(this._additionalLoadPromises);
      if (this._assetManager.HasHadErrorLoading())
        this._canvasManager && this._canvasManager.HideCordovaSplashScreen();
      else
        return (
          this._canvasManager && (await this._canvasManager.EndLoadingScreen()),
          await this._dispatcher.dispatchEventAndWaitAsync(
            new e.Event("beforeruntimestart")
          ),
          await this.Start(),
          this._messagePort.postMessage({ type: "runtime-ready" }),
          this
        );
    }
    async _RunOnStartupFunction(d) {
      try {
        await d(this._iRuntime);
      } catch (f) {
        console.error("[C3 runtime] Error in runOnStartup function: ", f);
      }
    }
    async _LoadDataJson(d) {
      d = d.project;
      this._projectName = d[0];
      this._projectVersion = d[16];
      this._projectUniqueId = d[31];
      this._appId = d[38];
      var f = d[39] || "loading-logo.png";
      this._isPixelRoundingEnabled = !!d[9];
      this._originalViewportWidth = this._viewportWidth = d[10];
      this._originalViewportHeight = this._viewportHeight = d[11];
      this._parallaxXorigin = this._originalViewportWidth / 2;
      this._parallaxYorigin = this._originalViewportHeight / 2;
      this._compositingMode = d[36];
      this._framerateMode = d[37];
      "low-latency" === this._compositingMode &&
        this.IsAndroidWebView() &&
        77 >= e.Platform.BrowserVersionNumber &&
        (console.warn(
          "[C3 runtime] Desynchronized (low-latency) compositing is enabled, but is disabled in the Android WebView <=77 due to crbug.com/1008842. Reverting to synchronized (standard) compositing."
        ),
        (this._compositingMode = "standard"));
      this._uses3dFeatures = !!d[40];
      this._sampling = d[14];
      this._usesAnyBackgroundBlending = d[15];
      this._usesAnyCrossSampling = d[42];
      this._usesAnyDepthSampling = d[17];
      this._usesLoaderLayout = !!d[18];
      this._loaderStyle = d[19];
      this._nextUid = d[21];
      this._pauseOnBlur = d[22];
      const h = this._assetManager;
      h._SetAudioFiles(d[7], d[25]);
      h._SetMediaSubfolder(d[8]);
      h._SetFontsSubfolder(d[32]);
      h._SetIconsSubfolder(d[28]);
      h._SetWebFonts(d[29]);
      if (0 === this._loaderStyle) {
        let v = "";
        this.IsPreview()
          ? h._HasLocalUrlBlob(f) && (v = h.GetLocalUrlAsBlobUrl(f))
          : (v = h.GetIconsSubfolder() + f);
        v && (this._loadingLogoAsset = h.LoadImage({ url: v }));
      }
      this._canvasManager &&
        (this._canvasManager.SetFullscreenMode(
          e.CanvasManager._FullscreenModeNumberToString(d[12])
        ),
        this._canvasManager.SetFullscreenScalingQuality(d[23] ? "high" : "low"),
        this._canvasManager.SetMipmapsEnabled(0 !== d[24]),
        this._canvasManager._SetGPUPowerPreference(d[34]),
        this._canvasManager._SetTextureAnisotropy(d[41]),
        this._canvasManager._SetWebGPUEnabled(d[13]),
        this._canvasManager._SetZAxisScale(d[30]),
        this._canvasManager._SetFieldOfView(d[26]));
      (f = d[43]) && (await this._LoadExportToVideoData(f));
      this._pluginManager.CreateSystemPlugin();
      this._objectReferenceTable = self.C3_GetObjectRefTable();
      for (var g of d[2]) this._pluginManager.CreatePlugin(g);
      this._objectReferenceTable = self.C3_GetObjectRefTable();
      this._LoadJsPropNameTable();
      for (var k of d[3])
        (g = e.ObjectClass.Create(this, this._allObjectClasses.length, k)),
          this._allObjectClasses.push(g),
          this._objectClassesByName.set(g.GetName().toLowerCase(), g),
          this._objectClassesBySid.set(g.GetSID(), g);
      for (const v of d[4]) this._allObjectClasses[v[0]]._LoadFamily(v);
      for (var m of d[27])
        (k = m.map((v) => this._allObjectClasses[v])),
          this._allContainers.push(e.New(e.Container, this, k));
      for (const v of this._allObjectClasses) v._OnAfterCreate();
      for (const v of d[5]) this._layoutManager.Create(v);
      (m = d[1]) &&
        (m = this._layoutManager.GetLayoutByName(m)) &&
        this._layoutManager.SetFirstLayout(m);
      for (var q of d[33]) this._timelineManager.Create(q);
      for (const v of d[35]) this._transitionManager.Create(v);
      for (const v of d[44]) this._templateManager.Create(v);
      this._templateManager.HasTemplates() ||
        (this._templateManager.Release(), (this._templateManager = null));
      this._InitScriptInterfaces();
      for (const v of d[6]) this._eventSheetManager.Create(v);
      this._eventSheetManager._PostInit();
      this._InitGlobalVariableScriptInterface();
      e.clearArray(this._objectReferenceTable);
      this.FlushPendingInstances();
      q = "any";
      d = d[20];
      1 === d ? (q = "portrait") : 2 === d && (q = "landscape");
      this.PostComponentMessageToDOM("runtime", "set-target-orientation", {
        targetOrientation: q,
      });
    }
    async _LoadExportToVideoData(d) {
      this._exportToVideo = new self.C3ExportToVideo(this, d);
      this._framerateMode = "unlimited-frame";
      this._canvasManager.SetFullscreenMode("off");
      this._devicePixelRatio = 1;
      self.devicePixelRatio = 1;
      await this.PostComponentMessageToDOMAsync(
        "runtime",
        "set-exporting-to-video",
        {
          message: this._exportToVideo.GetExportingMessageForPercent(0),
          duration: this._exportToVideo.GetDuration(),
        }
      );
    }
    GetLoaderStyle() {
      return this._loaderStyle;
    }
    IsExportToVideo() {
      return null !== this._exportToVideo;
    }
    GetExportVideoDuration() {
      return this._exportToVideo.GetDuration();
    }
    GetExportVideoFramerate() {
      return this._exportToVideo.GetFramerate();
    }
    _InitExportToVideo() {
      return this._exportToVideo.Init({
        width: this._canvasManager.GetDeviceWidth(),
        height: this._canvasManager.GetDeviceHeight(),
      });
    }
    _ExportToVideoAddFrame() {
      const d = this._tickCount / this.GetExportVideoFramerate();
      return this._exportToVideo.AddFrame(this._canvasManager.GetCanvas(), d);
    }
    _OnOfflineAudioRenderCompleted(d) {
      this._exportToVideo.OnOfflineAudioRenderCompleted(d);
    }
    _ExportToVideoFinish() {
      return this._exportToVideo.Finish();
    }
    IsFBInstantAvailable() {
      return this._isFBInstantAvailable;
    }
    IsLoading() {
      return this._isLoading;
    }
    AddLoadPromise(d) {
      this._additionalLoadPromises.push(d);
    }
    SetUsingCreatePromises(d) {
      this._isUsingCreatePromises = !!d;
    }
    AddCreatePromise(d) {
      this._isUsingCreatePromises && this._additionalCreatePromises.push(d);
    }
    GetCreatePromises() {
      return this._additionalCreatePromises;
    }
    _GetNextFamilyIndex() {
      return this._familyCount++;
    }
    GetFamilyCount() {
      return this._familyCount;
    }
    _AddEffectList(d) {
      this._allEffectLists.push(d);
    }
    _GetAllEffectLists() {
      return this._allEffectLists;
    }
    async _InitialiseCanvas(d) {
      this._canvasManager &&
        (await this._canvasManager.CreateCanvas(d),
        this._canvasManager.InitLoadingScreen(this._loaderStyle));
    }
    async _MaybeLoadOpusDecoder() {
      if (
        !this._assetManager.IsAudioFormatSupported("audio/webm; codecs=opus")
      ) {
        var d = null;
        try {
          d =
            this.IsiOSCordova() && this._assetManager.IsFileProtocol()
              ? await this._assetManager.CordovaFetchLocalFileAsArrayBuffer(
                  this._opusWasmBinaryUrl
                )
              : await this._assetManager.FetchArrayBuffer(
                  this._opusWasmBinaryUrl
                );
        } catch (f) {
          console.info(
            "Failed to fetch Opus decoder WASM; assuming project has no Opus audio.",
            f
          );
          return;
        }
        d
          ? this.AddJobWorkerBuffer(d, "opus-decoder-wasm")
          : this.AddJobWorkerBlob(null, "opus-decoder-wasm");
        await this.AddJobWorkerScripts([this._opusWasmScriptUrl]);
      }
    }
    async _WasmDecodeWebMOpus(d) {
      return await this.AddJob("OpusDecode", { arrayBuffer: d }, [d]);
    }
    async Start() {
      this._hasStarted = !0;
      this._startTime = Date.now();
      if (this._usesLoaderLayout) {
        for (var d of this._allObjectClasses)
          d.IsFamily() ||
            d.IsOnLoaderLayout() ||
            !d.IsWorldType() ||
            d.OnCreate();
        this._assetManager.WaitForAllToLoad().then(() => {
          this._isLoading = !1;
          this._OnLoadFinished();
        });
      } else this._isLoading = !1;
      this._assetManager.SetInitialLoadFinished();
      this.IsDebug() && b.RuntimeInit(c);
      for (const f of this._layoutManager.GetAllLayouts())
        f._CreateGlobalNonWorlds();
      this.IsExportToVideo() && (await this._InitExportToVideo());
      d = this._layoutManager.GetFirstLayout();
      await d._Load(null, this.GetRenderer());
      await d._StartRunning(!0);
      this._fpsLastTime = performance.now();
      this._usesLoaderLayout || this._OnLoadFinished();
      (
        await this.PostComponentMessageToDOMAsync(
          "runtime",
          "before-start-ticking"
        )
      ).isSuspended && !this.IsExportToVideo()
        ? this._suspendCount++
        : this.Tick();
    }
    _OnLoadFinished() {
      this.Trigger(e.Plugins.System.Cnds.OnLoadFinished, null, null);
      this.PostComponentMessageToDOM("runtime", "register-sw");
    }
    GetObjectReference(d) {
      d = Math.floor(d);
      const f = this._objectReferenceTable;
      if (0 > d || d >= f.length) throw Error("invalid object reference");
      return f[d];
    }
    _LoadJsPropNameTable() {
      for (const d of self.C3_JsPropNameTable) {
        const f = e.first(Object.keys(d));
        this._jsPropNameTable.push(f);
      }
    }
    GetJsPropName(d) {
      d = Math.floor(d);
      const f = this._jsPropNameTable;
      if (0 > d || d >= f.length) throw Error("invalid prop reference");
      return f[d];
    }
    HasDOM() {
      return this._hasDom;
    }
    IsHeadless() {
      return this._isHeadless;
    }
    IsInWorker() {
      return this._isInWorker;
    }
    GetRuntimeBaseURL() {
      return this._runtimeBaseUrl;
    }
    GetPreviewURL() {
      return this._previewUrl;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetEventStack() {
      return this._eventSheetManager.GetEventStack();
    }
    GetCurrentEventStackFrame() {
      return this._eventSheetManager.GetCurrentEventStackFrame();
    }
    GetCurrentEvent() {
      return this._eventSheetManager.GetCurrentEvent();
    }
    GetCurrentCondition() {
      return this._eventSheetManager.GetCurrentCondition();
    }
    IsCurrentConditionFirst() {
      return 0 === this.GetCurrentEventStackFrame().GetConditionIndex();
    }
    GetCurrentAction() {
      return this._eventSheetManager.GetCurrentAction();
    }
    GetPluginManager() {
      return this._pluginManager;
    }
    GetSystemPlugin() {
      return this._pluginManager.GetSystemPlugin();
    }
    GetObjectClassByIndex(d) {
      d = Math.floor(d);
      if (0 > d || d >= this._allObjectClasses.length)
        throw new RangeError("invalid index");
      return this._allObjectClasses[d];
    }
    GetObjectClassByName(d) {
      return this._objectClassesByName.get(d.toLowerCase()) || null;
    }
    GetObjectClassBySID(d) {
      return this._objectClassesBySid.get(d) || null;
    }
    GetSingleGlobalObjectClassByCtor(d) {
      return (d = this._pluginManager.GetPluginByConstructorFunction(d))
        ? d.GetSingleGlobalObjectClass()
        : null;
    }
    GetAllObjectClasses() {
      return this._allObjectClasses;
    }
    *allInstances() {
      for (const d of this._allObjectClasses)
        d.IsFamily() || (yield* d.instances());
    }
    Dispatcher() {
      return this._dispatcher;
    }
    UserScriptDispatcher() {
      return this._userScriptDispatcher;
    }
    DispatchUserScriptEvent(d) {
      d.runtime = this.GetIRuntime();
      const f = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();
      f && b.StartMeasuringScriptTime();
      this._userScriptDispatcher.dispatchEvent(d);
      f && b.AddScriptTime();
    }
    DispatchUserScriptEventAsyncWait(d) {
      d.runtime = this.GetIRuntime();
      return this._userScriptDispatcher.dispatchEventAndWaitAsync(d);
    }
    GetOriginalViewportWidth() {
      return this._originalViewportWidth;
    }
    GetOriginalViewportHeight() {
      return this._originalViewportHeight;
    }
    SetOriginalViewportSize(d, f) {
      if (
        this._originalViewportWidth !== d ||
        this._originalViewportHeight !== f
      )
        (this._originalViewportWidth = d),
          (this._originalViewportHeight = f),
          (d = this.GetLayoutManager()),
          d.SetAllLayerProjectionChanged(),
          d.SetAllLayerMVChanged();
    }
    GetViewportWidth() {
      return this._viewportWidth;
    }
    GetViewportHeight() {
      return this._viewportHeight;
    }
    SetViewportSize(d, f) {
      if (this._viewportWidth !== d || this._viewportHeight !== f)
        (this._viewportWidth = d),
          (this._viewportHeight = f),
          (d = this.GetLayoutManager()),
          d.SetAllLayerProjectionChanged(),
          d.SetAllLayerMVChanged();
    }
    _SetDevicePixelRatio(d) {
      this.IsExportToVideo() || (this._devicePixelRatio = d);
    }
    GetDevicePixelRatio() {
      return this._devicePixelRatio;
    }
    GetParallaxXOrigin() {
      return this._parallaxXorigin;
    }
    GetParallaxYOrigin() {
      return this._parallaxYorigin;
    }
    GetCanvasManager() {
      return this._canvasManager;
    }
    GetDrawWidth() {
      return this._canvasManager
        ? this._canvasManager.GetDrawWidth()
        : this._viewportWidth;
    }
    GetDrawHeight() {
      return this._canvasManager
        ? this._canvasManager.GetDrawHeight()
        : this._viewportHeight;
    }
    GetRenderScale() {
      return this._canvasManager ? this._canvasManager.GetRenderScale() : 1;
    }
    GetDisplayScale() {
      return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1;
    }
    GetEffectLayerScaleParam() {
      return this._canvasManager
        ? this._canvasManager.GetEffectLayerScaleParam()
        : 1;
    }
    GetEffectDevicePixelRatioParam() {
      return this._canvasManager
        ? this._canvasManager.GetEffectDevicePixelRatioParam()
        : 1;
    }
    GetCanvasClientX() {
      return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0;
    }
    GetCanvasClientY() {
      return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0;
    }
    GetCanvasCssWidth() {
      return this._canvasManager ? this._canvasManager.GetCssWidth() : 0;
    }
    GetCanvasCssHeight() {
      return this._canvasManager ? this._canvasManager.GetCssHeight() : 0;
    }
    GetFullscreenMode() {
      return this._canvasManager
        ? this._canvasManager.GetFullscreenMode()
        : "off";
    }
    GetAdditionalRenderTarget(d) {
      return this._canvasManager
        ? this._canvasManager.GetAdditionalRenderTarget(d)
        : null;
    }
    ReleaseAdditionalRenderTarget(d) {
      this._canvasManager &&
        this._canvasManager.ReleaseAdditionalRenderTarget(d);
    }
    UsesAnyBackgroundBlending() {
      return this._usesAnyBackgroundBlending;
    }
    UsesAnyCrossSampling() {
      return this._usesAnyCrossSampling;
    }
    UsesAnyDepthSampling() {
      return this._usesAnyDepthSampling;
    }
    GetGPUUtilisation() {
      return this._canvasManager
        ? this._canvasManager.GetGPUUtilisation()
        : NaN;
    }
    IsLinearSampling() {
      return "nearest" !== this.GetSampling();
    }
    GetFramerateMode() {
      return this._framerateMode;
    }
    GetCompositingMode() {
      return this._compositingMode;
    }
    GetSampling() {
      return this._sampling;
    }
    UsesLoaderLayout() {
      return this._usesLoaderLayout;
    }
    GetLoadingLogoAsset() {
      return this._loadingLogoAsset;
    }
    ReleaseLoadingLogoAsset() {
      this._loadingLogoAsset &&
        (this._loadingLogoAsset.Release(), (this._loadingLogoAsset = null));
    }
    GetLayoutManager() {
      return this._layoutManager;
    }
    GetMainRunningLayout() {
      return this._layoutManager.GetMainRunningLayout();
    }
    GetTimelineManager() {
      return this._timelineManager;
    }
    GetTransitionManager() {
      return this._transitionManager;
    }
    GetTemplateManager() {
      return this._templateManager;
    }
    GetAssetManager() {
      return this._assetManager;
    }
    LoadImage(d) {
      return this._assetManager.LoadImage(d);
    }
    CreateInstance(d, f, h, g, k, m) {
      return m &&
        this._templateManager &&
        (m = this._templateManager.GetTemplateData(d, m))
        ? this.CreateInstanceFromData(m, f, !1, h, g, !1, k, void 0, k)
        : this.CreateInstanceFromData(d, f, !1, h, g, !1, k, void 0, k);
    }
    CreateInstanceFromData(d, f, h, g, k, m, q, v, r) {
      var n = null;
      let p = null;
      if (d instanceof e.ObjectClass) {
        p = d;
        if (p.IsFamily()) {
          d = p.GetFamilyMembers();
          var u = Math.floor(this.Random() * d.length);
          p = d[u];
        }
        n = p.GetDefaultInstanceData();
      } else (n = d), (p = this.GetObjectClassByIndex(n[1]));
      var w = p.GetPlugin().IsWorldType();
      if (this._isLoading && w && !p.IsOnLoaderLayout()) return null;
      const y = f;
      w || (f = null);
      var B =
        h && !m && n && !this._instancesByUid.has(n[2])
          ? n[2]
          : this._nextUid++;
      u = n ? n[0] : null;
      d = e.New(e.Instance, {
        runtime: this,
        objectType: p,
        layer: f,
        worldData: u,
        instVarData: n ? n[3] : null,
        uid: B,
      });
      this._instancesByUid.set(B, d);
      B = null;
      w &&
        ((B = d.GetWorldInfo()),
        "undefined" !== typeof g &&
          "undefined" !== typeof k &&
          (B.SetX(g), B.SetY(k)),
        p._SetAnyCollisionCellChanged(!0));
      f &&
        (r || f._AddInstance(d, !0),
        (1 === f.GetParallaxX() && 1 === f.GetParallaxY()) ||
          p._SetAnyInstanceParallaxed(!0),
        f.GetLayout().MaybeLoadTexturesFor(p));
      this._objectCount++;
      let E = !0;
      if (v) {
        var z = v.GetObjectClass();
        z.IsInContainer() &&
          p.IsInContainer() &&
          ((v = p.GetContainer()), (z = z.GetContainer()), v === z && (E = !1));
      }
      if (p.IsInContainer() && !h && !m && E) {
        for (var D of p.GetContainer().objectTypes())
          D !== p &&
            ((v = this.CreateInstanceFromData(
              D,
              y,
              !1,
              B ? B.GetX() : g,
              B ? B.GetY() : k,
              !0,
              !1,
              void 0,
              r
            )),
            d._AddSibling(v));
        for (var J of d.siblings()) {
          J._AddSibling(d);
          for (const C of d.siblings()) J !== C && J._AddSibling(C);
        }
      }
      w && !h && q && this._CreateChildInstancesFromData(d, u, B, f, g, k, r);
      if (p.IsInContainer() && !h && !m && q)
        for (const C of d.siblings())
          if ((h = C.GetWorldInfo()))
            (D = C.GetPlugin()),
              (J = C.GetObjectClass().GetDefaultInstanceData()[0]),
              D.IsWorldType()
                ? this._CreateChildInstancesFromData(
                    C,
                    J,
                    h,
                    f,
                    h.GetX(),
                    h.GetY(),
                    r
                  )
                : this._CreateChildInstancesFromData(
                    C,
                    J,
                    h,
                    f,
                    void 0,
                    void 0,
                    r
                  );
      !m &&
        q &&
        ("undefined" === typeof g && (g = u[0]),
        "undefined" === typeof k && (k = u[1]),
        (f = B.GetTopParent()),
        (g = g - B.GetX() + f.GetX()),
        (k = k - B.GetY() + f.GetY()),
        f.SetXY(g, k));
      p._SetIIDsStale();
      k = n ? e.cloneArray(n[5]) : null;
      n = n ? n[4].map((C) => e.cloneArray(C)) : null;
      (w = w && u && u[13]) && d._SetHasTilemap();
      d._CreateSdkInstance(k, n);
      w && ((u = u[13]), d.GetSdkInstance().LoadTilemapData(u[2], u[0], u[1]));
      this._instancesPendingCreate.push(d);
      this._hasPendingInstances = !0;
      this.IsDebug() && b.InstanceCreated(d);
      return d;
    }
    _CreateChildInstancesFromData(d, f, h, g, k, m, q) {
      var v = h.GetSceneGraphZIndexExportData(),
        r = h.GetSceneGraphChildrenExportData();
      d.GetWorldInfo().SetSceneGraphZIndex(v);
      if (r) {
        "undefined" === typeof k && (k = f[0]);
        "undefined" === typeof m && (m = f[1]);
        v = new Set();
        h = f[0];
        f = f[1];
        for (const y of r) {
          var n = y[1],
            p = y[2];
          r = y[3];
          var u = !!y[4];
          const B = y[5];
          p = this._layoutManager
            .GetLayoutBySID(y[0])
            .GetLayer(n)
            .GetInitialInstanceData(p);
          n = this.GetObjectClassByIndex(p[1]);
          var w = d.HasSibling(n);
          const E = v.has(n);
          w && !E && u
            ? ((u = d.GetSibling(n)),
              (w = k + p[0][0] - h),
              (p = m + p[0][1] - f),
              u.GetWorldInfo().SetXY(w, p),
              u.GetWorldInfo().SetSceneGraphZIndex(B),
              d.AddChild(u, {
                transformX: !!((r >> 0) & 1),
                transformY: !!((r >> 1) & 1),
                transformWidth: !!((r >> 2) & 1),
                transformHeight: !!((r >> 3) & 1),
                transformAngle: !!((r >> 4) & 1),
                destroyWithParent: !!((r >> 5) & 1),
                transformZElevation: !!((r >> 6) & 1),
              }),
              v.add(n))
            : ((n = this.CreateInstanceFromData(
                p,
                g,
                !1,
                k + p[0][0] - h,
                m + p[0][1] - f,
                !1,
                !0,
                d,
                q
              )),
              n.GetWorldInfo().SetSceneGraphZIndex(B),
              d.AddChild(n, {
                transformX: !!((r >> 0) & 1),
                transformY: !!((r >> 1) & 1),
                transformWidth: !!((r >> 2) & 1),
                transformHeight: !!((r >> 3) & 1),
                transformAngle: !!((r >> 4) & 1),
                destroyWithParent: !!((r >> 5) & 1),
                transformZElevation: !!((r >> 6) & 1),
              }));
        }
      }
    }
    DestroyInstance(d) {
      if (!this._instancesToReleaseAtEndOfTick.has(d)) {
        var f = d.GetObjectClass(),
          h = this._instancesPendingDestroy.get(f);
        if (h) {
          if (h.has(d)) return;
          h.add(d);
        } else
          (h = new Set()), h.add(d), this._instancesPendingDestroy.set(f, h);
        this.IsDebug() && b.InstanceDestroyed(d);
        d._MarkDestroyed();
        this._hasPendingInstances = !0;
        if (d.IsInContainer())
          for (const g of d.siblings()) this.DestroyInstance(g);
        for (const g of d.children())
          g.GetDestroyWithParent() && this.DestroyInstance(g);
        this._layoutManager.IsEndingLayout() ||
          this._isLoadingState ||
          ((f = this.GetEventSheetManager()),
          f.BlockFlushingInstances(!0),
          d._TriggerOnDestroyed(),
          f.BlockFlushingInstances(!1));
        d._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout());
      }
    }
    FlushPendingInstances() {
      this._hasPendingInstances &&
        ((this._isFlushingPendingInstances = !0),
        this._FlushInstancesPendingCreate(),
        this._FlushInstancesPendingDestroy(),
        (this._hasPendingInstances = this._isFlushingPendingInstances = !1),
        this.UpdateRender());
    }
    _FlushInstancesPendingCreate() {
      for (const d of this._instancesPendingCreate) {
        const f = d.GetObjectClass();
        f._AddInstance(d);
        for (const h of f.GetFamilies()) h._AddInstance(d), h._SetIIDsStale();
      }
      e.clearArray(this._instancesPendingCreate);
    }
    _FlushInstancesPendingDestroy() {
      this._dispatcher.SetDelayRemoveEventsEnabled(!0);
      for (const [d, f] of this._instancesPendingDestroy.entries())
        this._FlushInstancesPendingDestroyForObjectClass(d, f), f.clear();
      this._instancesPendingDestroy.clear();
      this._dispatcher.SetDelayRemoveEventsEnabled(!1);
    }
    _FlushInstancesPendingDestroyForObjectClass(d, f) {
      for (const g of f) {
        var h = this._eventObjects.instancedestroy;
        h.instance = g;
        this._dispatcher.dispatchEvent(h);
        this._instancesByUid.delete(g.GetUID());
        this._instanceTimes.delete(g);
        if ((h = g.GetWorldInfo()))
          h._RemoveFromCollisionCells(),
            h._RemoveFromRenderCells(),
            h._MarkDestroyed();
        this._instancesToReleaseAtEndOfTick.add(g);
        this._objectCount--;
      }
      e.arrayRemoveAllInSet(d.GetInstances(), f);
      d._SetIIDsStale();
      this._instancesToReleaseAffectedObjectClasses.add(d);
      0 === d.GetInstances().length && d._SetAnyInstanceParallaxed(!1);
      for (const g of d.GetFamilies())
        e.arrayRemoveAllInSet(g.GetInstances(), f),
          g._SetIIDsStale(),
          this._instancesToReleaseAffectedObjectClasses.add(g);
      if (d.GetPlugin().IsWorldType()) {
        d = new Set([...f].map((g) => g.GetWorldInfo().GetLayer()));
        for (const g of d) g._RemoveAllInstancesInSet(f);
      }
    }
    _GetInstancesPendingCreate() {
      return this._instancesPendingCreate;
    }
    *instancesPendingCreateForObjectClass(d) {
      for (const f of this._GetInstancesPendingCreate())
        d.IsFamily()
          ? f.GetObjectClass().BelongsToFamily(d) && (yield f)
          : f.GetObjectClass() === d && (yield f);
    }
    _GetNewUID() {
      return this._nextUid++;
    }
    _MapInstanceByUID(d, f) {
      this._instancesByUid.set(d, f);
    }
    _OnWebGLContextLost() {
      this._dispatcher.dispatchEvent(e.New(e.Event, "webglcontextlost"));
      this.SetSuspended(!0);
      for (var d of this._allObjectClasses)
        !d.IsFamily() && d.HasLoadedTextures() && d.ReleaseTextures();
      (d = this.GetMainRunningLayout()) && d._OnWebGLContextLost();
      e.ImageInfo.OnWebGLContextLost();
      e.ImageAsset.OnWebGLContextLost();
    }
    async _OnWebGLContextRestored() {
      await this.GetMainRunningLayout()._Load(null, this.GetWebGLRenderer());
      this._dispatcher.dispatchEvent(e.New(e.Event, "webglcontextrestored"));
      this.SetSuspended(!1);
      this.UpdateRender();
    }
    _OnVisibilityChange(d) {
      this.SetSuspended(d.hidden);
    }
    _OnWindowBlur(d) {
      this.IsPreview() &&
        this._pauseOnBlur &&
        !e.Platform.IsMobile &&
        !d.data.parentHasFocus &&
        (this.SetSuspended(!0), (this._isPausedOnBlur = !0));
    }
    _OnWindowFocus() {
      this._isPausedOnBlur &&
        (this.SetSuspended(!1), (this._isPausedOnBlur = !1));
    }
    _RequestAnimationFrame() {
      const d = this._tickCallbacks;
      "vsync" === this._framerateMode
        ? -1 === this._rafId &&
          (this._rafId = self.requestAnimationFrame(d.normal))
        : "unlimited-tick" === this._framerateMode
        ? (-1 === this._ruafId &&
            (this._ruafId = e.RequestUnlimitedAnimationFrame(d.tickOnly)),
          -1 === this._rafId &&
            (this._rafId = self.requestAnimationFrame(d.renderOnly)))
        : -1 === this._ruafId &&
          (this._ruafId = e.RequestUnlimitedAnimationFrame(d.normal));
    }
    _CancelAnimationFrame() {
      -1 !== this._rafId &&
        (self.cancelAnimationFrame(this._rafId), (this._rafId = -1));
      -1 !== this._ruafId &&
        (e.CancelUnlimitedAnimationFrame(this._ruafId), (this._ruafId = -1));
    }
    IsSuspended() {
      return 0 < this._suspendCount;
    }
    SetSuspended(d) {
      if (!this.IsExportToVideo()) {
        var f = this.IsSuspended();
        this._suspendCount += d ? 1 : -1;
        0 > this._suspendCount && (this._suspendCount = 0);
        d = this.IsSuspended();
        !f && d
          ? (console.log("[Construct 3] Suspending"),
            this._CancelAnimationFrame(),
            this._dispatcher.dispatchEvent(e.New(e.Event, "suspend")),
            this.Trigger(e.Plugins.System.Cnds.OnSuspend, null, null))
          : f &&
            !d &&
            (console.log("[Construct 3] Resuming"),
            (this._fpsLastTime = this._lastTickTime = f = performance.now()),
            (this._mainThreadTimeCounter =
              this._mainThreadTime =
              this._fps =
              this._fpsFrameCount =
                0),
            this._dispatcher.dispatchEvent(e.New(e.Event, "resume")),
            this.Trigger(e.Plugins.System.Cnds.OnResume, null, null),
            this.HitBreakpoint() || this.Tick(f));
      }
    }
    _AddBehInstToTick(d) {
      this._behInstsToTick.Add(d);
    }
    _AddBehInstToPostTick(d) {
      this._behInstsToPostTick.Add(d);
    }
    _AddBehInstToTick2(d) {
      this._behInstsToTick2.Add(d);
    }
    _RemoveBehInstToTick(d) {
      this._behInstsToTick.Remove(d);
    }
    _RemoveBehInstToPostTick(d) {
      this._behInstsToPostTick.Remove(d);
    }
    _RemoveBehInstToTick2(d) {
      this._behInstsToTick2.Remove(d);
    }
    _BehaviorTick() {
      this._behInstsToTick.SetQueueingEnabled(!0);
      for (const d of this._behInstsToTick) d.Tick();
      this._behInstsToTick.SetQueueingEnabled(!1);
    }
    _BehaviorPostTick() {
      this._behInstsToPostTick.SetQueueingEnabled(!0);
      for (const d of this._behInstsToPostTick) d.PostTick();
      this._behInstsToPostTick.SetQueueingEnabled(!1);
    }
    _BehaviorTick2() {
      this._behInstsToTick2.SetQueueingEnabled(!0);
      for (const d of this._behInstsToTick2) d.Tick2();
      this._behInstsToTick2.SetQueueingEnabled(!1);
    }
    *_DebugBehaviorTick() {
      this._behInstsToTick.SetQueueingEnabled(!0);
      for (const d of this._behInstsToTick) {
        const f = d.Tick();
        e.IsIterator(f) && (yield* f);
      }
      this._behInstsToTick.SetQueueingEnabled(!1);
    }
    *_DebugBehaviorPostTick() {
      this._behInstsToPostTick.SetQueueingEnabled(!0);
      for (const d of this._behInstsToPostTick) {
        const f = d.PostTick();
        e.IsIterator(f) && (yield* f);
      }
      this._behInstsToPostTick.SetQueueingEnabled(!1);
    }
    *_DebugBehaviorTick2() {
      this._behInstsToTick2.SetQueueingEnabled(!0);
      for (const d of this._behInstsToTick2) {
        const f = d.Tick2();
        e.IsIterator(f) && (yield* f);
      }
      this._behInstsToTick2.SetQueueingEnabled(!1);
    }
    async Tick(d, f, h) {
      this._hasStartedTicking = !0;
      const g = "background-wake" === h;
      h = "background-wake" !== h && "skip-render" !== h;
      if (this._hasStarted && (!this.IsSuspended() || f || g)) {
        f = performance.now();
        this._isInTick = !0;
        this._MeasureDt(d || 0);
        d = this.Step_BeforePreTick();
        this.IsDebugging() && (await d);
        d = this._dispatcher.dispatchEventAndWait_AsyncOptional(
          this._eventObjects.pretick
        );
        d instanceof Promise && (await d);
        d = this.Step_AfterPreTick();
        this.IsDebugging() && (await d);
        this._NeedsHandleSaveOrLoad() && (await this._HandleSaveOrLoad());
        this.GetLayoutManager().IsPendingChangeMainLayout() &&
          (await this._MaybeChangeLayout());
        d = this.Step_RunEventsEtc();
        this.IsDebugging() && (await d);
        h && this.Render();
        if (
          this.IsExportToVideo() &&
          (await this._ExportToVideoAddFrame(),
          this.GetGameTime() >= this.GetExportVideoDuration())
        ) {
          this._ExportToVideoFinish();
          return;
        }
        this.IsSuspended() || g || this._RequestAnimationFrame();
        this._tickCount++;
        this._tickCountNoSave++;
        this._isInTick = !1;
        this._mainThreadTimeCounter += performance.now() - f;
      }
    }
    async Step_BeforePreTick() {
      const d = this._eventSheetManager,
        f = this.IsDebug();
      this.FlushPendingInstances();
      d.BlockFlushingInstances(!0);
      this.PushCurrentLayout(this.GetMainRunningLayout());
      f && b.StartMeasuringTime();
      this.IsDebugging()
        ? await d.DebugRunScheduledWaits()
        : d.RunScheduledWaits();
      f && b.AddEventsTime();
      this.PopCurrentLayout();
      d.BlockFlushingInstances(!1);
      this.FlushPendingInstances();
      d.BlockFlushingInstances(!0);
    }
    async Step_AfterPreTick() {
      const d = this.IsDebug(),
        f = this.IsDebugging(),
        h = this._dispatcher,
        g = this._eventObjects,
        k = this._userScriptEventObjects;
      d && b.StartMeasuringTime();
      f
        ? await this.DebugIterateAndBreak(this._DebugBehaviorTick())
        : this._BehaviorTick();
      f
        ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick())
        : this._BehaviorPostTick();
      d && b.AddBehaviorTickTime();
      d && b.StartMeasuringTime();
      f
        ? await this.DebugFireGeneratorEventAndBreak(g.tick)
        : h.dispatchEvent(g.tick);
      d && b.AddPluginTickTime();
      this._eventSheetManager.BlockFlushingInstances(!1);
      this.DispatchUserScriptEvent(k.tick);
    }
    async Step_RunEventsEtc() {
      const d = this._eventSheetManager,
        f = this._dispatcher,
        h = this._eventObjects,
        g = this.IsDebug(),
        k = this.IsDebugging();
      g && b.StartMeasuringTime();
      k
        ? await d.DebugRunEvents(this._layoutManager)
        : d.RunEvents(this._layoutManager);
      g && b.AddEventsTime();
      this._collisionEngine.ClearRegisteredCollisions();
      this._ReleaseInstancesAtEndOfTick();
      this._isLayoutFirstTick = !1;
      d.BlockFlushingInstances(!0);
      g && b.StartMeasuringTime();
      k
        ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2())
        : this._BehaviorTick2();
      g && b.AddBehaviorTickTime();
      g && b.StartMeasuringTime();
      k
        ? await this.DebugFireGeneratorEventAndBreak(h.tick2)
        : f.dispatchEvent(h.tick2);
      g && b.AddPluginTickTime();
      d.BlockFlushingInstances(!1);
      k && (await d.RunQueuedDebugTriggersAsync());
    }
    _ReleaseInstancesAtEndOfTick() {
      if (0 !== this._instancesToReleaseAtEndOfTick.size) {
        var d = this._dispatcher;
        d.SetDelayRemoveEventsEnabled(!0);
        for (const f of this._instancesToReleaseAffectedObjectClasses)
          f.GetSolStack().RemoveInstances(this._instancesToReleaseAtEndOfTick);
        this._instancesToReleaseAffectedObjectClasses.clear();
        this._eventSheetManager.RemoveInstancesFromScheduledWaits(
          this._instancesToReleaseAtEndOfTick
        );
        for (const f of this._instancesToReleaseAtEndOfTick) f.Release();
        this._instancesToReleaseAtEndOfTick.clear();
        d.SetDelayRemoveEventsEnabled(!1);
      }
    }
    async _MaybeChangeLayout() {
      const d = this.GetLayoutManager();
      let f = 0;
      for (; d.IsPendingChangeMainLayout() && 10 > f++; )
        await this._DoChangeLayout(d.GetPendingChangeMainLayout());
    }
    _MeasureDt(d) {
      let f = 0;
      this.IsExportToVideo()
        ? (this._dt1 = f = 1 / this.GetExportVideoFramerate())
        : 0 !== this._lastTickTime &&
          ((f = Math.max(d - this._lastTickTime, 0) / 1e3),
          0.5 < f && (f = 0),
          (this._dt1 = Math.min(f, 1 / this._minimumFramerate)));
      this._lastTickTime = d;
      this._dt = this._dt1 * this._timeScale;
      this._gameTime.Add(this._dt);
      this._gameTimeRaw.Add(f * this._timeScale);
      this._wallTime.Add(this._dt1);
      for (const [h, g] of this._instanceTimes)
        g.Add(this._dt1 * h.GetTimeScale());
      this._canvasManager && this._canvasManager._UpdateTick();
      1e3 <= d - this._fpsLastTime &&
        ((this._fpsLastTime += 1e3),
        1e3 <= d - this._fpsLastTime && (this._fpsLastTime = d),
        (this._fps = this._fpsFrameCount),
        (this._fpsFrameCount = 0),
        (this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1e3, 1)),
        (this._mainThreadTimeCounter = 0),
        this._canvasManager && this._canvasManager._Update1sFrameRange(),
        this._collisionEngine._Update1sStats(),
        this.IsDebug() && b.Update1sPerfStats());
      this._fpsFrameCount++;
    }
    _SetTrackingInstanceTime(d, f) {
      f
        ? this._instanceTimes.has(d) ||
          ((f = e.New(e.KahanSum)),
          f.Copy(this._gameTime),
          this._instanceTimes.set(d, f))
        : this._instanceTimes.delete(d);
    }
    _GetInstanceGameTime(d) {
      return (d = this._instanceTimes.get(d)) ? d.Get() : this.GetGameTime();
    }
    async _DoChangeLayout(d) {
      const f = this._dispatcher,
        h = this.GetLayoutManager().GetMainRunningLayout();
      await h._StopRunning();
      h._Unload(d, this.GetRenderer());
      h === d && this._eventSheetManager.ClearAllScheduledWaits();
      this._collisionEngine.ClearRegisteredCollisions();
      this._ReleaseInstancesAtEndOfTick();
      f.dispatchEvent(this._eventObjects.beforelayoutchange);
      e.Asyncify.SetHighThroughputMode(!0);
      await d._Load(h, this.GetRenderer());
      e.Asyncify.SetHighThroughputMode(!1);
      await d._StartRunning(!1);
      f.dispatchEvent(this._eventObjects.layoutchange);
      this.UpdateRender();
      this._isLayoutFirstTick = !0;
      this.FlushPendingInstances();
    }
    UpdateRender() {
      this._needRender = !0;
    }
    GetWebGLRenderer() {
      return this._canvasManager
        ? this._canvasManager.GetWebGLRenderer()
        : null;
    }
    GetWebGPURenderer() {
      return this._canvasManager
        ? this._canvasManager.GetWebGPURenderer()
        : null;
    }
    GetRenderer() {
      return this._canvasManager ? this._canvasManager.GetRenderer() : null;
    }
    Render() {
      const d = this._canvasManager;
      if (d && !d.IsRendererContextLost()) {
        var f = this.GetRenderer(),
          h = f.SupportsGPUProfiling(),
          g = h && f.IsWebGL();
        h = h && f.IsWebGPU();
        g && f.CheckForQueryResults();
        if (this._needRender || this.IsExportToVideo()) {
          var k = this._layoutManager.GetMainRunningLayout();
          f.Start();
          var m = this.IsDebug();
          m && b.StartMeasuringTime();
          this._needRender = !1;
          var q = null;
          g &&
            ((q = d.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery()),
            f.StartQuery(q));
          g = null;
          h &&
            ((g = f.StartFrameTiming(2 * (1 + k.GetLayerCount()))),
            f.WriteTimestamp(0));
          this.Uses3DFeatures() &&
          "low" === d.GetCurrentFullscreenScalingQuality()
            ? f.SetFixedSizeDepthBuffer(d.GetDrawWidth(), d.GetDrawHeight())
            : f.SetAutoSizeDepthBuffer();
          this._Render(this.GetRenderer(), k);
          q && f.EndQuery(q);
          h &&
            (f.WriteTimestamp(1), this._canvasManager._AddWebGPUFrameTiming(g));
          f.Finish();
          m && (b.AddDrawCallsTime(), b.UpdateInspectHighlight());
          d && d._MaybeTakeSnapshot();
        } else f.IncrementFrameNumber();
      }
    }
    _Render(d, f) {
      d.SetTextureFillMode();
      d.SetAlphaBlend();
      d.SetColorRgba(1, 1, 1, 1);
      d.SetRenderTarget(null);
      d.SetTexture(null);
      d.SetDepthEnabled(this.Uses3DFeatures());
      f.Draw(d);
    }
    Trigger(d, f, h) {
      if (!this._hasStarted) return !1;
      var g = !this._isInTick && !this._eventSheetManager.IsInTrigger();
      let k = 0;
      g && (k = performance.now());
      const m = this.IsDebug();
      m && this.SetDebuggingEnabled(!1);
      d = this._eventSheetManager._Trigger(this._layoutManager, d, f, h);
      g &&
        ((g = performance.now() - k),
        (this._mainThreadTimeCounter += g),
        m && b.AddTriggersTime(g));
      m && this.SetDebuggingEnabled(!0);
      return d;
    }
    DebugTrigger(d, f, h) {
      if (!this.IsDebug()) return this.Trigger(d, f, h);
      if (this.HitBreakpoint())
        throw Error("called DebugTrigger() while stopped on breakpoint");
      if (!this._isInTick && !this._eventSheetManager.IsInTrigger())
        throw Error(
          "called DebugTrigger() outside of event code - use TriggerAsync() instead"
        );
      return this._eventSheetManager._DebugTrigger(
        this._layoutManager,
        d,
        f,
        h
      );
    }
    async TriggerAsync(d, f, h) {
      if (!this.IsDebugging()) return this.Trigger(d, f, h);
      if (!this._hasStarted) return !1;
      if (this.HitBreakpoint())
        return this._eventSheetManager.QueueDebugTrigger(d, f, h);
      if (!this.GetMainRunningLayout())
        return this._eventSheetManager.QueueTrigger(d, f, h);
      const g = performance.now();
      d = this._eventSheetManager._DebugTrigger(this._layoutManager, d, f, h);
      for (f = d.next(); !f.done; )
        await this.DebugBreak(f.value), (f = d.next());
      this.IsSuspended() ||
        this._eventSheetManager.IsInTrigger() ||
        (await this._eventSheetManager.RunQueuedDebugTriggersAsync(),
        this._hasStartedTicking &&
          !this._isInTick &&
          this._RequestAnimationFrame());
      this._mainThreadTimeCounter += performance.now() - g;
      return f.value;
    }
    FastTrigger(d, f, h) {
      const g = this.IsDebug();
      g && this.SetDebuggingEnabled(!1);
      d = this._eventSheetManager._FastTrigger(this._layoutManager, d, f, h);
      g && this.SetDebuggingEnabled(!0);
      return d;
    }
    DebugFastTrigger(d, f, h) {
      return this._eventSheetManager._DebugFastTrigger(
        this._layoutManager,
        d,
        f,
        h
      );
    }
    ScheduleTriggers(d) {
      return this._scheduleTriggersThrottle.Add(d);
    }
    PushCurrentLayout(d) {
      this._currentLayoutStack.push(d);
    }
    PopCurrentLayout() {
      if (!this._currentLayoutStack.length) throw Error("layout stack empty");
      this._currentLayoutStack.pop();
    }
    GetCurrentLayout() {
      return this._currentLayoutStack.length
        ? this._currentLayoutStack.at(-1)
        : this.GetMainRunningLayout();
    }
    GetDt(d) {
      return d && -1 !== d.GetTimeScale()
        ? this._dt1 * d.GetTimeScale()
        : this._dt;
    }
    _GetDtFast() {
      return this._dt;
    }
    GetDt1() {
      return this._dt1;
    }
    GetTimeScale() {
      return this._timeScale;
    }
    SetTimeScale(d) {
      if (isNaN(d) || 0 > d) d = 0;
      this._timeScale = d;
    }
    SetMinimumFramerate(d) {
      this._minimumFramerate = e.clamp(d, 1, 120);
    }
    GetMinimumFramerate() {
      return this._minimumFramerate;
    }
    GetFPS() {
      return this._fps;
    }
    GetMainThreadTime() {
      return this._mainThreadTime;
    }
    GetStartTime() {
      return this._startTime;
    }
    GetGameTime() {
      return this._gameTime.Get();
    }
    GetGameTimeRaw() {
      return this._gameTimeRaw.Get();
    }
    GetWallTime() {
      return this._wallTime.Get();
    }
    GetTickCount() {
      return this._tickCount;
    }
    GetTickCountNoSave() {
      return this._tickCountNoSave;
    }
    GetObjectCount() {
      return this._objectCount;
    }
    GetProjectName() {
      return this._projectName;
    }
    GetProjectVersion() {
      return this._projectVersion;
    }
    GetProjectUniqueId() {
      return this._projectUniqueId;
    }
    GetAppId() {
      return this._appId;
    }
    GetInstanceByUID(d) {
      if (this._isLoadingState)
        throw Error(
          "cannot call while loading state - wait until afterload event"
        );
      return this._instancesByUid.get(d) || null;
    }
    _RefreshUidMap() {
      this._instancesByUid.clear();
      for (const d of this._allObjectClasses)
        if (!d.IsFamily())
          for (const f of d.GetInstances())
            this._instancesByUid.set(f.GetUID(), f);
    }
    IsPreview() {
      return "preview" === this._exportType;
    }
    IsDebug() {
      return this._isDebug;
    }
    GetExportType() {
      return this._exportType;
    }
    IsCordova() {
      return "cordova" === this._exportType;
    }
    IsAndroidWebView() {
      return (
        "Android" === e.Platform.OS &&
        ("cordova" === this._exportType ||
          "playable-ad" === this._exportType ||
          "instant-games" === this._exportType)
      );
    }
    IsiOSCordova() {
      return this._isiOSCordova;
    }
    IsiOSWebView() {
      return this._isiOSWebView;
    }
    GetCollisionEngine() {
      return this._collisionEngine;
    }
    GetSolidBehavior() {
      return this._pluginManager.GetSolidBehavior();
    }
    GetJumpthruBehavior() {
      return this._pluginManager.GetJumpthruBehavior();
    }
    Uses3DFeatures() {
      return this._uses3dFeatures;
    }
    GetZScaleFactor() {
      return this.GetRenderer().GetZAxisScaleFactor(this.GetViewportHeight());
    }
    GetDefaultCameraZ(d) {
      return this.GetRenderer().GetDefaultCameraZ(
        d || this.GetViewportHeight()
      );
    }
    IsLayoutFirstTick() {
      return this._isLayoutFirstTick;
    }
    SetPixelRoundingEnabled(d) {
      d = !!d;
      this._isPixelRoundingEnabled !== d &&
        ((this._isPixelRoundingEnabled = d),
        this.GetLayoutManager().SetAllLayerMVChanged(),
        this.UpdateRender());
    }
    IsPixelRoundingEnabled() {
      return this._isPixelRoundingEnabled;
    }
    SaveToSlot(d) {
      this._saveToSlotName = d;
    }
    LoadFromSlot(d) {
      this._loadFromSlotName = d;
    }
    LoadFromJsonString(d) {
      this._loadFromJson = d;
    }
    GetLastSaveJsonString() {
      return this._lastSaveJson;
    }
    _NeedsHandleSaveOrLoad() {
      return !(
        !this._saveToSlotName &&
        !this._loadFromSlotName &&
        null === this._loadFromJson
      );
    }
    async _HandleSaveOrLoad() {
      this._saveToSlotName &&
        (this.FlushPendingInstances(),
        await this._DoSaveToSlot(this._saveToSlotName),
        this._ClearSaveOrLoad());
      this._loadFromSlotName &&
        (await this._DoLoadFromSlot(this._loadFromSlotName),
        this._ClearSaveOrLoad(),
        this.IsDebug() && b.StepIfPausedInDebugger());
      if (null !== this._loadFromJson) {
        this.FlushPendingInstances();
        try {
          await this._DoLoadFromJsonString(this._loadFromJson),
            (this._lastSaveJson = this._loadFromJson),
            await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadComplete, null),
            (this._lastSaveJson = "");
        } catch (d) {
          console.error(
            "[Construct 3] Failed to load state from JSON string: ",
            d
          ),
            await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadFailed, null);
        }
        this._ClearSaveOrLoad();
      }
    }
    _ClearSaveOrLoad() {
      this._loadFromSlotName = this._saveToSlotName = "";
      this._loadFromJson = null;
    }
    _GetProjectStorage() {
      this._projectStorage ||
        (this._projectStorage = localforage.createInstance({
          name: "c3-localstorage-" + this.GetProjectUniqueId(),
          description: this.GetProjectName(),
        }));
      return this._projectStorage;
    }
    _GetSavegamesStorage() {
      this._savegamesStorage ||
        (this._savegamesStorage = localforage.createInstance({
          name: "c3-savegames-" + this.GetProjectUniqueId(),
          description: this.GetProjectName(),
        }));
      return this._savegamesStorage;
    }
    async _DoSaveToSlot(d) {
      const f = await this._SaveToJsonString();
      try {
        await this._GetSavegamesStorage().setItem(d, f),
          console.log(
            "[Construct 3] Saved state to storage (" + f.length + " chars)"
          ),
          (this._lastSaveJson = f),
          await this.TriggerAsync(e.Plugins.System.Cnds.OnSaveComplete, null),
          (this._lastSaveJson = "");
      } catch (h) {
        console.error("[Construct 3] Failed to save state to storage: ", h),
          await this.TriggerAsync(e.Plugins.System.Cnds.OnSaveFailed, null);
      }
    }
    async _DoLoadFromSlot(d) {
      try {
        const f = await this._GetSavegamesStorage().getItem(d);
        if (!f) throw Error("empty slot");
        console.log(
          "[Construct 3] Loaded state from storage (" + f.length + " chars)"
        );
        await this._DoLoadFromJsonString(f);
        this._lastSaveJson = f;
        await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadComplete, null);
        this._lastSaveJson = "";
      } catch (f) {
        console.error("[Construct 3] Failed to load state from storage: ", f),
          await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadFailed, null);
      }
    }
    async _SaveToJsonString() {
      const d = {
        c3save: !0,
        version: 1,
        rt: {
          time: this.GetGameTime(),
          timeRaw: this.GetGameTimeRaw(),
          walltime: this.GetWallTime(),
          timescale: this.GetTimeScale(),
          tickcount: this.GetTickCount(),
          next_uid: this._nextUid,
          running_layout: this.GetMainRunningLayout().GetSID(),
          start_time_offset: Date.now() - this._startTime,
        },
        types: {},
        layouts: {},
        events: this._eventSheetManager._SaveToJson(),
        timelines: this._timelineManager._SaveToJson(),
        user_script_data: null,
      };
      for (var f of this._allObjectClasses)
        f.IsFamily() ||
          f.HasNoSaveBehavior() ||
          (d.types[f.GetSID().toString()] = f._SaveToJson());
      for (const h of this._layoutManager.GetAllLayouts())
        d.layouts[h.GetSID().toString()] = h._SaveToJson();
      f = this._CreateUserScriptEvent("save");
      f.saveData = null;
      await this.DispatchUserScriptEventAsyncWait(f);
      d.user_script_data = f.saveData;
      return JSON.stringify(d);
    }
    IsLoadingState() {
      return this._isLoadingState;
    }
    async _DoLoadFromJsonString(d) {
      var f = this.GetLayoutManager();
      d = JSON.parse(d);
      if (d.c2save) throw Error("C2 saves are incompatible with C3 runtime");
      if (!d.c3save) throw Error("not valid C3 save data");
      if (1 < d.version) throw Error("C3 save data from future version");
      this._dispatcher.dispatchEvent(e.New(e.Event, "beforeload"));
      for (var h of this.allInstances()) h._OnBeforeLoad();
      this._isLoadingState = !0;
      h = d.rt;
      this._gameTime.Set(h.time);
      h.hasOwnProperty("timeRaw") && this._gameTimeRaw.Set(h.timeRaw);
      this._wallTime.Set(h.walltime);
      this._timeScale = h.timescale;
      this._tickCount = h.tickcount;
      this._startTime = Date.now() - h.start_time_offset;
      var g = h.running_layout;
      if (g !== this.GetMainRunningLayout().GetSID())
        if ((g = f.GetLayoutBySID(g))) await this._DoChangeLayout(g);
        else return;
      for (const [k, m] of Object.entries(d.types))
        (g = parseInt(k, 10)),
          (g = this.GetObjectClassBySID(g)),
          !g || g.IsFamily() || g.HasNoSaveBehavior() || g._LoadFromJson(m);
      this.FlushPendingInstances();
      this._RefreshUidMap();
      this._isLoadingState = !1;
      this._nextUid = h.next_uid;
      for (const [k, m] of Object.entries(d.layouts))
        (h = parseInt(k, 10)), (h = f.GetLayoutBySID(h)) && h._LoadFromJson(m);
      this._eventSheetManager._LoadFromJson(d.events);
      for (const k of this._allObjectClasses)
        if (!k.IsFamily() && k.IsInContainer())
          for (const m of k.GetInstances()) {
            h = m.GetIID();
            for (const q of k.GetContainer().objectTypes())
              if (q !== k) {
                g = q.GetInstances();
                if (0 > h || h >= g.length)
                  throw Error("missing sibling instance");
                m._AddSibling(g[h]);
              }
          }
      this._timelineManager._LoadFromJson(d.timelines);
      f.SetAllLayerProjectionChanged();
      f.SetAllLayerMVChanged();
      this._dispatcher.dispatchEvent(e.New(e.Event, "afterload"));
      f = this._CreateUserScriptEvent("load");
      f.saveData = d.user_script_data;
      await this.DispatchUserScriptEventAsyncWait(f);
      this.UpdateRender();
    }
    async AddJobWorkerScripts(d) {
      d = (
        await Promise.all(d.map((f) => this._assetManager.FetchBlob(f)))
      ).map((f) => URL.createObjectURL(f));
      this._jobScheduler.ImportScriptsToJobWorkers(d);
    }
    AddJobWorkerBlob(d, f) {
      this._jobScheduler.SendBlobToJobWorkers(d, f);
    }
    AddJobWorkerBuffer(d, f) {
      this._jobScheduler.SendBufferToJobWorkers(d, f);
    }
    AddJob(d, f, h) {
      return this._jobScheduler.AddJob(d, f, h);
    }
    BroadcastJob(d, f, h) {
      return this._jobScheduler.BroadcastJob(d, f, h);
    }
    InvokeDownload(d, f) {
      this.PostComponentMessageToDOM("runtime", "invoke-download", {
        url: d,
        filename: f,
      });
    }
    async RasterSvgImage(d, f, h, g, k, m) {
      g = g || f;
      k = k || h;
      if (this.IsInWorker())
        return (
          await this.PostComponentMessageToDOMAsync(
            "runtime",
            "raster-svg-image",
            {
              blob: d,
              imageWidth: f,
              imageHeight: h,
              surfaceWidth: g,
              surfaceHeight: k,
              imageBitmapOpts: m,
            }
          )
        ).imageBitmap;
      d = await self.C3_RasterSvgImageBlob(d, f, h, g, k);
      return m ? await self.createImageBitmap(d, m) : d;
    }
    async GetSvgImageSize(d) {
      return this.IsInWorker()
        ? await this.PostComponentMessageToDOMAsync(
            "runtime",
            "get-svg-image-size",
            { blob: d }
          )
        : await self.C3_GetSvgImageSize(d);
    }
    RequestDeviceOrientationEvent() {
      this._didRequestDeviceOrientationEvent ||
        ((this._didRequestDeviceOrientationEvent = !0),
        this.PostComponentMessageToDOM("runtime", "enable-device-orientation"));
    }
    RequestDeviceMotionEvent() {
      this._didRequestDeviceMotionEvent ||
        ((this._didRequestDeviceMotionEvent = !0),
        this.PostComponentMessageToDOM("runtime", "enable-device-motion"));
    }
    Random() {
      return this._randomNumberCallback();
    }
    SetRandomNumberGeneratorCallback(d) {
      this._randomNumberCallback = d;
    }
    _GetRemotePreviewStatusInfo() {
      const d = this.GetWebGLRenderer();
      return {
        fps: this.GetFPS(),
        cpu: this.GetMainThreadTime(),
        gpu: this.GetGPUUtilisation(),
        layout: this.GetMainRunningLayout()
          ? this.GetMainRunningLayout().GetName()
          : "",
        renderer: d ? d.GetUnmaskedRenderer() : "<unavailable>",
      };
    }
    HitBreakpoint() {
      return this.IsDebug() ? b.HitBreakpoint() : !1;
    }
    DebugBreak(d) {
      return this.IsDebugging() ? b.DebugBreak(d) : Promise.resolve();
    }
    DebugBreakNext() {
      return this.IsDebugging() ? b.BreakNext() : !1;
    }
    SetDebugBreakpointsEnabled(d) {
      this._breakpointsEnabled = !!d;
      this._UpdateDebuggingFlag();
    }
    AreDebugBreakpointsEnabled() {
      return this._breakpointsEnabled;
    }
    IsDebugging() {
      return this._isDebugging;
    }
    SetDebuggingEnabled(d) {
      d ? this._debuggingDisabled-- : this._debuggingDisabled++;
      this._UpdateDebuggingFlag();
    }
    _UpdateDebuggingFlag() {
      this._isDebugging =
        this.IsDebug() &&
        this._breakpointsEnabled &&
        0 === this._debuggingDisabled;
    }
    IsCPUProfiling() {
      return this.IsDebug() && b.IsCPUProfiling();
    }
    IsGPUProfiling() {
      return (
        this.IsDebug() &&
        this.GetRenderer().SupportsGPUProfiling() &&
        b.IsGPUProfiling()
      );
    }
    async DebugIterateAndBreak(d) {
      if (d) for (const f of d) await this.DebugBreak(f);
    }
    DebugFireGeneratorEventAndBreak(d) {
      return this.DebugIterateAndBreak(
        this._dispatcher.dispatchGeneratorEvent(d)
      );
    }
    _InvokeFunctionFromJS(d) {
      return this._eventSheetManager._InvokeFunctionFromJS(d.name, d.params);
    }
    GetIRuntime() {
      return this._iRuntime;
    }
    _CreateUserScriptEvent(d) {
      d = e.New(e.Event, d, !1);
      d.runtime = this._iRuntime;
      return d;
    }
    _InitScriptInterfaces() {
      var d = {};
      for (const f of this._allObjectClasses)
        d[f.GetJsPropName()] = {
          value: f.GetIObjectClass(),
          enumerable: !0,
          writable: !1,
        };
      d = Object.create(Object.prototype, d);
      this._iRuntime = new self.IRuntime(this, d);
      this._userScriptEventObjects = {
        tick: this._CreateUserScriptEvent("tick"),
      };
    }
    _InitGlobalVariableScriptInterface() {
      const d = {};
      for (const f of this.GetEventSheetManager().GetAllGlobalVariables())
        d[f.GetJsPropName()] = f._GetScriptInterfaceDescriptor();
      this._iRuntime._InitGlobalVars(d);
    }
    _GetCommonScriptInterfaces() {
      return this._commonScriptInterfaces;
    }
    _MapScriptInterface(d, f) {
      this._interfaceMap.set(d, f);
    }
    _UnwrapScriptInterface(d) {
      return this._interfaceMap.get(d);
    }
    _UnwrapIObjectClass(d) {
      if (!(d instanceof self.IObjectClass))
        throw new TypeError("expected IObjectClass");
      d = this._UnwrapScriptInterface(d);
      if (!(d && d instanceof e.ObjectClass))
        throw Error("invalid IObjectClass");
      return d;
    }
    _UnwrapIWorldInstance(d) {
      if (!(d instanceof self.IWorldInstance))
        throw new TypeError("expected IWorldInstance");
      d = this._UnwrapScriptInterface(d);
      if (!(d && d instanceof e.Instance)) throw Error("invalid IInstance");
      return d;
    }
  };
  self.C3_CreateRuntime = e.Runtime.Create;
  self.C3_InitRuntime = (d, f) => d.Init(f);
}
{
  ("use strict");
  const e = self.C3;
  e.JobSchedulerRuntime = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._runtime = b;
      this._jobPromises = new Map();
      this._nextJobId = 0;
      this._inputPort = a.inputPort;
      a.outputPort.onmessage = (c) => this._OnJobWorkerMessage(c);
      this._maxNumWorkers = a.maxNumWorkers;
      this._jobWorkerCount = 1;
      this._hadErrorCreatingWorker = this._isCreatingWorker = !1;
    }
    async Init() {}
    ImportScriptsToJobWorkers(b) {
      this._inputPort.postMessage({ type: "_import_scripts", scripts: b });
    }
    SendBlobToJobWorkers(b, a) {
      this._inputPort.postMessage({ type: "_send_blob", blob: b, id: a });
    }
    SendBufferToJobWorkers(b, a) {
      this._inputPort.postMessage({ type: "_send_buffer", buffer: b, id: a }, [
        b,
      ]);
    }
    AddJob(b, a, c, d, f) {
      c || (c = []);
      const h = this._nextJobId++;
      b = { type: b, isBroadcast: !1, jobId: h, params: a, transferables: c };
      a = new Promise((g, k) => {
        this._jobPromises.set(h, {
          resolve: g,
          progress: d,
          reject: k,
          cancelled: !1,
        });
      });
      f && f.SetAction(() => this._CancelJob(h));
      this._inputPort.postMessage(b, c);
      this._MaybeCreateExtraWorker();
      return a;
    }
    BroadcastJob(b, a, c) {
      c || (c = []);
      const d = this._nextJobId++;
      this._inputPort.postMessage(
        { type: b, isBroadcast: !0, jobId: d, params: a, transferables: c },
        c
      );
    }
    _CancelJob(b) {
      const a = this._jobPromises.get(b);
      a &&
        ((a.cancelled = !0),
        (a.resolve = null),
        (a.progress = null),
        (a.reject = null),
        this._inputPort.postMessage({ type: "_cancel", jobId: b }));
    }
    _OnJobWorkerMessage(b) {
      b = b.data;
      const a = b.type,
        c = b.jobId;
      switch (a) {
        case "result":
          this._OnJobResult(c, b.result);
          break;
        case "progress":
          this._OnJobProgress(c, b.progress);
          break;
        case "error":
          this._OnJobError(c, b.error);
          break;
        case "ready":
          this._OnJobWorkerReady();
          break;
        default:
          throw Error(`unknown message from worker '${a}'`);
      }
    }
    _OnJobResult(b, a) {
      const c = this._jobPromises.get(b);
      if (!c) throw Error("invalid job ID");
      c.cancelled || c.resolve(a);
      this._jobPromises.delete(b);
    }
    _OnJobProgress(b, a) {
      b = this._jobPromises.get(b);
      if (!b) throw Error("invalid job ID");
      !b.cancelled && b.progress && b.progress(a);
    }
    _OnJobError(b, a) {
      const c = this._jobPromises.get(b);
      if (!c) throw Error("invalid job ID");
      c.cancelled || c.reject(a);
      this._jobPromises.delete(b);
    }
    _OnJobWorkerReady() {
      this._isCreatingWorker &&
        ((this._isCreatingWorker = !1),
        this._jobWorkerCount++,
        this._jobWorkerCount < this._maxNumWorkers
          ? this._MaybeCreateExtraWorker()
          : this._inputPort.postMessage({ type: "_no_more_workers" }));
    }
    async _MaybeCreateExtraWorker() {
      if (
        !(
          this._jobWorkerCount >= this._maxNumWorkers ||
          this._isCreatingWorker ||
          this._hadErrorCreatingWorker ||
          this._jobPromises.size <= this._jobWorkerCount
        )
      )
        try {
          (this._isCreatingWorker = !0),
            ((
              await this._runtime.PostComponentMessageToDOMAsync(
                "runtime",
                "create-job-worker"
              )
            ).outputPort.onmessage = (b) => this._OnJobWorkerMessage(b));
        } catch (b) {
          (this._hadErrorCreatingWorker = !0),
            (this._isCreatingWorker = !1),
            console.error(
              `[Construct 3] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`,
              b
            );
        }
    }
  };
}
self.C3_Shaders = {};
self.C3_Shaders.alphaclamp = {
  glsl: "precision mediump float;\nvarying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform lowp float alphathreshold;\nuniform lowp float lowerclamp;\nuniform lowp float upperclamp;\nvoid main(void)\n{\nlowp vec4 front = texture2D(samplerFront, vTex);\nlowp float a = front.a;\nlowp vec4 unpremultiplied = front / a;\na = (a < alphathreshold ? lowerclamp : upperclamp);\nfront *= a;\nfront.a = a;\ngl_FragColor = front;\n}",
  wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nalphathreshold : f32;\nlowerclamp : f32;\nupperclamp : f32;\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3_UTILITY_FUNCTIONS%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@stage(fragment)\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\nfront.a = select(shaderParams.upperclamp, shaderParams.lowerclamp, front.a < shaderParams.alphathreshold);\nvar output : FragmentOutput;\noutput.color = vec4<f32>(front.rgb * front.a, front.a);\nreturn output;\n}",
  blendsBackground: !1,
  usesDepth: !1,
  extendBoxHorizontal: 0,
  extendBoxVertical: 0,
  crossSampling: !1,
  mustPreDraw: !1,
  preservesOpaqueness: !0,
  animated: !1,
  parameters: [
    ["alphathreshold", 0, "percent"],
    ["lowerclamp", 0, "percent"],
    ["upperclamp", 0, "percent"],
  ],
};
self.C3_Shaders.warpobject = {
  glsl: "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 srcStart;\nuniform mediump vec2 srcEnd;\nuniform mediump vec2 srcOriginStart;\nuniform mediump vec2 srcOriginEnd;\nuniform highmedp float seconds;\nuniform mediump vec2 pixelSize;\nuniform mediump float devicePixelRatio;\nuniform mediump float layerScale;\nuniform mediump float freqX;\nuniform mediump float freqY;\nuniform mediump float ampX;\nuniform mediump float ampY;\nuniform mediump float speedX;\nuniform mediump float speedY;\nvoid main(void)\n{\nmediump float _2pi = 2.0 * 3.14159265359;\nmediump vec2 srcOriginSize = srcOriginEnd - srcOriginStart;\nmediump vec2 n = ((vTex - srcOriginStart) / srcOriginSize);\nmediump vec2 p = vTex;\np.x += cos(n.y * _2pi * freqY + seconds * speedY * _2pi) * ampY * pixelSize.x * devicePixelRatio * layerScale;\np.y += sin(n.x * _2pi * freqX + seconds * speedX * _2pi) * ampX * pixelSize.y * devicePixelRatio * layerScale;\np = clamp(p, min(srcStart, srcEnd), max(srcStart, srcEnd));\ngl_FragColor = texture2D(samplerFront, p);\n}",
  wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nfreqX : f32;\nfreqY : f32;\nampX : f32;\nampY : f32;\nspeedX : f32;\nspeedY : f32;\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3PARAMS_STRUCT%%\n%%C3_UTILITY_FUNCTIONS%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\nlet pi2 : f32 = 6.283185307179586;\n@stage(fragment)\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\nvar n : vec2<f32> = c3_srcOriginToNorm(input.fragUV);\nvar p : vec2<f32> = input.fragUV + vec2<f32>(\ncos(n.y * pi2 * shaderParams.freqY + c3Params.seconds * shaderParams.speedY * pi2) * shaderParams.ampY * pixelSize.x * c3Params.devicePixelRatio * c3Params.layerScale,\nsin(n.x * pi2 * shaderParams.freqX + c3Params.seconds * shaderParams.speedX * pi2) * shaderParams.ampX * pixelSize.y * c3Params.devicePixelRatio * c3Params.layerScale\n);\np = c3_clampToSrc(p);\nvar output : FragmentOutput;\noutput.color = textureSample(textureFront, samplerFront, p);\nreturn output;\n}",
  blendsBackground: !1,
  usesDepth: !1,
  extendBoxHorizontal: 30,
  extendBoxVertical: 30,
  crossSampling: !1,
  mustPreDraw: !1,
  preservesOpaqueness: !1,
  animated: !0,
  parameters: [
    ["freqX", 0, "float"],
    ["freqY", 0, "float"],
    ["ampX", 0, "float"],
    ["ampY", 0, "float"],
    ["speedX", 0, "float"],
    ["speedY", 0, "float"],
  ],
};
self.C3_Shaders.warpripple = {
  glsl: "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 srcOriginStart;\nuniform mediump vec2 srcOriginEnd;\nuniform highmedp float seconds;\nuniform mediump vec2 pixelSize;\nuniform mediump float freq;\nuniform mediump float amp;\nuniform mediump float speed;\nconst mediump float PI = 3.1415926;\nvoid main(void)\n{\nmediump vec2 srcOriginSize = srcOriginEnd - srcOriginStart;\nmediump vec2 tex = (vTex - srcOriginStart) / srcOriginSize;\ntex = tex * 2.0 - 1.0;\nmediump float d = length(tex);\nmediump float a = atan(tex.y, tex.x);\nd += sin((d * 2.0 * PI) * freq / (pixelSize.x * 750.0) + (seconds * speed)) * amp * (pixelSize.x * 750.0);\ntex.x = cos(a) * d;\ntex.y = sin(a) * d;\ntex = (tex + 1.0) / 2.0;\ntex = clamp(tex, 0.0, 1.0);\ntex = tex * srcOriginSize + srcOriginStart;\ngl_FragColor = texture2D(samplerFront, tex);\n}",
  wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nfreq : f32;\namp : f32;\nspeed : f32;\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3PARAMS_STRUCT%%\n%%C3_UTILITY_FUNCTIONS%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\nlet pi : f32 = 3.1415926;\n@stage(fragment)\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\nvar tex = c3_srcOriginToNorm(input.fragUV);\ntex = tex * 2.0 - 1.0;\nvar d : f32 = length(tex);\nvar a = atan2(tex.y, tex.x);\nd = d + sin((d * 2.0 * pi) * shaderParams.freq / (pixelSize.x * 750.0) + (c3Params.seconds * shaderParams.speed)) * shaderParams.amp * (pixelSize.x * 750.0);\ntex.x = cos(a) * d;\ntex.y = sin(a) * d;\ntex = (tex + 1.0) / 2.0;\ntex = c3_clamp2(tex, 0.0, 1.0);\ntex = c3_normToSrcOrigin(tex);\nvar output : FragmentOutput;\noutput.color = textureSample(textureFront, samplerFront, tex);\nreturn output;\n}",
  blendsBackground: !1,
  usesDepth: !1,
  extendBoxHorizontal: 50,
  extendBoxVertical: 50,
  crossSampling: !1,
  mustPreDraw: !1,
  preservesOpaqueness: !1,
  animated: !0,
  parameters: [
    ["freq", 0, "float"],
    ["amp", 0, "percent"],
    ["speed", 0, "float"],
  ],
};
self.C3_Shaders.warpobjectmask = {
  glsl: "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 srcStart;\nuniform mediump vec2 srcEnd;\nuniform mediump vec2 srcOriginStart;\nuniform mediump vec2 srcOriginEnd;\nuniform lowp sampler2D samplerBack;\nuniform mediump vec2 destStart;\nuniform mediump vec2 destEnd;\nuniform highmedp float seconds;\nuniform mediump vec2 pixelSize;\nuniform mediump float devicePixelRatio;\nuniform mediump float layerScale;\nuniform mediump float freqX;\nuniform mediump float freqY;\nuniform mediump float ampX;\nuniform mediump float ampY;\nuniform mediump float speedX;\nuniform mediump float speedY;\nvoid main(void)\n{\nmediump float _2pi = 2.0 * 3.14159265359;\nlowp float fronta = texture2D(samplerFront, vTex).a;\nmediump vec2 srcSize = srcEnd - srcStart;\nmediump vec2 tex = ((vTex - srcStart) / srcSize);\nmediump vec2 srcOriginSize = srcOriginEnd - srcOriginStart;\nmediump vec2 n = ((vTex - srcOriginStart) / srcOriginSize);\nmediump vec2 p = mix(destStart, destEnd, tex);\np.x += cos(n.y * _2pi * freqY + seconds * speedY * _2pi) * ampY * pixelSize.x * devicePixelRatio * layerScale * fronta;\np.y += sin(n.x * _2pi * freqX + seconds * speedX * _2pi) * ampX * pixelSize.y * devicePixelRatio * layerScale * fronta;\np = clamp(p, min(destStart, destEnd), max(destStart, destEnd));\ngl_FragColor = texture2D(samplerBack, p);\n}",
  wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\nstruct ShaderParams {\nfreqX : f32;\nfreqY : f32;\nampX : f32;\nampY : f32;\nspeedX : f32;\nspeedY : f32;\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3PARAMS_STRUCT%%\n%%C3_UTILITY_FUNCTIONS%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\nlet pi2 : f32 = 6.283185307179586;\n@stage(fragment)\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\nvar fronta : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\nvar n : vec2<f32> = c3_srcOriginToNorm(input.fragUV);\nvar p : vec2<f32> = c3_getBackUV(input.fragPos.xy, textureBack) + vec2<f32>(\ncos(n.y * pi2 * shaderParams.freqY + c3Params.seconds * shaderParams.speedY * pi2) * shaderParams.ampY * pixelSize.x * c3Params.devicePixelRatio * c3Params.layerScale * fronta,\nsin(n.x * pi2 * shaderParams.freqX + c3Params.seconds * shaderParams.speedX * pi2) * shaderParams.ampX * pixelSize.y * c3Params.devicePixelRatio * c3Params.layerScale * fronta\n);\np = c3_clampToDest(p);\nvar output : FragmentOutput;\noutput.color = textureSample(textureBack, samplerBack, p);\nreturn output;\n}",
  blendsBackground: !0,
  usesDepth: !1,
  extendBoxHorizontal: 30,
  extendBoxVertical: 30,
  crossSampling: !0,
  mustPreDraw: !1,
  preservesOpaqueness: !1,
  animated: !0,
  parameters: [
    ["freqX", 0, "float"],
    ["freqY", 0, "float"],
    ["ampX", 0, "float"],
    ["ampY", 0, "float"],
    ["speedX", 0, "float"],
    ["speedY", 0, "float"],
  ],
};
self.C3_Shaders["simple-skend"] = {
  glsl: "uniform lowp float Skend;\nuniform lowp float Power;\nvarying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 srcStart;\nuniform mediump vec2 srcEnd;\nuniform mediump vec2 srcOriginStart;\nuniform mediump vec2 srcOriginEnd;\nuniform mediump vec2 layoutStart;\nuniform mediump vec2 layoutEnd;\nuniform lowp sampler2D samplerBack;\nuniform mediump vec2 destStart;\nuniform mediump vec2 destEnd;\nuniform mediump float seconds;\nuniform mediump vec2 pixelSize;\nuniform mediump float layerScale;\nuniform mediump float layerAngle;\nvoid main(void)\n{\nmediump vec2 tex = vTex;\nmediump vec2 layoutSize = abs(vec2(layoutEnd.x-layoutStart.x,(layoutEnd.y-layoutStart.y)));\nmediump vec2 texelSize = abs(srcOriginEnd-srcOriginStart)/layoutSize;\nmediump vec2 n = (vTex - srcOriginStart) / (srcOriginEnd - srcOriginStart);\ntex.x -= (texelSize.x*Skend)*pow((1.-n.y),Power);\ntex = clamp(tex, srcOriginStart, srcOriginEnd);\ngl_FragColor = texture2D(samplerFront,tex);\n}",
  wgsl: "",
  blendsBackground: !1,
  usesDepth: !1,
  extendBoxHorizontal: 0,
  extendBoxVertical: 0,
  crossSampling: !1,
  mustPreDraw: !1,
  preservesOpaqueness: !1,
  animated: !1,
  parameters: [
    ["Skend", 0, "float"],
    ["Power", 0, "float"],
  ],
};
self.C3_Shaders.blurvertical = {
  glsl: "varying mediump vec2 vTex;\nuniform mediump sampler2D samplerFront;\nuniform mediump vec2 pixelSize;\nuniform mediump float intensity;\nvoid main(void)\n{\nmediump vec4 sum = vec4(0.0);\nmediump float pixelHeight = pixelSize.y;\nmediump float halfPixelHeight = pixelHeight / 2.0;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 7.0 + halfPixelHeight)) * 0.06;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 5.0 + halfPixelHeight)) * 0.10;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 3.0 + halfPixelHeight)) * 0.13;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 1.0 + halfPixelHeight)) * 0.16;\nmediump vec4 front = texture2D(samplerFront, vTex);\nsum += front * 0.10;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 1.0 + halfPixelHeight)) * 0.16;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 3.0 + halfPixelHeight)) * 0.13;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 5.0 + halfPixelHeight)) * 0.10;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 7.0 + halfPixelHeight)) * 0.06;\ngl_FragColor = mix(front, sum, intensity);\n}",
  wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nintensity : f32;\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3_UTILITY_FUNCTIONS%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@stage(fragment)\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar pixelHeight : f32 = c3_getPixelSize(textureFront).y;\nvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\nvar sum : vec4<f32> =\ntextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 7.5)) * 0.06 +\ntextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 5.5)) * 0.10 +\ntextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 3.5)) * 0.13 +\ntextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 1.5)) * 0.16 +\nfront * 0.10 +\ntextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 1.5)) * 0.16 +\ntextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 3.5)) * 0.13 +\ntextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 5.5)) * 0.10 +\ntextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 7.5)) * 0.06;\nvar output : FragmentOutput;\noutput.color = mix(front, sum, shaderParams.intensity);\nreturn output;\n}",
  blendsBackground: !1,
  usesDepth: !1,
  extendBoxHorizontal: 0,
  extendBoxVertical: 8,
  crossSampling: !1,
  mustPreDraw: !1,
  preservesOpaqueness: !1,
  animated: !1,
  parameters: [["intensity", 0, "percent"]],
};
self.C3_Shaders.vignette = {
  glsl: "varying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 srcStart;\nuniform mediump vec2 srcEnd;\nuniform mediump float vignetteStart;\nuniform mediump float vignetteEnd;\nvoid main(void)\n{\nlowp vec4 front = texture2D(samplerFront, vTex);\nlowp float a = front.a;\nif (a != 0.0)\nfront.rgb /= a;\nmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\nlowp float d = distance(tex, vec2(0.5, 0.5));\nfront.rgb *= smoothstep(vignetteEnd, vignetteStart, d);\nfront.rgb *= a;\ngl_FragColor = front;\n}",
  wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nvignetteStart : f32;\nvignetteEnd : f32;\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3PARAMS_STRUCT%%\n%%C3_UTILITY_FUNCTIONS%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\nlet center : vec2<f32> = vec2<f32>(0.5);\n@stage(fragment)\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\nvar rgb : vec3<f32> = front.rgb;\nvar tex : vec2<f32> = c3_srcToNorm(input.fragUV);\nvar d : f32 = distance(tex, center);\nrgb = rgb * smoothStep(shaderParams.vignetteEnd, shaderParams.vignetteStart, d);\nvar output : FragmentOutput;\noutput.color = vec4<f32>(rgb * front.a, front.a);\nreturn output;\n}",
  blendsBackground: !1,
  usesDepth: !1,
  extendBoxHorizontal: 0,
  extendBoxVertical: 0,
  crossSampling: !1,
  mustPreDraw: !1,
  preservesOpaqueness: !0,
  animated: !1,
  parameters: [
    ["vignetteStart", 0, "percent"],
    ["vignetteEnd", 0, "percent"],
  ],
};
("use strict");
{
  const e = self.C3;
  let b = null,
    a = "",
    c = "",
    d = [],
    f = "",
    h = "",
    g = "";
  const k = e.New(e.ArrayStack);
  function m(q, v) {
    q = q[1];
    v = v[1];
    if ("number" === typeof q && "number" === typeof v) return q - v;
    q = "" + q;
    v = "" + v;
    return q < v ? -1 : q > v ? 1 : 0;
  }
  e.Plugins.System = class extends e.SDKPluginBase {
    constructor(q) {
      super(q);
      this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack();
      this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
      this._imagesLoadingComplete = this._imagesLoadingTotal = 0;
      this._functionMaps = new Map();
    }
    Release() {
      super.Release();
    }
    UpdateRender() {
      this._runtime.UpdateRender();
    }
    Trigger(q) {
      this._runtime.Trigger(q, null, null);
    }
    GetRegex(q, v) {
      (b && q === a && v === c) || ((b = new RegExp(q, v)), (a = q), (c = v));
      b.lastIndex = 0;
      return b;
    }
    GetRegexMatches(q, v, r) {
      if (q === f && v === h && r === g) return d;
      const n = this.GetRegex(v, r);
      d = q.match(n);
      f = q;
      h = v;
      g = r;
      return d;
    }
    async _LoadTexturesForObjectClasses(q, v) {
      if (v.length) {
        this._imagesLoadingTotal += v.length;
        var r = [];
        for (const n of v) r.push(q.MaybeLoadTexturesFor(n));
        await e.PromiseAllWithProgress(r, () => {
          this._imagesLoadingComplete++;
        });
        this._imagesLoadingComplete++;
        this._imagesLoadingComplete === this._imagesLoadingTotal &&
          (this._runtime.Trigger(
            e.Plugins.System.Cnds.OnImageLoadingComplete,
            null,
            null
          ),
          (this._imagesLoadingTotal = this._imagesLoadingComplete = 0));
      }
    }
    _UnloadTexturesForObjectClasses(q, v) {
      for (const r of v)
        0 === r.GetInstanceCount() && q.MaybeUnloadTexturesFor(r);
    }
    _GetForEachStack() {
      return k;
    }
    _Repeat(q) {
      var v = this._runtime.GetEventSheetManager();
      const r = v.GetEventStack(),
        n = r.GetCurrentStackFrame(),
        p = n.GetCurrentEvent(),
        u = p.GetSolModifiers();
      var w = n.IsSolModifierAfterCnds();
      const y = r.Push(p),
        B = v.GetLoopStack(),
        E = B.Push();
      E.SetEnd(q);
      if (w)
        for (w = 0; w < q && !E.IsStopped(); ++w)
          v.PushCopySol(u), E.SetIndex(w), p.Retrigger(n, y), v.PopSol(u);
      else
        for (v = 0; v < q && !E.IsStopped(); ++v)
          E.SetIndex(v), p.Retrigger(n, y);
      r.Pop();
      B.Pop();
      return !1;
    }
    *_DebugRepeat(q) {
      var v = this._runtime.GetEventSheetManager();
      const r = v.GetEventStack(),
        n = r.GetCurrentStackFrame(),
        p = n.GetCurrentEvent(),
        u = p.GetSolModifiers();
      var w = n.IsSolModifierAfterCnds();
      const y = r.Push(p),
        B = v.GetLoopStack(),
        E = B.Push();
      E.SetEnd(q);
      if (w)
        for (w = 0; w < q && !E.IsStopped(); ++w)
          v.PushCopySol(u),
            E.SetIndex(w),
            yield* p.DebugRetrigger(n, y),
            v.PopSol(u);
      else
        for (v = 0; v < q && !E.IsStopped(); ++v)
          E.SetIndex(v), yield* p.DebugRetrigger(n, y);
      r.Pop();
      B.Pop();
      return !1;
    }
    _While() {
      var q = this._runtime.GetEventSheetManager();
      const v = q.GetEventStack(),
        r = v.GetCurrentStackFrame(),
        n = r.GetCurrentEvent(),
        p = n.GetSolModifiers();
      var u = r.IsSolModifierAfterCnds();
      const w = v.Push(n),
        y = q.GetLoopStack(),
        B = y.Push();
      if (u)
        for (u = 0; !B.IsStopped(); ++u)
          q.PushCopySol(p),
            B.SetIndex(u),
            n.Retrigger(r, w) || B.Stop(),
            q.PopSol(p);
      else
        for (q = 0; !B.IsStopped(); ++q)
          B.SetIndex(q), n.Retrigger(r, w) || B.Stop();
      v.Pop();
      y.Pop();
      return !1;
    }
    *_DebugWhile() {
      var q = this._runtime.GetEventSheetManager();
      const v = q.GetEventStack(),
        r = v.GetCurrentStackFrame(),
        n = r.GetCurrentEvent(),
        p = n.GetSolModifiers();
      var u = r.IsSolModifierAfterCnds();
      const w = v.Push(n),
        y = q.GetLoopStack(),
        B = y.Push();
      if (u)
        for (u = 0; !B.IsStopped(); ++u)
          q.PushCopySol(p),
            B.SetIndex(u),
            (yield* n.DebugRetrigger(r, w)) || B.Stop(),
            q.PopSol(p);
      else
        for (q = 0; !B.IsStopped(); ++q)
          B.SetIndex(q), (yield* n.DebugRetrigger(r, w)) || B.Stop();
      v.Pop();
      y.Pop();
      return !1;
    }
    _For(q, v, r) {
      var n = this._runtime.GetEventSheetManager();
      const p = n.GetEventStack(),
        u = p.GetCurrentStackFrame(),
        w = u.GetCurrentEvent(),
        y = w.GetSolModifiers(),
        B = u.IsSolModifierAfterCnds(),
        E = p.Push(w),
        z = n.GetLoopStack(),
        D = z.Push();
      D.SetName(q);
      D.SetEnd(r);
      if (r < v)
        if (B)
          for (q = v; q >= r && !D.IsStopped(); --q)
            n.PushCopySol(y), D.SetIndex(q), w.Retrigger(u, E), n.PopSol(y);
        else
          for (n = v; n >= r && !D.IsStopped(); --n)
            D.SetIndex(n), w.Retrigger(u, E);
      else if (B)
        for (q = v; q <= r && !D.IsStopped(); ++q)
          n.PushCopySol(y), D.SetIndex(q), w.Retrigger(u, E), n.PopSol(y);
      else
        for (n = v; n <= r && !D.IsStopped(); ++n)
          D.SetIndex(n), w.Retrigger(u, E);
      p.Pop();
      z.Pop();
      return !1;
    }
    *_DebugFor(q, v, r) {
      var n = this._runtime.GetEventSheetManager();
      const p = n.GetEventStack(),
        u = p.GetCurrentStackFrame(),
        w = u.GetCurrentEvent(),
        y = w.GetSolModifiers(),
        B = u.IsSolModifierAfterCnds(),
        E = p.Push(w),
        z = n.GetLoopStack(),
        D = z.Push();
      D.SetName(q);
      D.SetEnd(r);
      if (r < v)
        if (B)
          for (q = v; q >= r && !D.IsStopped(); --q)
            n.PushCopySol(y),
              D.SetIndex(q),
              yield* w.DebugRetrigger(u, E),
              n.PopSol(y);
        else
          for (n = v; n >= r && !D.IsStopped(); --n)
            D.SetIndex(n), yield* w.DebugRetrigger(u, E);
      else if (B)
        for (q = v; q <= r && !D.IsStopped(); ++q)
          n.PushCopySol(y),
            D.SetIndex(q),
            yield* w.DebugRetrigger(u, E),
            n.PopSol(y);
      else
        for (n = v; n <= r && !D.IsStopped(); ++n)
          D.SetIndex(n), yield* w.DebugRetrigger(u, E);
      p.Pop();
      z.Pop();
      return !1;
    }
    _ForEach(q) {
      var v = this._runtime.GetEventSheetManager();
      const r = v.GetEventStack(),
        n = r.GetCurrentStackFrame(),
        p = n.GetCurrentEvent(),
        u = p.GetSolModifiers();
      var w = n.IsSolModifierAfterCnds();
      const y = r.Push(p),
        B = v.GetLoopStack(),
        E = B.Push(),
        z = q.IsInContainer(),
        D = q.GetCurrentSol(),
        J = k.Push();
      e.shallowAssignArray(J, D.GetInstances());
      E.SetEnd(J.length);
      if (w)
        for (let C = 0, H = J.length; C < H && !E.IsStopped(); ++C)
          v.PushCopySol(u),
            (w = J[C]),
            q.GetCurrentSol().SetSinglePicked(w),
            z && w.SetSiblingsSinglePicked(),
            E.SetIndex(C),
            p.Retrigger(n, y),
            v.PopSol(u);
      else {
        D._SetSelectAll(!1);
        q = D._GetOwnInstances();
        e.clearArray(q);
        q.push(null);
        for (let C = 0, H = J.length; C < H && !E.IsStopped(); ++C)
          (v = J[C]),
            (q[0] = v),
            z && v.SetSiblingsSinglePicked(),
            E.SetIndex(C),
            p.Retrigger(n, y);
      }
      r.Pop();
      B.Pop();
      e.clearArray(J);
      k.Pop();
      return !1;
    }
    *_DebugForEach(q) {
      var v = this._runtime.GetEventSheetManager();
      const r = v.GetEventStack(),
        n = r.GetCurrentStackFrame(),
        p = n.GetCurrentEvent(),
        u = p.GetSolModifiers();
      var w = n.IsSolModifierAfterCnds();
      const y = r.Push(p),
        B = v.GetLoopStack(),
        E = B.Push(),
        z = q.IsInContainer(),
        D = q.GetCurrentSol(),
        J = k.Push();
      e.shallowAssignArray(J, D.GetInstances());
      E.SetEnd(J.length);
      if (w)
        for (let C = 0, H = J.length; C < H && !E.IsStopped(); ++C)
          v.PushCopySol(u),
            (w = J[C]),
            q.GetCurrentSol().SetSinglePicked(w),
            z && w.SetSiblingsSinglePicked(),
            E.SetIndex(C),
            yield* p.DebugRetrigger(n, y),
            v.PopSol(u);
      else {
        D._SetSelectAll(!1);
        q = D._GetOwnInstances();
        e.clearArray(q);
        q.push(null);
        for (let C = 0, H = J.length; C < H && !E.IsStopped(); ++C)
          (v = J[C]),
            (q[0] = v),
            z && v.SetSiblingsSinglePicked(),
            E.SetIndex(C),
            yield* p.DebugRetrigger(n, y);
      }
      r.Pop();
      B.Pop();
      e.clearArray(J);
      k.Pop();
      return !1;
    }
    _ForEachOrdered(q, v) {
      var r = this._runtime.GetEventSheetManager();
      const n = r.GetEventStack(),
        p = r.GetCurrentCondition(),
        u = n.GetCurrentStackFrame(),
        w = u.GetCurrentEvent(),
        y = w.GetSolModifiers(),
        B = u.IsSolModifierAfterCnds(),
        E = n.Push(w),
        z = r.GetLoopStack(),
        D = z.Push(),
        J = q.IsInContainer(),
        C = q.GetCurrentSol(),
        H = k.Push();
      e.clearArray(H);
      const K = C.GetInstances();
      D.SetEnd(K.length);
      for (let P = 0, S = K.length; P < S; ++P)
        H.push([K[P], p.ReevaluateParameter(1, P)]);
      H.sort(m);
      1 === v && H.reverse();
      if (B)
        for (let P = 0, S = H.length; P < S && !D.IsStopped(); ++P)
          r.PushCopySol(y),
            (v = H[P][0]),
            q.GetCurrentSol().SetSinglePicked(v),
            J && v.SetSiblingsSinglePicked(),
            D.SetIndex(P),
            w.Retrigger(u, E),
            r.PopSol(y);
      else {
        C._SetSelectAll(!1);
        q = C._GetOwnInstances();
        e.clearArray(q);
        q.push(null);
        for (let P = 0, S = H.length; P < S && !D.IsStopped(); ++P)
          (r = H[P][0]),
            (q[0] = r),
            J && r.SetSiblingsSinglePicked(),
            D.SetIndex(P),
            w.Retrigger(u, E);
      }
      n.Pop();
      z.Pop();
      e.clearArray(H);
      k.Pop();
      return !1;
    }
    *_DebugForEachOrdered(q, v) {
      var r = this._runtime.GetEventSheetManager();
      const n = r.GetEventStack(),
        p = r.GetCurrentCondition(),
        u = n.GetCurrentStackFrame(),
        w = u.GetCurrentEvent(),
        y = w.GetSolModifiers(),
        B = u.IsSolModifierAfterCnds(),
        E = n.Push(w),
        z = r.GetLoopStack(),
        D = z.Push(),
        J = q.IsInContainer(),
        C = q.GetCurrentSol(),
        H = k.Push();
      e.clearArray(H);
      const K = C.GetInstances();
      D.SetEnd(K.length);
      for (let P = 0, S = K.length; P < S; ++P)
        H.push([K[P], p.ReevaluateParameter(1, P)]);
      H.sort(m);
      1 === v && H.reverse();
      if (B)
        for (let P = 0, S = H.length; P < S && !D.IsStopped(); ++P)
          r.PushCopySol(y),
            (v = H[P][0]),
            q.GetCurrentSol().SetSinglePicked(v),
            J && v.SetSiblingsSinglePicked(),
            D.SetIndex(P),
            yield* w.DebugRetrigger(u, E),
            r.PopSol(y);
      else {
        C._SetSelectAll(!1);
        q = C._GetOwnInstances();
        e.clearArray(q);
        q.push(null);
        for (let P = 0, S = H.length; P < S && !D.IsStopped(); ++P)
          (r = H[P][0]),
            (q[0] = r),
            J && r.SetSiblingsSinglePicked(),
            D.SetIndex(P),
            yield* w.DebugRetrigger(u, E);
      }
      n.Pop();
      z.Pop();
      e.clearArray(H);
      k.Pop();
      return !1;
    }
    _GetFunctionMap(q, v) {
      let r = this._functionMaps.get(q);
      if (r) return r;
      if (!v) return null;
      r = { defaultFunc: null, strMap: new Map() };
      this._functionMaps.set(q, r);
      return r;
    }
    _DoCallMappedFunction(q, v, r, n, p) {
      v.GetEventBlock().RunAsMappedFunctionCall(r);
      n && q.PopSol(p);
    }
    *_DebugDoCallMappedFunction(q, v, r, n, p) {
      yield* v.GetEventBlock().DebugRunAsMappedFunctionCall(r);
      n && q.PopSol(p);
    }
  };
}
{
  const e = self.C3;
  e.Plugins.System.Type = class extends e.DefendedBase {
    constructor(b) {
      super();
      this._objectClass = b;
      this._runtime = b.GetRuntime();
      this._plugin = b.GetPlugin();
    }
    OnCreate() {}
    Release() {
      this._plugin = this._runtime = this._objectClass = null;
    }
  };
}
{
  const e = self.C3;
  e.Plugins.System.Instance = class extends e.DefendedBase {
    constructor(b, a) {
      super();
      this._inst = b;
      this._objectClass = this._inst.GetObjectClass();
      this._sdkType = this._objectClass.GetSdkType();
      this._runtime = this._inst.GetRuntime();
    }
    Release() {
      this._runtime = this._sdkType = this._objectClass = this._inst = null;
    }
  };
}
{
  const e = self.C3,
    b = [];
  e.Plugins.System.Cnds = {
    EveryTick() {
      return !0;
    },
    OnLayoutStart() {
      return !0;
    },
    OnLayoutEnd() {
      return !0;
    },
    OnSuspend() {
      return !0;
    },
    OnResume() {
      return !0;
    },
    IsSuspended() {
      return this._runtime.IsSuspended();
    },
    Else() {
      const a = this._runtime.GetCurrentEventStackFrame();
      return a.GetElseBranchRan() ? !1 : !a.GetLastEventTrue();
    },
    TriggerOnce() {
      const a = this._runtime.GetCurrentCondition().GetSavedDataMap();
      let c = a.get("TriggerOnce_lastTick");
      "undefined" === typeof c && ((c = -1), a.set("TriggerOnce_lastTick", -1));
      const d = this._runtime.GetTickCount();
      a.set("TriggerOnce_lastTick", d);
      return this._runtime.IsLayoutFirstTick() || c !== d - 1;
    },
    Every(a) {
      const c = this._runtime.GetCurrentCondition().GetSavedDataMap(),
        d = c.get("Every_lastTime") || 0,
        f = this._runtime.GetGameTime();
      c.has("Every_seconds") || c.set("Every_seconds", a);
      const h = c.get("Every_seconds");
      if (f >= d + h)
        return (
          c.set("Every_lastTime", d + h),
          f >= c.get("Every_lastTime") + 0.04 && c.set("Every_lastTime", f),
          c.set("Every_seconds", a),
          !0
        );
      f < d - 0.1 && c.set("Every_lastTime", f);
      return !1;
    },
    IsGroupActive(a) {
      return (
        (a = this._runtime.GetEventSheetManager().GetEventGroupByName(a)) &&
        a.IsGroupActive()
      );
    },
    IsPreview() {
      return this._runtime.IsPreview();
    },
    IsMobile() {
      return e.Platform.IsMobile;
    },
    OnLoadFinished() {
      return !0;
    },
    OnCanvasSnapshot() {
      return !0;
    },
    EffectsSupported() {
      return !0;
    },
    OnSaveComplete() {
      return !0;
    },
    OnSaveFailed() {
      return !0;
    },
    OnLoadComplete() {
      return !0;
    },
    OnLoadFailed() {
      return !0;
    },
    ObjectUIDExists(a) {
      return !!this._runtime.GetInstanceByUID(a);
    },
    IsOnPlatform(a) {
      switch (a) {
        case 0:
          return "browser" === e.Platform.Context;
        case 1:
          return "iOS" === e.Platform.OS;
        case 2:
          return "Android" === e.Platform.OS;
        case 8:
          return "cordova" === e.Platform.Context;
        case 9:
          return "scirra-arcade" === this._runtime.GetExportType();
        case 10:
          return "nwjs" === e.Platform.Context;
        case 13:
          return "windows-uwp" === this._runtime.GetExportType();
        default:
          return !1;
      }
    },
    RegexTest(a, c, d) {
      return this.GetRegex(c, d).test(a);
    },
    Compare(a, c, d) {
      return e.compare(a, c, d);
    },
    CompareBetween(a, c, d) {
      return a >= c && a <= d;
    },
    CompareVar(a, c, d) {
      return e.compare(a.GetValue(), c, d);
    },
    CompareBoolVar(a) {
      return !!a.GetValue();
    },
    CompareTime(a, c) {
      const d = this._runtime.GetGameTime();
      return 0 === a
        ? ((a = this._runtime.GetCurrentCondition().GetSavedDataMap()),
          !a.get("CompareTime_executed") && d >= c
            ? (a.set("CompareTime_executed", !0), !0)
            : !1)
        : e.compare(d, a, c);
    },
    IsNaN(a) {
      return isNaN(a);
    },
    AngleWithin(a, c, d) {
      return e.angleDiff(e.toRadians(a), e.toRadians(d)) <= e.toRadians(c);
    },
    IsClockwiseFrom(a, c) {
      return e.angleClockwise(e.toRadians(a), e.toRadians(c));
    },
    IsBetweenAngles(a, c, d) {
      a = e.toRadians(a);
      c = e.toRadians(c);
      d = e.toRadians(d);
      return e.angleClockwise(d, c)
        ? e.angleClockwise(a, c) && !e.angleClockwise(a, d)
        : !(!e.angleClockwise(a, c) && e.angleClockwise(a, d));
    },
    IsValueType(a, c) {
      return "number" === typeof a ? 0 === c : 1 === c;
    },
    EvaluateExpression(a) {
      return !!a;
    },
    PickByComparison(a, c, d, f) {
      if (!a) return !1;
      const h = this._GetForEachStack(),
        g = h.Push(),
        k = a.GetCurrentSol();
      e.shallowAssignArray(g, k.GetInstances());
      k.IsSelectAll() && e.clearArray(k._GetOwnElseInstances());
      const m = this._runtime.GetCurrentCondition();
      let q = 0;
      for (let v = 0, r = g.length; v < r; ++v) {
        const n = g[v];
        g[q] = n;
        c = m.ReevaluateParameter(1, v);
        f = m.ReevaluateParameter(3, v);
        e.compare(c, d, f) ? ++q : k._PushElseInstance(n);
      }
      e.truncateArray(g, q);
      k.SetArrayPicked(g);
      c = !!g.length;
      e.clearArray(g);
      h.Pop();
      a.ApplySolToContainer();
      return c;
    },
    PickByEvaluate(a, c) {
      if (!a) return !1;
      const d = this._GetForEachStack(),
        f = d.Push(),
        h = a.GetCurrentSol();
      e.shallowAssignArray(f, h.GetInstances());
      h.IsSelectAll() && e.clearArray(h._GetOwnElseInstances());
      const g = this._runtime.GetCurrentCondition();
      let k = 0;
      for (let m = 0, q = f.length; m < q; ++m) {
        const v = f[m];
        f[k] = v;
        (c = g.ReevaluateParameter(1, m)) ? ++k : h._PushElseInstance(v);
      }
      e.truncateArray(f, k);
      h.SetArrayPicked(f);
      c = !!f.length;
      e.clearArray(f);
      d.Pop();
      a.ApplySolToContainer();
      return c;
    },
    PickNth(a, c) {
      if (!a) return !1;
      const d = a.GetCurrentSol(),
        f = d.GetInstances();
      c = Math.floor(c);
      if (c >= f.length) return !1;
      d.PickOne(f[c]);
      a.ApplySolToContainer();
      return !0;
    },
    PickRandom(a) {
      if (!a) return !1;
      const c = a.GetCurrentSol(),
        d = c.GetInstances(),
        f = Math.floor(this._runtime.Random() * d.length);
      if (f >= d.length) return !1;
      c.PickOne(d[f]);
      a.ApplySolToContainer();
      return !0;
    },
    PickAll(a) {
      if (!a || !a.GetInstanceCount()) return !1;
      a.GetCurrentSol()._SetSelectAll(!0);
      a.ApplySolToContainer();
      return !0;
    },
    PickOverlappingPoint(a, c, d) {
      if (!a) return !1;
      const f = a.GetCurrentSol();
      var h = f.GetInstances();
      const g = this._runtime.GetCurrentEvent().IsOrBlock(),
        k = this._runtime.GetCurrentCondition().IsInverted();
      f.IsSelectAll()
        ? (e.shallowAssignArray(b, h), f.ClearArrays(), f._SetSelectAll(!1))
        : g
        ? (e.shallowAssignArray(b, f._GetOwnElseInstances()),
          e.clearArray(f._GetOwnElseInstances()))
        : (e.shallowAssignArray(b, f._GetOwnInstances()),
          e.clearArray(f._GetOwnInstances()));
      for (let m = 0, q = b.length; m < q; ++m)
        (h = b[m]),
          e.xor(h.GetWorldInfo().ContainsPoint(c, d), k)
            ? f._PushInstance(h)
            : f._PushElseInstance(h);
      a.ApplySolToContainer();
      return e.xor(!!f._GetOwnInstances().length, k);
    },
    PickLastCreated(a) {
      if (!a) return !1;
      var c = a.IsFamily();
      let d = null;
      const f = this._runtime._GetInstancesPendingCreate();
      for (let h = f.length - 1; 0 <= h; --h) {
        const g = f[h];
        if (c) {
          if (g.GetObjectClass().BelongsToFamily(a)) {
            d = g;
            break;
          }
        } else if (g.GetObjectClass() === a) {
          d = g;
          break;
        }
      }
      d || ((c = a.GetInstances()), c.length && (d = c.at(-1)));
      if (!d) return !1;
      a.GetCurrentSol().PickOne(d);
      a.ApplySolToContainer();
      return !0;
    },
    Repeat(a) {
      return this._runtime.IsDebugging()
        ? this._DebugRepeat(a)
        : this._Repeat(a);
    },
    While() {
      return this._runtime.IsDebugging() ? this._DebugWhile() : this._While();
    },
    For(a, c, d) {
      return this._runtime.IsDebugging()
        ? this._DebugFor(a, c, d)
        : this._For(a, c, d);
    },
    ForEach(a) {
      return this._runtime.IsDebugging()
        ? this._DebugForEach(a)
        : this._ForEach(a);
    },
    ForEachOrdered(a, c, d) {
      return this._runtime.IsDebugging()
        ? this._DebugForEachOrdered(a, d)
        : this._ForEachOrdered(a, d);
    },
    LayerVisible(a) {
      return a ? a.IsVisible() : !1;
    },
    LayerInteractive(a) {
      return a ? a.IsSelfAndParentsInteractive() : !1;
    },
    LayerEmpty(a) {
      return a ? !a.GetInstanceCount() : !1;
    },
    LayerCmpOpacity(a, c, d) {
      return a ? e.compare(100 * a.GetOpacity(), c, d) : !1;
    },
    OnImageLoadingComplete() {
      return !0;
    },
    IsLoadingImages() {
      return 0 < this._imagesLoadingTotal;
    },
  };
}
{
  const e = self.C3;
  function b(g, k) {
    const m = g[0] - k[0];
    return 0 !== m ? m : g[1] - k[1];
  }
  function a(g, k) {
    return g[1] - k[1];
  }
  const c = [],
    d = [],
    f = e.New(e.Rect),
    h = e.New(e.Color);
  e.Plugins.System.Acts = {
    SetVar(g, k) {
      g.SetValue(k);
    },
    AddVar(g, k) {
      g.IsNumber() && "number" !== typeof k && (k = parseFloat(k));
      g.SetValue(g.GetValue() + k);
    },
    SubVar(g, k) {
      g.IsNumber() && g.SetValue(g.GetValue() - k);
    },
    SetBoolVar(g, k) {
      g.SetValue(!!k);
    },
    ToggleBoolVar(g) {
      g.SetValue(!g.GetValue());
    },
    ResetGlobals() {
      this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue();
    },
    CreateObject(g, k, m, q, v, r) {
      g &&
        k &&
        (m = this._runtime.CreateInstance(g, k, m, q, v, r)) &&
        (v && k.SortAndAddInstancesByZIndex(m),
        (k = this._runtime.GetEventSheetManager()),
        k.BlockFlushingInstances(!0),
        m._TriggerOnCreatedOnSelfAndRelated(),
        k.BlockFlushingInstances(!1),
        g.GetCurrentSol().SetSinglePicked(m),
        m.IsInContainer() && m.SetSiblingsSinglePicked());
    },
    CreateObjectByName(g, k, m, q, v, r) {
      g &&
        k &&
        (g = this._runtime.GetObjectClassByName(g)) &&
        e.Plugins.System.Acts.CreateObject.call(this, g, k, m, q, v, r);
    },
    RecreateInitialObjects(g, k, m, q, v, r, n, p, u, w) {
      if (g) {
        var y = this._runtime.GetCurrentLayout();
        if (
          r &&
          ((y = this._runtime.GetLayoutManager().GetLayoutByName(r)), !y)
        )
          return;
        r = null;
        if ("number" !== typeof n || 0 <= n)
          if (((r = y.GetLayer(n)), !r)) return;
        f.set(k, m, q, v);
        k = y.RecreateInitialObjects(g, f, r, p, u, w);
        g.GetCurrentSol().SetArrayPicked(k);
        g.ApplySolToContainer();
      }
    },
    StopLoop() {
      const g = this._loopStack;
      g.IsInLoop() && g.GetCurrent().Stop();
    },
    SetGroupActive(g, k) {
      (g = this._runtime.GetEventSheetManager().GetEventGroupByName(g)) &&
        (0 === k
          ? g.SetGroupActive(!1)
          : 1 === k
          ? g.SetGroupActive(!0)
          : g.SetGroupActive(!g.IsGroupActive()));
    },
    SetTimescale(g) {
      this._runtime.SetTimeScale(g);
    },
    SetObjectTimescale(g, k) {
      0 > k && (k = 0);
      if (g) {
        g = g.GetCurrentSol().GetInstances();
        for (const m of g) m.SetTimeScale(k);
      }
    },
    RestoreObjectTimescale(g) {
      if (g) {
        g = g.GetCurrentSol().GetInstances();
        for (const k of g) k.RestoreTimeScale();
      }
    },
    Wait(g) {
      if (!(0 > g))
        return (
          this._runtime.GetEventSheetManager().AddScheduledWait().InitTimer(g),
          !0
        );
    },
    WaitForSignal(g) {
      this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(g);
      return !0;
    },
    WaitForPreviousActions() {
      const g = this._runtime.GetEventSheetManager();
      g.AddScheduledWait().InitPromise(g.GetPromiseForAllAsyncActions());
      return !0;
    },
    Signal(g) {
      g = g.toLowerCase();
      for (const k of this._runtime.GetEventSheetManager().scheduledWaits())
        k.IsSignal() && k.GetSignalTag() === g && k.SetSignalled();
    },
    async SnapshotCanvas(g, k, m, q, v, r) {
      const n = this._runtime.GetCanvasManager();
      n &&
        (this.UpdateRender(),
        await n.SnapshotCanvas(
          0 === g ? "image/png" : "image/jpeg",
          k / 100,
          m,
          q,
          v,
          r
        ),
        await this._runtime.TriggerAsync(
          e.Plugins.System.Cnds.OnCanvasSnapshot,
          null
        ));
    },
    SetCanvasSize(g, k) {
      if (!(0 >= g || 0 >= k)) {
        this._runtime.SetViewportSize(g, k);
        this._runtime.GetCurrentLayout().BoundScrolling();
        var m = this._runtime.GetCanvasManager();
        m &&
          ("off" !== m.GetCurrentFullscreenMode() &&
            this._runtime.SetOriginalViewportSize(g, k),
          m.SetSize(m.GetLastWidth(), m.GetLastHeight(), !0),
          this._runtime.UpdateRender());
      }
    },
    SetFullscreenQuality(g) {
      const k = this._runtime.GetCanvasManager();
      k &&
        "off" !== k.GetCurrentFullscreenMode() &&
        (k.SetFullscreenScalingQuality(0 !== g ? "high" : "low"),
        k.SetSize(k.GetLastWidth(), k.GetLastHeight(), !0));
    },
    SaveState(g) {
      this._runtime.SaveToSlot(g);
    },
    LoadState(g) {
      this._runtime.LoadFromSlot(g);
    },
    LoadStateJSON(g) {
      this._runtime.LoadFromJsonString(g);
    },
    SetHalfFramerateMode(g) {},
    ResetPersisted() {
      for (const g of this._runtime.GetLayoutManager().GetAllLayouts())
        g.ResetPersistData();
    },
    SetPixelRounding(g) {
      this._runtime.SetPixelRoundingEnabled(0 !== g);
    },
    SetMinimumFramerate(g) {
      this._runtime.SetMinimumFramerate(g);
    },
    SortZOrderByInstVar(g, k) {
      if (g) {
        var m = g.GetCurrentSol().GetInstances(),
          q = this._runtime.GetCurrentLayout(),
          v = g.IsFamily();
        g = g.GetFamilyIndex();
        for (let n = 0, p = m.length; n < p; ++n) {
          var r = m[n];
          const u = r.GetWorldInfo();
          if (!u) continue;
          let w;
          w = v
            ? r.GetInstanceVariableValue(
                k + r.GetObjectClass().GetFamilyInstanceVariableOffset(g)
              )
            : r.GetInstanceVariableValue(k);
          c.push([u.GetLayer().GetIndex(), u.GetZIndex()]);
          d.push([r, w]);
        }
        if (c.length) {
          c.sort(b);
          d.sort(a);
          k = !1;
          for (let n = 0, p = c.length; n < p; ++n)
            (m = d[n][0]),
              (v = q.GetLayerByIndex(c[n][0])),
              (g = c[n][1]),
              (r = v._GetInstances()),
              r[g] !== m &&
                ((r[g] = m),
                m.GetWorldInfo()._SetLayer(v),
                v.SetZIndicesChanged(),
                (k = !0));
          k && this._runtime.UpdateRender();
          e.clearArray(c);
          e.clearArray(d);
        }
      }
    },
    GoToLayout(g) {
      if (!this._runtime.IsLoading()) {
        var k = this._runtime.GetLayoutManager();
        k.IsPendingChangeMainLayout() || k.ChangeMainLayout(g);
      }
    },
    GoToLayoutByName(g) {
      if (!this._runtime.IsLoading()) {
        var k = this._runtime.GetLayoutManager();
        k.IsPendingChangeMainLayout() ||
          ((g = k.GetLayoutByName(g)) && k.ChangeMainLayout(g));
      }
    },
    NextPrevLayout(g) {
      if (!this._runtime.IsLoading()) {
        var k = this._runtime.GetLayoutManager();
        if (!k.IsPendingChangeMainLayout()) {
          var m = k.GetAllLayouts(),
            q = m.indexOf(k.GetMainRunningLayout());
          (g && 0 === q) ||
            ((g || q !== m.length - 1) &&
              k.ChangeMainLayout(m[q + (g ? -1 : 1)]));
        }
      }
    },
    RestartLayout() {
      if (!this._runtime.IsLoading()) {
        var g = this._runtime.GetLayoutManager();
        g.IsPendingChangeMainLayout() ||
          (g.ChangeMainLayout(g.GetMainRunningLayout()),
          this._runtime
            .GetEventSheetManager()
            .ResetAllGroupsInitialActivation());
      }
    },
    SetLayerVisible(g, k) {
      g && g.SetVisible(k);
    },
    SetLayerInteractive(g, k) {
      g && g.SetInteractive(k);
    },
    SetLayerOpacity(g, k) {
      g && g.SetOpacity(k / 100);
    },
    SetLayerScale(g, k) {
      g && g.SetOwnScale(k);
    },
    SetLayerScaleRate(g, k) {
      g && g.SetScaleRate(k);
    },
    SetLayerAngle(g, k) {
      g && g.SetAngle(e.toRadians(+k));
    },
    SetLayerScroll(g, k, m) {
      g &&
        (g.SetOwnScrollPositionEnabled(!0), g.SetScrollX(k), g.SetScrollY(m));
    },
    RestoreLayerScroll(g) {
      g && g.SetOwnScrollPositionEnabled(!1);
    },
    SetLayerParallax(g, k, m) {
      g && g.SetParallax(k / 100, m / 100);
    },
    SetLayerZElevation(g, k) {
      g && g.SetZElevation(+k);
    },
    SetLayerBackground(g, k) {
      g &&
        (h.setFromRgbValue(k),
        h.clamp(),
        (g = g.GetBackgroundColor()),
        g.equalsIgnoringAlpha(h) || (g.copyRgb(h), this.UpdateRender()));
    },
    SetLayerTransparent(g, k) {
      g && g.SetTransparent(k);
    },
    SetLayerBlendMode(g, k) {
      g && g.SetBlendMode(k);
    },
    SetLayerEffectEnabled(g, k, m) {
      g &&
        (m = g.GetEffectList().GetEffectTypeByName(m)) &&
        ((k = 1 === k),
        m.IsActive() !== k &&
          (m.SetActive(k),
          g.UpdateActiveEffects(),
          this._runtime.UpdateRender()));
    },
    SetLayerEffectParam(g, k, m, q) {
      if (g && ((g = g.GetEffectList()), (k = g.GetEffectTypeByName(k)))) {
        m = Math.floor(m);
        var v = k.GetShaderProgram().GetParameterType(m);
        v &&
          ("color" === v
            ? (h.setFromRgbValue(q), (q = h))
            : "percent" === v && (q /= 100),
          g.SetEffectParameter(k.GetIndex(), m, q) &&
            k.IsActive() &&
            this._runtime.UpdateRender());
      }
    },
    SetLayerForceOwnTexture(g, k) {
      g && g.SetForceOwnTexture(k);
    },
    SetLayoutScale(g) {
      this._runtime.GetCurrentLayout().SetScale(+g);
    },
    SetLayoutAngle(g) {
      this._runtime.GetCurrentLayout().SetAngle(e.toRadians(+g));
    },
    SetLayoutEffectEnabled(g, k) {
      const m = this._runtime.GetCurrentLayout();
      if ((k = m.GetEffectList().GetEffectTypeByName(k)))
        (g = 1 === g),
          k.IsActive() !== g &&
            (k.SetActive(g),
            m.UpdateActiveEffects(),
            this._runtime.UpdateRender());
    },
    SetLayoutEffectParam(g, k, m) {
      const q = this._runtime.GetCurrentLayout().GetEffectList();
      if ((g = q.GetEffectTypeByName(g))) {
        k = Math.floor(k);
        var v = g.GetShaderProgram().GetParameterType(k);
        v &&
          ("color" === v
            ? (h.setFromRgbValue(m), (m = h))
            : "percent" === v && (m /= 100),
          q.SetEffectParameter(g.GetIndex(), k, m) &&
            g.IsActive() &&
            this._runtime.UpdateRender());
      }
    },
    SetLayoutVanishingPoint(g, k) {
      this._runtime.GetCurrentLayout().SetVanishingPointXY(g / 100, k / 100);
    },
    SetLayoutProjection(g) {
      const k = this._runtime.GetCurrentLayout();
      0 === g ? k.SetPerspectiveProjection() : k.SetOrthographicProjection();
    },
    ScrollX(g) {
      this._runtime.GetCurrentLayout().SetScrollX(g);
    },
    ScrollY(g) {
      this._runtime.GetCurrentLayout().SetScrollY(g);
    },
    Scroll(g, k) {
      const m = this._runtime.GetCurrentLayout();
      m.SetScrollX(g);
      m.SetScrollY(k);
    },
    ScrollToObject(g) {
      if (g && (g = g.GetFirstPicked()) && (g = g.GetWorldInfo())) {
        var k = this._runtime.GetCurrentLayout();
        k.SetScrollX(g.GetX());
        k.SetScrollY(g.GetY());
      }
    },
    async LoadObjectTextures(g) {
      const k = this._runtime.GetMainRunningLayout();
      k &&
        g &&
        !this._runtime.IsLoading() &&
        ((g = g.IsFamily() ? g.GetFamilyMembers() : [g]),
        await this._LoadTexturesForObjectClasses(k, g));
    },
    async LoadObjectTexturesByName(g) {
      await e.Plugins.System.Acts.LoadObjectTextures.call(
        this,
        this._runtime.GetObjectClassByName(g)
      );
    },
    UnloadObjectTextures(g) {
      const k = this._runtime.GetMainRunningLayout();
      k &&
        g &&
        ((g = g.IsFamily() ? g.GetFamilyMembers() : [g]),
        this._UnloadTexturesForObjectClasses(k, g));
    },
    UnloadObjectTexturesByName(g) {
      e.Plugins.System.Acts.UnloadObjectTextures.call(
        this,
        this._runtime.GetObjectClassByName(g)
      );
    },
    UnloadUnusedTextures() {
      const g = this._runtime.GetMainRunningLayout();
      if (g) {
        var k = g._GetTextureLoadedObjectTypes();
        this._UnloadTexturesForObjectClasses(g, k);
      }
    },
    async LoadLayoutTextures(g) {
      const k = this._runtime.GetMainRunningLayout();
      g &&
        k &&
        !this._runtime.IsLoading() &&
        (await this._LoadTexturesForObjectClasses(
          k,
          g._GetInitialObjectClasses()
        ));
    },
    async LoadLayoutTexturesByName(g) {
      const k = this._runtime.GetMainRunningLayout();
      (g = this._runtime.GetLayoutManager().GetLayoutByName(g)) &&
        k &&
        !this._runtime.IsLoading() &&
        (await this._LoadTexturesForObjectClasses(
          k,
          g._GetInitialObjectClasses()
        ));
    },
    SetFunctionReturnValue(g) {
      const k = this._eventStack.GetCurrentExpFuncStackFrame();
      if (k)
        switch (k.GetFunctionReturnType()) {
          case 1:
            "number" === typeof g && k.SetFunctionReturnValue(g);
            break;
          case 2:
            "string" === typeof g && k.SetFunctionReturnValue(g);
            break;
          case 3:
            k.SetFunctionReturnValue(g);
        }
    },
    MapFunction(g, k, m) {
      var q = this._GetFunctionMap(g.toLowerCase(), !0);
      const v = q.strMap,
        r = k.toLowerCase();
      v.has(r) &&
        console.warn(
          `[Construct 3] Function map '${g}' string '${k}' already in map; overwriting entry`
        );
      if ((q = e.first(v.values()) || q.defaultFunc)) {
        q = 0 !== q.GetReturnType();
        const n = 0 !== m.GetReturnType();
        if (q !== n) {
          console.error(
            `[Construct 3] Function map '${g}' string '${k}' function return type not compatible with other functions in the map; entry ignored`
          );
          return;
        }
      }
      v.set(r, m);
    },
    MapFunctionDefault(g, k) {
      const m = this._GetFunctionMap(g.toLowerCase(), !0);
      m.defaultFunc &&
        console.warn(
          `[Construct 3] Function map '${g}' already has a default; overwriting entry`
        );
      var q = e.first(m.strMap.values()) || m.defaultFunc;
      if (q) {
        q = 0 !== q.GetReturnType();
        const v = 0 !== k.GetReturnType();
        if (q !== v) {
          console.error(
            `[Construct 3] Function map '${g}' default: function return type not compatible with other functions in the map; entry ignored`
          );
          return;
        }
      }
      m.defaultFunc = k;
    },
    CallMappedFunction(g, k, m) {
      m = Math.floor(m);
      var q = this._GetFunctionMap(g.toLowerCase(), !1);
      if (q) {
        var v = q.strMap.get(k.toLowerCase());
        if (!v)
          if (q.defaultFunc) (v = q.defaultFunc), (m = 0);
          else {
            console.warn(
              `[Construct 3] Call mapped function: no function associated with map '${g}' string '${k}'; call ignored (consider setting a default)`
            );
            return;
          }
        if (v.IsEnabled())
          if (0 !== v.GetReturnType())
            console.warn(
              `[Construct 3] Call mapped function: map '${g}' string '${k}' has a return type so cannot be called`
            );
          else {
            g = this._runtime;
            k = g.GetEventSheetManager();
            var r = k.GetCurrentEvent();
            q = r.GetSolModifiersIncludingParents();
            var n = 0 < q.length;
            n && k.PushCleanSol(q);
            var p = [];
            if ((r = k.FindFirstFunctionBlockParent(r))) {
              r = r.GetFunctionParameters();
              for (let u = m, w = r.length; u < w; ++u) p.push(r[u].GetValue());
            }
            m = v.GetFunctionParameters();
            for (let u = p.length, w = m.length; u < w; ++u)
              p.push(m[u].GetInitialValue());
            return g.IsDebugging()
              ? this._DebugDoCallMappedFunction(k, v, p, n, q)
              : this._DoCallMappedFunction(k, v, p, n, q);
          }
      } else
        console.warn(
          `[Construct 3] Call mapped function: map name '${g}' not found; call ignored`
        );
    },
  };
}
{
  const e = self.C3;
  e.Plugins.System.Exps = {
    int: function (b) {
      "string" === typeof b && ((b = parseInt(b, 10)), isNaN(b) && (b = 0));
      return Math.floor(b);
    },
    float: function (b) {
      "string" === typeof b && ((b = parseFloat(b)), isNaN(b) && (b = 0));
      return b;
    },
    str(b) {
      return b.toString();
    },
    len(b) {
      return "string" === typeof b ? b.length : 0;
    },
    random(b, a) {
      return "undefined" === typeof a
        ? this._runtime.Random() * b
        : this._runtime.Random() * (a - b) + b;
    },
    choose(...b) {
      const a = Math.floor(this._runtime.Random() * b.length);
      return b[a];
    },
    pi() {
      return Math.PI;
    },
    infinity() {
      return Infinity;
    },
    sqrt(b) {
      return Math.sqrt(b);
    },
    abs(b) {
      return Math.abs(b);
    },
    round(b) {
      return Math.round(b);
    },
    roundtodp(b, a) {
      a = Math.max(Math.floor(a), 0);
      a = Math.pow(10, a);
      return Math.round((b + Number.EPSILON) * a) / a;
    },
    floor(b) {
      return Math.floor(b);
    },
    ceil(b) {
      return Math.ceil(b);
    },
    sign(b) {
      return Math.sign(b);
    },
    sin(b) {
      return Math.sin(e.toRadians(b));
    },
    cos(b) {
      return Math.cos(e.toRadians(b));
    },
    tan(b) {
      return Math.tan(e.toRadians(b));
    },
    asin(b) {
      return e.toDegrees(Math.asin(b));
    },
    acos(b) {
      return e.toDegrees(Math.acos(b));
    },
    atan(b) {
      return e.toDegrees(Math.atan(b));
    },
    exp(b) {
      return Math.exp(b);
    },
    ln(b) {
      return Math.log(b);
    },
    log10(b) {
      return Math.log(b) / Math.LN10;
    },
    max(...b) {
      let a = b[0];
      "number" !== typeof a && (a = 0);
      for (let c = 1, d = b.length; c < d; ++c) {
        let f = b[c];
        "number" === typeof f && a < f && (a = f);
      }
      return a;
    },
    min(...b) {
      let a = b[0];
      "number" !== typeof a && (a = 0);
      for (let c = 1, d = b.length; c < d; ++c) {
        let f = b[c];
        "number" === typeof f && a > f && (a = f);
      }
      return a;
    },
    clamp(b, a, c) {
      return e.clamp(b, a, c);
    },
    distance(b, a, c, d) {
      return e.distanceTo(b, a, c, d);
    },
    angle(b, a, c, d) {
      return e.toDegrees(e.angleTo(b, a, c, d));
    },
    lerp(b, a, c) {
      return e.lerp(b, a, c);
    },
    unlerp(b, a, c) {
      return e.unlerp(b, a, c);
    },
    qarp(b, a, c, d) {
      return e.qarp(b, a, c, d);
    },
    cubic(b, a, c, d, f) {
      return e.cubic(b, a, c, d, f);
    },
    cosp(b, a, c) {
      return e.cosp(b, a, c);
    },
    anglediff(b, a) {
      return e.toDegrees(e.angleDiff(e.toRadians(b), e.toRadians(a)));
    },
    anglelerp(b, a, c) {
      return e.toDegrees(e.angleLerp(e.toRadians(b), e.toRadians(a), c));
    },
    anglerotate(b, a, c) {
      return e.toDegrees(
        e.angleRotate(e.toRadians(b), e.toRadians(a), e.toRadians(c))
      );
    },
    setbit(b, a, c) {
      a |= 0;
      return ((b | 0) & ~(1 << a)) | ((0 !== c ? 1 : 0) << a);
    },
    togglebit(b, a) {
      return (b | 0) ^ (1 << (a | 0));
    },
    getbit(b, a) {
      return (b | 0) & (1 << (a | 0)) ? 1 : 0;
    },
    newline() {
      return "\n";
    },
    uppercase(b) {
      return "string" === typeof b ? b.toUpperCase() : "";
    },
    lowercase(b) {
      return "string" === typeof b ? b.toLowerCase() : "";
    },
    left(b, a) {
      return "string" === typeof b ? b.substr(0, a) : "";
    },
    mid(b, a, c) {
      return "string" !== typeof b ? "" : 0 > c ? b.substr(a) : b.substr(a, c);
    },
    right(b, a) {
      return "string" === typeof b ? b.substr(Math.max(b.length - a, 0)) : "";
    },
    trim(b) {
      return "string" === typeof b ? b.trim() : "";
    },
    tokenat(b, a, c) {
      if ("string" !== typeof b || "string" !== typeof c) return "";
      b = b.split(c);
      a = Math.floor(a);
      return 0 > a || a >= b.length ? "" : b[a];
    },
    tokencount(b, a) {
      return "string" === typeof b && "string" === typeof a && b.length
        ? b.split(a).length
        : 0;
    },
    find(b, a) {
      return "string" === typeof b && "string" === typeof a
        ? b.search(new RegExp(e.EscapeRegex(a), "i"))
        : -1;
    },
    findcase(b, a) {
      return "string" === typeof b && "string" === typeof a
        ? b.search(new RegExp(e.EscapeRegex(a), ""))
        : -1;
    },
    replace(b, a, c) {
      return "string" === typeof b &&
        "string" === typeof a &&
        "string" === typeof c
        ? b.replace(new RegExp(e.EscapeRegex(a), "gi"), c)
        : "string" === typeof b
        ? b
        : "";
    },
    regexsearch(b, a, c) {
      a = this.GetRegex(a, c);
      return b ? b.search(a) : -1;
    },
    regexreplace(b, a, c, d) {
      a = this.GetRegex(a, c);
      return b ? b.replace(a, d) : "";
    },
    regexmatchcount(b, a, c) {
      return (b = this.GetRegexMatches(b.toString(), a, c)) ? b.length : 0;
    },
    regexmatchat(b, a, c, d) {
      d = Math.floor(d);
      b = this.GetRegexMatches(b.toString(), a, c);
      return !b || 0 > d || d >= b.length ? "" : b[d];
    },
    zeropad(b, a) {
      let c = 0 > b ? "-" : "";
      0 > b && (b = -b);
      c += "0".repeat(Math.max(a - b.toString().length, 0));
      return c + b.toString();
    },
    urlencode(b) {
      return encodeURIComponent(b);
    },
    urldecode(b) {
      return decodeURIComponent(b);
    },
    dt() {
      return this._runtime._GetDtFast();
    },
    timescale() {
      return this._runtime.GetTimeScale();
    },
    wallclocktime() {
      return (Date.now() - this._runtime.GetStartTime()) / 1e3;
    },
    unixtime() {
      return Date.now();
    },
    time() {
      return this._runtime.GetGameTime();
    },
    tickcount() {
      return this._runtime.GetTickCount();
    },
    objectcount() {
      return this._runtime.GetObjectCount();
    },
    fps() {
      return this._runtime.GetFPS();
    },
    cpuutilisation() {
      return this._runtime.GetMainThreadTime();
    },
    gpuutilisation() {
      return this._runtime.GetGPUUtilisation();
    },
    windowwidth() {
      return this._runtime.GetCanvasManager().GetDeviceWidth();
    },
    windowheight() {
      return this._runtime.GetCanvasManager().GetDeviceHeight();
    },
    originalwindowwidth() {
      return this._runtime.GetOriginalViewportWidth();
    },
    originalwindowheight() {
      return this._runtime.GetOriginalViewportHeight();
    },
    originalviewportwidth() {
      return this._runtime.GetOriginalViewportWidth();
    },
    originalviewportheight() {
      return this._runtime.GetOriginalViewportHeight();
    },
    scrollx() {
      return this._runtime.GetCurrentLayout().GetScrollX();
    },
    scrolly() {
      return this._runtime.GetCurrentLayout().GetScrollY();
    },
    layoutname() {
      return this._runtime.GetCurrentLayout().GetName();
    },
    layoutscale() {
      return this._runtime.GetCurrentLayout().GetScale();
    },
    layoutangle() {
      return e.toDegrees(this._runtime.GetCurrentLayout().GetAngle());
    },
    layoutwidth() {
      return this._runtime.GetCurrentLayout().GetWidth();
    },
    layoutheight() {
      return this._runtime.GetCurrentLayout().GetHeight();
    },
    vanishingpointx() {
      return 100 * this._runtime.GetCurrentLayout().GetVanishingPointX();
    },
    vanishingpointy() {
      return 100 * this._runtime.GetCurrentLayout().GetVanishingPointY();
    },
    viewportleft(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.GetViewport3D().getLeft()
        : 0;
    },
    viewporttop(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.GetViewport3D().getTop()
        : 0;
    },
    viewportright(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.GetViewport3D().getRight()
        : 0;
    },
    viewportbottom(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.GetViewport3D().getBottom()
        : 0;
    },
    viewportwidth(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.GetViewport3D().width()
        : 0;
    },
    viewportheight(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.GetViewport3D().height()
        : 0;
    },
    canvastolayerx(b, a, c) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.CanvasCssToLayer(a, c)[0]
        : 0;
    },
    canvastolayery(b, a, c) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.CanvasCssToLayer(a, c)[1]
        : 0;
    },
    layertocanvasx(b, a, c) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.LayerToCanvasCss(a, c)[0]
        : 0;
    },
    layertocanvasy(b, a, c) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.LayerToCanvasCss(a, c)[1]
        : 0;
    },
    layerscale(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.GetOwnScale()
        : 0;
    },
    layerangle(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? e.toDegrees(b.GetOwnAngle())
        : 0;
    },
    layeropacity(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? 100 * b.GetOpacity()
        : 0;
    },
    layerscalerate(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.GetScaleRate()
        : 0;
    },
    layerscrollx(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.GetScrollX()
        : 0;
    },
    layerscrolly(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.GetScrollY()
        : 0;
    },
    layerparallaxx(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? 100 * b.GetParallaxX()
        : 0;
    },
    layerparallaxy(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? 100 * b.GetParallaxY()
        : 0;
    },
    layerzelevation(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.GetZElevation()
        : 0;
    },
    layerindex(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b))
        ? b.GetIndex()
        : -1;
    },
    canvassnapshot() {
      const b = this._runtime.GetCanvasManager();
      return b ? b.GetCanvasSnapshotUrl() : "";
    },
    loopindex(b) {
      const a = this._loopStack;
      return a.IsInLoop()
        ? b
          ? (b = a.FindByName(b))
            ? b.GetIndex()
            : 0
          : a.GetCurrent().GetIndex()
        : 0;
    },
    savestatejson() {
      return this._runtime.GetLastSaveJsonString();
    },
    callmapped(b, a, ...c) {
      var d = this._GetFunctionMap(b.toLowerCase(), !1);
      if (!d)
        return (
          console.warn(
            `[Construct 3] Call mapped function: map name '${b}' not found; returning 0`
          ),
          0
        );
      var f = d.strMap.get(a.toLowerCase());
      if (!f)
        if (d.defaultFunc) f = d.defaultFunc;
        else
          return (
            console.warn(
              `[Construct 3] Call mapped function: no function associated with map '${b}' string '${a}'; returning 0 (consider setting a default)`
            ),
            0
          );
      d = f.GetReturnType();
      const h = f.GetDefaultReturnValue();
      if (0 === d)
        return (
          console.warn(
            `[Construct 3] Call mapped function: map '${b}' string '${a}' has no return type so cannot be called from an expression; returning 0`
          ),
          0
        );
      if (!f.IsEnabled()) return h;
      b = this._runtime.GetEventSheetManager();
      a = b.GetCurrentEvent().GetSolModifiersIncludingParents();
      const g = 0 < a.length;
      g && b.PushCleanSol(a);
      const k = f.GetFunctionParameters();
      for (let m = c.length, q = k.length; m < q; ++m)
        c.push(k[m].GetInitialValue());
      f = f.GetEventBlock();
      c = f.RunAsExpressionFunctionCall(
        f.GetSolModifiersIncludingParents(),
        d,
        h,
        ...c
      );
      g && b.PopSol(a);
      return c;
    },
    loadingprogress() {
      return this._runtime.GetAssetManager().GetLoadProgress();
    },
    imageloadingprogress() {
      return 0 === this._imagesLoadingTotal
        ? 1
        : this._imagesLoadingComplete / this._imagesLoadingTotal;
    },
    renderer() {
      return this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl";
    },
    rendererdetail() {
      return this._runtime.GetWebGPURenderer()
        ? "<unavailable>"
        : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer();
    },
    imagememoryusage() {
      let b = this._runtime.GetRenderer().GetEstimatedTextureMemoryUsage();
      return Math.round((100 * b) / 1048576) / 100;
    },
    rgb(b, a, c) {
      return e.PackRGB(b, a, c);
    },
    rgbex(b, a, c) {
      return e.PackRGBEx(b / 100, a / 100, c / 100);
    },
    rgba(b, a, c, d) {
      return e.PackRGBAEx(b / 100, a / 100, c / 100, d / 100);
    },
    rgbex255(b, a, c) {
      return e.PackRGBEx(b / 255, a / 255, c / 255);
    },
    rgba255(b, a, c, d) {
      return e.PackRGBAEx(b / 255, a / 255, c / 255, d / 255);
    },
    projectname() {
      return this._runtime.GetProjectName();
    },
    projectversion() {
      return this._runtime.GetProjectVersion();
    },
    currenteventsheetname() {
      return this._runtime.GetCurrentEvent().GetEventSheet().GetName();
    },
    currenteventnumber() {
      return this._runtime.GetCurrentEvent().GetDisplayNumber();
    },
  };
}
("use strict");
{
  const e = self.C3;
  e.Plugins.Text = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Text.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
    LoadTextures(b) {}
    ReleaseTextures() {}
  };
}
{
  const e = self.C3,
    b = self.C3X,
    a = [0, 0, 0],
    c = ["left", "center", "right"],
    d = ["top", "center", "bottom"],
    f = new e.Rect(),
    h = new e.Quad(),
    g = new e.Color();
  e.Plugins.Text.Instance = class extends e.SDKWorldInstanceBase {
    constructor(r, n) {
      super(r);
      this._text = "";
      this._enableBBcode = !0;
      this._faceName = "Arial";
      this._ptSize = 12;
      this._lineHeightOffset = 0;
      this._isItalic = this._isBold = !1;
      this._color = e.New(e.Color);
      this._verticalAlign = this._horizontalAlign = 0;
      this._wrapByWord = !0;
      this._typewriterEndTime = this._typewriterStartTime = -1;
      this._typewriterLength = 0;
      this._rendererText = e.New(
        e.Gfx.RendererText,
        this._runtime.GetRenderer(),
        { timeout: 5 }
      );
      this._rendererText.ontextureupdate = () => this._runtime.UpdateRender();
      this._rendererText.SetIsAsync(!1);
      n &&
        ((this._text = n[0]),
        (this._enableBBcode = !!n[1]),
        (this._faceName = n[2]),
        (this._ptSize = n[3]),
        (this._lineHeightOffset = n[4]),
        (this._isBold = !!n[5]),
        (this._isItalic = !!n[6]),
        (this._horizontalAlign = n[8]),
        (this._verticalAlign = n[9]),
        (this._wrapByWord = 0 === n[10]),
        (r = n[7]),
        this._color.setRgb(r[0], r[1], r[2]),
        this.GetWorldInfo().SetVisible(n[11]));
      this._UpdateTextSettings();
    }
    Release() {
      this._CancelTypewriter();
      this._rendererText.Release();
      this._rendererText = null;
      super.Release();
    }
    _UpdateTextSettings() {
      const r = this._rendererText;
      r.SetText(this._text);
      r.SetBBCodeEnabled(this._enableBBcode);
      r.SetFontName(this._faceName);
      r.SetLineHeight(this._lineHeightOffset);
      r.SetBold(this._isBold);
      r.SetItalic(this._isItalic);
      r.SetColor(this._color);
      r.SetHorizontalAlignment(c[this._horizontalAlign]);
      r.SetVerticalAlignment(d[this._verticalAlign]);
      r.SetWordWrapMode(this._wrapByWord ? "word" : "character");
    }
    _UpdateTextSize() {
      const r = this.GetWorldInfo();
      this._rendererText.SetFontSize(this._ptSize);
      this._rendererText.SetFontSizeScale(r.GetSceneGraphScale());
      var n = r.GetLayer();
      n = n.GetRenderScale() * n.Get2DScaleFactorToZ(r.GetTotalZElevation());
      this._rendererText.SetSize(r.GetWidth(), r.GetHeight(), n);
    }
    Draw(r) {
      var n = this.GetWorldInfo();
      this._UpdateTextSize();
      const p = this._rendererText.GetTexture();
      if (p) {
        var u = n.GetLayer();
        if (
          0 === n.GetAngle() &&
          0 === u.GetAngle() &&
          0 === n.GetTotalZElevation() &&
          !n.HasMesh() &&
          u.RendersIn2DMode()
        ) {
          n = n.GetBoundingQuad();
          const [w, y] = u.LayerToDrawSurface(n.getTlx(), n.getTly()),
            [B, E] = u.LayerToDrawSurface(n.getBrx(), n.getBry());
          n = w - Math.round(w);
          const z = y - Math.round(y);
          f.set(w, y, B, E);
          f.offset(-n, -z);
          h.setFromRect(f);
          const [D, J] = r.GetRenderTargetSize(r.GetRenderTarget());
          this._runtime.GetCanvasManager().SetDeviceTransform(r, D, J);
          r.SetTexture(p);
          r.Quad3(h, this._rendererText.GetTexRect());
          u._SetTransform(r);
        } else
          r.SetTexture(p),
            n.HasMesh() ? this._DrawMesh(n, r) : this._DrawStandard(n, r);
      }
    }
    _DrawStandard(r, n) {
      r = r.GetBoundingQuad();
      this._runtime.IsPixelRoundingEnabled() && (r = this._PixelRoundQuad(r));
      n.Quad3(r, this._rendererText.GetTexRect());
    }
    _DrawMesh(r, n) {
      const p = r.GetTransformedMesh();
      if (r.IsMeshChanged()) {
        r.CalculateBbox(f, h, !1);
        let u = h;
        this._runtime.IsPixelRoundingEnabled() && (u = this._PixelRoundQuad(u));
        p.CalculateTransformedMesh(
          r.GetSourceMesh(),
          u,
          this._rendererText.GetTexRect()
        );
        r.SetMeshChanged(!1);
      }
      p.Draw(n);
    }
    _PixelRoundQuad(r) {
      const n = r.getTlx() - Math.round(r.getTlx()),
        p = r.getTly() - Math.round(r.getTly());
      if (0 === n && 0 === p) return r;
      h.copy(r);
      h.offset(-n, -p);
      return h;
    }
    GetCurrentSurfaceSize() {
      const r = this._rendererText.GetTexture();
      return r ? [r.GetWidth(), r.GetHeight()] : [100, 100];
    }
    GetCurrentTexRect() {
      return this._rendererText.GetTexRect();
    }
    IsCurrentTexRotated() {
      return !1;
    }
    SaveToJson() {
      const r = {
        t: this._text,
        c: this._color.toJSON(),
        fn: this._faceName,
        ps: this._ptSize,
      };
      this._enableBBcode && (r.bbc = this._enableBBcode);
      0 !== this._horizontalAlign && (r.ha = this._horizontalAlign);
      0 !== this._verticalAlign && (r.va = this._verticalAlign);
      this._wrapByWord || (r.wr = this._wrapByWord);
      0 !== this._lineHeightOffset && (r.lho = this._lineHeightOffset);
      this._isBold && (r.b = this._isBold);
      this._isItalic && (r.i = this._isItalic);
      -1 !== this._typewriterEndTime &&
        (r.tw = {
          st: this._typewriterStartTime,
          en: this._typewriterEndTime,
          l: this._typewriterLength,
        });
      return r;
    }
    LoadFromJson(r) {
      this._CancelTypewriter();
      this._text = r.t;
      this._color.setFromJSON(r.c);
      this._faceName = r.fn;
      this._ptSize = r.ps;
      this._enableBBcode = r.hasOwnProperty("bbc") ? r.bbc : !1;
      this._horizontalAlign = r.hasOwnProperty("ha") ? r.ha : 0;
      this._verticalAlign = r.hasOwnProperty("va") ? r.va : 0;
      this._wrapByWord = r.hasOwnProperty("wr") ? r.wr : !0;
      this._lineHeightOffset = r.hasOwnProperty("lho") ? r.lho : 0;
      this._isBold = r.hasOwnProperty("b") ? r.b : !1;
      this._isItalic = r.hasOwnProperty("i") ? r.i : !1;
      r.hasOwnProperty("tw") &&
        ((r = r.tw),
        (this._typewriterStartTime = r.st),
        (this._typewriterEndTime = r.en),
        (this._typewriterLength = r.l));
      this._UpdateTextSettings();
      -1 !== this._typewriterEndTime && this._StartTicking();
    }
    GetPropertyValueByIndex(r) {
      switch (r) {
        case 0:
          return this._text;
        case 1:
          return this._enableBBcode;
        case 2:
          return this._faceName;
        case 3:
          return this._ptSize;
        case 4:
          return this._lineHeightOffset;
        case 5:
          return this._isBold;
        case 6:
          return this._isItalic;
        case 7:
          return (
            (a[0] = this._color.getR()),
            (a[1] = this._color.getG()),
            (a[2] = this._color.getB()),
            a
          );
        case 8:
          return this._horizontalAlign;
        case 9:
          return this._verticalAlign;
        case 10:
          return this._wrapByWord ? 1 : 0;
      }
    }
    SetPropertyValueByIndex(r, n) {
      switch (r) {
        case 0:
          if (this._text === n) break;
          this._text = n;
          this._UpdateTextSettings();
          break;
        case 1:
          if (this._enableBBcode === !!n) break;
          this._enableBBcode = !!n;
          this._UpdateTextSettings();
          break;
        case 2:
          if (this._faceName === n) break;
          this._faceName = n;
          this._UpdateTextSettings();
          break;
        case 3:
          if (this._ptSize === n) break;
          this._ptSize = n;
          this._UpdateTextSettings();
          break;
        case 4:
          if (this._lineHeightOffset === n) break;
          this._lineHeightOffset = n;
          this._UpdateTextSettings();
          break;
        case 5:
          if (this._isBold === !!n) break;
          this._isBold = !!n;
          this._UpdateTextSettings();
          break;
        case 6:
          if (this._isItalic === !!n) break;
          this._isItalic = !!n;
          this._UpdateTextSettings();
          break;
        case 7:
          r = this._color;
          if (r.getR() === n[0] && r.getG() === n[1] && r.getB() === n[2])
            break;
          this._color.setRgb(n[0], n[1], n[2]);
          this._UpdateTextSettings();
          break;
        case 8:
          if (this._horizontalAlign === n) break;
          this._horizontalAlign = n;
          this._UpdateTextSettings();
          break;
        case 9:
          if (this._verticalAlign === n) break;
          this._verticalAlign = n;
          this._UpdateTextSettings();
          break;
        case 10:
          this._wrapByWord !== (0 === n) &&
            ((this._wrapByWord = 0 === n), this._UpdateTextSettings());
      }
    }
    SetPropertyColorOffsetValueByIndex(r, n, p, u) {
      if (0 !== n || 0 !== p || 0 !== u)
        switch (r) {
          case 7:
            this._color.addRgb(n, p, u), this._UpdateTextSettings();
        }
    }
    _SetText(r) {
      this._text !== r &&
        ((this._text = r),
        this._rendererText.SetText(r),
        this._runtime.UpdateRender());
    }
    GetText() {
      return this._text;
    }
    _StartTypewriter(r, n) {
      this._SetText(r);
      this._typewriterStartTime = this._runtime.GetWallTime();
      this._typewriterEndTime =
        this._typewriterStartTime + n / this.GetInstance().GetActiveTimeScale();
      this._typewriterLength = e.BBString.StripAnyTags(r).length;
      this._rendererText.SetDrawMaxCharacterCount(0);
      this._StartTicking();
    }
    _CancelTypewriter() {
      this._typewriterEndTime = this._typewriterStartTime = -1;
      this._typewriterLength = 0;
      this._rendererText.SetDrawMaxCharacterCount(-1);
      this._StopTicking();
    }
    _FinishTypewriter() {
      -1 !== this._typewriterEndTime &&
        (this._CancelTypewriter(),
        this.Trigger(e.Plugins.Text.Cnds.OnTypewriterTextFinished),
        this._runtime.UpdateRender());
    }
    _SetFontFace(r) {
      this._faceName !== r &&
        ((this._faceName = r),
        this._rendererText.SetFontName(r),
        this._runtime.UpdateRender());
    }
    _GetFontFace() {
      return this._faceName;
    }
    _SetBold(r) {
      r = !!r;
      this._isBold !== r &&
        ((this._isBold = r),
        this._rendererText.SetBold(r),
        this._runtime.UpdateRender());
    }
    _IsBold() {
      return this._isBold;
    }
    _SetItalic(r) {
      r = !!r;
      this._isItalic !== r &&
        ((this._isItalic = r),
        this._rendererText.SetItalic(r),
        this._runtime.UpdateRender());
    }
    _IsItalic() {
      return this._isItalic;
    }
    _SetFontSize(r) {
      this._ptSize !== r && ((this._ptSize = r), this._runtime.UpdateRender());
    }
    _GetFontSize() {
      return this._ptSize;
    }
    _SetFontColor(r) {
      this._color.equalsIgnoringAlpha(r) ||
        (this._color.copyRgb(r),
        this._rendererText.SetColor(this._color),
        this._runtime.UpdateRender());
    }
    _GetFontColor() {
      return this._color;
    }
    _SetLineHeight(r) {
      this._lineHeightOffset !== r &&
        ((this._lineHeightOffset = r),
        this._UpdateTextSettings(),
        this._runtime.UpdateRender());
    }
    _GetLineHeight() {
      return this._lineHeightOffset;
    }
    _SetHAlign(r) {
      this._horizontalAlign !== r &&
        ((this._horizontalAlign = r),
        this._UpdateTextSettings(),
        this._runtime.UpdateRender());
    }
    _GetHAlign() {
      return this._horizontalAlign;
    }
    _SetVAlign(r) {
      this._verticalAlign !== r &&
        ((this._verticalAlign = r),
        this._UpdateTextSettings(),
        this._runtime.UpdateRender());
    }
    _GetVAlign() {
      return this._verticalAlign;
    }
    _SetWrapByWord(r) {
      r = !!r;
      this._wrapByWord !== r &&
        ((this._wrapByWord = r),
        this._UpdateTextSettings(),
        this._runtime.UpdateRender());
    }
    _IsWrapByWord() {
      return this._wrapByWord;
    }
    _GetTextWidth() {
      this._UpdateTextSize();
      return this._rendererText.GetTextWidth();
    }
    _GetTextHeight() {
      this._UpdateTextSize();
      return this._rendererText.GetTextHeight();
    }
    Tick() {
      var r = this._runtime.GetWallTime();
      r >= this._typewriterEndTime
        ? (this._CancelTypewriter(),
          this.Trigger(e.Plugins.Text.Cnds.OnTypewriterTextFinished),
          this._runtime.UpdateRender())
        : ((r = e.relerp(
            this._typewriterStartTime,
            this._typewriterEndTime,
            r,
            0,
            this._typewriterLength
          )),
          (r = Math.floor(r)),
          r !== this._rendererText.GetDrawMaxCharacterCount() &&
            (this._rendererText.SetDrawMaxCharacterCount(r),
            this._runtime.UpdateRender()));
    }
    GetDebuggerProperties() {
      return [
        {
          title: "plugins.text.name",
          properties: [
            {
              name: "plugins.text.properties.text.name",
              value: this._text,
              onedit: (r) => this._SetText(r),
            },
          ],
        },
      ];
    }
    GetScriptInterfaceClass() {
      return self.ITextInstance;
    }
  };
  const k = new WeakMap(),
    m = new Map([
      ["left", 0],
      ["center", 1],
      ["right", 2],
    ]),
    q = new Map([
      ["top", 0],
      ["center", 1],
      ["bottom", 2],
    ]),
    v = new Map([
      ["word", !0],
      ["character", !1],
    ]);
  self.ITextInstance = class extends self.IWorldInstance {
    constructor() {
      super();
      k.set(this, self.IInstance._GetInitInst().GetSdkInstance());
    }
    get text() {
      return k.get(this).GetText();
    }
    set text(r) {
      b.RequireString(r);
      const n = k.get(this);
      n._CancelTypewriter();
      n._SetText(r);
    }
    typewriterText(r, n) {
      b.RequireString(r);
      b.RequireFiniteNumber(n);
      const p = k.get(this);
      p._CancelTypewriter();
      p._StartTypewriter(r, n);
    }
    typewriterFinish() {
      k.get(this)._FinishTypewriter();
    }
    set fontFace(r) {
      b.RequireString(r);
      k.get(this)._SetFontFace(r);
    }
    get fontFace() {
      return k.get(this)._GetFontFace();
    }
    set isBold(r) {
      k.get(this)._SetBold(r);
    }
    get isBold() {
      return k.get(this)._IsBold();
    }
    set isItalic(r) {
      k.get(this)._SetItalic(r);
    }
    get isItalic() {
      return k.get(this)._IsItalic();
    }
    set sizePt(r) {
      b.RequireFiniteNumber(r);
      k.get(this)._SetFontSize(r);
    }
    get sizePt() {
      return k.get(this)._GetFontSize();
    }
    set fontColor(r) {
      b.RequireArray(r);
      if (3 > r.length) throw Error("expected 3 elements");
      g.setRgb(r[0], r[1], r[2]);
      k.get(this)._SetFontColor(g);
    }
    get fontColor() {
      const r = k.get(this)._GetFontColor();
      return [r.getR(), r.getG(), r.getB()];
    }
    set lineHeight(r) {
      b.RequireFiniteNumber(r);
      k.get(this)._SetLineHeight(r);
    }
    get lineHeight() {
      return k.get(this)._GetLineHeight();
    }
    set horizontalAlign(r) {
      b.RequireString(r);
      r = m.get(r);
      if ("undefined" === typeof r) throw Error("invalid mode");
      k.get(this)._SetHAlign(r);
    }
    get horizontalAlign() {
      return c[k.get(this)._GetHAlign()];
    }
    set verticalAlign(r) {
      b.RequireString(r);
      r = q.get(r);
      if ("undefined" === typeof r) throw Error("invalid mode");
      k.get(this)._SetVAlign(r);
    }
    get verticalAlign() {
      return d[k.get(this)._GetVAlign()];
    }
    set wordWrapMode(r) {
      b.RequireString(r);
      r = v.get(r);
      if ("undefined" === typeof r) throw Error("invalid mode");
      k.get(this)._SetWrapByWord(r);
    }
    get wordWrapMode() {
      return k.get(this)._IsWrapByWord() ? "word" : "character";
    }
    get textWidth() {
      return k.get(this)._GetTextWidth();
    }
    get textHeight() {
      return k.get(this)._GetTextHeight();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Text.Cnds = {
    CompareText(b, a) {
      return a ? this._text === b : e.equalsNoCase(this._text, b);
    },
    IsRunningTypewriterText() {
      return -1 !== this._typewriterEndTime;
    },
    OnTypewriterTextFinished() {
      return !0;
    },
  };
}
{
  const e = self.C3,
    b = e.New(e.Color);
  e.Plugins.Text.Acts = {
    SetText(a) {
      this._CancelTypewriter();
      "number" === typeof a && 1e9 > a && (a = Math.round(1e10 * a) / 1e10);
      this._SetText(a.toString());
    },
    AppendText(a) {
      this._CancelTypewriter();
      "number" === typeof a && 1e9 > a && (a = Math.round(1e10 * a) / 1e10);
      (a = a.toString()) && this._SetText(this._text + a);
    },
    TypewriterText(a, c) {
      this._CancelTypewriter();
      "number" === typeof a && 1e9 > a && (a = Math.round(1e10 * a) / 1e10);
      this._StartTypewriter(a.toString(), c);
    },
    SetFontFace(a, c) {
      let d = !1,
        f = !1;
      switch (c) {
        case 1:
          d = !0;
          break;
        case 2:
          f = !0;
          break;
        case 3:
          f = d = !0;
      }
      if (a !== this._faceName || d !== this._isBold || f !== this._isItalic)
        this._SetFontFace(a), this._SetBold(d), this._SetItalic(f);
    },
    SetFontSize(a) {
      this._SetFontSize(a);
    },
    SetFontColor(a) {
      b.setFromRgbValue(a);
      b.clamp();
      this._SetFontColor(b);
    },
    SetWebFont(a, c) {
      console.warn(
        "[Text] 'Set web font' action is deprecated and no longer has any effect"
      );
    },
    SetEffect(a) {
      this.GetWorldInfo().SetBlendMode(a);
      this._runtime.UpdateRender();
    },
    TypewriterFinish() {
      this._FinishTypewriter();
    },
    SetLineHeight(a) {
      this._SetLineHeight(a);
    },
    SetHAlign(a) {
      this._SetHAlign(a);
    },
    SetVAlign(a) {
      this._SetVAlign(a);
    },
    SetWrapping(a) {
      this._SetWrapByWord(0 === a);
    },
  };
}
{
  const e = self.C3;
  e.Plugins.Text.Exps = {
    Text() {
      return this._text;
    },
    PlainText() {
      return this._enableBBcode
        ? e.BBString.StripAnyTags(this._text)
        : this._text;
    },
    FaceName() {
      return this._faceName;
    },
    FaceSize() {
      return this._ptSize;
    },
    TextWidth() {
      return this._GetTextWidth();
    },
    TextHeight() {
      return this._GetTextHeight();
    },
    LineHeight() {
      return this._lineHeightOffset;
    },
  };
}
("use strict");
{
  const e = self.C3;
  e.Plugins.Sprite = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3,
    b = [];
  e.Plugins.Sprite.Type = class extends e.SDKTypeBase {
    constructor(a) {
      super(a);
      this._animations = a.GetAnimations();
    }
    Release() {
      e.clearArray(this._animations);
      super.Release();
    }
    OnCreate() {
      for (const a of this._animations) a.LoadAllAssets(this._runtime);
    }
    LoadTextures(a) {
      const c = { sampling: this._runtime.GetSampling() };
      return Promise.all(this._animations.map((d) => d.LoadAllTextures(a, c)));
    }
    ReleaseTextures() {
      for (const a of this._animations) a.ReleaseAllTextures();
    }
    OnDynamicTextureLoadComplete() {
      this._UpdateAllCurrentTexture();
    }
    _UpdateAllCurrentTexture() {
      for (const a of this._objectClass.instancesIncludingPendingCreate())
        a.GetSdkInstance()._UpdateCurrentTexture();
    }
    FinishCondition(a) {
      e.Plugins.Sprite.FinishCollisionCondition(this, a);
    }
    BeforeRunAction(a) {
      b.push({ objectClass: null, instances: [] });
    }
    _SpawnPickInstance(a, c) {
      const d = b.at(-1);
      d.objectClass = a;
      d.instances.push(c);
    }
    AfterRunAction(a) {
      a = b.pop();
      const c = a.objectClass;
      c &&
        (c.GetCurrentSol().SetArrayPicked(a.instances),
        c.ApplySolToContainer());
    }
  };
}
{
  const e = self.C3,
    b = self.C3X,
    a = e.New(e.Rect),
    c = e.New(e.Quad),
    d = e.New(e.Vector2);
  e.Plugins.Sprite.Instance = class extends e.SDKWorldInstanceBase {
    constructor(g, k) {
      super(g);
      let m = !0,
        q = "",
        v = 0,
        r = !0;
      k && ((m = !!k[0]), (q = k[1]), (v = k[2]), (r = k[3]));
      this._currentAnimation =
        this._objectClass.GetAnimationByName(q) ||
        this._objectClass.GetAnimations()[0];
      this._currentFrameIndex = e.clamp(
        v,
        0,
        this._currentAnimation.GetFrameCount() - 1
      );
      this._currentAnimationFrame = this._currentAnimation.GetFrameAt(
        this._currentFrameIndex
      );
      k = this._currentAnimationFrame.GetImageInfo();
      this._currentTexture = k.GetTexture();
      this._currentRcTex = k.GetTexRect();
      this._currentQuadTex = k.GetTexQuad();
      this.HandleWebGLContextLoss();
      g.SetFlag(2, !0);
      g.SetFlag(1, 0 <= this._currentAnimation.GetSpeed());
      this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed());
      this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo();
      this._animationTimer = e.New(e.KahanSum);
      this._animationRepeats = this._frameStartTime = 0;
      this._animTriggerName = "";
      this._changeAnimFrameIndex = -1;
      this._changeAnimationName = "";
      this._changeAnimationFrom = 0;
      g = this.GetWorldInfo();
      this._bquadRef = g.GetBoundingQuad();
      g.SetVisible(m);
      g.SetCollisionEnabled(r);
      g.SetOriginX(this._currentAnimationFrame.GetOriginX());
      g.SetOriginY(this._currentAnimationFrame.GetOriginY());
      g.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly());
      g.SetBboxChanged();
      (1 === this._objectClass.GetAnimationCount() &&
        1 === this._objectClass.GetAnimations()[0].GetFrameCount()) ||
        0 === this._currentAnimationSpeed ||
        this._StartTicking();
    }
    Release() {
      this._animationTimer =
        this._currentTexture =
        this._currentAnimationFrame =
        this._currentAnimation =
          null;
      super.Release();
    }
    GetCurrentImageInfo() {
      return this._currentAnimationFrame.GetImageInfo();
    }
    IsOriginalSizeKnown() {
      return !0;
    }
    OnWebGLContextLost() {
      this._currentTexture = null;
    }
    OnWebGLContextRestored() {
      this._UpdateCurrentTexture();
    }
    Draw(g) {
      var k = this._currentTexture;
      null !== k &&
        (g.SetTexture(k),
        (k = this.GetWorldInfo()),
        k.HasMesh() ? this._DrawMesh(k, g) : this._DrawStandard(k, g));
    }
    _DrawStandard(g, k) {
      let m = this._bquadRef;
      this._runtime.IsPixelRoundingEnabled() && (m = g.PixelRoundQuad(m));
      k.Quad4(m, this._currentQuadTex);
    }
    _DrawMesh(g, k) {
      const m = g.GetTransformedMesh();
      if (g.IsMeshChanged()) {
        g.CalculateBbox(a, c, !1);
        let q = c;
        this._runtime.IsPixelRoundingEnabled() && (q = g.PixelRoundQuad(q));
        m.CalculateTransformedMesh(g.GetSourceMesh(), q, this._currentQuadTex);
        g.SetMeshChanged(!1);
      }
      m.Draw(k);
    }
    GetAnimationTime() {
      return this._animationTimer.Get();
    }
    IsAnimationPlaying() {
      return this._inst.GetFlag(2);
    }
    SetAnimationPlaying(g) {
      this._inst.SetFlag(2, g);
    }
    IsPlayingForwards() {
      return this._inst.GetFlag(1);
    }
    SetPlayingForwards(g) {
      this._inst.SetFlag(1, g);
    }
    IsInAnimationTrigger() {
      return this._inst.GetFlag(4);
    }
    SetInAnimationTrigger(g) {
      this._inst.SetFlag(4, g);
    }
    Tick() {
      this._changeAnimationName && this._DoChangeAnimation();
      0 <= this._changeAnimFrameIndex && this._DoChangeAnimFrame();
      const g = this._currentAnimationSpeed;
      if (this.IsAnimationPlaying() && 0 !== g) {
        var k = this._runtime.GetDt(this._inst);
        this._animationTimer.Add(k);
        k = this.GetAnimationTime();
        var m = this._currentAnimationFrame,
          q = m.GetDuration() / g;
        if (!(k < this._frameStartTime + q)) {
          var v = this._currentAnimation,
            r = this._currentAnimationRepeatTo,
            n = v.GetFrameCount(),
            p = v.GetRepeatCount(),
            u = v.IsLooping(),
            w = v.IsPingPong();
          this.IsPlayingForwards()
            ? this._currentFrameIndex++
            : this._currentFrameIndex--;
          this._frameStartTime += q;
          this._currentFrameIndex >= n &&
            (w
              ? (this.SetPlayingForwards(!1), (this._currentFrameIndex = n - 2))
              : u
              ? (this._currentFrameIndex = r)
              : (this._animationRepeats++,
                this._animationRepeats >= p
                  ? this._FinishAnimation(!1)
                  : (this._currentFrameIndex = r)));
          0 > this._currentFrameIndex &&
            (w
              ? ((this._currentFrameIndex = 1),
                this.SetPlayingForwards(!0),
                u ||
                  (this._animationRepeats++,
                  this._animationRepeats >= p && this._FinishAnimation(!0)))
              : u
              ? (this._currentFrameIndex = r)
              : (this._animationRepeats++,
                this._animationRepeats >= p
                  ? this._FinishAnimation(!0)
                  : (this._currentFrameIndex = r)));
          this._currentFrameIndex = e.clamp(this._currentFrameIndex, 0, n - 1);
          q = v.GetFrameAt(this._currentFrameIndex);
          k > this._frameStartTime + q.GetDuration() / g &&
            (this._frameStartTime = k);
          this._OnFrameChanged(m, q);
        }
      } else this._StopTicking();
    }
    _FinishAnimation(g) {
      this._currentFrameIndex = g
        ? 0
        : this._currentAnimation.GetFrameCount() - 1;
      this.SetAnimationPlaying(!1);
      this._animTriggerName = this._currentAnimation.GetName();
      this.SetInAnimationTrigger(!0);
      this.DispatchScriptEvent("animationend", !1, {
        animationName: this._animTriggerName,
      });
      this.Trigger(e.Plugins.Sprite.Cnds.OnAnyAnimFinished);
      this.Trigger(e.Plugins.Sprite.Cnds.OnAnimFinished);
      this.SetInAnimationTrigger(!1);
      this._animationRepeats = 0;
    }
    _OnFrameChanged(g, k) {
      if (g !== k) {
        var m = this.GetWorldInfo(),
          q = g.GetImageInfo(),
          v = k.GetImageInfo(),
          r = q.GetWidth();
        q = q.GetHeight();
        var n = v.GetWidth(),
          p = v.GetHeight();
        r !== n && m.SetWidth(m.GetWidth() * (n / r));
        q !== p && m.SetHeight(m.GetHeight() * (p / q));
        m.SetOriginX(k.GetOriginX());
        m.SetOriginY(k.GetOriginY());
        m.SetSourceCollisionPoly(k.GetCollisionPoly());
        m.SetBboxChanged();
        this._currentAnimationFrame = k;
        this._currentTexture = v.GetTexture();
        this._currentRcTex = v.GetTexRect();
        this._currentQuadTex = v.GetTexQuad();
        m = this.GetInstance().GetBehaviorInstances();
        for (let u = 0, w = m.length; u < w; ++u)
          m[u].OnSpriteFrameChanged(g, k);
        this.DispatchScriptEvent("framechange", !1, {
          animationName: this._currentAnimation.GetName(),
          animationFrame: this._currentFrameIndex,
        });
        this.Trigger(e.Plugins.Sprite.Cnds.OnFrameChanged);
        this._runtime.UpdateRender();
      }
    }
    _StartAnim(g) {
      this.SetAnimationPlaying(!0);
      this._frameStartTime = this.GetAnimationTime();
      1 === g &&
        0 !== this._currentFrameIndex &&
        ((this._changeAnimFrameIndex = 0),
        this.IsInAnimationTrigger() || this._DoChangeAnimFrame());
      this._StartTicking();
    }
    _SetAnim(g, k) {
      this._changeAnimationName = g;
      this._changeAnimationFrom = k;
      this._StartTicking();
      this.IsInAnimationTrigger() || this._DoChangeAnimation();
    }
    _GetCurrentAnimation() {
      return this._currentAnimation;
    }
    _GetCurrentAnimationName() {
      return this._changeAnimationName
        ? this._changeAnimationName
        : this._currentAnimation.GetName();
    }
    _SetAnimFrame(g) {
      isFinite(g) &&
        ((this._changeAnimFrameIndex = g),
        this.IsInAnimationTrigger() || this._DoChangeAnimFrame());
    }
    _GetAnimFrame() {
      return this._currentFrameIndex;
    }
    _SetAnimSpeed(g) {
      this._currentAnimationSpeed = Math.abs(g);
      this.SetPlayingForwards(0 <= g);
      0 < this._currentAnimationSpeed && this._StartTicking();
    }
    _GetAnimSpeed() {
      return this.IsPlayingForwards()
        ? this._currentAnimationSpeed
        : -this._currentAnimationSpeed;
    }
    _SetAnimRepeatToFrame(g) {
      this._currentAnimationRepeatTo = g = e.clamp(
        Math.floor(g),
        0,
        this._currentAnimation.GetFrameCount() - 1
      );
    }
    _GetAnimRepeatToFrame() {
      return this._currentAnimationRepeatTo;
    }
    _DoChangeAnimation() {
      const g = this._currentAnimationFrame;
      var k = this._objectClass.GetAnimationByName(this._changeAnimationName);
      this._changeAnimationName = "";
      !k ||
        (k === this._currentAnimation && this.IsAnimationPlaying()) ||
        ((this._currentAnimation = k),
        this.SetPlayingForwards(0 <= k.GetSpeed()),
        (this._currentAnimationSpeed = Math.abs(k.GetSpeed())),
        (this._currentAnimationRepeatTo = k.GetRepeatTo()),
        (this._currentFrameIndex = e.clamp(
          this._currentFrameIndex,
          0,
          this._currentAnimation.GetFrameCount() - 1
        )),
        1 === this._changeAnimationFrom && (this._currentFrameIndex = 0),
        this.SetAnimationPlaying(!0),
        (this._frameStartTime = this.GetAnimationTime()),
        (k = this._currentAnimation.GetFrameAt(this._currentFrameIndex)),
        this._OnFrameChanged(g, k));
    }
    _DoChangeAnimFrame() {
      const g = this._currentAnimationFrame;
      var k = this._currentFrameIndex;
      this._currentFrameIndex = e.clamp(
        Math.floor(this._changeAnimFrameIndex),
        0,
        this._currentAnimation.GetFrameCount() - 1
      );
      this._changeAnimFrameIndex = -1;
      k !== this._currentFrameIndex &&
        ((k = this._currentAnimation.GetFrameAt(this._currentFrameIndex)),
        this._OnFrameChanged(g, k),
        (this._frameStartTime = this.GetAnimationTime()));
    }
    _UpdateCurrentTexture() {
      const g = this._currentAnimationFrame.GetImageInfo();
      this._currentTexture = g.GetTexture();
      this._currentRcTex = g.GetTexRect();
      this._currentQuadTex = g.GetTexQuad();
      this.GetWorldInfo().SetMeshChanged(!0);
    }
    GetTexture() {
      return this._currentTexture;
    }
    GetTexRect() {
      return this._currentRcTex;
    }
    GetTexQuad() {
      return this._currentQuadTex;
    }
    GetImagePointCount() {
      return this._currentAnimationFrame.GetImagePointCount();
    }
    GetImagePoint(g) {
      const k = this._currentAnimationFrame,
        m = this.GetWorldInfo();
      if ("string" === typeof g) g = k.GetImagePointByName(g);
      else if ("number" === typeof g) g = k.GetImagePointByIndex(g - 1);
      else throw new TypeError("expected string or number");
      if (!g) return [m.GetX(), m.GetY()];
      d.copy(g.GetVec2());
      if (m.HasMesh()) {
        const [q, v] = m.GetSourceMesh().TransformPoint(d.getX(), d.getY());
        d.set(q, v);
      }
      d.offset(-k.GetOriginX(), -k.GetOriginY());
      d.scale(m.GetWidth(), m.GetHeight());
      d.rotate(m.GetAngle());
      d.offset(m.GetX(), m.GetY());
      return [d.getX(), d.getY()];
    }
    GetCollisionPolyPointCount() {
      return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount();
    }
    GetCollisionPolyPoint(g) {
      g = Math.floor(g);
      const k = this.GetWorldInfo();
      var m = k.GetTransformedCollisionPoly();
      const q = m.pointCount();
      g === q && (g = 0);
      if (0 > g || g >= q) return [0, 0];
      m = m.pointsArr();
      return [m[2 * g] + k.GetX(), m[2 * g + 1] + k.GetY()];
    }
    GetDebuggerProperties() {
      const g = e.Plugins.Sprite.Acts;
      return [
        {
          title: "plugins.sprite.debugger.animation-properties.title",
          properties: [
            {
              name: "plugins.sprite.debugger.animation-properties.current-animation",
              value: this._currentAnimation.GetName(),
              onedit: (k) => this.CallAction(g.SetAnim, k, 0),
            },
            {
              name: "plugins.sprite.debugger.animation-properties.current-frame",
              value: this._currentFrameIndex,
              onedit: (k) => this.CallAction(g.SetAnimFrame, k),
            },
            {
              name: "plugins.sprite.debugger.animation-properties.is-playing",
              value: this.IsAnimationPlaying(),
              onedit: (k) =>
                k
                  ? this.CallAction(g.StartAnim, 0)
                  : this.CallAction(g.StopAnim),
            },
            {
              name: "plugins.sprite.debugger.animation-properties.speed",
              value: this._currentAnimationSpeed,
              onedit: (k) => this.CallAction(g.SetAnimSpeed, k),
            },
            {
              name: "plugins.sprite.debugger.animation-properties.repeats",
              value: this._animationRepeats,
              onedit: (k) => (this._animationRepeats = k),
            },
          ],
        },
      ];
    }
    SaveToJson() {
      const g = { a: this._currentAnimation.GetSID() };
      0 !== this._frameStartTime && (g.fs = this._frameStartTime);
      var k = this.GetAnimationTime();
      0 !== k && (g.at = k);
      0 !== this._currentFrameIndex && (g.f = this._currentFrameIndex);
      0 !== this._currentAnimationSpeed &&
        (g.cas = this._currentAnimationSpeed);
      1 !== this._animationRepeats && (g.ar = this._animationRepeats);
      0 !== this._currentAnimationRepeatTo &&
        (g.rt = this._currentAnimationRepeatTo);
      this.IsAnimationPlaying() || (g.ap = this.IsAnimationPlaying());
      this.IsPlayingForwards() || (g.af = this.IsPlayingForwards());
      k = this.GetWorldInfo();
      k.IsCollisionEnabled() && (g.ce = k.IsCollisionEnabled());
      return g;
    }
    LoadFromJson(g) {
      var k = this.GetObjectClass().GetAnimationBySID(g.a);
      k && (this._currentAnimation = k);
      this._frameStartTime = g.hasOwnProperty("fs") ? g.fs : 0;
      this._animationTimer.Set(g.hasOwnProperty("at") ? g.at : 0);
      k = g.hasOwnProperty("f") ? g.f : 0;
      this._currentFrameIndex = e.clamp(
        k,
        0,
        this._currentAnimation.GetFrameCount() - 1
      );
      this._currentAnimationSpeed = g.hasOwnProperty("cas") ? g.cas : 0;
      this._animationRepeats = g.hasOwnProperty("ar") ? g.ar : 1;
      k = g.hasOwnProperty("rt") ? g.rt : 0;
      this._currentAnimationRepeatTo = e.clamp(
        k,
        0,
        this._currentAnimation.GetFrameCount() - 1
      );
      this.SetAnimationPlaying(g.hasOwnProperty("ap") ? !!g.ap : !0);
      this.SetPlayingForwards(g.hasOwnProperty("af") ? !!g.af : !0);
      this._currentAnimationFrame = k = this._currentAnimation.GetFrameAt(
        this._currentFrameIndex
      );
      this._UpdateCurrentTexture();
      const m = this.GetWorldInfo();
      m.SetOriginX(k.GetOriginX());
      m.SetOriginY(k.GetOriginY());
      m.SetSourceCollisionPoly(k.GetCollisionPoly());
      m.SetCollisionEnabled(!!g.ce);
    }
    GetPropertyValueByIndex(g) {
      const k = this.GetWorldInfo();
      switch (g) {
        case 3:
          return k.IsCollisionEnabled();
        case 2:
          return e.clamp(
            this._currentFrameIndex,
            0,
            this._currentAnimation.GetFrameCount() - 1
          );
      }
    }
    SetPropertyValueByIndex(g, k) {
      var m = this.GetWorldInfo();
      switch (g) {
        case 3:
          m.SetCollisionEnabled(!!k);
          break;
        case 2:
          this.SetAnimationPlaying(!1);
          g = this._currentAnimation.GetFrameCount() - 1;
          m = k = e.clamp(k, 0, g);
          k = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
          const q = this._currentAnimation.GetFrameAt(m);
          this._OnFrameChanged(k, q);
          this._currentFrameIndex = e.clamp(m, 0, g);
      }
    }
    GetScriptInterfaceClass() {
      return self.ISpriteInstance;
    }
  };
  const f = new WeakMap(),
    h = new Map([
      ["current-frame", 0],
      ["beginning", 1],
    ]);
  self.ISpriteInstance = class extends self.IWorldInstance {
    constructor() {
      super();
      f.set(this, self.IInstance._GetInitInst().GetSdkInstance());
    }
    getImagePointCount() {
      return f.get(this).GetImagePointCount();
    }
    getImagePointX(g) {
      if ("string" !== typeof g && "number" !== typeof g)
        throw new TypeError("expected string or number");
      return f.get(this).GetImagePoint(g)[0];
    }
    getImagePointY(g) {
      if ("string" !== typeof g && "number" !== typeof g)
        throw new TypeError("expected string or number");
      return f.get(this).GetImagePoint(g)[1];
    }
    getImagePoint(g) {
      if ("string" !== typeof g && "number" !== typeof g)
        throw new TypeError("expected string or number");
      return f.get(this).GetImagePoint(g);
    }
    getPolyPointCount() {
      return f.get(this).GetCollisionPolyPointCount();
    }
    getPolyPointX(g) {
      b.RequireFiniteNumber(g);
      return f.get(this).GetCollisionPolyPoint(g)[0];
    }
    getPolyPointY(g) {
      b.RequireFiniteNumber(g);
      return f.get(this).GetCollisionPolyPoint(g)[1];
    }
    getPolyPoint(g) {
      b.RequireFiniteNumber(g);
      return f.get(this).GetCollisionPolyPoint(g);
    }
    stopAnimation() {
      f.get(this).SetAnimationPlaying(!1);
    }
    startAnimation(g = "current-frame") {
      b.RequireString(g);
      g = h.get(g);
      if ("undefined" === typeof g) throw Error("invalid mode");
      f.get(this)._StartAnim(g);
    }
    setAnimation(g, k = "beginning") {
      b.RequireString(g);
      b.RequireString(k);
      k = h.get(k);
      if ("undefined" === typeof k) throw Error("invalid mode");
      f.get(this)._SetAnim(g, k);
    }
    getAnimation(g) {
      b.RequireString(g);
      return (g = f.get(this).GetObjectClass().GetAnimationByName(g))
        ? g.GetIAnimation()
        : null;
    }
    get animation() {
      return f.get(this)._GetCurrentAnimation().GetIAnimation();
    }
    get animationName() {
      return f.get(this)._GetCurrentAnimationName();
    }
    set animationFrame(g) {
      b.RequireFiniteNumber(g);
      f.get(this)._SetAnimFrame(g);
    }
    get animationFrame() {
      return f.get(this)._GetAnimFrame();
    }
    set animationSpeed(g) {
      b.RequireFiniteNumber(g);
      f.get(this)._SetAnimSpeed(g);
    }
    get animationSpeed() {
      return f.get(this)._GetAnimSpeed();
    }
    set animationRepeatToFrame(g) {
      b.RequireFiniteNumber(g);
      f.get(this)._SetAnimRepeatToFrame(g);
    }
    get animationRepeatToFrame() {
      return f.get(this)._GetAnimRepeatToFrame();
    }
    get imageWidth() {
      return f.get(this).GetCurrentImageInfo().GetWidth();
    }
    get imageHeight() {
      return f.get(this).GetCurrentImageInfo().GetHeight();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Sprite.Cnds = {
    IsAnimPlaying(b) {
      return e.equalsNoCase(this._GetCurrentAnimationName(), b);
    },
    CompareFrame(b, a) {
      return e.compare(this._currentFrameIndex, b, a);
    },
    CompareAnimSpeed(b, a) {
      return e.compare(this._GetAnimSpeed(), b, a);
    },
    OnAnimFinished(b) {
      return e.equalsNoCase(this._animTriggerName, b);
    },
    OnAnyAnimFinished() {
      return !0;
    },
    OnFrameChanged() {
      return !0;
    },
    IsMirrored() {
      return 0 > this.GetWorldInfo().GetWidth();
    },
    IsFlipped() {
      return 0 > this.GetWorldInfo().GetHeight();
    },
    OnURLLoaded() {
      return !0;
    },
    OnURLFailed() {
      return !0;
    },
    IsCollisionEnabled() {
      return this.GetWorldInfo().IsCollisionEnabled();
    },
  };
}
{
  const e = self.C3;
  e.Plugins.Sprite.Acts = {
    Spawn(b, a, c, d) {
      if (b && a) {
        var [f, h] = this.GetImagePoint(c);
        if ((c = this._runtime.CreateInstance(b, a, f, h, d)))
          d && a.SortAndAddInstancesByZIndex(c),
            b.GetPlugin().IsRotatable() &&
              ((a = c.GetWorldInfo()),
              a.SetAngle(this.GetWorldInfo().GetAngle()),
              a.SetBboxChanged()),
            (a = this._runtime.GetEventSheetManager()),
            a.BlockFlushingInstances(!0),
            c._TriggerOnCreatedOnSelfAndRelated(),
            a.BlockFlushingInstances(!1),
            b !== this.GetObjectClass() &&
              this._sdkType._SpawnPickInstance(b, c);
      }
    },
    StopAnim() {
      this.SetAnimationPlaying(!1);
    },
    StartAnim(b) {
      this._StartAnim(b);
    },
    SetAnim(b, a) {
      this._SetAnim(b, a);
    },
    SetAnimFrame(b) {
      this._SetAnimFrame(b);
    },
    SetAnimSpeed(b) {
      this._SetAnimSpeed(b);
    },
    SetAnimRepeatToFrame(b) {
      this._SetAnimRepeatToFrame(b);
    },
    SetMirrored(b) {
      const a = this.GetWorldInfo(),
        c = a.GetWidth();
      b = Math.abs(c) * (0 === b ? -1 : 1);
      c !== b && (a.SetWidth(b), a.SetBboxChanged());
    },
    SetFlipped(b) {
      const a = this.GetWorldInfo(),
        c = a.GetHeight();
      b = Math.abs(c) * (0 === b ? -1 : 1);
      c !== b && (a.SetHeight(b), a.SetBboxChanged());
    },
    SetScale(b) {
      const a = this._currentAnimationFrame.GetImageInfo(),
        c = this.GetWorldInfo();
      var d = 0 > c.GetWidth() ? -1 : 1;
      const f = 0 > c.GetHeight() ? -1 : 1;
      d *= a.GetWidth() * b;
      b = a.GetHeight() * b * f;
      if (c.GetWidth() !== d || c.GetHeight() !== b)
        c.SetSize(d, b), c.SetBboxChanged();
    },
    async LoadURL(b, a, c) {
      c = this._currentAnimationFrame.GetImageInfo();
      const d = this.GetWorldInfo(),
        f = this._runtime;
      if (c.GetURL() === b)
        0 === a && (d.SetSize(c.GetWidth(), c.GetHeight()), d.SetBboxChanged()),
          this.Trigger(e.Plugins.Sprite.Cnds.OnURLLoaded);
      else {
        var h = e.New(e.ImageInfo);
        try {
          await h.LoadDynamicAsset(f, b);
          if (!h.IsLoaded()) throw Error("image failed to load");
          await h.LoadStaticTexture(f.GetRenderer(), {
            sampling: this._runtime.GetSampling(),
          });
        } catch (g) {
          console.error("Load image from URL failed: ", g);
          this.Trigger(e.Plugins.Sprite.Cnds.OnURLFailed);
          return;
        }
        c.ReplaceWith(h);
        this._sdkType._UpdateAllCurrentTexture();
        this.WasReleased() ||
          0 !== a ||
          (d.SetSize(c.GetWidth(), c.GetHeight()), d.SetBboxChanged());
        f.UpdateRender();
        this.WasReleased() ||
          (await this.TriggerAsync(e.Plugins.Sprite.Cnds.OnURLLoaded));
      }
    },
    SetCollisions(b) {
      this.GetWorldInfo().SetCollisionEnabled(b);
    },
    SetSolidCollisionFilter(b, a) {
      this.GetWorldInfo().SetSolidCollisionFilter(0 === b, a);
    },
    SetEffect(b) {
      this.GetWorldInfo().SetBlendMode(b);
      this._runtime.UpdateRender();
    },
  };
}
self.C3.Plugins.Sprite.Exps = {
  AnimationFrame() {
    return this._currentFrameIndex;
  },
  AnimationFrameCount() {
    return this._currentAnimation.GetFrameCount();
  },
  AnimationName() {
    return this._currentAnimation.GetName();
  },
  AnimationSpeed() {
    return this._GetAnimSpeed();
  },
  OriginalAnimationSpeed() {
    return this._currentAnimation.GetSpeed();
  },
  ImagePointX(e) {
    return this.GetImagePoint(e)[0];
  },
  ImagePointY(e) {
    return this.GetImagePoint(e)[1];
  },
  ImagePointCount() {
    return this.GetImagePointCount();
  },
  ImageWidth() {
    return this.GetCurrentImageInfo().GetWidth();
  },
  ImageHeight() {
    return this.GetCurrentImageInfo().GetHeight();
  },
  PolyPointXAt(e) {
    return this.GetCollisionPolyPoint(e)[0];
  },
  PolyPointYAt(e) {
    return this.GetCollisionPolyPoint(e)[1];
  },
  PolyPointCount() {
    return this.GetCollisionPolyPointCount();
  },
};
("use strict");
{
  const e = self.C3;
  e.Plugins.Spritefont2 = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Spritefont2.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b);
      this._spriteFont = e.New(self.SpriteFont);
    }
    Release() {
      super.Release();
    }
    OnCreate() {
      this.GetImageInfo().LoadAsset(this._runtime);
    }
    LoadTextures(b) {
      return this.GetImageInfo().LoadStaticTexture(b, {
        sampling: this._runtime.GetSampling(),
      });
    }
    ReleaseTextures() {
      this.GetImageInfo().ReleaseTexture();
    }
    GetSpriteFont() {
      return this._spriteFont;
    }
    UpdateSettings(b, a, c, d) {
      const f = this.GetImageInfo(),
        h = this._spriteFont;
      h.SetWidth(f.GetWidth());
      h.SetHeight(f.GetHeight());
      h.SetCharacterWidth(b);
      h.SetCharacterHeight(a);
      h.SetCharacterSet(c);
      h.SetSpacingData(d);
      h.UpdateCharacterMap();
    }
  };
}
{
  const e = self.C3,
    b = self.C3X,
    a = ["left", "center", "right"],
    c = ["top", "center", "bottom"];
  e.Plugins.Spritefont2.Instance = class extends e.SDKWorldInstanceBase {
    constructor(k, m) {
      super(k);
      this._text = "";
      this._enableBBcode = !0;
      this._characterHeight = this._characterWidth = 16;
      this._characterSet =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,;:?!-_~#\"'&()[]|`\\/@\u00b0+=*$\u00a3\u20ac<>";
      k = "";
      this._characterScale = 1;
      this._verticalAlign =
        this._horizontalAlign =
        this._lineHeight =
        this._characterSpacing =
          0;
      this._wrapByWord = !0;
      this._spriteFontText = null;
      this._typewriterEndTime = this._typewriterStartTime = -1;
      this._typewriterLength = 0;
      m &&
        ((this._text = m[0]),
        (this._enableBBcode = m[1]),
        (this._characterWidth = m[2]),
        (this._characterHeight = m[3]),
        (this._characterSet = m[4]),
        (k = m[5]),
        (this._characterScale = m[6]),
        (this._characterSpacing = m[7]),
        (this._lineHeight = m[8]),
        (this._horizontalAlign = m[9]),
        (this._verticalAlign = m[10]),
        (this._wrapByWord = 0 === m[11]),
        this.GetWorldInfo().SetVisible(m[12]));
      this._sdkType.UpdateSettings(
        this._characterWidth,
        this._characterHeight,
        this._characterSet,
        k
      );
      this._spriteFontText = e.New(
        self.SpriteFontText,
        this._sdkType.GetSpriteFont()
      );
      m = this.GetWorldInfo();
      this._spriteFontText.SetSize(m.GetWidth(), m.GetHeight());
      this._UpdateSettings();
      this._inst.SetMustMitigateZFighting();
    }
    Release() {
      this._CancelTypewriter();
      this._spriteFontText.Release();
      this._spriteFontText = null;
      super.Release();
    }
    _UpdateSettings() {
      const k = this._spriteFontText;
      k &&
        (k.SetBBCodeEnabled(this._enableBBcode),
        k.SetText(this._text),
        k.SetWordWrapMode(this._wrapByWord ? "word" : "character"),
        k.SetHorizontalAlign(a[this._horizontalAlign]),
        k.SetVerticalAlign(c[this._verticalAlign]),
        k.SetSpacing(this._characterSpacing),
        k.SetLineHeight(this._lineHeight));
    }
    Draw(k) {
      const m = this._objectClass.GetImageInfo();
      var q = m.GetTexture();
      if (q) {
        k.SetTexture(q);
        q = this.GetWorldInfo();
        var v = q.GetBoundingQuad(),
          r = this._spriteFontText;
        r.SetScale(this._characterScale);
        r.SetSceneGraphScale(q.GetSceneGraphScale());
        this._runtime.IsPixelRoundingEnabled() && (v = q.PixelRoundQuad(v));
        r.SetSize(q.GetWidth(), q.GetHeight());
        r.GetSpriteFont().SetTexRect(m.GetTexRect());
        r.SetColor(q.GetUnpremultipliedColor());
        r.Draw(k, v.getTlx(), v.getTly(), q.GetAngle());
      }
    }
    SaveToJson() {
      const k = {
        t: this._text,
        ebbc: this._enableBBcode,
        csc: this._characterScale,
        csp: this._characterSpacing,
        lh: this._lineHeight,
        ha: this._horizontalAlign,
        va: this._verticalAlign,
        w: this._wrapByWord,
        cw: this._sdkType.GetSpriteFont().GetCharacterWidth(),
        ch: this._sdkType.GetSpriteFont().GetCharacterHeight(),
        cs: this._sdkType.GetSpriteFont().GetCharacterSet(),
        sd: this._sdkType.GetSpriteFont().GetSpacingData(),
      };
      -1 !== this._typewriterEndTime &&
        (k.tw = {
          st: this._typewriterStartTime,
          en: this._typewriterEndTime,
          l: this._typewriterLength,
        });
      return k;
    }
    LoadFromJson(k) {
      this._CancelTypewriter();
      this._text = k.t;
      this._enableBBcode = k.ebbc;
      this._characterScale = k.csc;
      this._characterSpacing = k.csp;
      this._lineHeight = k.lh;
      this._horizontalAlign = k.ha;
      this._verticalAlign = k.va;
      this._wrapByWord = k.w;
      if (k.hasOwnProperty("tw")) {
        var m = k.tw;
        this._typewriterStartTime = m.st;
        this._typewriterEndTime = m.en;
        this._typewriterLength = k.l;
      }
      m = this._sdkType.GetSpriteFont();
      m.SetCharacterWidth(k.cw);
      m.SetCharacterHeight(k.ch);
      m.SetCharacterSet(k.cs);
      m.SetSpacingData(k.sd);
      this._UpdateSettings();
      -1 !== this._typewriterEndTime && this._StartTicking();
    }
    GetPropertyValueByIndex(k) {
      switch (k) {
        case 0:
          return this._text;
        case 1:
          return this._enableBBcode;
        case 2:
          return this._sdkType.GetSpriteFont().GetCharacterWidth();
        case 3:
          return this._sdkType.GetSpriteFont().GetCharacterHeight();
        case 4:
          return this._sdkType.GetSpriteFont().GetCharacterSet();
        case 5:
          return this._sdkType.GetSpriteFont().GetSpacingData();
        case 6:
          return this._characterScale;
        case 7:
          return this._characterSpacing;
        case 8:
          return this._lineHeight;
        case 9:
          return this._horizontalAlign;
        case 10:
          return this._verticalAlign;
        case 11:
          return this._wrapByWord ? 1 : 0;
      }
    }
    SetPropertyValueByIndex(k, m) {
      switch (k) {
        case 0:
          if (this._text === m) break;
          this._text = m;
          this._UpdateSettings();
          break;
        case 1:
          if (this._enableBBcode === !!m) break;
          this._enableBBcode = !!m;
          this._UpdateSettings();
          break;
        case 2:
          this._sdkType.GetSpriteFont().SetCharacterWidth(m);
          break;
        case 3:
          this._sdkType.GetSpriteFont().SetCharacterHeight(m);
          break;
        case 4:
          this._sdkType.GetSpriteFont().SetCharacterSet(m);
          break;
        case 5:
          this._sdkType.GetSpriteFont().SetSpacingData(m);
          break;
        case 6:
          if (this._characterScale === m) break;
          this._characterScale = m;
          this._UpdateSettings();
          break;
        case 7:
          if (this._characterSpacing === m) break;
          this._characterSpacing = m;
          this._UpdateSettings();
          break;
        case 8:
          if (this._lineHeight === m) break;
          this._lineHeight = m;
          this._UpdateSettings();
          break;
        case 9:
          if (this._horizontalAlign === m) break;
          this._horizontalAlign = m;
          this._UpdateSettings();
          break;
        case 10:
          if (this._verticalAlign === m) break;
          this._verticalAlign = m;
          this._UpdateSettings();
          break;
        case 11:
          this._wrapByWord !== (0 === m) &&
            ((this._wrapByWord = 0 === m), this._UpdateSettings());
      }
    }
    _SetText(k) {
      this._text !== k &&
        ((this._text = k),
        this._spriteFontText.SetText(k),
        this._runtime.UpdateRender());
    }
    GetText() {
      return this._text;
    }
    _StartTypewriter(k, m) {
      this._SetText(k);
      this._typewriterStartTime = this._runtime.GetWallTime();
      this._typewriterEndTime =
        this._typewriterStartTime + m / this.GetInstance().GetActiveTimeScale();
      this._typewriterLength = e.BBString.StripAnyTags(k).length;
      this._spriteFontText.SetDrawMaxCharacterCount(0);
      this._StartTicking();
    }
    _CancelTypewriter() {
      this._typewriterEndTime = this._typewriterStartTime = -1;
      this._typewriterLength = 0;
      this._spriteFontText.SetDrawMaxCharacterCount(-1);
      this._StopTicking();
    }
    _FinishTypewriter() {
      -1 !== this._typewriterEndTime &&
        (this._CancelTypewriter(),
        this.Trigger(e.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished),
        this._runtime.UpdateRender());
    }
    _SetScale(k) {
      this._characterScale !== k &&
        ((this._characterScale = k),
        this._spriteFontText.SetScale(this._characterScale),
        this._runtime.UpdateRender());
    }
    _GetScale() {
      return this._characterScale;
    }
    _SetCharacterSpacing(k) {
      this._characterSpacing !== k &&
        ((this._characterSpacing = k),
        this._spriteFontText.SetSpacing(this._characterSpacing),
        this._runtime.UpdateRender());
    }
    _GetCharacterSpacing() {
      return this._characterSpacing;
    }
    _SetLineHeight(k) {
      this._lineHeight !== k &&
        ((this._lineHeight = k),
        this._spriteFontText.SetLineHeight(this._lineHeight),
        this._runtime.UpdateRender());
    }
    _GetLineHeight() {
      return this._lineHeight;
    }
    _SetHAlign(k) {
      this._horizontalAlign !== k &&
        ((this._horizontalAlign = k),
        this._UpdateSettings(),
        this._runtime.UpdateRender());
    }
    _GetHAlign() {
      return this._horizontalAlign;
    }
    _SetVAlign(k) {
      this._verticalAlign !== k &&
        ((this._verticalAlign = k),
        this._UpdateSettings(),
        this._runtime.UpdateRender());
    }
    _GetVAlign() {
      return this._verticalAlign;
    }
    _SetWrapByWord(k) {
      k = !!k;
      this._wrapByWord !== k &&
        ((this._wrapByWord = k),
        this._UpdateSettings(),
        this._runtime.UpdateRender());
    }
    _IsWrapByWord() {
      return this._wrapByWord;
    }
    Tick() {
      var k = this._runtime.GetWallTime();
      k >= this._typewriterEndTime
        ? (this._CancelTypewriter(),
          this.Trigger(e.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished),
          this._runtime.UpdateRender())
        : ((k = e.relerp(
            this._typewriterStartTime,
            this._typewriterEndTime,
            k,
            0,
            this._typewriterLength
          )),
          (k = Math.floor(k)),
          k !== this._spriteFontText.GetDrawMaxCharacterCount() &&
            (this._spriteFontText.SetDrawMaxCharacterCount(k),
            this._runtime.UpdateRender()));
    }
    GetDebuggerProperties() {
      return [
        {
          title: "plugins.spritefont2.name",
          properties: [
            {
              name: "plugins.spritefont2.properties.text.name",
              value: this._text,
              onedit: (k) => this._SetText(k),
            },
          ],
        },
      ];
    }
    GetScriptInterfaceClass() {
      return self.ISpriteFontInstance;
    }
  };
  const d = new WeakMap(),
    f = new Map([
      ["left", 0],
      ["center", 1],
      ["right", 2],
    ]),
    h = new Map([
      ["top", 0],
      ["center", 1],
      ["bottom", 2],
    ]),
    g = new Map([
      ["word", !0],
      ["character", !1],
    ]);
  self.ISpriteFontInstance = class extends self.IWorldInstance {
    constructor() {
      super();
      d.set(this, self.IInstance._GetInitInst().GetSdkInstance());
    }
    get text() {
      return d.get(this).GetText();
    }
    set text(k) {
      b.RequireString(k);
      const m = d.get(this);
      m._CancelTypewriter();
      m._SetText(k);
    }
    typewriterText(k, m) {
      b.RequireString(k);
      b.RequireFiniteNumber(m);
      const q = d.get(this);
      q._CancelTypewriter();
      q._StartTypewriter(k, m);
    }
    typewriterFinish() {
      d.get(this)._FinishTypewriter();
    }
    set characterScale(k) {
      b.RequireFiniteNumber(k);
      d.get(this)._SetScale(k);
    }
    get characterScale() {
      return d.get(this)._GetScale();
    }
    set characterSpacing(k) {
      b.RequireFiniteNumber(k);
      d.get(this)._SetCharacterSpacing(k);
    }
    get characterSpacing() {
      return d.get(this)._GetCharacterSpacing();
    }
    set lineHeight(k) {
      b.RequireFiniteNumber(k);
      d.get(this)._SetLineHeight(k);
    }
    get lineHeight() {
      return d.get(this)._GetLineHeight();
    }
    set horizontalAlign(k) {
      b.RequireString(k);
      k = f.get(k);
      if ("undefined" === typeof k) throw Error("invalid mode");
      d.get(this)._SetHAlign(k);
    }
    get horizontalAlign() {
      return a[d.get(this)._GetHAlign()];
    }
    set verticalAlign(k) {
      b.RequireString(k);
      k = h.get(k);
      if ("undefined" === typeof k) throw Error("invalid mode");
      d.get(this)._SetVAlign(k);
    }
    get verticalAlign() {
      return c[d.get(this)._GetVAlign()];
    }
    set wordWrapMode(k) {
      b.RequireString(k);
      k = g.get(k);
      if ("undefined" === typeof k) throw Error("invalid mode");
      d.get(this)._SetWrapByWord(k);
    }
    get wordWrapMode() {
      return d.get(this)._IsWrapByWord() ? "word" : "character";
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Spritefont2.Cnds = {
    CompareText(b, a) {
      return a ? this._text === b : e.equalsNoCase(this._text, b);
    },
    IsRunningTypewriterText() {
      return -1 !== this._typewriterEndTime;
    },
    OnTypewriterTextFinished() {
      return !0;
    },
  };
}
self.C3.Plugins.Spritefont2.Acts = {
  SetText(e) {
    this._CancelTypewriter();
    "number" === typeof e && 1e9 > e && (e = Math.round(1e10 * e) / 1e10);
    this._SetText(e.toString());
  },
  AppendText(e) {
    this._CancelTypewriter();
    "number" === typeof e && 1e9 > e && (e = Math.round(1e10 * e) / 1e10);
    (e = e.toString()) && this._SetText(this._text + e);
  },
  TypewriterText(e, b) {
    this._CancelTypewriter();
    "number" === typeof e && 1e9 > e && (e = Math.round(1e10 * e) / 1e10);
    this._StartTypewriter(e.toString(), b);
  },
  TypewriterFinish() {
    this._FinishTypewriter();
  },
  SetScale(e) {
    this._SetScale(e);
  },
  SetCharacterSpacing(e) {
    this._SetCharacterSpacing(e);
  },
  SetLineHeight(e) {
    this._SetLineHeight(e);
  },
  SetCharacterWidth(e, b) {
    let a = !1;
    const c = this._sdkType.GetSpriteFont();
    for (const d of e)
      if (" " === d) c.SetSpaceWidth(b), (a = !0);
      else if ((e = c.GetCharacter(d))) e.SetDisplayWidth(b), (a = !0);
    a && c.SetCharacterWidthsChanged();
    this._runtime.UpdateRender();
  },
  SetEffect(e) {
    this.GetWorldInfo().SetBlendMode(e);
    this._runtime.UpdateRender();
  },
  SetHAlign(e) {
    this._SetHAlign(e);
  },
  SetVAlign(e) {
    this._SetVAlign(e);
  },
  SetWrapping(e) {
    this._SetWrapByWord(0 === e);
  },
};
{
  const e = self.C3;
  e.Plugins.Spritefont2.Exps = {
    CharacterWidth(b) {
      return (b = this._sdkType.GetSpriteFont().GetCharacter(b))
        ? b.GetDisplayWidth()
        : this._sdkType.GetSpriteFont().GetCharacterWidth();
    },
    CharacterHeight() {
      return this._characterHeight;
    },
    CharacterScale() {
      return this._characterScale;
    },
    CharacterSpacing() {
      return this._characterSpacing;
    },
    LineHeight() {
      return this._lineHeight;
    },
    Text() {
      return this._text;
    },
    PlainText() {
      return this._enableBBcode
        ? e.BBString.StripAnyTags(this._text)
        : this._text;
    },
    TextWidth() {
      const b = this.GetWorldInfo();
      this._spriteFontText.SetSize(b.GetWidth(), b.GetHeight());
      return this._spriteFontText.GetTextWidth();
    },
    TextHeight() {
      const b = this.GetWorldInfo();
      this._spriteFontText.SetSize(b.GetWidth(), b.GetHeight());
      return this._spriteFontText.GetTextHeight();
    },
  };
}
{
  ("use strict");
  const e = self.C3;
  self.SpriteFontCharacter = class {
    constructor(b, a, c, d) {
      let f = b.GetCharacterWidth(),
        h = b.GetCharacterHeight();
      this._spriteFont = b;
      this._char = a;
      this._pxRect = new e.Rect(c, d, c + f, d + h);
      this._texRect = new e.Rect();
      this._displayWidth = -1;
      this._UpdateTexRect();
    }
    Release() {
      this._texRect = this._pxRect = this._spriteFont = null;
    }
    _UpdateTexRect() {
      let b = this._spriteFont.GetWidth(),
        a = this._spriteFont.GetHeight();
      this._texRect.copy(this._pxRect);
      this._texRect.divide(b, a);
      this._texRect.lerpInto(this._spriteFont.GetTexRect());
    }
    GetSpriteFont() {
      return this._spriteFont;
    }
    GetChar() {
      return this._char;
    }
    GetTexRect() {
      return this._texRect;
    }
    SetDisplayWidth(b) {
      this._displayWidth = b;
    }
    GetDisplayWidth() {
      return 0 > this._displayWidth
        ? this._spriteFont.GetCharacterWidth()
        : this._displayWidth;
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = new e.Rect(),
    a = new e.Quad(),
    c = new e.Color(),
    d = new Set(["left", "center", "right"]),
    f = new Set(["top", "center", "bottom"]),
    h = new Set(["word", "character"]);
  self.SpriteFontText = class {
    constructor(g) {
      this._spriteFont = g;
      this._cssHeight = this._cssWidth = 0;
      this._text = "";
      this._isBBcodeEnabled = !1;
      this._bbString = null;
      this._wrappedText = e.New(e.WordWrap);
      this._wrapMode = "word";
      this._wrapChanged = !1;
      this._horizontalAlign = "left";
      this._verticalAlign = "top";
      this._sceneGraphScale = this._scale = 1;
      this._lineHeight = this._spacing = 0;
      this._color = e.New(e.Color);
      this._drawMaxCharCount = -1;
      this._drawCharCount = 0;
      this._measureTextCallback = (k, m) => this._MeasureText(k, m);
      this._spriteFont._AddSpriteFontText(this);
    }
    Release() {
      this._spriteFont._RemoveSpriteFontText(this);
      this._measureTextCallback = this._color = null;
      this._wrappedText.Clear();
      this._bbString = this._spriteFont = this._wrappedText = null;
    }
    _MeasureText(g, k) {
      var m = this._GetStyleTag(k, "scale"),
        q = (m ? parseFloat(m.param) : this._scale) * this._sceneGraphScale;
      m = this._GetStyleTag(k, "scalex");
      m = (m ? parseFloat(m.param) : 1) * q;
      k = this._GetStyleTag(k, "scaley");
      k = (k ? parseFloat(k.param) : 1) * q;
      k = this._spriteFont.GetCharacterHeight() * k + this._lineHeight;
      const v = this.GetSpriteFont();
      q = v.GetCharacterWidth() * m;
      const r = this.GetSpacing();
      if (v.HasAnyCustomWidths()) {
        let p = 0,
          u = 0;
        for (var n of g) {
          g = q;
          const w = v.GetCharacter(n);
          w
            ? (g = w.GetDisplayWidth() * m)
            : " " === n && (g = v.GetSpaceWidth() * m);
          u += g;
          ++p;
        }
        return { width: u + p * r, height: k };
      }
      n = [...g].length;
      return { width: q * n + Math.max(n, 0) * r, height: k };
    }
    _SetWrapChanged() {
      this._wrapChanged = !0;
      this._wrappedText.Clear();
    }
    SetSize(g, k) {
      0 >= g ||
        0 >= k ||
        (this._cssWidth === g && this._cssHeight === k) ||
        (this._cssWidth !== g && this._SetWrapChanged(),
        (this._cssWidth = g),
        (this._cssHeight = k));
    }
    SetDrawMaxCharacterCount(g) {
      this._drawMaxCharCount = Math.floor(g);
    }
    GetDrawMaxCharacterCount() {
      return this._drawMaxCharCount;
    }
    _GetStyleTag(g, k) {
      for (let m = g.length - 1; 0 <= m; --m) {
        const q = g[m];
        if (q.tag === k) return q;
      }
      return null;
    }
    _HasStyleTag(g, k) {
      return !!this._GetStyleTag(g, k);
    }
    _MaybeWrapText() {
      if (this._wrapChanged) {
        !this._isBBcodeEnabled ||
          (this._bbString && this._bbString.toString() === this._text) ||
          (this._bbString = new e.BBString(this._text, { noEscape: !0 }));
        var g = -this.GetSpacing();
        this._wrappedText.WordWrap(
          this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text,
          this._measureTextCallback,
          this._cssWidth,
          this._wrapMode,
          g
        );
        this._wrapChanged = !1;
      }
    }
    Draw(g, k, m, q) {
      this._MaybeWrapText();
      let v = (this._drawCharCount = 0);
      const r = this._lineHeight,
        n = e.cloneArray(this._wrappedText.GetLines()),
        p = Math.sin(q);
      q = Math.cos(q);
      var u = n.reduce((w, y) => w + y.height, 0) - r;
      "center" === this._verticalAlign
        ? (v = Math.max(Math.floor(this._cssHeight / 2 - u / 2), 0))
        : "bottom" === this._verticalAlign &&
          (v = Math.floor(this._cssHeight - u));
      for (let w = 0, y = n.length; w < y; ++w) {
        u = n[w];
        const B = u.height;
        if (0 < w && v > this._cssHeight - (B - r)) break;
        0 <= v && this._DrawLine(g, u, k, m, v, p, q);
        v += B;
      }
    }
    _DrawLine(g, k, m, q, v, r, n) {
      const p = k.height;
      let u = 0;
      "center" === this._horizontalAlign
        ? (u = Math.max(Math.floor((this._cssWidth - k.width) / 2), 0))
        : "right" === this._horizontalAlign &&
          (u = Math.max(Math.floor(this._cssWidth - k.width), 0));
      for (const w of k.fragments)
        this._DrawFragment(g, w, m, q, u, v, r, n, p), (u += w.width);
    }
    _DrawFragment(g, k, m, q, v, r, n, p, u) {
      var w = k.text,
        y = k.width,
        B = k.styles;
      if (-1 !== this._drawMaxCharCount) {
        if (this._drawCharCount >= this._drawMaxCharCount) return;
        this._drawCharCount + w.length > this._drawMaxCharCount &&
          ((w = w.substr(0, this._drawMaxCharCount - this._drawCharCount)),
          (y = this._MeasureText(w, B).width));
        this._drawCharCount += w.length;
      }
      var E = this._GetStyleTag(B, "background");
      if (
        !((e.IsStringAllWhitespace(w) && !E) || this._HasStyleTag(B, "hide"))
      ) {
        k = this._GetStyleTag(B, "scale");
        var z = (k ? parseFloat(k.param) : this._scale) * this._sceneGraphScale;
        k = this._GetStyleTag(B, "scalex");
        k = (k ? parseFloat(k.param) : 1) * z;
        var D = this._GetStyleTag(B, "scaley");
        z *= D ? parseFloat(D.param) : 1;
        z *= this._spriteFont.GetCharacterHeight();
        r += u - this._lineHeight - z;
        u = this._GetStyleTag(B, "offsetx");
        v += u ? parseFloat(u.param) : 0;
        u = this._GetStyleTag(B, "offsety");
        r += u ? parseFloat(u.param) : 0;
        E &&
          (g.SetColorFillMode(),
          c.parseString(E.param),
          c.setA(1),
          g.SetColor(c),
          b.set(v, r, v + y, r + z),
          b.getRight() > this._cssWidth && b.setRight(this._cssWidth),
          a.setFromRotatedRectPrecalc(b, n, p),
          a.offset(m, q),
          g.Quad(a),
          g.SetTextureFillMode());
        (y = this._GetStyleTag(B, "color"))
          ? (c.parseString(y.param), c.setA(this._color.getA()))
          : c.copy(this._color);
        (y = this._GetStyleTag(B, "opacity")) &&
          c.setA((c.getA() * parseFloat(y.param)) / 100);
        c.premultiply();
        g.SetColor(c);
        y = this._spriteFont.GetCharacterWidth() * k;
        B = Math.abs(this.GetSpacing());
        for (const J of w)
          if ((w = this._spriteFont.GetCharacter(J))) {
            E = w.GetDisplayWidth() * k;
            if (v + E > this._cssWidth + B + 1e-5) break;
            b.set(v, r, v + y, r + z);
            a.setFromRotatedRectPrecalc(b, n, p);
            a.offset(m, q);
            g.Quad3(a, w.GetTexRect());
            v += E + this._spacing;
          } else v += this._spriteFont.GetSpaceWidth() * k + this._spacing;
      }
    }
    GetSpriteFont() {
      return this._spriteFont;
    }
    SetBBCodeEnabled(g) {
      g = !!g;
      this._isBBcodeEnabled !== g &&
        ((this._isBBcodeEnabled = g), this._SetWrapChanged());
    }
    IsBBCodeEnabled() {
      return this._isBBcodeEnabled;
    }
    SetText(g) {
      this._text !== g && ((this._text = g), this._SetWrapChanged());
    }
    SetWordWrapMode(g) {
      if (!h.has(g)) throw Error("invalid word wrap mode");
      this._wrapMode !== g && ((this._wrapMode = g), this._SetWrapChanged());
    }
    SetHorizontalAlign(g) {
      if (!d.has(g)) throw Error("invalid alignment");
      this._horizontalAlign = g;
    }
    SetVerticalAlign(g) {
      if (!f.has(g)) throw Error("invalid alignment");
      this._verticalAlign = g;
    }
    SetScale(g) {
      this._scale !== g && ((this._scale = g), this._SetWrapChanged());
    }
    GetScale() {
      return this._scale;
    }
    SetSceneGraphScale(g) {
      this._sceneGraphScale !== g &&
        ((this._sceneGraphScale = g), this._SetWrapChanged());
    }
    GetSceneGraphScale() {
      return this._sceneGraphScale;
    }
    SetSpacing(g) {
      this._spacing !== g && ((this._spacing = g), this._SetWrapChanged());
    }
    GetSpacing() {
      return this._spacing;
    }
    SetLineHeight(g) {
      this._lineHeight = g;
      this._SetWrapChanged();
    }
    GetLineHeight() {
      return this._lineHeight;
    }
    SetOpacity(g) {
      g = e.clamp(g, 0, 1);
      this._color.a = g;
    }
    SetColor(g) {
      this._color.equals(g) || this._color.copy(g);
    }
    GetColor() {
      return this._color;
    }
    GetTextWidth() {
      this._MaybeWrapText();
      return this._wrappedText.GetMaxLineWidth();
    }
    GetTextHeight() {
      this._MaybeWrapText();
      var g = this._spriteFont.GetCharacterHeight() * this._scale;
      const k = this._lineHeight;
      g += k;
      return this._wrappedText.GetLineCount() * g - k;
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = {
      width: 256,
      height: 256,
      characterWidth: 16,
      characterHeight: 16,
      characterSet: "",
    };
  self.SpriteFont = class {
    constructor(a) {
      a = Object.assign({}, b, a);
      if (
        0 >= a.width ||
        0 >= a.height ||
        0 >= a.characterWidth ||
        0 >= a.characterHeight
      )
        throw Error("invalid size");
      this._width = a.width;
      this._height = a.height;
      this._characterWidth = a.characterWidth;
      this._characterHeight = a.characterHeight;
      this._characterSet = a.characterSet;
      this._spacingData = "";
      this._spacingParsed = null;
      this._hasAnyCustomWidths = !1;
      this._spaceWidth = -1;
      this._texRect = new e.Rect(0, 0, 1, 1);
      this._characterMap = new Map();
      this._mapChanged = !0;
      this._allTexts = new Set();
    }
    Release() {
      this._texRect = null;
      this._ReleaseCharacters();
      this._characterMap = null;
      this._allTexts && this._allTexts.clear();
      this._allTexts = null;
    }
    _ReleaseCharacters() {
      for (let a of this._characterMap.values()) a.Release();
      this._characterMap.clear();
    }
    _AddSpriteFontText(a) {
      this._allTexts.add(a);
    }
    _RemoveSpriteFontText(a) {
      this._allTexts.delete(a);
    }
    UpdateCharacterMap() {
      if (this._mapChanged) {
        this._ReleaseCharacters();
        var a = [...this._characterSet],
          c = Math.floor(this._width / this._characterWidth),
          d = c * Math.floor(this._height / this._characterHeight);
        for (let f = 0, h = a.length; f < h && !(f >= d); ++f) {
          let g = a[f];
          this._characterMap.set(
            g,
            e.New(
              self.SpriteFontCharacter,
              this,
              g,
              (f % c) * this._characterWidth,
              Math.floor(f / c) * this._characterHeight
            )
          );
        }
        this._hasAnyCustomWidths = !1;
        this._spaceWidth = -1;
        if (Array.isArray(this._spacingParsed))
          for (let f of this._spacingParsed)
            if (
              Array.isArray(f) &&
              2 === f.length &&
              ((a = f[0]),
              (c = f[1]),
              "number" === typeof a &&
                isFinite(a) &&
                "string" === typeof c &&
                a !== this._characterWidth)
            )
              for (let h of c)
                (c = this._characterMap.get(h))
                  ? (c.SetDisplayWidth(a), (this._hasAnyCustomWidths = !0))
                  : " " === h &&
                    ((this._spaceWidth = a), (this._hasAnyCustomWidths = !0));
        this._mapChanged = !1;
        for (let f of this._allTexts) f._SetWrapChanged();
      }
    }
    SetCharacterWidthsChanged() {
      this._hasAnyCustomWidths = !0;
      for (const a of this._allTexts) a._SetWrapChanged();
    }
    GetCharacter(a) {
      this.UpdateCharacterMap();
      return this._characterMap.get(a) || null;
    }
    HasAnyCustomWidths() {
      return this._hasAnyCustomWidths;
    }
    SetWidth(a) {
      a = Math.floor(a);
      if (0 >= a) throw Error("invalid size");
      this._width !== a && ((this._width = a), (this._mapChanged = !0));
    }
    GetWidth() {
      return this._width;
    }
    SetHeight(a) {
      a = Math.floor(a);
      if (0 >= a) throw Error("invalid size");
      this._height !== a && ((this._height = a), (this._mapChanged = !0));
    }
    GetHeight() {
      return this._height;
    }
    SetTexRect(a) {
      if (!this._texRect.equals(a)) {
        this._texRect.copy(a);
        for (const c of this._characterMap.values()) c._UpdateTexRect();
      }
    }
    GetTexRect() {
      return this._texRect;
    }
    SetCharacterWidth(a) {
      a = Math.floor(a);
      if (0 >= a) throw Error("invalid size");
      this._characterWidth !== a &&
        ((this._characterWidth = a), (this._mapChanged = !0));
    }
    GetCharacterWidth() {
      return this._characterWidth;
    }
    SetCharacterHeight(a) {
      a = Math.floor(a);
      if (0 >= a) throw Error("invalid size");
      this._characterHeight !== a &&
        ((this._characterHeight = a), (this._mapChanged = !0));
    }
    GetCharacterHeight() {
      return this._characterHeight;
    }
    SetCharacterSet(a) {
      this._characterSet !== a &&
        ((this._characterSet = a), (this._mapChanged = !0));
    }
    GetCharacterSet() {
      return this._characterSet;
    }
    SetSpacingData(a) {
      if (
        this._spacingData !== a &&
        ((this._spacingData = a),
        (this._mapChanged = !0),
        (this._spacingParsed = null),
        this._spacingData.length)
      )
        try {
          this._spacingParsed = JSON.parse(this._spacingData);
        } catch (c) {
          this._spacingParsed = null;
        }
    }
    GetSpacingData() {
      return this._spacingData;
    }
    SetSpaceWidth(a) {
      0 > a && (a = -1);
      this._spaceWidth !== a &&
        ((this._spaceWidth = a),
        0 <= this._spaceWidth && (this._hasAnyCustomWidths = !0));
    }
    GetSpaceWidth() {
      return 0 > this._spaceWidth ? this._characterWidth : this._spaceWidth;
    }
  };
}
("use strict");
{
  const e = self.C3;
  e.Plugins.Dictionary = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Dictionary.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3,
    b = self.IInstance;
  e.Plugins.Dictionary.Instance = class extends e.SDKInstanceBase {
    constructor(c, d) {
      super(c);
      this._data = new Map();
      this._curKey = "";
    }
    Release() {
      this._data.clear();
      super.Release();
    }
    GetAsJsonString() {
      return JSON.stringify({
        c2dictionary: !0,
        data: e.MapToObject(this._data),
      });
    }
    GetDataMap() {
      return this._data;
    }
    SaveToJson() {
      return e.MapToObject(this._data);
    }
    LoadFromJson(c) {
      e.ObjectToMap(c, this._data);
    }
    GetDebuggerProperties() {
      return [
        {
          title: "plugins.dictionary.name",
          properties: [
            {
              name: "plugins.dictionary.debugger.key-count",
              value: this._data.size,
            },
            ...[...this._data].map((c) => ({
              name: "$" + c[0],
              value: c[1],
              onedit: (d) => this._data.set(c[0], d),
            })),
          ],
        },
      ];
    }
    GetScriptInterfaceClass() {
      return self.IDictionaryInstance;
    }
  };
  const a = new WeakMap();
  self.IDictionaryInstance = class extends b {
    constructor() {
      super();
      a.set(this, b._GetInitInst().GetSdkInstance());
    }
    getDataMap() {
      return a.get(this).GetDataMap();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Dictionary.Cnds = {
    CompareValue(b, a, c) {
      b = this._data.get(b);
      return "undefined" === typeof b ? !1 : e.compare(b, a, c);
    },
    ForEachKey() {
      const b = this._runtime,
        a = b.GetEventSheetManager(),
        c = b.GetCurrentEvent(),
        d = c.GetSolModifiers(),
        f = b.GetEventStack(),
        h = f.GetCurrentStackFrame(),
        g = f.Push(c);
      b.SetDebuggingEnabled(!1);
      for (const k of this._data.keys())
        (this._curKey = k), a.PushCopySol(d), c.Retrigger(h, g), a.PopSol(d);
      b.SetDebuggingEnabled(!0);
      this._curKey = "";
      f.Pop();
      return !1;
    },
    CompareCurrentValue(b, a) {
      const c = this._data.get(this._curKey);
      return "undefined" === typeof c ? !1 : e.compare(c, b, a);
    },
    HasKey(b) {
      return this._data.has(b);
    },
    IsEmpty() {
      return 0 === this._data.size;
    },
  };
}
{
  const e = self.C3;
  e.Plugins.Dictionary.Acts = {
    AddKey(b, a) {
      this._data.set(b, a);
    },
    SetKey(b, a) {
      this._data.has(b) && this._data.set(b, a);
    },
    DeleteKey(b) {
      this._data.delete(b);
    },
    Clear() {
      this._data.clear();
    },
    JSONLoad(b) {
      let a = null;
      try {
        a = JSON.parse(b);
      } catch (c) {
        console.error("[Construct 3] Error parsing JSON: ", c);
        return;
      }
      a.c2dictionary && e.ObjectToMap(a.data, this._data);
    },
    JSONDownload(b) {
      const a = URL.createObjectURL(
        new Blob([this.GetAsJsonString()], { type: "application/json" })
      );
      this._runtime.InvokeDownload(a, b);
    },
  };
}
self.C3.Plugins.Dictionary.Exps = {
  Get(e) {
    e = this._data.get(e);
    return "undefined" === typeof e ? 0 : e;
  },
  GetDefault(e, b) {
    e = this._data.get(e);
    return "undefined" === typeof e ? b : e;
  },
  KeyCount() {
    return this._data.size;
  },
  CurrentKey() {
    return this._curKey;
  },
  CurrentValue() {
    return this._data.get(this._curKey) || 0;
  },
  AsJSON() {
    return this.GetAsJsonString();
  },
};
("use strict");
{
  const e = self.C3,
    b = [];
  e.Plugins.Audio = class extends e.SDKPluginBase {
    constructor(a) {
      super(a);
    }
    _AddActionPromise(a) {
      b.push(a);
    }
    static async WaitForAllActionPromises() {
      await Promise.all(b);
      e.clearArray(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Audio.Type = class extends e.SDKTypeBase {
    constructor(a) {
      super(a);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
      return self.IAudioObjectType;
    }
  };
  function b() {
    if (self.C3Audio_DOMInterface) return self.C3Audio_DOMInterface;
    throw Error(
      "audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode"
    );
  }
  self.IAudioObjectType = class extends self.IObjectClass {
    constructor(a) {
      super(a);
    }
    get audioContext() {
      return b().GetAudioContext();
    }
    get destinationNode() {
      return b().GetDestinationNode();
    }
  };
}
{
  const e = self.C3,
    b = ["interactive", "balanced", "playback"];
  e.Plugins.Audio.Instance = class extends e.SDKInstanceBase {
    constructor(a, c) {
      super(a, "audio");
      this._nextPlayTime = 0;
      this._triggerTag = "";
      this._saveLoadMode = this._timeScaleMode = 0;
      this._playInBackground = !1;
      this._distanceModel = this._panningModel = 1;
      this._listenerX = this._runtime.GetViewportWidth() / 2;
      this._listenerY = this._runtime.GetViewportHeight() / 2;
      this._listenerZ = -600;
      this._referenceDistance = 600;
      this._maxDistance = 1e4;
      this._rolloffFactor = 1;
      this._listenerInst = null;
      this._loadListenerUid = -1;
      this._masterVolume = 1;
      this._isSilent = !1;
      this._sampleRate = 0;
      this._audioContextState = "suspended";
      this._effectCount = new Map();
      this._preloadCount = this._preloadTotal = 0;
      this._remoteUrls = new Map();
      a = "interactive";
      c &&
        ((this._timeScaleMode = c[0]),
        (this._saveLoadMode = c[1]),
        (this._playInBackground = c[2]),
        (a = b[c[3]]),
        (this._panningModel = c[4]),
        (this._distanceModel = c[5]),
        (this._listenerZ = -c[6]),
        (this._referenceDistance = c[7]),
        (this._maxDistance = c[8]),
        (this._rolloffFactor = c[9]));
      this._lastAIState = [];
      this._lastFxState = [];
      this._lastAnalysersData = [];
      this.AddDOMMessageHandlers([
        ["state", (d) => this._OnUpdateState(d)],
        ["audiocontext-state", (d) => this._OnAudioContextStateChanged(d)],
        ["fxstate", (d) => this._OnUpdateFxState(d)],
        ["trigger", (d) => this._OnTrigger(d)],
      ]);
      c = this.GetRuntime().Dispatcher();
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(c, "instancedestroy", (d) =>
          this._OnInstanceDestroyed(d.instance)
        ),
        e.Disposable.From(c, "afterload", () => this._OnAfterLoad()),
        e.Disposable.From(c, "suspend", () => this._OnSuspend()),
        e.Disposable.From(c, "resume", () => this._OnResume())
      );
      this._runtime.AddLoadPromise(
        this.PostToDOMAsync("create-audio-context", {
          preloadList: this._runtime
            .GetAssetManager()
            .GetAudioToPreload()
            .map((d) => ({
              originalUrl: d.originalUrl,
              url: d.url,
              type: d.type,
              fileSize: d.fileSize,
            })),
          isiOSCordova: this._runtime.IsiOSCordova(),
          timeScaleMode: this._timeScaleMode,
          latencyHint: a,
          panningModel: this._panningModel,
          distanceModel: this._distanceModel,
          refDistance: this._referenceDistance,
          maxDistance: this._maxDistance,
          rolloffFactor: this._rolloffFactor,
          listenerPos: [this._listenerX, this._listenerY, this._listenerZ],
        }).then((d) => {
          this._sampleRate = d.sampleRate;
          this._audioContextState = d.audioContextState;
        })
      );
      this._StartTicking();
    }
    Release() {
      this._listenerInst = null;
      super.Release();
    }
    _AddActionPromise(a) {
      this.GetPlugin()._AddActionPromise(a);
    }
    _OnInstanceDestroyed(a) {
      this._listenerInst === a && (this._listenerInst = null);
    }
    DbToLinearNoCap(a) {
      return Math.pow(10, a / 20);
    }
    DbToLinear(a) {
      a = this.DbToLinearNoCap(a);
      return isFinite(a) ? Math.max(Math.min(a, 1), 0) : 0;
    }
    LinearToDbNoCap(a) {
      return (Math.log(a) / Math.log(10)) * 20;
    }
    LinearToDb(a) {
      return this.LinearToDbNoCap(Math.max(Math.min(a, 1), 0));
    }
    _OnSuspend() {
      this._playInBackground ||
        this.PostToDOM("set-suspended", { isSuspended: !0 });
    }
    _OnResume() {
      this._playInBackground ||
        this.PostToDOM("set-suspended", { isSuspended: !1 });
    }
    _OnUpdateState(a) {
      const c = a.tickCount,
        d = this._lastAIState.filter(
          (f) =>
            f.hasOwnProperty("placeholder") &&
            (f.placeholder > c || -1 === f.placeholder)
        );
      this._lastAIState = a.audioInstances;
      this._lastAnalysersData = a.analysers;
      0 < d.length && e.appendArray(this._lastAIState, d);
    }
    _OnAudioContextStateChanged(a) {
      this._audioContextState = a.audioContextState;
    }
    GetAudioContextState() {
      return this._runtime.IsExportToVideo()
        ? "running"
        : this._audioContextState;
    }
    _OnUpdateFxState(a) {
      this._lastFxState = a.fxstate;
    }
    _GetFirstAudioStateByTag(a) {
      for (const c of this._lastAIState) if (e.equalsNoCase(c.tag, a)) return c;
      return null;
    }
    _IsTagPlaying(a) {
      return this._lastAIState.some(
        (c) => e.equalsNoCase(a, c.tag) && c.isPlaying
      );
    }
    _MaybeMarkAsPlaying(a, c, d, f) {
      if (this._IsTagPlaying(a)) return null;
      a = {
        tag: a,
        duration: 0,
        volume: f,
        isPlaying: !0,
        playbackTime: 0,
        playbackRate: 1,
        uid: -1,
        bufferOriginalUrl: "",
        bufferUrl: "",
        bufferType: "",
        isMusic: c,
        isLooping: d,
        isMuted: !1,
        resumePosition: 0,
        pan: null,
        placeholder: -1,
      };
      this._lastAIState.push(a);
      return a;
    }
    async _OnTrigger(a) {
      const c = a.type;
      this._triggerTag = a.tag;
      a = a.aiid;
      if ("ended" === c) {
        for (const d of this._lastAIState)
          if (d.aiid === a) {
            d.isPlaying = !1;
            break;
          }
        await this.TriggerAsync(e.Plugins.Audio.Cnds.OnEnded);
      } else
        "fade-ended" === c &&
          (await this.TriggerAsync(e.Plugins.Audio.Cnds.OnFadeEnded));
    }
    Tick() {
      const a = {
        timeScale: this._runtime.GetTimeScale(),
        gameTime: this._runtime.GetGameTimeRaw(),
        instPans: this.GetInstancePans(),
        tickCount: this._runtime.GetTickCountNoSave(),
      };
      if (this._listenerInst) {
        const c = this._listenerInst.GetWorldInfo();
        this._listenerX = c.GetX();
        this._listenerY = c.GetY();
        a.listenerPos = [this._listenerX, this._listenerY, this._listenerZ];
      }
      this.PostToDOM("tick", a);
    }
    rotatePtAround(a, c, d, f, h) {
      if (0 === d) return [a, c];
      const g = Math.sin(d);
      d = Math.cos(d);
      a -= f;
      c -= h;
      const k = a * g;
      a = a * d - c * g;
      return [a + f, c * d + k + h];
    }
    GetInstancePans() {
      return this._lastAIState
        .filter((a) => -1 !== a.uid)
        .map((a) => this._runtime.GetInstanceByUID(a.uid))
        .filter((a) => a)
        .map((a) => {
          const c = a.GetWorldInfo(),
            d = c.GetLayer().GetAngle(),
            [f, h] = this.rotatePtAround(
              c.GetX(),
              c.GetY(),
              -d,
              this._listenerX,
              this._listenerY
            );
          return { uid: a.GetUID(), x: f, y: h, angle: c.GetAngle() - d };
        });
    }
    GetAnalyserData(a, c) {
      for (const d of this._lastAnalysersData)
        if (d.index === c && e.equalsNoCase(d.tag, a)) return d;
      return null;
    }
    _IncrementEffectCount(a) {
      this._effectCount.set(a, (this._effectCount.get(a) || 0) + 1);
    }
    _ShouldSave(a) {
      return a.hasOwnProperty("placeholder") || 3 === this._saveLoadMode
        ? !1
        : a.isMusic && 1 === this._saveLoadMode
        ? !1
        : a.isMusic || 2 !== this._saveLoadMode
        ? !0
        : !1;
    }
    SaveToJson() {
      return {
        isSilent: this._isSilent,
        masterVolume: this._masterVolume,
        listenerZ: this._listenerZ,
        listenerUid: this._listenerInst ? this._listenerInst.GetUID() : -1,
        remoteUrls: [...this._remoteUrls.entries()],
        playing: this._lastAIState.filter((a) => this._ShouldSave(a)),
        effects: this._lastFxState,
        analysers: this._lastAnalysersData,
      };
    }
    LoadFromJson(a) {
      this._isSilent = a.isSilent;
      this._masterVolume = a.masterVolume;
      this._listenerZ = a.listenerZ;
      this._listenerInst = null;
      this._loadListenerUid = a.listenerUid;
      this._remoteUrls.clear();
      if (a.remoteUrls)
        for (const [c, d] of a.remoteUrls) this._remoteUrls.set(c, d);
      this._lastAIState = a.playing;
      this._lastFxState = a.effects;
      this._lastAnalysersData = a.analysers;
    }
    _OnAfterLoad() {
      if (
        -1 !== this._loadListenerUid &&
        ((this._listenerInst = this._runtime.GetInstanceByUID(
          this._loadListenerUid
        )),
        (this._loadListenerUid = -1),
        this._listenerInst)
      ) {
        var a = this._listenerInst.GetWorldInfo();
        this._listenerX = a.GetX();
        this._listenerY = a.GetY();
      }
      for (var c of this._lastAIState)
        (a = this._runtime
          .GetAssetManager()
          .GetProjectAudioFileUrl(c.bufferOriginalUrl))
          ? ((c.bufferUrl = a.url), (c.bufferType = a.type))
          : (c.bufferUrl = null);
      for (const d of Object.values(this._lastFxState))
        for (const f of d)
          f.hasOwnProperty("bufferOriginalUrl") &&
            (c = this._runtime
              .GetAssetManager()
              .GetProjectAudioFileUrl(f.bufferOriginalUrl)) &&
            ((f.bufferUrl = c.url), (f.bufferType = c.type));
      this.PostToDOM("load-state", {
        saveLoadMode: this._saveLoadMode,
        timeScale: this._runtime.GetTimeScale(),
        gameTime: this._runtime.GetGameTimeRaw(),
        listenerPos: [this._listenerX, this._listenerY, this._listenerZ],
        isSilent: this._isSilent,
        masterVolume: this._masterVolume,
        playing: this._lastAIState.filter((d) => null !== d.bufferUrl),
        effects: this._lastFxState,
      });
    }
    GetDebuggerProperties() {
      const a = [];
      for (const [c, d] of Object.entries(this._lastFxState))
        a.push({ name: "$" + c, value: d.map((f) => f.type).join(", ") });
      return [
        { title: "plugins.audio.debugger.tag-effects", properties: a },
        {
          title: "plugins.audio.debugger.currently-playing",
          properties: [
            {
              name: "plugins.audio.debugger.currently-playing-count",
              value: this._lastAIState.length,
            },
            ...this._lastAIState.map((c, d) => ({
              name: "$#" + d,
              value: `${c.bufferOriginalUrl} ("${c.tag}") ${
                Math.round(10 * c.playbackTime) / 10
              } / ${Math.round(10 * c.duration) / 10}`,
            })),
          ],
        },
      ];
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Audio.Cnds = {
    OnEnded(b) {
      return e.equalsNoCase(this._triggerTag, b);
    },
    OnFadeEnded(b) {
      return e.equalsNoCase(this._triggerTag, b);
    },
    PreloadsComplete() {
      return this._preloadCount === this._preloadTotal;
    },
    AdvancedAudioSupported() {
      return !0;
    },
    IsSilent() {
      return this._isSilent;
    },
    IsAnyPlaying() {
      for (const b of this._lastAIState) if (b.isPlaying) return !0;
      return !1;
    },
    IsTagPlaying(b) {
      return this._IsTagPlaying(b);
    },
  };
}
{
  const e = self.C3,
    b =
      "lowpass highpass bandpass lowshelf highshelf peaking notch allpass".split(
        " "
      );
  e.Plugins.Audio.Acts = {
    Play(a, c, d, f, h) {
      a = e.Plugins.Audio.Acts._DoPlay.call(this, a, c, d, f, h);
      this._AddActionPromise(a);
      return a;
    },
    async _DoPlay(a, c, d, f, h) {
      if (!this._isSilent) {
        var g = a[1],
          k = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
        if (k) {
          h = h ? h : 0;
          var m = this._nextPlayTime;
          this._nextPlayTime = 0;
          var q = this._MaybeMarkAsPlaying(
            f.toLowerCase(),
            g,
            0 !== c,
            this.DbToLinear(d)
          );
          try {
            await this.PostToDOMAsync("play", {
              originalUrl: a[0],
              url: k.url,
              type: k.type,
              isMusic: g,
              tag: f.toLowerCase(),
              isLooping: 0 !== c,
              vol: this.DbToLinear(d),
              pos: h,
              off: m,
              trueClock: !!self.C3_GetAudioContextCurrentTime,
            });
          } finally {
            q && (q.placeholder = this._runtime.GetTickCountNoSave());
          }
        }
      }
    },
    async PlayAtPosition(a, c, d, f, h, g, k, m, q, v) {
      if (!this._isSilent) {
        var r = a[1],
          n = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
        if (n) {
          var p = this._nextPlayTime;
          this._nextPlayTime = 0;
          var u = this._MaybeMarkAsPlaying(
            v.toLowerCase(),
            r,
            0 !== c,
            this.DbToLinear(d)
          );
          try {
            await this.PostToDOMAsync("play", {
              originalUrl: a[0],
              url: n.url,
              type: n.type,
              isMusic: r,
              tag: v.toLowerCase(),
              isLooping: 0 !== c,
              vol: this.DbToLinear(d),
              pos: 0,
              off: p,
              trueClock: !!self.C3_GetAudioContextCurrentTime,
              panning: {
                x: f,
                y: h,
                angle: e.toRadians(g),
                innerAngle: e.toRadians(k),
                outerAngle: e.toRadians(m),
                outerGain: this.DbToLinear(q),
              },
            });
          } finally {
            u && (u.placeholder = this._runtime.GetTickCountNoSave());
          }
        }
      }
    },
    async PlayAtObject(a, c, d, f, h, g, k, m) {
      if (
        !this._isSilent &&
        f &&
        (f = f.GetFirstPicked()) &&
        f.GetWorldInfo()
      ) {
        var q = f.GetWorldInfo(),
          v = q.GetLayer().GetAngle(),
          [r, n] = this.rotatePtAround(
            q.GetX(),
            q.GetY(),
            -v,
            this._listenerX,
            this._listenerY
          ),
          p = a[1],
          u = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
        if (u) {
          var w = this._nextPlayTime;
          this._nextPlayTime = 0;
          var y = this._MaybeMarkAsPlaying(
            m.toLowerCase(),
            p,
            0 !== c,
            this.DbToLinear(d)
          );
          try {
            await this.PostToDOMAsync("play", {
              originalUrl: a[0],
              url: u.url,
              type: u.type,
              isMusic: p,
              tag: m.toLowerCase(),
              isLooping: 0 !== c,
              vol: this.DbToLinear(d),
              pos: 0,
              off: w,
              trueClock: !!self.C3_GetAudioContextCurrentTime,
              panning: {
                x: r,
                y: n,
                angle: q.GetAngle() - v,
                innerAngle: e.toRadians(h),
                outerAngle: e.toRadians(g),
                outerGain: this.DbToLinear(k),
                uid: f.GetUID(),
              },
            });
          } finally {
            y && (y.placeholder = this._runtime.GetTickCountNoSave());
          }
        }
      }
    },
    async PlayByName(a, c, d, f, h) {
      if (!this._isSilent) {
        a = 1 === a;
        var g =
          this._runtime.GetAssetManager().GetProjectAudioFileUrl(c) ||
          this._remoteUrls.get(c.toLowerCase());
        if (g) {
          var k = this._nextPlayTime;
          this._nextPlayTime = 0;
          var m = this._MaybeMarkAsPlaying(
            h.toLowerCase(),
            a,
            0 !== d,
            this.DbToLinear(f)
          );
          try {
            await this.PostToDOMAsync("play", {
              originalUrl: c,
              url: g.url,
              type: g.type,
              isMusic: a,
              tag: h.toLowerCase(),
              isLooping: 0 !== d,
              vol: this.DbToLinear(f),
              pos: 0,
              off: k,
              trueClock: !!self.C3_GetAudioContextCurrentTime,
            });
          } finally {
            m && (m.placeholder = this._runtime.GetTickCountNoSave());
          }
        }
      }
    },
    async PlayAtPositionByName(a, c, d, f, h, g, k, m, q, v, r) {
      if (!this._isSilent) {
        a = 1 === a;
        var n =
          this._runtime.GetAssetManager().GetProjectAudioFileUrl(c) ||
          this._remoteUrls.get(c.toLowerCase());
        if (n) {
          var p = this._nextPlayTime;
          this._nextPlayTime = 0;
          var u = this._MaybeMarkAsPlaying(
            r.toLowerCase(),
            a,
            0 !== d,
            this.DbToLinear(f)
          );
          try {
            await this.PostToDOMAsync("play", {
              originalUrl: c,
              url: n.url,
              type: n.type,
              isMusic: a,
              tag: r.toLowerCase(),
              isLooping: 0 !== d,
              vol: this.DbToLinear(f),
              pos: 0,
              off: p,
              trueClock: !!self.C3_GetAudioContextCurrentTime,
              panning: {
                x: h,
                y: g,
                angle: e.toRadians(k),
                innerAngle: e.toRadians(m),
                outerAngle: e.toRadians(q),
                outerGain: this.DbToLinear(v),
              },
            });
          } finally {
            u && (u.placeholder = this._runtime.GetTickCountNoSave());
          }
        }
      }
    },
    async PlayAtObjectByName(a, c, d, f, h, g, k, m, q) {
      if (
        !this._isSilent &&
        !this._isSilent &&
        h &&
        (h = h.GetFirstPicked()) &&
        h.GetWorldInfo()
      ) {
        var v = h.GetWorldInfo(),
          r = v.GetLayer().GetAngle(),
          [n, p] = this.rotatePtAround(
            v.GetX(),
            v.GetY(),
            -r,
            this._listenerX,
            this._listenerY
          );
        a = 1 === a;
        var u =
          this._runtime.GetAssetManager().GetProjectAudioFileUrl(c) ||
          this._remoteUrls.get(c.toLowerCase());
        if (u) {
          var w = this._nextPlayTime;
          this._nextPlayTime = 0;
          var y = this._MaybeMarkAsPlaying(
            q.toLowerCase(),
            a,
            0 !== d,
            this.DbToLinear(f)
          );
          try {
            await this.PostToDOMAsync("play", {
              originalUrl: c,
              url: u.url,
              type: u.type,
              isMusic: a,
              tag: q.toLowerCase(),
              isLooping: 0 !== d,
              vol: this.DbToLinear(f),
              pos: 0,
              off: w,
              trueClock: !!self.C3_GetAudioContextCurrentTime,
              panning: {
                x: n,
                y: p,
                angle: v.GetAngle() - r,
                innerAngle: e.toRadians(g),
                outerAngle: e.toRadians(k),
                outerGain: this.DbToLinear(m),
                uid: h.GetUID(),
              },
            });
          } finally {
            y && (y.placeholder = this._runtime.GetTickCountNoSave());
          }
        }
      }
    },
    SetLooping(a, c) {
      this.PostToDOM("set-looping", {
        tag: a.toLowerCase(),
        isLooping: 0 === c,
      });
    },
    SetMuted(a, c) {
      this.PostToDOM("set-muted", { tag: a.toLowerCase(), isMuted: 0 === c });
    },
    SetVolume(a, c) {
      this.PostToDOM("set-volume", {
        tag: a.toLowerCase(),
        vol: this.DbToLinear(c),
      });
    },
    FadeVolume(a, c, d, f) {
      this.PostToDOM("fade-volume", {
        tag: a.toLowerCase(),
        vol: this.DbToLinear(c),
        duration: d,
        stopOnEnd: 0 === f,
      });
    },
    async Preload(a) {
      const c = a[1],
        d = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
      d &&
        (this._preloadTotal++,
        await this.PostToDOMAsync("preload", {
          originalUrl: a[0],
          url: d.url,
          type: d.type,
          isMusic: c,
        }),
        this._preloadCount++);
    },
    async PreloadByName(a, c) {
      a = 1 === a;
      const d =
        this._runtime.GetAssetManager().GetProjectAudioFileUrl(c) ||
        this._remoteUrls.get(c.toLowerCase());
      d &&
        (this._preloadTotal++,
        await this.PostToDOMAsync("preload", {
          originalUrl: c,
          url: d.url,
          type: d.type,
          isMusic: a,
        }),
        this._preloadCount++);
    },
    SetPlaybackRate(a, c) {
      this.PostToDOM("set-playback-rate", {
        tag: a.toLowerCase(),
        rate: Math.max(c, 0),
      });
    },
    Stop(a) {
      this.PostToDOM("stop", { tag: a.toLowerCase() });
    },
    StopAll() {
      this.PostToDOM("stop-all");
    },
    SetPaused(a, c) {
      this.PostToDOM("set-paused", { tag: a.toLowerCase(), paused: 0 === c });
    },
    Seek(a, c) {
      this.PostToDOM("seek", { tag: a.toLowerCase(), pos: c });
    },
    SetSilent(a) {
      2 === a && (a = this._isSilent ? 1 : 0);
      a = 0 === a;
      this._isSilent !== a &&
        ((this._isSilent = a), this.PostToDOM("set-silent", { isSilent: a }));
    },
    SetMasterVolume(a) {
      a = this.DbToLinear(a);
      this._masterVolume !== a &&
        ((this._masterVolume = a),
        this.PostToDOM("set-master-volume", { vol: a }));
    },
    AddFilterEffect(a, c, d, f, h, g, k) {
      a = a.toLowerCase();
      c = b[c];
      this._IncrementEffectCount(a);
      this.PostToDOM("add-effect", {
        type: "filter",
        tag: a,
        params: [c, d, f, h, g, e.clamp(k / 100, 0, 1)],
      });
    },
    AddDelayEffect(a, c, d, f) {
      a = a.toLowerCase();
      this._IncrementEffectCount(a);
      this.PostToDOM("add-effect", {
        type: "delay",
        tag: a,
        params: [c, this.DbToLinear(d), e.clamp(f / 100, 0, 1)],
      });
    },
    AddFlangerEffect(a, c, d, f, h, g) {
      a = a.toLowerCase();
      this._IncrementEffectCount(a);
      this.PostToDOM("add-effect", {
        type: "flanger",
        tag: a,
        params: [c / 1e3, d / 1e3, f, h / 100, e.clamp(g / 100, 0, 1)],
      });
    },
    AddPhaserEffect(a, c, d, f, h, g, k) {
      a = a.toLowerCase();
      this._IncrementEffectCount(a);
      this.PostToDOM("add-effect", {
        type: "phaser",
        tag: a,
        params: [c, d, f, h, g, e.clamp(k / 100, 0, 1)],
      });
    },
    AddConvolutionEffect(a, c, d, f) {
      a = a.toLowerCase();
      const h = this._runtime.GetAssetManager().GetProjectAudioFileUrl(c[0]);
      h &&
        (this._IncrementEffectCount(a),
        this.PostToDOM("add-effect", {
          type: "convolution",
          tag: a,
          bufferOriginalUrl: c[0],
          bufferUrl: h.url,
          bufferType: h.type,
          params: [0 === d, e.clamp(f / 100, 0, 1)],
        }));
    },
    AddGainEffect(a, c) {
      a = a.toLowerCase();
      this._IncrementEffectCount(a);
      this.PostToDOM("add-effect", {
        type: "gain",
        tag: a,
        params: [this.DbToLinear(c)],
      });
    },
    AddMuteEffect(a) {
      a = a.toLowerCase();
      this._IncrementEffectCount(a);
      this.PostToDOM("add-effect", { type: "gain", tag: a, params: [0] });
    },
    AddTremoloEffect(a, c, d) {
      a = a.toLowerCase();
      this._IncrementEffectCount(a);
      this.PostToDOM("add-effect", {
        type: "tremolo",
        tag: a,
        params: [c, e.clamp(d / 100, 0, 1)],
      });
    },
    AddRingModEffect(a, c, d) {
      a = a.toLowerCase();
      this._IncrementEffectCount(a);
      this.PostToDOM("add-effect", {
        type: "ringmod",
        tag: a,
        params: [c, e.clamp(d / 100, 0, 1)],
      });
    },
    AddDistortionEffect(a, c, d, f, h, g) {
      a = a.toLowerCase();
      this._IncrementEffectCount(a);
      this.PostToDOM("add-effect", {
        type: "distortion",
        tag: a,
        params: [
          this.DbToLinearNoCap(c),
          this.DbToLinearNoCap(d),
          f,
          this.DbToLinearNoCap(h),
          e.clamp(g / 100, 0, 1),
        ],
      });
    },
    AddCompressorEffect(a, c, d, f, h, g) {
      a = a.toLowerCase();
      this._IncrementEffectCount(a);
      this.PostToDOM("add-effect", {
        type: "compressor",
        tag: a,
        params: [c, d, f, h / 1e3, g / 1e3],
      });
    },
    AddAnalyserEffect(a, c, d) {
      a = a.toLowerCase();
      this._IncrementEffectCount(a);
      this.PostToDOM("add-effect", {
        type: "analyser",
        tag: a,
        params: [c, d],
      });
    },
    RemoveEffects(a) {
      a = a.toLowerCase();
      this._effectCount.set(a, 0);
      this.PostToDOM("remove-effects", { tag: a });
      this._lastFxState = {};
    },
    SetEffectParameter(a, c, d, f, h, g) {
      this.PostToDOM("set-effect-param", {
        tag: a.toLowerCase(),
        index: Math.floor(c),
        param: d,
        value: f,
        ramp: h,
        time: g,
      });
    },
    SetListenerObject(a) {
      a &&
        (a = a.GetFirstPicked()) &&
        a.GetWorldInfo() &&
        (this._listenerInst = a);
    },
    SetListenerZ(a) {
      this._listenerZ = a;
    },
    ScheduleNextPlay(a) {
      this._nextPlayTime = Math.max(a, 0);
    },
    UnloadAudio(a) {
      const c = a[1];
      (a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0])) &&
        this.PostToDOM("unload", { url: a.url, type: a.type, isMusic: c });
    },
    UnloadAudioByName(a, c) {
      a = 1 === a;
      (c =
        this._runtime.GetAssetManager().GetProjectAudioFileUrl(c) ||
        this._remoteUrls.get(c.toLowerCase())) &&
        this.PostToDOM("unload", { url: c.url, type: c.type, isMusic: a });
    },
    UnloadAll() {
      this.PostToDOM("unload-all");
    },
    AddRemoteURL(a, c, d) {
      this._remoteUrls.set(d.toLowerCase(), { url: a, type: c });
    },
  };
}
self.C3.Plugins.Audio.Exps = {
  Duration(e) {
    return (e = this._GetFirstAudioStateByTag(e)) ? e.duration : 0;
  },
  PlaybackTime(e) {
    return (e = this._GetFirstAudioStateByTag(e)) ? e.playbackTime : 0;
  },
  PlaybackRate(e) {
    return (e = this._GetFirstAudioStateByTag(e)) ? e.playbackRate : 0;
  },
  Volume(e) {
    return (e = this._GetFirstAudioStateByTag(e))
      ? this.LinearToDb(e.volume)
      : 0;
  },
  MasterVolume() {
    return this.LinearToDb(this._masterVolume);
  },
  EffectCount(e) {
    return this._effectCount.get(e.toLowerCase()) || 0;
  },
  AnalyserFreqBinCount(e, b) {
    return (e = this.GetAnalyserData(e, Math.floor(b))) ? e.binCount : 0;
  },
  AnalyserFreqBinAt(e, b, a) {
    e = this.GetAnalyserData(e, Math.floor(b));
    if (!e) return 0;
    a = Math.floor(a);
    return 0 > a || a >= e.binCount ? 0 : e.freqBins[a];
  },
  AnalyserPeakLevel(e, b) {
    return (e = this.GetAnalyserData(e, Math.floor(b))) ? e.peak : 0;
  },
  AnalyserRMSLevel(e, b) {
    return (e = this.GetAnalyserData(e, Math.floor(b))) ? e.rms : 0;
  },
  SampleRate() {
    return this._sampleRate;
  },
  CurrentTime() {
    return self.C3_GetAudioContextCurrentTime
      ? self.C3_GetAudioContextCurrentTime()
      : performance.now() / 1e3;
  },
};
("use strict");
{
  const e = self.C3;
  e.Plugins.Browser = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Browser.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3;
  e.Plugins.Browser.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b, "browser");
      this._initLocationStr = "";
      this._isOnline = !1;
      this._docTitle = this._referrer = "";
      this._isCookieEnabled = !1;
      this._windowOuterHeight =
        this._windowOuterWidth =
        this._screenHeight =
        this._screenWidth =
          0;
      this._isConstructArcade = !1;
      this.AddDOMMessageHandlers([
        ["online-state", (c) => this._OnOnlineStateChanged(c)],
        ["backbutton", () => this._OnBackButton()],
        ["sw-message", (c) => this._OnSWMessage(c)],
        ["hashchange", (c) => this._OnHashChange(c)],
      ]);
      b = this.GetRuntime().Dispatcher();
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(b, "afterfirstlayoutstart", () =>
          this._OnAfterFirstLayoutStart()
        ),
        e.Disposable.From(b, "window-resize", () => this._OnWindowResize()),
        e.Disposable.From(b, "suspend", () => this._OnSuspend()),
        e.Disposable.From(b, "resume", () => this._OnResume())
      );
      this._runtime.AddLoadPromise(
        this.PostToDOMAsync("get-initial-state", {
          exportType: this._runtime.GetExportType(),
        }).then((c) => {
          this._initLocationStr = c.location;
          this._isOnline = c.isOnline;
          this._referrer = c.referrer;
          this._docTitle = c.title;
          this._isCookieEnabled = c.isCookieEnabled;
          this._screenWidth = c.screenWidth;
          this._screenHeight = c.screenHeight;
          this._windowOuterWidth = c.windowOuterWidth;
          this._windowOuterHeight = c.windowOuterHeight;
          this._isConstructArcade = c.isConstructArcade;
        })
      );
    }
    Release() {
      super.Release();
    }
    _OnAfterFirstLayoutStart() {
      this.PostToDOM("ready-for-sw-messages");
    }
    async _OnOnlineStateChanged(b) {
      b = !!b.isOnline;
      this._isOnline !== b &&
        ((this._isOnline = b)
          ? await this.TriggerAsync(e.Plugins.Browser.Cnds.OnOnline)
          : await this.TriggerAsync(e.Plugins.Browser.Cnds.OnOffline));
    }
    async _OnWindowResize() {
      await this.TriggerAsync(e.Plugins.Browser.Cnds.OnResize);
    }
    _OnSuspend() {
      this.Trigger(e.Plugins.Browser.Cnds.OnPageHidden);
    }
    _OnResume() {
      this.Trigger(e.Plugins.Browser.Cnds.OnPageVisible);
    }
    async _OnBackButton() {
      await this.TriggerAsync(e.Plugins.Browser.Cnds.OnBackButton);
    }
    _OnSWMessage(b) {
      b = b.type;
      "downloading-update" === b
        ? this.Trigger(e.Plugins.Browser.Cnds.OnUpdateFound)
        : "update-ready" === b || "update-pending" === b
        ? this.Trigger(e.Plugins.Browser.Cnds.OnUpdateReady)
        : "offline-ready" === b &&
          this.Trigger(e.Plugins.Browser.Cnds.OnOfflineReady);
    }
    _OnHashChange(b) {
      this._initLocationStr = b.location;
      this.Trigger(e.Plugins.Browser.Cnds.OnHashChange);
    }
    GetDebuggerProperties() {
      return [
        {
          title: "plugins.browser.name",
          properties: [
            {
              name: "plugins.browser.debugger.user-agent",
              value: navigator.userAgent,
            },
            {
              name: "plugins.browser.debugger.is-online",
              value: this._isOnline,
            },
            {
              name: "plugins.browser.debugger.is-fullscreen",
              value: this._runtime.GetCanvasManager().IsDocumentFullscreen(),
            },
          ],
        },
      ];
    }
  };
}
self.C3.Plugins.Browser.Cnds = {
  IsOnline() {
    return this._isOnline;
  },
  OnOnline() {
    return !0;
  },
  OnOffline() {
    return !0;
  },
  OnResize() {
    return !0;
  },
  CookiesEnabled() {
    return this._isCookieEnabled;
  },
  IsFullscreen() {
    return this._runtime.GetCanvasManager().IsDocumentFullscreen();
  },
  OnBackButton() {
    return !0;
  },
  IsPortraitLandscape(e) {
    const b = this._runtime.GetCanvasManager().GetLastWidth(),
      a = this._runtime.GetCanvasManager().GetLastHeight();
    return (b <= a ? 0 : 1) === e;
  },
  OnUpdateFound() {
    return !0;
  },
  OnUpdateReady() {
    return !0;
  },
  OnOfflineReady() {
    return !0;
  },
  OnHashChange() {
    return !0;
  },
  PageVisible() {
    return !this._runtime.IsSuspended();
  },
  OnPageHidden() {
    return !0;
  },
  OnPageVisible() {
    return !0;
  },
  HasJava() {
    return !1;
  },
  IsDownloadingUpdate() {
    return !1;
  },
  OnMenuButton() {
    return !1;
  },
  OnSearchButton() {
    return !1;
  },
  IsMetered() {
    return !1;
  },
  IsCharging() {
    return !0;
  },
  SupportsFullscreen() {
    return !0;
  },
};
{
  const e = self.C3,
    b =
      "portrait landscape portrait-primary portrait-secondary landscape-primary landscape-secondary".split(
        " "
      );
  e.Plugins.Browser.Acts = {
    Alert(a) {
      this.PostToDOM("alert", { message: a.toString() });
    },
    Close() {
      this._isConstructArcade ||
        (this._runtime.IsDebug()
          ? self.C3Debugger.CloseWindow()
          : this.PostToDOM("close"));
    },
    Focus() {
      this.PostToDOM("set-focus", { isFocus: !0 });
    },
    Blur() {
      this.PostToDOM("set-focus", { isFocus: !1 });
    },
    GoBack() {
      this._isConstructArcade || this.PostToDOM("navigate", { type: "back" });
    },
    GoForward() {
      this._isConstructArcade ||
        this.PostToDOM("navigate", { type: "forward" });
    },
    GoHome() {},
    Reload() {
      this._isConstructArcade ||
        (this._runtime.IsDebug()
          ? this._runtime.PostToDebugger({ type: "reload" })
          : this.PostToDOM("navigate", { type: "reload" }));
    },
    GoToURL(a, c) {
      this._PostToDOMMaybeSync("navigate", {
        type: "url",
        url: a,
        target: c,
        exportType: this._runtime.GetExportType(),
      });
    },
    GoToURLWindow(a, c) {
      this._PostToDOMMaybeSync("navigate", {
        type: "new-window",
        url: a,
        tag: c,
        exportType: this._runtime.GetExportType(),
      });
    },
    RequestFullScreen(a, c) {
      2 <= a && (a += 1);
      6 === a && (a = 2);
      1 === a && (a = 0);
      a = e.CanvasManager._FullscreenModeNumberToString(a);
      this._runtime.GetCanvasManager().SetDocumentFullscreenMode(a);
      this._PostToDOMMaybeSync("request-fullscreen", { navUI: c });
    },
    CancelFullScreen() {
      this._PostToDOMMaybeSync("exit-fullscreen");
    },
    Vibrate(a) {
      a = a.split(",");
      for (let c = 0, d = a.length; c < d; ++c) a[c] = parseInt(a[c], 10);
      this._PostToDOMMaybeSync("vibrate", { pattern: a });
    },
    async InvokeDownload(a, c) {
      a &&
        c &&
        ((a = await this._runtime.GetAssetManager().GetProjectFileUrl(a)),
        this._runtime.InvokeDownload(a, c));
    },
    InvokeDownloadString(a, c, d) {
      d &&
        ((a = `data:${c},${encodeURIComponent(a)}`),
        this._runtime.InvokeDownload(a, d));
    },
    ConsoleLog(a, c) {
      c = c.toString();
      0 === a
        ? console.log(c)
        : 1 === a
        ? console.warn(c)
        : 2 === a && console.error(c);
    },
    ConsoleGroup(a) {
      console.group(a);
    },
    ConsoleGroupEnd() {
      console.groupEnd();
    },
    ExecJs(a) {
      try {
        eval(a);
      } catch (c) {
        console.error("Error executing JavaScript: ", c);
      }
    },
    LockOrientation(a) {
      a = Math.floor(a);
      0 > a ||
        a >= b.length ||
        this._PostToDOMMaybeSync("lock-orientation", { orientation: b[a] });
    },
    UnlockOrientation() {
      this._PostToDOMMaybeSync("unlock-orientation");
    },
    LoadStyleSheet(a) {
      this._runtime.GetAssetManager().LoadStyleSheet(a);
    },
    SetHash(a) {
      this.PostToDOM("set-hash", { hash: a });
    },
  };
}
self.C3.Plugins.Browser.Exps = {
  URL() {
    return this._runtime.IsInWorker()
      ? this._initLocationStr
      : location.toString();
  },
  Protocol() {
    return this._runtime.IsInWorker()
      ? new URL(this._initLocationStr).protocol
      : location.protocol;
  },
  Domain() {
    return this._runtime.IsInWorker()
      ? new URL(this._initLocationStr).hostname
      : location.hostname;
  },
  Port() {
    return this._runtime.IsInWorker()
      ? new URL(this._initLocationStr).port
      : location.port;
  },
  PathName() {
    return this._runtime.IsInWorker()
      ? new URL(this._initLocationStr).pathname
      : location.pathname;
  },
  Hash() {
    return this._runtime.IsInWorker()
      ? new URL(this._initLocationStr).hash
      : location.hash;
  },
  QueryString() {
    return this._runtime.IsInWorker()
      ? new URL(this._initLocationStr).search
      : location.search;
  },
  QueryParam(e) {
    const b = this._runtime.IsInWorker()
      ? new URL(this._initLocationStr).search
      : location.search;
    return (e = RegExp("[?&]" + e + "=([^&]*)").exec(b))
      ? decodeURIComponent(e[1].replace(/\+/g, " "))
      : "";
  },
  Referrer() {
    return this._referrer;
  },
  Title() {
    return this._docTitle;
  },
  Language() {
    return navigator.language;
  },
  Platform() {
    return navigator.platform;
  },
  UserAgent() {
    return navigator.userAgent;
  },
  ExecJS(e) {
    let b = 0;
    try {
      b = eval(e);
    } catch (a) {
      console.error("Error executing JavaScript: ", a);
    }
    return "number" === typeof b || "string" === typeof b
      ? b
      : "boolean" === typeof b
      ? b
        ? 1
        : 0
      : 0;
  },
  Name() {
    return navigator.appName;
  },
  Version() {
    return navigator.appVersion;
  },
  Product() {
    return navigator.product;
  },
  Vendor() {
    return navigator.vendor;
  },
  BatteryLevel() {
    return 1;
  },
  BatteryTimeLeft() {
    return Infinity;
  },
  Bandwidth() {
    const e = navigator.connection;
    return e
      ? e.downlink || e.downlinkMax || e.bandwidth || Infinity
      : Infinity;
  },
  ConnectionType() {
    const e = navigator.connection;
    return e ? e.type || "unknown" : "unknown";
  },
  DevicePixelRatio() {
    return self.devicePixelRatio;
  },
  ScreenWidth() {
    return this._screenWidth;
  },
  ScreenHeight() {
    return this._screenHeight;
  },
  WindowInnerWidth() {
    return this._runtime.GetCanvasManager().GetLastWidth();
  },
  WindowInnerHeight() {
    return this._runtime.GetCanvasManager().GetLastHeight();
  },
  WindowOuterWidth() {
    return this._windowOuterWidth;
  },
  WindowOuterHeight() {
    return this._windowOuterWidth;
  },
};
("use strict");
{
  const e = self.C3;
  e.Plugins.LocalStorage = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.LocalStorage.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3;
  e.Plugins.LocalStorage.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b);
      this._lastValue = this._currentKey = "";
      this._keyNamesList = [];
      this._errorMessage = "";
      this._pendingSets = this._pendingGets = 0;
      this._storage = this._runtime._GetProjectStorage();
      this._debugCache = new Map();
      this._isLoadingDebugCache = !1;
    }
    Release() {
      super.Release();
    }
    async _TriggerStorageError(b) {
      this._errorMessage = this._GetErrorString(b);
      await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnError);
    }
    _GetErrorString(b) {
      return b
        ? "string" === typeof b
          ? b
          : "string" === typeof b.message
          ? b.message
          : "string" === typeof b.name
          ? b.name
          : "string" === typeof b.data
          ? b.data
          : "unknown error"
        : "unknown error";
    }
    GetDebuggerProperties() {
      this._isLoadingDebugCache || this._DebugCacheStorage();
      return [
        {
          title: "plugins.localstorage.name",
          properties: [...this._debugCache.entries()].map((b) => ({
            name: "$" + b[0],
            value: b[1],
            onedit: (a) => this._storage.setItem(b[0], a),
          })),
        },
      ];
    }
    async _DebugCacheStorage() {
      this._isLoadingDebugCache = !0;
      try {
        const b = await this._storage.keys();
        b.sort((c, d) => {
          c = c.toLowerCase();
          d = d.toLowerCase();
          return c < d ? -1 : d < c ? 1 : 0;
        });
        const a = await Promise.all(b.map((c) => this._storage.getItem(c)));
        this._debugCache.clear();
        for (let c = 0, d = b.length; c < d; ++c)
          this._debugCache.set(b[c], a[c]);
      } catch (b) {
        console.warn("[C3 debugger] Error displaying local storage: ", b);
      } finally {
        this._isLoadingDebugCache = !1;
      }
    }
  };
}
{
  const e = self.C3;
  e.Plugins.LocalStorage.Cnds = {
    OnItemSet(b) {
      return this._currentKey === b;
    },
    OnAnyItemSet() {
      return !0;
    },
    OnItemGet(b) {
      return this._currentKey === b;
    },
    OnAnyItemGet() {
      return !0;
    },
    OnItemRemoved(b) {
      return this._currentKey === b;
    },
    OnAnyItemRemoved() {
      return !0;
    },
    OnCleared() {
      return !0;
    },
    OnAllKeyNamesLoaded() {
      return !0;
    },
    OnError() {
      return !0;
    },
    OnItemExists(b) {
      return this._currentKey === b;
    },
    OnItemMissing(b) {
      return this._currentKey === b;
    },
    CompareKey(b, a) {
      return e.compare(this._currentKey, b, a);
    },
    CompareValue(b, a) {
      return e.compare(this._lastValue, b, a);
    },
    IsProcessingSets() {
      return 0 < this._pendingSets;
    },
    IsProcessingGets() {
      return 0 < this._pendingGets;
    },
    OnAllSetsComplete() {
      return !0;
    },
    OnAllGetsComplete() {
      return !0;
    },
  };
}
{
  const e = self.C3;
  function b(a) {
    return "string" === typeof a || "number" === typeof a;
  }
  e.Plugins.LocalStorage.Acts = {
    async SetItem(a, c) {
      this._pendingSets++;
      try {
        const d = await this._storage.setItem(a, c);
        await this.ScheduleTriggers(async () => {
          this._currentKey = a;
          this._lastValue = d;
          await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAnyItemSet);
          await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemSet);
        });
      } catch (d) {
        await this._TriggerStorageError(d);
      } finally {
        this._pendingSets--,
          0 === this._pendingSets &&
            (await this.TriggerAsync(
              e.Plugins.LocalStorage.Cnds.OnAllSetsComplete
            ));
      }
    },
    async SetBinaryItem(a, c) {
      if (c && (c = c.GetFirstPicked(this._inst)) && (c = c.GetSdkInstance())) {
        c = c.GetArrayBufferReadOnly();
        this._pendingSets++;
        try {
          await this._storage.setItem(a, c),
            await this.ScheduleTriggers(async () => {
              this._currentKey = a;
              this._lastValue = "";
              await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAnyItemSet);
              await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemSet);
            });
        } catch (d) {
          await this._TriggerStorageError(d);
        } finally {
          this._pendingSets--,
            0 === this._pendingSets &&
              (await this.TriggerAsync(
                e.Plugins.LocalStorage.Cnds.OnAllSetsComplete
              ));
        }
      }
    },
    async GetItem(a) {
      this._pendingGets++;
      try {
        const c = await this._storage.getItem(a);
        await this.ScheduleTriggers(async () => {
          this._currentKey = a;
          this._lastValue = b(c) ? c : "";
          await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAnyItemGet);
          await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemGet);
        });
      } catch (c) {
        await this._TriggerStorageError(c);
      } finally {
        this._pendingGets--,
          0 === this._pendingGets &&
            (await this.TriggerAsync(
              e.Plugins.LocalStorage.Cnds.OnAllGetsComplete
            ));
      }
    },
    async GetBinaryItem(a, c) {
      if (c && (c = c.GetFirstPicked(this._inst))) {
        var d = c.GetSdkInstance();
        this._pendingGets++;
        try {
          let f = await this._storage.getItem(a);
          f = f instanceof ArrayBuffer ? f : new ArrayBuffer(0);
          await this.ScheduleTriggers(async () => {
            this._lastValue = "";
            this._currentKey = a;
            d.SetArrayBufferTransfer(f);
            await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAnyItemGet);
            await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemGet);
          });
        } catch (f) {
          await this._TriggerStorageError(f);
        } finally {
          this._pendingGets--,
            0 === this._pendingGets &&
              (await this.TriggerAsync(
                e.Plugins.LocalStorage.Cnds.OnAllGetsComplete
              ));
        }
      }
    },
    async CheckItemExists(a) {
      try {
        const c = await this._storage.getItem(a);
        await this.ScheduleTriggers(async () => {
          this._currentKey = a;
          "undefined" === typeof c || null === c
            ? ((this._lastValue = ""),
              await this.TriggerAsync(
                e.Plugins.LocalStorage.Cnds.OnItemMissing
              ))
            : ((this._lastValue = b(c) ? c : ""),
              await this.TriggerAsync(
                e.Plugins.LocalStorage.Cnds.OnItemExists
              ));
        });
      } catch (c) {
        await this._TriggerStorageError(c);
      }
    },
    async RemoveItem(a) {
      try {
        await this._storage.removeItem(a),
          await this.ScheduleTriggers(async () => {
            this._currentKey = a;
            this._lastValue = "";
            await this.TriggerAsync(
              e.Plugins.LocalStorage.Cnds.OnAnyItemRemoved
            );
            await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemRemoved);
          });
      } catch (c) {
        await this._TriggerStorageError(c);
      }
    },
    async ClearStorage() {
      try {
        await this._storage.clear(),
          await this.ScheduleTriggers(async () => {
            this._lastValue = this._currentKey = "";
            e.clearArray(this._keyNamesList);
            await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnCleared);
          });
      } catch (a) {
        await this._TriggerStorageError(a);
      }
    },
    async GetAllKeyNames() {
      try {
        const a = await this._storage.keys();
        await this.ScheduleTriggers(async () => {
          this._keyNamesList = a;
          await this.TriggerAsync(
            e.Plugins.LocalStorage.Cnds.OnAllKeyNamesLoaded
          );
        });
      } catch (a) {
        await this._TriggerStorageError(a);
      }
    },
  };
}
self.C3.Plugins.LocalStorage.Exps = {
  ItemValue() {
    return this._lastValue;
  },
  Key() {
    return this._currentKey;
  },
  KeyCount() {
    return this._keyNamesList.length;
  },
  KeyAt(e) {
    e = Math.floor(e);
    return 0 > e || e >= this._keyNamesList.length ? "" : this._keyNamesList[e];
  },
  ErrorMessage() {
    return this._errorMessage;
  },
};
("use strict");
{
  const e = self.C3;
  e.Plugins.NodeWebkit = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.NodeWebkit.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3,
    b = new Map([
      ["EACCES", "access denied"],
      ["EEXIST", "file exists"],
      ["EISDIR", "is a directory"],
      ["EMFILE", "too many open files"],
      ["ENOENT", "no such file or directory"],
      ["ENOTDIR", "not a directory"],
      ["ENOTEMPTY", "directory not empty"],
      ["EPERM", "operation not permitted"],
    ]);
  e.Plugins.NodeWebkit.Instance = class extends e.SDKInstanceBase {
    constructor(a, c) {
      super(a, "nwjs");
      this._isNWjs =
        "nwjs" === this._runtime.GetExportType() ||
        (this._runtime.IsPreview() && /nwjs\//i.test(navigator.userAgent));
      this._os =
        this._process =
        this._childProcess =
        this._fs =
        this._path =
          null;
      this._projectFilesFolder =
        this._userFolder =
        this._appFolder =
        this._fileError =
        this._currentTag =
          "";
      this._slash = "\\";
      this._fileList = [];
      this._chosenPath = this._droppedFile = "";
      this._argv = [];
      this._windowTitle = this._clipboardText = "";
      this._windowHeight =
        this._windowWidth =
        this._windowY =
        this._windowX =
          0;
      this._isNWjs && this._InitNWjs();
    }
    _InitNWjs() {
      this._path = require("path");
      this._fs = require("fs");
      this._childProcess = require("child_process");
      this._process = self.process || nw.process;
      this._os = require("os");
      "win32" !== this._process.platform && (this._slash = "/");
      this._appFolder =
        this._path.dirname(this._process.execPath) + this._slash;
      this._userFolder = this._os.homedir() + this._slash;
      this._projectFilesFolder = this._process.mainModule.filename;
      const a = Math.max(
        this._projectFilesFolder.lastIndexOf("/"),
        this._projectFilesFolder.lastIndexOf("\\")
      );
      -1 !== a &&
        (this._projectFilesFolder = this._projectFilesFolder.substr(0, a + 1));
      this.AddDOMMessageHandlers([
        ["drop", (c) => this._OnDrop(c)],
        ["open-dlg", (c) => this._OnOpenDlg(c)],
        ["open-dlg-cancel", () => this._OnOpenDlgCancel()],
        ["folder-dlg", (c) => this._OnFolderDlg(c)],
        ["folder-dlg-cancel", () => this._OnFolderDlgCancel()],
        ["save-dlg", (c) => this._OnSaveDlg(c)],
        ["save-dlg-cancel", () => this._OnSaveDlgCancel()],
        ["window-change", (c) => this._OnWindowChange(c)],
        ["clipboard-change", (c) => this._OnClipboardChange(c)],
      ]);
      this._runtime.AddLoadPromise(
        this.PostToDOMAsync("init").then((c) => {
          this._OnWindowChange(c);
          this._OnClipboardChange(c);
          this._argv = c.argv;
        })
      );
    }
    Release() {
      super.Release();
    }
    _OnWindowChange(a) {
      this._windowTitle = a["window-title"];
      this._windowX = a["window-x"];
      this._windowY = a["window-y"];
      this._windowWidth = a["window-width"];
      this._windowHeight = a["window-height"];
    }
    _OnClipboardChange(a) {
      this._clipboardText = a["clipboard-text"];
    }
    _BufferToArrayBuffer(a) {
      const c = a.buffer,
        d = a.byteLength,
        f = a.byteOffset;
      return c.byteLength !== a.length ? c.slice(f, f + d) : c;
    }
    _GetBinaryDataSdkInstance(a) {
      return a
        ? (a = a.GetFirstPicked(this._inst))
          ? a.GetSdkInstance()
          : null
        : null;
    }
    _ReadBinaryFile(a) {
      return new Promise((c, d) => {
        this._fs.readFile(a, {}, (f, h) => {
          f ? d(f) : c(this._BufferToArrayBuffer(h));
        });
      });
    }
    _WriteBinaryFile(a, c) {
      e.WeakRequireInstanceOf(c, ArrayBuffer);
      const d = new Uint8Array(c);
      return new Promise((f, h) => {
        this._fs.writeFile(a, d, {}, (g) => {
          g ? h(g) : f();
        });
      });
    }
    _GetFileError(a) {
      return a && "string" === typeof a.code
        ? b.get(a.code) || a.code
        : "unknown error";
    }
    _OnFileSystemError(a) {
      this._fileError = this._GetFileError(a);
      this.Trigger(e.Plugins.NodeWebkit.Cnds.OnFileSystemError);
      this._fileError = "";
    }
    async _OnDrop(a) {
      a = a.filePaths;
      for (const c of a)
        (this._droppedFile = c),
          await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnFileDrop);
      this._droppedFile = "";
    }
    async _OnOpenDlg(a) {
      this._chosenPath = a.chosenPath;
      await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnOpenDlg);
    }
    async _OnOpenDlgCancel() {
      await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnOpenDlgCancel);
    }
    async _OnFolderDlg(a) {
      this._chosenPath = a.chosenPath;
      await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnFolderDlg);
    }
    async _OnFolderDlgCancel() {
      await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnFolderDlgCancel);
    }
    async _OnSaveDlg(a) {
      this._chosenPath = a.chosenPath;
      await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnSaveDlg);
    }
    async _OnSaveDlgCancel() {
      await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnSaveDlgCancel);
    }
    GetDebuggerProperties() {
      return [
        {
          title: "plugins.nodewebkit.name",
          properties: [
            {
              name: "plugins.nodewebkit.debugger.app-folder",
              value: this._appFolder,
            },
            {
              name: "plugins.nodewebkit.debugger.user-folder",
              value: this._userFolder,
            },
            {
              name: "plugins.nodewebkit.debugger.project-files-folder",
              value: this._projectFilesFolder,
            },
          ],
        },
      ];
    }
  };
}
self.C3.Plugins.NodeWebkit.Cnds = {
  PathExists(e) {
    return this._isNWjs ? this._fs.existsSync(e) : !1;
  },
  OnBinaryFileRead(e) {
    return this._currentTag === e;
  },
  OnBinaryFileWritten(e) {
    return this._currentTag === e;
  },
  OnFileSystemError() {
    return !0;
  },
  OnFileDrop() {
    return !0;
  },
  OnOpenDlg() {
    return !0;
  },
  OnFolderDlg() {
    return !0;
  },
  OnSaveDlg() {
    return !0;
  },
  OnOpenDlgCancel() {
    return !0;
  },
  OnFolderDlgCancel() {
    return !0;
  },
  OnSaveDlgCancel() {
    return !0;
  },
};
{
  const e = self.C3;
  function b(a, c, d) {
    "function" === typeof a.copyfileSync
      ? a.copyfileSync(c, d)
      : ((c = a.readFileSync(c, { flags: "rb" })),
        a.writeFileSync(d, c, { flags: "wb" }));
  }
  e.Plugins.NodeWebkit.Acts = {
    WriteTextFile(a, c) {
      if (this._isNWjs)
        try {
          this._fs.writeFileSync(a, c, { encoding: "utf8" });
        } catch (d) {
          console.error(`Error writing text file '${a}': `, d),
            this._OnFileSystemError(d);
        }
    },
    async ReadBinaryFile(a, c, d) {
      d = this._GetBinaryDataSdkInstance(d);
      if (this._isNWjs && d)
        try {
          const f = await this._ReadBinaryFile(c);
          d.SetArrayBufferTransfer(f);
          this._currentTag = a;
          await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnBinaryFileRead);
          this._currentTag = "";
        } catch (f) {
          console.error(`Error reading binary file '${c}': `, f),
            this._OnFileSystemError(f);
        }
    },
    async WriteBinaryFile(a, c, d) {
      d = this._GetBinaryDataSdkInstance(d);
      if (this._isNWjs && d)
        try {
          const f = d.GetArrayBufferReadOnly();
          await this._WriteBinaryFile(c, f);
          this._currentTag = a;
          await this.TriggerAsync(
            e.Plugins.NodeWebkit.Cnds.OnBinaryFileWritten
          );
          this._currentTag = "";
        } catch (f) {
          console.error(`Error writing binary file '${c}': `, f),
            this._OnFileSystemError(f);
        }
    },
    RenameFile(a, c) {
      if (this._isNWjs)
        try {
          this._fs.renameSync(a, c);
        } catch (d) {
          console.error(`Error renaming file '${a}': `, d),
            this._OnFileSystemError(d);
        }
    },
    DeleteFile(a) {
      if (this._isNWjs)
        try {
          this._fs.unlinkSync(a);
        } catch (c) {
          "ENOENT" !== c.code &&
            (console.error(`Error deleting file '${a}': `, c),
            this._OnFileSystemError(c));
        }
    },
    CopyFile(a, c) {
      if (this._isNWjs)
        try {
          b(this._fs, a, c);
        } catch (d) {
          console.error(`Error copying file '${a}': `, d),
            this._OnFileSystemError(d);
        }
    },
    MoveFile(a, c) {
      if (this._isNWjs && a !== c)
        try {
          b(this._fs, a, c), this._fs.existsSync(c) && this._fs.unlinkSync(a);
        } catch (d) {
          console.error(`Error moving file '${a}': `, d),
            this._OnFileSystemError(d);
        }
    },
    RunFile(a) {
      this._isNWjs && this._childProcess.exec(a, () => {});
    },
    ShellOpen(a) {
      this._isNWjs &&
        this.PostToDOM("shell-cmd", { method: "openItem", arg: a });
    },
    OpenBrowser(a) {
      this._isNWjs &&
        this.PostToDOM("shell-cmd", { method: "openExternal", arg: a });
    },
    CreateFolder(a) {
      if (this._isNWjs)
        try {
          this._fs.mkdirSync(a);
        } catch (c) {
          console.error(`Error creating folder '${a}': `, c),
            this._OnFileSystemError(c);
        }
    },
    AppendFile(a, c) {
      if (this._isNWjs)
        try {
          this._fs.appendFileSync(a, c, { encoding: "utf8" });
        } catch (d) {
          console.error(`Error appending to file '${a}': `, d),
            this._OnFileSystemError(d);
        }
    },
    ListFiles(a) {
      if (this._isNWjs)
        try {
          this._fileList = this._fs.readdirSync(a);
        } catch (c) {
          (this._fileList = []),
            console.error(`Error listing files at '${a}': `, c),
            this._OnFileSystemError(c);
        }
    },
    ShowOpenDlg(a) {
      this._isNWjs && this.PostToDOM("show-open-dlg", { accept: a });
    },
    ShowFolderDlg() {
      this._isNWjs && this.PostToDOM("show-folder-dlg");
    },
    ShowSaveDlg(a) {
      this._isNWjs && this.PostToDOM("show-save-dlg", { accept: a });
    },
    SetWindowX(a) {
      this._isNWjs && this.PostToDOM("set-window-x", { x: a });
    },
    SetWindowY(a) {
      this._isNWjs && this.PostToDOM("set-window-y", { y: a });
    },
    SetWindowWidth(a) {
      this._isNWjs && this.PostToDOM("set-window-width", { width: a });
    },
    SetWindowHeight(a) {
      this._isNWjs && this.PostToDOM("set-window-height", { height: a });
    },
    SetWindowTitle(a) {
      this._isNWjs &&
        ((this._windowTitle = a), this.PostToDOM("set-title", { title: a }));
    },
    WindowMinimize() {
      this._isNWjs && this.PostToDOM("window-cmd", { method: "minimize" });
    },
    WindowMaximize() {
      this._isNWjs && this.PostToDOM("window-cmd", { method: "maximize" });
    },
    WindowUnmaximize() {
      this._isNWjs && this.PostToDOM("window-cmd", { method: "unmaximize" });
    },
    WindowRestore() {
      this._isNWjs && this.PostToDOM("window-cmd", { method: "restore" });
    },
    WindowRequestAttention(a) {
      this._isNWjs &&
        this.PostToDOM("window-attention", { request: a ? 3 : 0 });
    },
    WindowSetMaxSize(a, c) {
      this._isNWjs &&
        this.PostToDOM("set-window-max-size", { width: a, height: c });
    },
    WindowSetMinSize(a, c) {
      this._isNWjs &&
        this.PostToDOM("set-window-min-size", { width: a, height: c });
    },
    WindowSetResizable(a) {
      this._isNWjs &&
        this.PostToDOM("set-window-resizable", { resizable: 0 !== a });
    },
    WindowSetAlwaysOnTop(a) {
      this._isNWjs && this.PostToDOM("set-window-always-top", { top: 0 !== a });
    },
    ShowDevTools() {
      this._isNWjs && this.PostToDOM("window-cmd", { method: "showDevTools" });
    },
    SetClipboardText(a) {
      this._isNWjs &&
        ((this._clipboardText = a),
        this.PostToDOM("set-clipboard", { text: a }));
    },
    ClearClipboard() {
      this._isNWjs &&
        ((this._clipboardText = ""), this.PostToDOM("clear-clipboard"));
    },
  };
}
self.C3.Plugins.NodeWebkit.Exps = {
  AppFolder() {
    return this._appFolder;
  },
  AppFolderURL() {
    return "file://" + this._appFolder;
  },
  ProjectFilesFolder() {
    return this._projectFilesFolder;
  },
  ProjectFilesFolderURL() {
    return "file://" + this._projectFilesFolder;
  },
  UserFolder() {
    return this._userFolder;
  },
  ReadFile(e) {
    if (!this._isNWjs) return "";
    let b = "";
    try {
      b = this._fs.readFileSync(e, { encoding: "utf8" });
    } catch (a) {
      console.error(`Failed to read file '${e}': `, a),
        this._OnFileSystemError(a);
    }
    return b;
  },
  FileSize(e) {
    if (!this._isNWjs) return 0;
    let b = 0;
    try {
      const a = this._fs.statSync(e);
      a && (b = a.size || 0);
    } catch (a) {
      console.error(`Failed to read file '${e}' size: `, a),
        this._OnFileSystemError(a);
    }
    return b;
  },
  ListCount() {
    return this._fileList.length;
  },
  ListAt(e) {
    e = Math.floor(e);
    return 0 > e || e >= this._fileList.length ? "" : this._fileList[e];
  },
  DroppedFile() {
    return this._droppedFile;
  },
  ChosenPath() {
    return this._chosenPath;
  },
  WindowX() {
    return this._windowX;
  },
  WindowY() {
    return this._windowY;
  },
  WindowWidth() {
    return this._windowWidth;
  },
  WindowHeight() {
    return this._windowHeight;
  },
  WindowTitle() {
    return this._windowTitle;
  },
  ClipboardText() {
    return this._isNWjs ? this._clipboardText : "";
  },
  ArgumentCount() {
    return this._isNWjs ? this._argv.length : 0;
  },
  ArgumentAt(e) {
    if (!this._isNWjs) return "";
    e = Math.floor(e);
    const b = this._argv;
    return 0 > e || e >= b.length ? "" : b[e];
  },
  FileError() {
    return this._fileError;
  },
};
("use strict");
{
  const e = self.C3;
  e.Plugins.Particles = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Particles.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {
      this.GetImageInfo().LoadAsset(this._runtime);
    }
    LoadTextures(b) {
      return this.GetImageInfo().LoadStaticTexture(b, {
        sampling: this._runtime.GetSampling(),
      });
    }
    ReleaseTextures() {
      this.GetImageInfo().ReleaseTexture();
    }
  };
}
{
  const e = self.C3,
    b = e.New(e.Rect);
  e.Plugins.Particles.Instance = class extends e.SDKWorldInstanceBase {
    constructor(a, c) {
      super(a);
      this._isFirstTick = !0;
      this._particleEngine = a = e.New(self.ParticleEngine);
      a.ononeshotfinish = () => this._OnOneShotFinish();
      this._spawnObjectClass = null;
      this._particleUpdateCallback = (f, h, g, k, m, q) =>
        this._OnParticleUpdate(f, h, g, k, m, q);
      this._particleDestroyCallback = (f) => this._OnParticleDestroy(f);
      this._hasAnyDefaultParticle = !0;
      c &&
        (a.SetRate(c[0]),
        a.SetSprayCone(e.toRadians(c[1])),
        a.SetSprayType(c[2] ? "one-shot" : "continuous-spray"),
        this._SetParticleObjectClass(this._runtime.GetObjectClassBySID(c[3])),
        a.SetInitSpeed(c[4]),
        a.SetInitSize(c[5]),
        a.SetInitOpacity(c[6] / 100),
        a.SetGrowRate(c[7]),
        a.SetInitXRandom(c[8]),
        a.SetInitYRandom(c[9]),
        a.SetInitSpeedRandom(c[10]),
        a.SetInitSizeRandom(c[11]),
        a.SetGrowRandom(c[12]),
        a.SetAcceleration(c[13]),
        a.SetGravity(c[14]),
        a.SetLifeAngleRandom(c[15]),
        a.SetLifeSpeedRandom(c[16]),
        a.SetLifeOpacityRandom(c[17]),
        a.SetDestroyModeIndex(c[18]),
        a.SetTimeout(c[19]));
      this._UpdateEngineParameters();
      this._spawnObjectClass && (this._hasAnyDefaultParticle = !1);
      "one-shot" === a.GetSprayType()
        ? a.CreateOneShotSpray()
        : a.SetSpraying(!0);
      const d = this.GetWorldInfo();
      d.SetBboxChangeEventEnabled(!0);
      this._inst.Dispatcher().addEventListener("bboxchange", () => {
        d.OverwriteBoundingBox(this._particleEngine.GetBoundingBox());
      });
      this.GetRuntime().GetRenderer().IsWebGPU() &&
        d.SetUsePointsShaderProgram();
      this._afterLoad = (f) => this._OnAfterLoad(f);
      this.GetRuntime()
        .Dispatcher()
        .addEventListener("afterload", this._afterLoad);
      this._StartTicking();
    }
    Release() {
      this.GetRuntime()
        .Dispatcher()
        .removeEventListener("afterload", this._afterLoad);
      this._afterLoad = null;
      this._particleEngine.Release();
      this._particleDestroyCallback =
        this._particleUpdateCallback =
        this._particleEngine =
          null;
      super.Release();
    }
    _SetParticleObjectClass(a) {
      a === this.GetObjectClass() && (a = null);
      this._spawnObjectClass = a;
      this._particleEngine.onparticlecreate = a
        ? (c) => this._OnParticleCreate(c)
        : null;
      this._spawnObjectClass || (this._hasAnyDefaultParticle = !0);
    }
    _UpdateEngineParameters() {
      const a = this._particleEngine,
        c = this.GetWorldInfo();
      a.SetMasterOpacity(c.GetOpacity());
      a.SetPixelRounding(this._runtime.IsPixelRoundingEnabled());
      a.SetSpawnX(c.GetX());
      a.SetSpawnY(c.GetY());
      a.SetSpawnAngle(c.GetAngle());
      a.SetInitSizeScale(c.GetSceneGraphScale());
    }
    _OnOneShotFinish() {
      this._runtime.DestroyInstance(this._inst);
    }
    Draw(a) {
      if (this._hasAnyDefaultParticle) {
        var c = this._objectClass.GetImageInfo(),
          d = c.GetTexture();
        if (d) {
          var f = this.GetWorldInfo(),
            h = f.GetLayer();
          this._runtime.GetCanvasManager().IsPastingToDrawingCanvas()
            ? b.set(-Infinity, -Infinity, Infinity, Infinity)
            : h.Has3DCamera()
            ? h.CalculateViewport3D(f.GetTotalZElevation(), b)
            : h.GetViewportForZ(f.GetTotalZElevation(), b);
          a.SetTexture(d);
          d = h.Get2DScaleFactorToZ(f.GetTotalZElevation());
          this._particleEngine.SetParticleScale(h.GetRenderScale() * d);
          this._particleEngine.Draw(a, c.GetTexRect(), b, h.Has3DCamera());
        }
      }
    }
    SaveToJson() {
      const a = this._particleEngine;
      return {
        r: a.GetRate(),
        sc: a.GetSprayCone(),
        st: a.GetSprayType(),
        isp: a.GetInitSpeed(),
        isz: a.GetInitSize(),
        io: a.GetInitOpacity(),
        gr: a.GetGrowRate(),
        xr: a.GetInitXRandom(),
        yr: a.GetInitYRandom(),
        spr: a.GetInitSpeedRandom(),
        szr: a.GetInitSizeRandom(),
        grnd: a.GetGrowRandom(),
        acc: a.GetAcceleration(),
        g: a.GetGravity(),
        lar: a.GetLifeAngleRandom(),
        lsr: a.GetLifeSpeedRandom(),
        lor: a.GetLifeOpacityRandom(),
        dm: a.GetDestroyModeIndex(),
        to: a.GetTimeout(),
        s: a.IsSpraying(),
        pcc: a._GetCreateCounter(),
        ft: this._isFirstTick,
        p: a.GetParticles().map((c) => c.toJSON()),
      };
    }
    LoadFromJson(a) {
      var c = this._particleEngine;
      c.SetRate(a.r);
      c.SetSprayCone(a.sc);
      c.SetSprayType(a.st);
      c.SetInitSpeed(a.isp);
      c.SetInitSize(a.isz);
      c.SetInitOpacity(a.io);
      c.SetGrowRate(a.gr);
      c.SetInitXRandom(a.xr);
      c.SetInitYRandom(a.yr);
      c.SetInitSpeedRandom(a.spr);
      c.SetInitSizeRandom(a.szr);
      c.SetGrowRandom(a.grnd);
      c.SetAcceleration(a.acc);
      c.SetGravity(a.g);
      c.SetLifeAngleRandom(a.lar);
      c.SetLifeSpeedRandom(a.lsr);
      c.SetLifeOpacityRandom(a.lor);
      c.SetDestroyModeIndex(a.dm);
      c.SetTimeout(a.to);
      c.SetSpraying(a.s);
      c._SetCreateCounter(a.pcc);
      this._isFirstTick = a.ft;
      a = a.p;
      c.SetParticleCount(a.length);
      c = c.GetParticles();
      for (let d = 0, f = c.length; d < f; ++d) c[d].setFromJSON(a[d]);
    }
    _OnAfterLoad() {
      var a = this._particleEngine;
      a.UpdateAllParticlesUserData();
      a.ApplyParticleDataToUserData(this);
      if ("one-shot" === a.GetSprayType()) {
        a = a.GetParticles();
        for (let f = 0, h = a.length; f < h; ++f) {
          var c = a[f],
            d = c.GetUserData();
          d &&
            (d = d.GetWorldInfo()) &&
            (d = d.GetInstance()) &&
            ((c = c.GetUserDataUID()),
            (d = d.GetUID()),
            "number" !== typeof c || "number" !== typeof d || c !== d) &&
            ((d = this.GetRuntime()),
            (c = d.GetInstanceByUID(c)) && d.DestroyInstance(c));
        }
      }
    }
    Tick() {
      const a = this._runtime.GetDt(this._inst);
      this._UpdateEngineParameters();
      this._isFirstTick &&
        "one-shot" === this._particleEngine.GetSprayType() &&
        this._particleEngine.ReInitAllParticles();
      this._particleEngine.Tick(a);
      this._particleEngine.IsSpraying() && this._runtime.UpdateRender();
      this.GetWorldInfo().SetBboxChanged();
      this._isFirstTick = !1;
    }
    _OnParticleCreate(a) {
      const c = this._runtime.CreateInstance(
          this._spawnObjectClass,
          this.GetWorldInfo().GetLayer(),
          a.GetX(),
          a.GetY()
        ),
        d = c.GetWorldInfo();
      d.SetSize(a.GetSize(), a.GetSize());
      d.SetAngle(a.GetAngle());
      d.SetOpacity(a.GetOpacity());
      d.SetUnpremultipliedColor(this.GetWorldInfo().GetUnpremultipliedColor());
      d.SetBboxChanged();
      d.ZOrderMoveAdjacentToInstance(this.GetInstance(), !0);
      c._TriggerOnCreated();
      a.SetUpdateCallback(this._particleUpdateCallback);
      a.SetDestroyCallback(this._particleDestroyCallback);
      return c;
    }
    _OnParticleUpdate(a, c, d, f, h, g) {
      a.IsDestroyed() ||
        ((a = a.GetWorldInfo()),
        a.OffsetXY(c, d),
        a.SetSize(a.GetWidth() + f, a.GetHeight() + f),
        a.SetAngle(a.GetAngle() + h),
        a.SetOpacity(a.GetOpacity() + g),
        a.SetBboxChanged());
    }
    _OnParticleDestroy(a) {
      a.IsDestroyed() || this._runtime.DestroyInstance(a);
    }
    GetPropertyValueByIndex(a) {
      const c = this._particleEngine;
      switch (a) {
        case 0:
          return c.GetRate();
        case 1:
          return e.toDegrees(c.GetSprayCone());
        case 2:
          return "one-shot" === c.GetSprayType() ? 1 : 0;
        case 4:
          return c.GetInitSpeed();
        case 5:
          return c.GetInitSize();
        case 6:
          return 100 * c.GetInitOpacity();
        case 7:
          return c.GetGrowRate();
        case 8:
          return c.GetInitXRandom();
        case 9:
          return c.GetInitYRandom();
        case 10:
          return c.GetInitSpeedRandom();
        case 11:
          return c.GetInitSizeRandom();
        case 12:
          return c.GetGrowRandom();
        case 13:
          return c.GetAcceleration();
        case 14:
          return c.GetGravity();
        case 15:
          return c.GetLifeAngleRandom();
        case 16:
          return c.GetLifeSpeedRandom();
        case 17:
          return c.GetLifeOpacityRandom();
        case 18:
          return c.GetDestroyModeIndex();
        case 19:
          return c.GetTimeout();
      }
    }
    SetPropertyValueByIndex(a, c) {
      const d = this._particleEngine;
      switch (a) {
        case 0:
          d.SetRate(c);
          break;
        case 1:
          d.SetSprayCone(e.toRadians(c));
          break;
        case 2:
          d.SetSprayType(c ? "one-shot" : "continuous-spray");
          break;
        case 4:
          d.SetInitSpeed(c);
          break;
        case 5:
          d.SetInitSize(c);
          break;
        case 6:
          d.SetInitOpacity(c / 100);
          break;
        case 7:
          d.SetGrowRate(c);
          break;
        case 8:
          d.SetInitXRandom(c);
          break;
        case 9:
          d.SetInitYRandom(c);
          break;
        case 10:
          d.SetInitSpeedRandom(c);
          break;
        case 11:
          d.SetInitSizeRandom(c);
          break;
        case 12:
          d.SetGrowRandom(c);
          break;
        case 13:
          d.SetAcceleration(c);
          break;
        case 14:
          d.SetGravity(c);
          break;
        case 15:
          d.SetLifeAngleRandom(c);
          break;
        case 16:
          d.SetLifeSpeedRandom(c);
          break;
        case 17:
          d.SetLifeOpacityRandom(c);
          break;
        case 18:
          d.SetDestroyModeIndex(c);
          break;
        case 19:
          d.SetTimeout(c);
      }
    }
    GetDebuggerProperties() {
      const a = this._particleEngine;
      return [
        {
          title: "plugins.particles.name",
          properties: [
            {
              name: "plugins.particles.debugger.particle-count",
              value: a.GetParticleCount(),
            },
            {
              name: "plugins.particles.properties.type.name",
              value: [
                "plugins.particles.properties.type.items." + a.GetSprayType(),
              ],
            },
            {
              name: "plugins.particles.debugger.is-spraying",
              value: a.IsSpraying(),
              onedit: (c) => a.SetSpraying(c),
            },
            {
              name: "plugins.particles.properties.rate.name",
              value: a.GetRate(),
              onedit: (c) => a.SetRate(c),
            },
            {
              name: "plugins.particles.properties.spray-cone.name",
              value: e.toDegrees(a.GetSprayCone()),
              onedit: (c) => a.SetSprayCone(e.toRadians(c)),
            },
            {
              name: "plugins.particles.properties.speed.name",
              value: a.GetInitSpeed(),
              onedit: (c) => a.SetInitSpeed(c),
            },
            {
              name: "plugins.particles.properties.size.name",
              value: a.GetInitSize(),
              onedit: (c) => a.SetInitSize(c),
            },
            {
              name: "plugins.particles.properties.opacity.name",
              value: a.GetInitOpacity(),
              onedit: (c) => a.SetInitOpacity(c),
            },
            {
              name: "plugins.particles.properties.grow-rate.name",
              value: a.GetGrowRate(),
              onedit: (c) => a.SetGrowRate(c),
            },
            {
              name: "plugins.particles.properties.x-randomiser.name",
              value: a.GetInitXRandom(),
              onedit: (c) => a.SetInitXRandom(c),
            },
            {
              name: "plugins.particles.properties.y-randomiser.name",
              value: a.GetInitYRandom(),
              onedit: (c) => a.SetInitYRandom(c),
            },
            {
              name: "plugins.particles.properties.initial-speed-randomiser.name",
              value: a.GetInitSpeedRandom(),
              onedit: (c) => a.SetInitSpeedRandom(c),
            },
            {
              name: "plugins.particles.properties.size-randomiser.name",
              value: a.GetInitSizeRandom(),
              onedit: (c) => a.SetInitSizeRandom(c),
            },
            {
              name: "plugins.particles.properties.grow-rate-randomiser.name",
              value: a.GetGrowRandom(),
              onedit: (c) => a.SetGrowRandom(c),
            },
            {
              name: "plugins.particles.properties.acceleration.name",
              value: a.GetAcceleration(),
              onedit: (c) => a.SetAcceleration(c),
            },
            {
              name: "plugins.particles.properties.gravity.name",
              value: a.GetGravity(),
              onedit: (c) => a.SetGravity(c),
            },
            {
              name: "plugins.particles.properties.angle-randomiser.name",
              value: a.GetLifeAngleRandom(),
              onedit: (c) => a.SetLifeAngleRandom(c),
            },
            {
              name: "plugins.particles.properties.life-speed-randomiser.name",
              value: a.GetLifeSpeedRandom(),
              onedit: (c) => a.SetLifeSpeedRandom(c),
            },
            {
              name: "plugins.particles.properties.opacity-randomiser.name",
              value: a.GetLifeOpacityRandom(),
              onedit: (c) => a.SetLifeOpacityRandom(c),
            },
            {
              name: "plugins.particles.properties.timeout.name",
              value: a.GetTimeout(),
              onedit: (c) => a.SetTimeout(c),
            },
          ],
        },
      ];
    }
  };
}
self.C3.Plugins.Particles.Cnds = {
  IsSpraying() {
    return this._particleEngine.IsSpraying();
  },
};
{
  const e = self.C3;
  e.Plugins.Particles.Acts = {
    SetSpraying(b) {
      this._particleEngine.SetSpraying(0 !== b);
    },
    SetRate(b) {
      this._particleEngine.SetRate(b);
      "one-shot" === this._particleEngine.GetSprayType() &&
        this._isFirstTick &&
        this._particleEngine.SetParticleCount(b);
    },
    SetParticleObject(b) {
      this._SetParticleObjectClass(b);
    },
    UnsetParticleObject() {
      this._SetParticleObjectClass(null);
    },
    SetSprayCone(b) {
      this._particleEngine.SetSprayCone(e.toRadians(b));
    },
    SetInitSpeed(b) {
      this._particleEngine.SetInitSpeed(b);
    },
    SetInitSize(b) {
      this._particleEngine.SetInitSize(b);
    },
    SetInitOpacity(b) {
      this._particleEngine.SetInitOpacity(b / 100);
    },
    SetGrowRate(b) {
      this._particleEngine.SetGrowRate(b);
    },
    SetXRandomiser(b) {
      this._particleEngine.SetInitXRandom(b);
    },
    SetYRandomiser(b) {
      this._particleEngine.SetInitYRandom(b);
    },
    SetSpeedRandomiser(b) {
      this._particleEngine.SetInitSpeedRandom(b);
    },
    SetSizeRandomiser(b) {
      this._particleEngine.SetInitSizeRandom(b);
    },
    SetGrowRateRandomiser(b) {
      this._particleEngine.SetGrowRandom(b);
    },
    SetParticleAcc(b) {
      this._particleEngine.SetAcceleration(b);
    },
    SetGravity(b) {
      this._particleEngine.SetGravity(b);
    },
    SetAngleRandomiser(b) {
      this._particleEngine.SetLifeAngleRandom(b);
    },
    SetLifeSpeedRandomiser(b) {
      this._particleEngine.SetLifeSpeedRandom(b);
    },
    SetOpacityRandomiser(b) {
      this._particleEngine.SetLifeOpacityRandom(b);
    },
    SetTimeout(b) {
      this._particleEngine.SetTimeout(b);
    },
    SetEffect(b) {
      this.GetWorldInfo().SetBlendMode(b);
      this._runtime.UpdateRender();
    },
  };
}
{
  const e = self.C3;
  e.Plugins.Particles.Exps = {
    ParticleCount() {
      return this._particleEngine.GetParticleCount();
    },
    Rate() {
      return this._particleEngine.GetRate();
    },
    SprayCone() {
      return e.toDegrees(this._particleEngine.GetSprayCone());
    },
    InitSpeed() {
      return this._particleEngine.GetInitSpeed();
    },
    InitSize() {
      return this._particleEngine.GetInitSize();
    },
    InitOpacity() {
      return 100 * this._particleEngine.GetInitOpacity();
    },
    InitGrowRate() {
      return this._particleEngine.GetGrowRate();
    },
    XRandom() {
      return this._particleEngine.GetInitXRandom();
    },
    YRandom() {
      return this._particleEngine.GetInitYRandom();
    },
    InitSizeRandom() {
      return this._particleEngine.GetInitSizeRandom();
    },
    InitSpeedRandom() {
      return this._particleEngine.GetInitSpeedRandom();
    },
    InitGrowRandom() {
      return this._particleEngine.GetGrowRandom();
    },
    ParticleAcceleration() {
      return this._particleEngine.GetAcceleration();
    },
    Gravity() {
      return this._particleEngine.GetGravity();
    },
    ParticleAngleRandom() {
      return this._particleEngine.GetLifeAngleRandom();
    },
    ParticleSpeedRandom() {
      return this._particleEngine.GetLifeSpeedRandom();
    },
    ParticleOpacityRandom() {
      return this._particleEngine.GetLifeOpacityRandom();
    },
    Timeout() {
      return this._particleEngine.GetTimeout();
    },
  };
}
{
  ("use strict");
  const e = self.C3,
    b = [],
    a = new Set(["continuous-spray", "one-shot"]),
    c = ["fade-to-invisible", "timeout-expired", "particle-stopped"];
  self.ParticleEngine = class {
    constructor() {
      this._sprayCone = this._rate = 0;
      this._sprayType = "continuous-spray";
      this._isSpraying = !1;
      this._masterOpacity = 0;
      this._isPixelRounding = !1;
      this._initSize =
        this._initSpeed =
        this._spawnAngle =
        this._spawnY =
        this._spawnX =
          0;
      this._initSizeScale = 1;
      this._createCounter =
        this._timeout =
        this._destroyMode =
        this._lifeOpacityRandom =
        this._lifeSpeedRandom =
        this._lifeAngleRandom =
        this._gravity =
        this._acceleration =
        this._growRandom =
        this._initSizeRandom =
        this._initSpeedRandom =
        this._yRandom =
        this._xRandom =
        this._growRate =
        this._initOpacity =
          0;
      this._particleScale = 1;
      this.onparticlecreate = this.ononeshotfinish = null;
      this._particles = [];
      this._boundingBox = new e.Rect();
      this._color = new e.Color();
    }
    Release() {
      this.Cancel();
      e.clearArray(this._particles);
      this._color =
        this._boundingBox =
        this.onparticlecreate =
        this.ononeshotfinish =
        this._particles =
          null;
    }
    Cancel() {
      const d = this._particles;
      for (let f = 0, h = d.length; f < h; ++f) d[f].Destroy();
      e.appendArray(b, d);
      e.clearArray(d);
      1e3 < b.length && e.truncateArray(b, 1e3);
      this._isSpraying = !1;
    }
    CreateOneShotSpray() {
      for (let d = 0, f = this._rate; d < f; ++d) this._CreateParticle();
      this._particles.length && (this._isSpraying = !0);
    }
    _CreateParticle() {
      let d;
      b.length
        ? ((d = b.pop()), d.SetEngine(this))
        : (d = e.New(self.Particle, this));
      this._particles.push(d);
      d.Init(this.onparticlecreate);
      return d;
    }
    ReInitAllParticles() {
      const d = this._particles,
        f = this.onparticlecreate;
      for (let h = 0, g = d.length; h < g; ++h) d[h].Init(f);
    }
    UpdateAllParticlesUserData() {
      const d = this._particles,
        f = this.onparticlecreate;
      for (let h = 0, g = d.length; h < g; ++h) d[h].UpdateUserData(f);
    }
    ApplyParticleDataToUserData(d) {
      const f = this._particles;
      for (let g = 0, k = f.length; g < k; ++g) {
        const m = f[g];
        var h = m.GetUserData();
        h &&
          ((h = h.GetWorldInfo()),
          h.SetX(m.GetX()),
          h.SetY(m.GetY()),
          h.SetSize(m.GetSize(), m.GetSize()),
          h.SetOpacity(m.GetOpacity()),
          h.SetAngle(m.GetAngle()),
          h.SetUnpremultipliedColor(d.GetWorldInfo().GetUnpremultipliedColor()),
          h.SetBboxChanged());
      }
    }
    SetParticleCount(d) {
      var f = this._particles;
      if (d < f.length) {
        d = f.length - d;
        for (let h = 0; h < d; ++h) {
          const g = f.pop();
          g.Destroy();
          b.push(g);
        }
        1e3 < b.length && e.truncateArray(b, 1e3);
      } else if (d > f.length)
        for (f = d - f.length, d = 0; d < f; ++d) this._CreateParticle();
    }
    GetParticles() {
      return this._particles;
    }
    GetParticleCount() {
      return this._particles.length;
    }
    Tick(d) {
      this._SpawnContinuous(d);
      this._TickParticles(d);
      this._MaybeFinishOneShot();
    }
    _SpawnContinuous(d) {
      if ("continuous-spray" === this._sprayType && this._isSpraying) {
        this._createCounter += d * this._rate;
        d = Math.floor(this._createCounter);
        this._createCounter -= d;
        for (let f = 0; f < d; ++f) this._CreateParticle();
      }
    }
    _SetCreateCounter(d) {
      this._createCounter = d;
    }
    _GetCreateCounter() {
      return this._createCounter;
    }
    _TickParticles(d) {
      const f = this._boundingBox;
      f.set(this._spawnX, this._spawnY, this._spawnX, this._spawnY);
      const h = this._particles;
      let g = 0;
      for (let k = 0, m = h.length; k < m; ++k) {
        const q = h[k];
        h[g] = q;
        q.Tick(d);
        q.IsActive()
          ? (++g, f.expandToContain(q.GetBoundingBox()))
          : (q.Destroy(), b.push(q));
      }
      e.truncateArray(h, g);
      1e3 < b.length && e.truncateArray(b, 1e3);
    }
    _MaybeFinishOneShot() {
      if (
        "one-shot" === this._sprayType &&
        0 === this._particles.length &&
        this._isSpraying
      ) {
        if (this.ononeshotfinish) this.ononeshotfinish();
        this._isSpraying = !1;
      }
    }
    Draw(d, f, h, g) {
      d.StartRenderingPoints(f);
      this._color.copy(d.GetColor());
      const k = this._particles;
      for (let m = 0, q = k.length; m < q; ++m) {
        const v = k[m];
        h.intersectsRect(v.GetBoundingBox()) && v.Draw(d, f, g);
      }
      d.FinishRenderingPoints();
    }
    GetColor() {
      return this._color;
    }
    SetRate(d) {
      this._rate = +d;
    }
    GetRate() {
      return this._rate;
    }
    SetSprayCone(d) {
      this._sprayCone = +d;
    }
    GetSprayCone() {
      return this._sprayCone;
    }
    SetSprayType(d) {
      if (!a.has(d)) throw Error("invalid spray type");
      this._sprayType = d;
    }
    GetSprayType() {
      return this._sprayType;
    }
    SetSpraying(d) {
      this._isSpraying = !!d;
    }
    IsSpraying() {
      return this._isSpraying;
    }
    SetMasterOpacity(d) {
      this._masterOpacity = +d;
    }
    GetMasterOpacity() {
      return this._masterOpacity;
    }
    SetPixelRounding(d) {
      this._isPixelRounding = !!d;
    }
    IsPixelRounding() {
      return this._isPixelRounding;
    }
    SetSpawnX(d) {
      this._spawnX = +d;
    }
    GetSpawnX() {
      return this._spawnX;
    }
    SetSpawnY(d) {
      this._spawnY = +d;
    }
    GetSpawnY() {
      return this._spawnY;
    }
    SetSpawnAngle(d) {
      this._spawnAngle = +d;
    }
    GetInitAngle() {
      return this._spawnAngle;
    }
    SetInitSpeed(d) {
      this._initSpeed = +d;
    }
    GetInitSpeed() {
      return this._initSpeed;
    }
    SetInitSize(d) {
      this._initSize = +d;
    }
    GetInitSize() {
      return this._initSize;
    }
    SetInitSizeScale(d) {
      this._initSizeScale = +d;
    }
    GetInitSizeScale() {
      return this._initSizeScale;
    }
    SetInitOpacity(d) {
      this._initOpacity = +d;
    }
    GetInitOpacity() {
      return this._initOpacity;
    }
    SetGrowRate(d) {
      this._growRate = +d;
    }
    GetGrowRate() {
      return this._growRate;
    }
    SetInitXRandom(d) {
      this._xRandom = +d;
    }
    GetInitXRandom() {
      return this._xRandom;
    }
    SetInitYRandom(d) {
      this._yRandom = +d;
    }
    GetInitYRandom() {
      return this._yRandom;
    }
    SetInitSpeedRandom(d) {
      this._initSpeedRandom = +d;
    }
    GetInitSpeedRandom() {
      return this._initSpeedRandom;
    }
    SetInitSizeRandom(d) {
      this._initSizeRandom = +d;
    }
    GetInitSizeRandom() {
      return this._initSizeRandom;
    }
    SetGrowRandom(d) {
      this._growRandom = +d;
    }
    GetGrowRandom() {
      return this._growRandom;
    }
    SetAcceleration(d) {
      this._acceleration = +d;
    }
    GetAcceleration() {
      return this._acceleration;
    }
    SetGravity(d) {
      this._gravity = +d;
    }
    GetGravity() {
      return this._gravity;
    }
    SetLifeAngleRandom(d) {
      this._lifeAngleRandom = +d;
    }
    GetLifeAngleRandom() {
      return this._lifeAngleRandom;
    }
    SetLifeSpeedRandom(d) {
      this._lifeSpeedRandom = +d;
    }
    GetLifeSpeedRandom() {
      return this._lifeSpeedRandom;
    }
    SetLifeOpacityRandom(d) {
      this._lifeOpacityRandom = +d;
    }
    GetLifeOpacityRandom() {
      return this._lifeOpacityRandom;
    }
    SetDestroyMode(d) {
      d = c.indexOf(d);
      if (-1 === d) throw Error("invalid destroy mode");
      this._destroyMode = d;
    }
    SetDestroyModeIndex(d) {
      this.SetDestroyMode(c[d]);
    }
    GetDestroyMode() {
      return c[this._destroyMode];
    }
    GetDestroyModeIndex() {
      return this._destroyMode;
    }
    SetTimeout(d) {
      this._timeout = +d;
    }
    GetTimeout() {
      return this._timeout;
    }
    SetParticleScale(d) {
      this._particleScale = +d;
    }
    GetParticleScale() {
      return this._particleScale;
    }
    GetBoundingBox() {
      return this._boundingBox;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  function b(h) {
    return Math.random() * h - h / 2;
  }
  const a = new e.Quad(),
    c = new e.Color(),
    d = self.devicePixelRatio || 1;
  let f = !1;
  self.Particle = class {
    constructor(h) {
      this._engine = h;
      this._isActive = !1;
      this._angle = this._speed = this._y = this._x = 0;
      this._opacity = 1;
      this._age =
        this._gs =
        this._halfSize =
        this._size =
        this._grow =
        this._lastOpacity =
          0;
      this._bbox = new e.Rect();
      this._userData = null;
      this._userDataUid = NaN;
      this._destroyCallback = this._updateCallback = null;
    }
    SetEngine(h) {
      this._engine = h;
    }
    Init(h) {
      const g = this._engine;
      this._isActive = !0;
      this._x = g.GetSpawnX() + b(g.GetInitXRandom());
      this._y = g.GetSpawnY() + b(g.GetInitYRandom());
      this._speed = g.GetInitSpeed() + b(g.GetInitSpeedRandom());
      this._angle = g.GetInitAngle() + b(g.GetSprayCone());
      this._lastOpacity = this._opacity = g.GetInitOpacity();
      this._size =
        (g.GetInitSize() + b(g.GetInitSizeRandom())) * g.GetInitSizeScale();
      this._halfSize = this._size / 2;
      this._grow = g.GetGrowRate() + b(g.GetGrowRandom());
      this._age = this._gs = 0;
      this._UpdateBoundingBox();
      h
        ? this._userData || (this._userData = h(this))
        : (this._destroyCallback =
            this._updateCallback =
            this._userData =
              null);
    }
    UpdateUserData(h) {
      if (h) {
        if (!this._userData || this._userData.IsDestroyed())
          this._userData = h(this);
      } else
        this._destroyCallback = this._updateCallback = this._userData = null;
    }
    SetUpdateCallback(h) {
      this._updateCallback = h;
    }
    SetDestroyCallback(h) {
      this._destroyCallback = h;
    }
    Destroy() {
      const h = this._destroyCallback;
      h && h(this._userData);
      this._destroyCallback = this._updateCallback = this._userData = null;
    }
    toJSON() {
      let h;
      this._userData &&
        (h = this._userData.GetWorldInfo().GetInstance().GetUID());
      return [
        this._x,
        this._y,
        this._speed,
        this._angle,
        this._opacity,
        this._grow,
        this._size,
        this._gs,
        this._age,
        h,
      ];
    }
    setFromJSON(h) {
      this._x = h[0];
      this._y = h[1];
      this._speed = h[2];
      this._angle = h[3];
      this._opacity = h[4];
      this._grow = h[5];
      this._size = h[6];
      this._gs = h[7];
      this._age = h[8];
      this._userDataUid = h[9];
      this._halfSize = this._size / 2;
      this._UpdateBoundingBox();
    }
    Tick(h) {
      var g = this._engine,
        k = this._speed * h,
        m = this._angle;
      const q = Math.cos(m) * k;
      k = Math.sin(m) * k + this._gs * h;
      this._x += q;
      this._y += k;
      m = this._grow * h;
      this._size += m;
      this._halfSize = this._size / 2;
      this._speed += g.GetAcceleration() * h;
      this._gs += g.GetGravity() * h;
      this._age += h;
      this._UpdateBoundingBox();
      var v = g.GetLifeAngleRandom(),
        r = g.GetLifeSpeedRandom();
      const n = g.GetLifeOpacityRandom();
      let p = 0;
      0 !== v && ((p = b(v * h)), (this._angle += p));
      0 !== r && (this._speed += b(r * h));
      0 !== n && (this._opacity = e.clamp(this._opacity + b(n * h), 0, 1));
      h =
        1 <= this._size &&
        (2 === g.GetDestroyModeIndex()
          ? 0 < this._speed
          : this._age < g.GetTimeout());
      (v = this._updateCallback) &&
        h &&
        ((r = g.GetMasterOpacity() * this._opacity),
        0 === g.GetDestroyModeIndex() && (r *= 1 - this._age / g.GetTimeout()),
        (g = r - this._lastOpacity),
        (this._lastOpacity = r),
        v(this._userData, q, k, m, p, g));
      this._isActive = h;
    }
    IsActive() {
      return this._isActive;
    }
    GetBoundingBox() {
      return this._bbox;
    }
    _UpdateBoundingBox() {
      const h = this._x,
        g = this._y,
        k = this._halfSize;
      this._bbox.set(h - k, g - k, h + k, g + k);
    }
    Draw(h, g, k) {
      if (!this._userData) {
        var m = this._engine,
          q = m.GetMasterOpacity() * this._opacity;
        0 === m.GetDestroyModeIndex() && (q *= 1 - this._age / m.GetTimeout());
        if (!(0 >= q)) {
          var v = this._size,
            r = v * m.GetParticleScale() * d;
          if (!(1 > r)) {
            var n = this._x,
              p = this._y;
            m.IsPixelRounding() && ((n = (n + 0.5) | 0), (p = (p + 0.5) | 0));
            h.IsWebGPU()
              ? h.Point(n, p, v, q)
              : k || r > h.GetMaxPointSize() || r < h.GetMinPointSize()
              ? (c.copy(m.GetColor()),
                c.multiplyAlpha(q),
                h.SetColor(c),
                (f = !0),
                a.setFromRect(this._bbox),
                h.Quad3(a, g))
              : (f && (h.SetColor(m.GetColor()), (f = !1)),
                h.Point(n, p, r, q));
          }
        }
      }
    }
    GetUserData() {
      return this._userData;
    }
    GetUserDataUID() {
      return this._userDataUid;
    }
    GetX() {
      return this._x;
    }
    GetY() {
      return this._y;
    }
    GetSize() {
      return this._size;
    }
    GetAngle() {
      return this._angle;
    }
    GetOpacity() {
      return this._opacity;
    }
  };
}
("use strict");
{
  const e = self.C3;
  e.Plugins.Tilemap = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
  e.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL = -2147483648;
  e.Plugins.Tilemap.TILE_FLIPPED_VERTICAL = 1073741824;
  e.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL = 536870912;
  e.Plugins.Tilemap.TILE_FLAGS_MASK = 3758096384;
  e.Plugins.Tilemap.TILE_ID_MASK = 536870911;
}
{
  const e = self.C3,
    b = e.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL,
    a = e.Plugins.Tilemap.TILE_FLIPPED_VERTICAL,
    c = e.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL,
    d = e.Plugins.Tilemap.TILE_ID_MASK;
  e.Plugins.Tilemap.Type = class extends e.SDKTypeBase {
    constructor(f) {
      super(f);
      this._tilePolys = [];
      this._areTilePolysCached = !1;
      this._maxTileIndex = 0;
      this._brushesData = [];
    }
    Release() {
      super.Release();
    }
    OnCreate() {
      this.GetImageInfo().LoadAsset(this._runtime);
    }
    LoadTextures(f) {
      return this.GetImageInfo().LoadStaticTexture(f, {
        sampling: this._runtime.GetSampling(),
      });
    }
    ReleaseTextures() {
      this.GetImageInfo().ReleaseTexture();
    }
    OnDynamicTextureLoadComplete() {
      for (const f of this.GetObjectClass().instancesIncludingPendingCreate())
        f.GetSdkInstance()._OnDynamicTextureLoadComplete();
    }
    LoadTilemapData(f, h, g) {
      this._maxTileIndex = h;
      for (const k of f)
        k
          ? this._tilePolys.push({
              poly: k[0],
              use: !!k[1],
              flipmap: [
                [
                  [null, null],
                  [null, null],
                ],
                [
                  [null, null],
                  [null, null],
                ],
              ],
            })
          : this._tilePolys.push(null);
      for (const k of g)
        this._brushesData.push({ name: k[0], type: k[1], tileData: k[2] });
    }
    _ForceCacheOfTileCollisionPolys(f, h) {
      this._areTilePolysCached = !1;
      this._MaybeCacheTileCollisionPolys(f, h);
    }
    _MaybeCacheTileCollisionPolys(f, h) {
      if (!this._areTilePolysCached) {
        this._areTilePolysCached = !0;
        for (let g = 0, k = this._tilePolys.length; g < k; ++g)
          this._tilePolys[g] &&
            (this._CacheTilePoly(g, f, h, !1, !1, !1),
            this._CacheTilePoly(g, f, h, !1, !1, !0),
            this._CacheTilePoly(g, f, h, !1, !0, !1),
            this._CacheTilePoly(g, f, h, !1, !0, !0),
            this._CacheTilePoly(g, f, h, !0, !1, !1),
            this._CacheTilePoly(g, f, h, !0, !1, !0),
            this._CacheTilePoly(g, f, h, !0, !0, !1),
            this._CacheTilePoly(g, f, h, !0, !0, !0));
      }
    }
    _CacheTilePoly(f, h, g, k, m, q) {
      if (!(0 > f || f >= this._tilePolys.length) && (f = this._tilePolys[f])) {
        var v = e.New(e.CollisionPoly, f.poly, f.use);
        v.transform(h, g, 0);
        q && v.diag();
        k && v.mirror(h / 2);
        m && v.flip(g / 2);
        f.flipmap[k ? 1 : 0][m ? 1 : 0][q ? 1 : 0] = null;
        f.flipmap[k ? 1 : 0][m ? 1 : 0][q ? 1 : 0] = v;
      }
    }
    GetTilePoly(f) {
      if (-1 === f) return null;
      var h = f & d;
      return 0 > h || h >= this._tilePolys.length
        ? null
        : (h = this._tilePolys[h])
        ? h.flipmap[f & b ? 1 : 0][f & a ? 1 : 0][f & c ? 1 : 0]
        : null;
    }
    IsTilePolyEnabled(f) {
      return f ? f.IsEnabled() : !0;
    }
    GetMaxTileIndex() {
      return this._maxTileIndex;
    }
    GetBrushData(f) {
      return this._brushesData[f];
    }
  };
}
{
  const e = self.C3,
    b = self.C3X,
    a = e.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL,
    c = e.Plugins.Tilemap.TILE_FLIPPED_VERTICAL,
    d = e.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL,
    f = e.Plugins.Tilemap.TILE_FLAGS_MASK,
    h = e.Plugins.Tilemap.TILE_ID_MASK,
    g = e.New(e.Rect),
    k = e.New(e.Rect),
    m = e.New(e.Rect);
  function q(n) {
    const p = [];
    n = n.split(",");
    for (let B = 0, E = n.length; B < E; ++B) {
      var u = n[B],
        w = u.indexOf("x");
      if (-1 < w) {
        var y = parseInt(u.substring(0, w), 10);
        u = u.substring(w + 1);
        w = parseInt(u, 10);
        u.includes("h") && (w |= a);
        u.includes("v") && (w |= c);
        for (u.includes("d") && (w |= d); 0 < y; --y) p.push(w);
      } else
        (y = parseInt(u, 10)),
          u.includes("h") && (y |= a),
          u.includes("v") && (y |= c),
          u.includes("d") && (y |= d),
          p.push(y);
    }
    return p;
  }
  e.Plugins.Tilemap.Instance = class extends e.SDKWorldInstanceBase {
    constructor(n, p) {
      super(n);
      n = this.GetWorldInfo();
      this._tileHeight = this._tileWidth = 32;
      this._mapHeight =
        this._mapWidth =
        this._tileYspacing =
        this._tileXspacing =
        this._tileYoffset =
        this._tileXoffset =
          0;
      this._lastWidth = n.GetWidth();
      this._lastHeight = n.GetHeight();
      this._cellHeight = this._cellWidth = 0;
      this._tileCells = [];
      this._tileTexQuads = new Map();
      this._isAnyQuadMapChanged = !0;
      this._ownImageInfo = null;
      p &&
        (n.SetVisible(p[0]),
        (this._tileWidth = Math.max(p[1], 1)),
        (this._tileHeight = Math.max(p[2], 1)),
        (this._tileXoffset = p[3]),
        (this._tileYoffset = p[4]),
        (this._tileXspacing = p[5]),
        (this._tileYspacing = p[6]));
      this._cellWidth = Math.ceil(
        this._runtime.GetOriginalViewportWidth() / this._tileWidth
      );
      this._cellHeight = Math.ceil(
        this._runtime.GetOriginalViewportHeight() / this._tileHeight
      );
      this._sdkType._MaybeCacheTileCollisionPolys(
        this._tileWidth,
        this._tileHeight
      );
      this._autoTiling = null;
    }
    Release() {
      this._ReleaseOwnImage();
      e.clearArray(this._tileCells);
      this._tileCells = null;
      this._tileTexQuads.clear();
      this._tileTexQuads = null;
      super.Release();
    }
    _ReleaseOwnImage() {
      this._ownImageInfo &&
        (this._ownImageInfo.Release(), (this._ownImageInfo = null));
    }
    LoadTilemapData(n, p, u) {
      this._mapWidth = p;
      this._mapHeight = u;
      this._MaybeResizeTilemap(!0);
      this.SetTilesFromRLECSV(n);
      this._MaybeBuildAllQuadMap();
    }
    _MaybeResizeTilemap(n) {
      const [p, u] = this.GetMapDisplaySize();
      if (!(p <= this._mapWidth && u <= this._mapHeight) || n) {
        if (n) {
          n = Math.ceil(this._mapHeight / this._cellHeight);
          var w = Math.ceil(this._mapWidth / this._cellWidth);
        } else
          (n = this._tileCells.length),
            (w = Math.ceil(this._mapWidth / this._cellWidth)),
            u > this._mapHeight &&
              ((this._mapHeight = u),
              (n = Math.ceil(this._mapHeight / this._cellHeight))),
            p > this._mapWidth &&
              ((this._mapWidth = p),
              (w = Math.ceil(this._mapWidth / this._cellWidth))),
            this._SetAllQuadMapChanged(),
            this._SetPhysicsChanged(),
            this._runtime.UpdateRender();
        var y = this._tileCells;
        if (y.length < n) for (var B = y.length; B < n; ++B) y.push([]);
        for (B = 0; B < n; ++B) {
          const E = y[B];
          for (let z = E.length; z < w; ++z)
            E.push(e.New(e.Plugins.Tilemap.TileCell, this, z, B));
        }
      }
    }
    SetTilesFromRLECSV(n) {
      n = q(n);
      let p = 0;
      const u = this._mapWidth,
        w = this._cellWidth,
        y = this._cellHeight;
      for (let B = 0, E = this._mapHeight; B < E; ++B)
        for (let z = 0; z < u; ++z) {
          const D = n[p++],
            J = this.GetCellAt(z, B);
          J && J.SetTileAt(z % w, B % y, D);
        }
    }
    GetTilesAsRLECSV() {
      let n = "";
      if (0 >= this._mapWidth || 0 >= this._mapHeight) return n;
      let p = 1;
      var u = this.GetTileAt(0, 0);
      const [w, y] = this.GetMapDisplaySize();
      let B, E, z;
      for (let D = 0; D < y; ++D)
        for (let J = 0 === D ? 1 : 0; J < w; ++J) {
          const C = this.GetTileAt(J, D);
          C === u
            ? ++p
            : (-1 === u
                ? ((B = -1), (u = z = E = !1))
                : ((B = u & h),
                  (E = 0 !== (u & a)),
                  (z = 0 !== (u & c)),
                  (u = 0 !== (u & d))),
              (n = 1 === p ? n + ("" + B) : n + ("" + p + "x" + B)),
              E && (n += "h"),
              z && (n += "v"),
              u && (n += "d"),
              (n += ","),
              (p = 1),
              (u = C));
        }
      -1 === u
        ? ((B = -1), (u = z = E = !1))
        : ((B = u & h),
          (E = 0 !== (u & a)),
          (z = 0 !== (u & c)),
          (u = 0 !== (u & d)));
      n = 1 === p ? n + ("" + B) : n + ("" + p + "x" + B);
      E && (n += "h");
      z && (n += "v");
      u && (n += "d");
      return n;
    }
    _SetAllQuadMapChanged() {
      const n = this._tileCells;
      for (let p = 0, u = n.length; p < u; ++p) {
        const w = n[p];
        for (let y = 0, B = w.length; y < B; ++y) w[y]._SetQuadMapChanged();
      }
      this._isAnyQuadMapChanged = !0;
    }
    _MaybeBuildAllQuadMap() {
      if (this._isAnyQuadMapChanged) {
        this._isAnyQuadMapChanged = !1;
        var n = this._tileCells;
        for (let p = 0, u = n.length; p < u; ++p) {
          const w = n[p];
          for (let y = 0, B = w.length; y < B; ++y) w[y].MaybeBuildQuadMap();
        }
      }
    }
    SetTileChanged() {
      this._isAnyQuadMapChanged = !0;
      this._SetPhysicsChanged();
      this._runtime.UpdateRender();
    }
    _SetPhysicsChanged() {
      this.GetWorldInfo().SetPhysicsBodyChanged(!0);
    }
    GetCellAt(n, p) {
      if (0 > n || 0 > p) return null;
      p = Math.floor(p / this._cellHeight);
      if (p >= this._tileCells.length) return null;
      p = this._tileCells[p];
      n = Math.floor(n / this._cellWidth);
      return n >= p.length ? null : p[n];
    }
    GetCellAtIndex(n, p) {
      if (0 > n || 0 > p || p >= this._tileCells.length) return null;
      p = this._tileCells[p];
      return n >= p.length ? null : p[n];
    }
    GetTileAt(n, p) {
      n = Math.floor(n);
      p = Math.floor(p);
      if (0 > n || 0 > p || n >= this._mapWidth || p >= this._mapHeight)
        return -1;
      const u = this.GetCellAt(n, p);
      return u
        ? u.GetTilesArr()[p % this._cellHeight][n % this._cellWidth]
        : -1;
    }
    SetTileAt(n, p, u) {
      n = Math.floor(n);
      p = Math.floor(p);
      if (
        !(
          0 > n ||
          0 > p ||
          n >= this._mapWidth ||
          p >= this._mapHeight ||
          (-1 !== u && (u & h) > this.GetMaxTileIndex())
        )
      ) {
        var w = this.GetCellAt(n, p);
        w && w.SetTileAt(n % this._cellWidth, p % this._cellHeight, u);
      }
    }
    GetMaxTileIndex() {
      return this._sdkType.GetMaxTileIndex();
    }
    WorldToCellX(n) {
      return Math.floor(
        (n - this.GetWorldInfo().GetX()) / (this._cellWidth * this._tileWidth)
      );
    }
    WorldToCellY(n) {
      return Math.floor(
        (n - this.GetWorldInfo().GetY()) / (this._cellHeight * this._tileHeight)
      );
    }
    WorldToTileX(n) {
      return Math.floor((n - this.GetWorldInfo().GetX()) / this._tileWidth);
    }
    WorldToTileY(n) {
      return Math.floor((n - this.GetWorldInfo().GetY()) / this._tileHeight);
    }
    GetMapWidth() {
      return this._mapWidth;
    }
    GetMapHeight() {
      return this._mapHeight;
    }
    GetMapDisplayWidth() {
      return Math.floor(this.GetWorldInfo().GetWidth() / this.GetTileWidth());
    }
    GetMapDisplayHeight() {
      return Math.floor(this.GetWorldInfo().GetHeight() / this.GetTileHeight());
    }
    GetMapDisplaySize() {
      const n = this.GetWorldInfo();
      return [
        Math.floor(n.GetWidth() / this.GetTileWidth()),
        Math.floor(n.GetHeight() / this.GetTileHeight()),
      ];
    }
    GetTileWidth() {
      return this._tileWidth;
    }
    GetTileHeight() {
      return this._tileHeight;
    }
    GetCellWidth() {
      return this._cellWidth;
    }
    GetCellHeight() {
      return this._cellHeight;
    }
    GetCollisionRectCandidates(n, p) {
      var u = this.WorldToCellX(n.getLeft());
      const w = this.WorldToCellY(n.getTop()),
        y = this.WorldToCellX(n.getRight());
      for (n = this.WorldToCellY(n.getBottom()); u <= y; ++u)
        for (let B = w; B <= n; ++B) {
          const E = this.GetCellAtIndex(u, B);
          E && (E.MaybeBuildQuadMap(), e.appendArray(p, E.GetCollisionRects()));
        }
    }
    TestPointOverlapTile(n, p) {
      var u = this.WorldToTileX(n),
        w = this.WorldToTileY(p);
      u = this.GetTileAt(u, w);
      if (-1 === u) return !1;
      u = this._sdkType.GetTilePoly(u);
      if (!u) return !0;
      if (!this._sdkType.IsTilePolyEnabled(u)) return !1;
      var y = this.GetWorldInfo();
      w =
        Math.floor((n - y.GetX()) / this._tileWidth) * this._tileWidth +
        y.GetX();
      y =
        Math.floor((p - y.GetY()) / this._tileHeight) * this._tileHeight +
        y.GetY();
      return u.containsPoint(n - w, p - y);
    }
    GetAllCollisionRects(n) {
      const p = this._tileCells;
      for (let u = 0, w = p.length; u < w; ++u) {
        const y = p[u];
        for (let B = 0, E = y.length; B < E; ++B) {
          const z = y[B];
          z.MaybeBuildQuadMap();
          e.appendArray(n, z.GetCollisionRects());
        }
      }
    }
    GetCurrentImageInfo() {
      return this._ownImageInfo || this._objectClass.GetImageInfo();
    }
    GetTileUvQuad(n) {
      const p = this._tileTexQuads;
      var u = p.get(n);
      if (u) return u;
      var w = n & h;
      u = 0 !== (n & a);
      const y = 0 !== (n & c),
        B = 0 !== (n & d);
      var E = this.GetCurrentImageInfo(),
        z = E.GetWidth(),
        D = this._tileWidth,
        J = this._tileXspacing;
      D = Math.floor(
        (Math.floor(((z - this._tileXoffset) / (D + J)) * D) + J) / D
      );
      z = w % D;
      w = Math.floor(w / D);
      D =
        E.GetOffsetX() +
        this._tileXoffset +
        (this._tileWidth + this._tileXspacing) * z;
      J =
        E.GetOffsetY() +
        this._tileYoffset +
        (this._tileHeight + this._tileYspacing) * w;
      g.setWH(D, J, this._tileWidth, this._tileHeight);
      g.divide(E.GetSheetWidth(), E.GetSheetHeight());
      E = e.New(e.Quad);
      E.setFromRect(g);
      B && E.diag();
      u && E.mirror();
      y && E.flip();
      E.offset(z, w);
      p.set(n, E);
      return E;
    }
    _OnDynamicTextureLoadComplete() {
      this._tileTexQuads.clear();
      this._SetAllQuadMapChanged();
    }
    Draw(n) {
      var p = this.GetCurrentImageInfo(),
        u = p.GetTexture();
      if (u) {
        g.copy(p.GetTexRect());
        g.offsetLeft(this._tileXoffset / u.GetWidth());
        g.offsetTop(this._tileYoffset / u.GetHeight());
        n.SetTilemapFillMode();
        n.SetTilemapInfo(
          g,
          u.GetWidth(),
          u.GetHeight(),
          this._tileWidth,
          this._tileHeight,
          this._tileXspacing,
          this._tileYspacing
        );
        n.SetTexture(u);
        var w = this.GetWorldInfo(),
          y = w.GetLayer();
        if (
          w.GetWidth() !== this._lastWidth ||
          w.GetHeight() !== this._lastHeight
        )
          this._SetPhysicsChanged(),
            this._SetAllQuadMapChanged(),
            (this._lastWidth = w.GetWidth()),
            (this._lastHeight = w.GetHeight());
        p = w.GetX();
        u = w.GetY();
        this._runtime.IsPixelRoundingEnabled() &&
          ((p = Math.round(p)), (u = Math.round(u)));
        var B = this._cellWidth * this._tileWidth,
          E = this._cellHeight * this._tileHeight;
        w = w.GetTotalZElevation();
        if (y.Has3DCamera()) {
          k.set(-Infinity, -Infinity, Infinity, Infinity);
          E = y._GetViewFrustum();
          for (var z of this._tileCells)
            for (var D of z)
              D.GetLayoutRect(m),
                E.ContainsAABB(
                  m.getLeft(),
                  m.getTop(),
                  w,
                  m.getRight(),
                  m.getBottom(),
                  w
                ) && (D.MaybeBuildQuadMap(), D.Draw(n, k, p, u));
        } else
          for (
            y.GetViewportForZ(w, k),
              y = Math.floor((k.getLeft() - p) / B),
              z = Math.floor((k.getRight() - p) / B),
              D = Math.floor((k.getTop() - u) / E),
              E = Math.floor((k.getBottom() - u) / E),
              B = y;
            B <= z;
            ++B
          )
            for (y = D; y <= E; ++y)
              if ((w = this.GetCellAtIndex(B, y)))
                w.MaybeBuildQuadMap(), w.Draw(n, k, p, u);
      }
    }
    SaveToJson() {
      this._MaybeResizeTilemap();
      const [n, p] = this.GetMapDisplaySize();
      return {
        tw: this._tileWidth,
        th: this._tileHeight,
        tox: this._tileXoffset,
        toy: this._tileYoffset,
        tsx: this._tileXspacing,
        tsy: this._tileYspacing,
        w: n,
        h: p,
        d: this.GetTilesAsRLECSV(),
      };
    }
    LoadFromJson(n) {
      this._tileWidth = n.tw;
      this._tileHeight = n.th;
      this._tileXoffset = n.tox;
      this._tileYoffset = n.toy;
      this._tileXspacing = n.tsx;
      this._tileYspacing = n.tsy;
      this._mapWidth = n.w;
      this._mapHeight = n.h;
      this._MaybeResizeTilemap(!0);
      this.SetTilesFromRLECSV(n.d);
      this._SetPhysicsChanged();
      this._SetAllQuadMapChanged();
    }
    GetAsJsonString() {
      this._MaybeResizeTilemap();
      const [n, p] = this.GetMapDisplaySize();
      return JSON.stringify({
        c2tilemap: !0,
        width: n,
        height: p,
        data: this.GetTilesAsRLECSV(),
      });
    }
    StateComboToFlags(n) {
      switch (n) {
        case 0:
          return 0;
        case 1:
          return a;
        case 2:
          return c;
        case 3:
          return a | d;
        case 4:
          return a | c;
        case 5:
          return c | d;
        case 6:
          return a | c | d;
        case 7:
          return d;
        default:
          return 0;
      }
    }
    GetPropertyValueByIndex(n) {
      switch (n) {
        case 1:
          return this._tileWidth;
        case 2:
          return this._tileHeight;
        case 3:
          return this._tileXoffset;
        case 4:
          return this._tileYoffset;
        case 5:
          return this._tileXspacing;
        case 6:
          return this._tileYspacing;
      }
    }
    SetPropertyValueByIndex(n, p) {
      switch (n) {
        case 1:
          if (this._tileWidth === p) break;
          this._tileWidth = Math.max(p, 1);
          this._cellWidth = Math.ceil(
            this._runtime.GetOriginalViewportWidth() / this._tileWidth
          );
          this._sdkType._ForceCacheOfTileCollisionPolys();
          this._UpdateQuadMaps();
          break;
        case 2:
          if (this._tileHeight === p) break;
          this._tileHeight = Math.max(p, 1);
          this._cellHeight = Math.ceil(
            this._runtime.GetOriginalViewportHeight() / this._tileHeight
          );
          this._sdkType._ForceCacheOfTileCollisionPolys();
          this._UpdateQuadMaps();
          break;
        case 3:
          if (this._tileXoffset === p) break;
          this._tileXoffset = p;
          this._UpdateQuadMaps();
          break;
        case 4:
          if (this._tileYoffset === p) break;
          this._tileYoffset = p;
          this._UpdateQuadMaps();
          break;
        case 5:
          if (this._tileXspacing === p) break;
          this._tileXspacing = p;
          this._UpdateQuadMaps();
          break;
        case 6:
          this._tileYspacing !== p &&
            ((this._tileYspacing = p), this._UpdateQuadMaps());
      }
    }
    _UpdateQuadMaps() {
      this._tileTexQuads.clear();
      this._SetAllQuadMapChanged();
      this._MaybeBuildAllQuadMap();
    }
    GetScriptInterfaceClass() {
      return r;
    }
  };
  const v = new WeakMap(),
    r = (self.ITilemapInstance = class extends self.IWorldInstance {
      constructor() {
        super();
        v.set(this, self.IInstance._GetInitInst().GetSdkInstance());
      }
      get mapWidth() {
        return v.get(this).GetMapWidth();
      }
      get mapHeight() {
        return v.get(this).GetMapHeight();
      }
      get mapDisplayWidth() {
        return v.get(this).GetMapDisplayWidth();
      }
      get mapDisplayHeight() {
        return v.get(this).GetMapDisplayHeight();
      }
      get tileWidth() {
        return v.get(this).GetTileWidth();
      }
      get tileHeight() {
        return v.get(this).GetTileHeight();
      }
      getTileAt(n, p) {
        b.RequireFiniteNumber(n);
        b.RequireFiniteNumber(p);
        return v.get(this).GetTileAt(n, p);
      }
      setTileAt(n, p, u) {
        b.RequireFiniteNumber(n);
        b.RequireFiniteNumber(p);
        b.RequireFiniteNumber(u);
        return v.get(this).SetTileAt(n, p, u);
      }
    });
  r.TILE_FLIPPED_HORIZONTAL = a;
  r.TILE_FLIPPED_VERTICAL = c;
  r.TILE_FLIPPED_DIAGONAL = d;
  r.TILE_FLAGS_MASK = f;
  r.TILE_ID_MASK = h;
}
{
  const e = self.C3,
    b = e.Plugins.Tilemap.TILE_FLAGS_MASK,
    a = e.Plugins.Tilemap.TILE_ID_MASK;
  e.Plugins.Tilemap.Cnds = {
    CompareTileAt(c, d, f, h) {
      c = this.GetTileAt(c, d);
      -1 !== c && (c &= a);
      return e.compare(c, f, h);
    },
    CompareTileStateAt(c, d, f) {
      c = this.GetTileAt(c, d);
      d = 0;
      -1 !== c && (d = c & b);
      return d === this.StateComboToFlags(f);
    },
    OnURLLoaded() {
      return !0;
    },
    OnURLFailed() {
      return !0;
    },
  };
}
{
  const e = self.C3,
    b = e.Plugins.Tilemap.TILE_ID_MASK;
  e.Plugins.Tilemap.Acts = {
    EraseTile(a, c) {
      this._MaybeResizeTilemap();
      this.SetTileAt(a, c, -1);
    },
    SetTile(a, c, d, f) {
      this._MaybeResizeTilemap();
      this.SetTileAt(a, c, (d & b) | this.StateComboToFlags(f));
    },
    SetTileState(a, c, d) {
      const f = this.GetTileAt(a, c);
      -1 !== f &&
        (this._MaybeResizeTilemap(),
        this.SetTileAt(a, c, (f & b) | this.StateComboToFlags(d)));
    },
    EraseTileRange(a, c, d, f) {
      const h = Math.floor(Math.max(a, 0));
      var g = Math.floor(Math.max(c, 0));
      a = Math.floor(Math.min(a + d, this._mapWidth));
      for (c = Math.floor(Math.min(c + f, this._mapHeight)); g < c; ++g)
        for (f = h; f < a; ++f) this.SetTileAt(f, g, -1);
    },
    SetTileRange(a, c, d, f, h, g) {
      this._MaybeResizeTilemap();
      const k = Math.floor(Math.max(a, 0));
      var m = Math.floor(Math.max(c, 0));
      a = Math.floor(Math.min(a + d, this._mapWidth));
      c = Math.floor(Math.min(c + f, this._mapHeight));
      for (h = (h & b) | this.StateComboToFlags(g); m < c; ++m)
        for (g = k; g < a; ++g) this.SetTileAt(g, m, h);
    },
    SetTileStateRange(a, c, d, f, h) {
      this._MaybeResizeTilemap();
      const g = Math.floor(Math.max(a, 0));
      var k = Math.floor(Math.max(c, 0));
      a = Math.floor(Math.min(a + d, this._mapWidth));
      c = Math.floor(Math.min(c + f, this._mapHeight));
      for (h = this.StateComboToFlags(h); k < c; ++k)
        for (f = g; f < a; ++f)
          (d = this.GetTileAt(f, k)),
            -1 !== d && this.SetTileAt(f, k, (d & b) | h);
    },
    LoadFromJSON(a) {
      let c = null;
      try {
        c = JSON.parse(a);
      } catch (d) {
        console.error("[Construct 3] Failed to parse tilemap JSON: ", d);
        return;
      }
      c.c2tilemap
        ? ((this._mapWidth = c.width),
          (this._mapHeight = c.height),
          this._MaybeResizeTilemap(!0),
          this.SetTilesFromRLECSV(c.data),
          this._SetAllQuadMapChanged(),
          this._SetPhysicsChanged())
        : console.error("[Construct 3] Unrecognized JSON data format");
    },
    JSONDownload(a) {
      const c = URL.createObjectURL(
        new Blob([this.GetAsJsonString()], { type: "application/json" })
      );
      this._runtime.InvokeDownload(c, a);
    },
    async LoadURL(a, c) {
      if (!this._ownImageInfo || this._ownImageInfo.GetURL() !== a) {
        c = this._runtime;
        var d = e.New(e.ImageInfo);
        try {
          await d.LoadDynamicAsset(c, a);
          if (!d.IsLoaded()) throw Error("image failed to load");
          if (this.WasReleased()) return d.Release(), null;
          if (
            !(await d.LoadStaticTexture(c.GetRenderer(), {
              sampling: this._runtime.GetSampling(),
            }))
          )
            return;
        } catch (f) {
          console.error("Load image from URL failed: ", f);
          this.Trigger(e.Plugins.Tilemap.Cnds.OnURLFailed);
          return;
        }
        this.WasReleased()
          ? d.Release()
          : (this._ReleaseOwnImage(),
            (this._ownImageInfo = d),
            c.UpdateRender(),
            this._tileTexQuads.clear(),
            this._SetAllQuadMapChanged(),
            await this.TriggerAsync(e.Plugins.Tilemap.Cnds.OnURLLoaded));
      }
    },
    SetEffect(a) {
      2 <= a && a++;
      this.GetWorldInfo().SetBlendMode(a);
      this._runtime.UpdateRender();
    },
    SetTileWithBrush(a, c, d) {
      this._MaybeResizeTilemap();
      this._autoTiling ||
        (this._autoTiling = new e.Plugins.Tilemap.AutoTiling(
          this,
          this._sdkType
        ));
      this._autoTiling.SetAutoTile(a, c, d);
    },
    EraseTileWithBrush(a, c, d) {
      this._MaybeResizeTilemap();
      this._autoTiling ||
        (this._autoTiling = new e.Plugins.Tilemap.AutoTiling(
          this,
          this._sdkType
        ));
      this._autoTiling.EraseAutoTile(a, c, d);
    },
  };
}
{
  const e = self.C3,
    b = e.Plugins.Tilemap.TILE_ID_MASK;
  e.Plugins.Tilemap.Exps = {
    TileAt(a, c) {
      a = this.GetTileAt(a, c);
      return -1 === a ? -1 : a & b;
    },
    PositionToTileX(a) {
      return this.WorldToTileX(a);
    },
    PositionToTileY(a) {
      return this.WorldToTileY(a);
    },
    TileToPositionX(a) {
      return (
        a * this._tileWidth + this.GetWorldInfo().GetX() + this._tileWidth / 2
      );
    },
    TileToPositionY(a) {
      return (
        a * this._tileHeight + this.GetWorldInfo().GetY() + this._tileHeight / 2
      );
    },
    SnapX(a) {
      const c = this.GetWorldInfo().GetX();
      return (
        Math.floor((a - c) / this._tileWidth) * this._tileWidth +
        c +
        this._tileWidth / 2
      );
    },
    SnapY(a) {
      const c = this.GetWorldInfo().GetY();
      return (
        Math.floor((a - c) / this._tileHeight) * this._tileHeight +
        c +
        this._tileHeight / 2
      );
    },
    TilesJSON() {
      return this.GetAsJsonString();
    },
    TileWidth() {
      return this.GetTileWidth();
    },
    TileHeight() {
      return this.GetTileHeight();
    },
    MapDisplayWidth() {
      return this.GetMapDisplayWidth();
    },
    MapDisplayHeight() {
      return this.GetMapDisplayHeight();
    },
  };
}
{
  ("use strict");
  const e = self.C3,
    b = e.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL,
    a = e.Plugins.Tilemap.TILE_FLIPPED_VERTICAL,
    c = e.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL,
    d = e.Plugins.Tilemap.TILE_ID_MASK,
    f = e.New(e.Rect),
    h = e.New(e.Quad);
  e.Plugins.Tilemap.TileQuad = class extends e.DefendedBase {
    constructor() {
      super();
      this._tileId = this._id = -1;
      this._isDiagFlip = this._isVertFlip = this._isHorizFlip = !1;
      this._rc = e.New(e.Rect);
      this._uv = null;
    }
    Update(g, k, m, q, v, r, n, p) {
      this._id = g;
      this._tileId = g & d;
      this._isHorizFlip = 0 !== (g & b);
      this._isVertFlip = 0 !== (g & a);
      this._isDiagFlip = 0 !== (g & c);
      this._rc.setWH(q * k + r, v * m + n, k, m);
      this._uv = p.GetTileUvQuad(this._id);
    }
    Draw(g, k, m, q, v) {
      f.copy(this._rc);
      f.offset(m, q);
      f.intersectsRect(k) && (h.setFromRect(f), g.Quad4(h, this._uv));
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Plugins.Tilemap.TileCollisionRect = class extends e.DefendedBase {
    constructor() {
      super();
      this._id = -1;
      this._poly = null;
      this._rc = e.New(e.Rect);
    }
    Update(b, a, c, d, f, h, g, k) {
      this._id = b;
      this._poly = a;
      this._rc.setWH(f * c + g, h * d + k, c, d);
    }
    ExtendRight(b) {
      this._rc.setRight(this._rc.getRight() + b);
    }
    GetTileId() {
      return this._id;
    }
    HasPoly() {
      return !!this._poly;
    }
    GetPoly() {
      return this._poly;
    }
    GetRect() {
      return this._rc;
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Plugins.Tilemap.TileCell = class extends e.DefendedBase {
    constructor(b, a, c) {
      super();
      const d = b.GetCellWidth(),
        f = b.GetCellHeight();
      this._sdkInst = b;
      this._x = a;
      this._y = c;
      this._left = this._x * d * b.GetTileWidth();
      this._top = this._y * f * b.GetTileHeight();
      this._tiles = [];
      this._quads = [];
      this._collisionRects = [];
      this._isQuadMapValid = !1;
      for (b = 0; b < f; ++b)
        (a = new Int32Array(d)), a.fill(-1), this._tiles.push(a);
    }
    Clear() {
      const b = this._sdkInst.GetCellWidth();
      var a = this._sdkInst.GetCellHeight();
      const c = this._tiles;
      if (c.length < a)
        for (let d = c.length; d < a; ++d) c.push(new Int32Array(b));
      else c.length > a && e.truncateArray(c, a);
      for (let d = 0, f = c.length; d < f; ++d)
        (a = c[d]),
          a.length !== b && ((a = new Int32Array(b)), (c[d] = a)),
          a.fill(-1);
    }
    GetLayoutRect(b) {
      var a = this._sdkInst,
        c = a.GetWorldInfo();
      const d = a.GetCellWidth() * a.GetTileWidth();
      a = a.GetCellHeight() * a.GetTileHeight();
      const f = c.GetX() + this._left;
      c = c.GetY() + this._top;
      b.set(f, c, f + d, c + a);
    }
    _SetQuadMapChanged() {
      this._isQuadMapValid = !1;
    }
    MaybeBuildQuadMap() {
      if (!this._isQuadMapValid) {
        var b = this._sdkInst,
          a = b.GetSdkType(),
          c = b.GetWorldInfo(),
          d = b.GetTileWidth(),
          f = b.GetTileHeight(),
          h = b.GetCellWidth(),
          g = b.GetCellHeight(),
          k = this._left,
          m = this._top;
        if (!(0 >= d || 0 >= f)) {
          var q = Math.min(b.GetMapWidth(), Math.floor(c.GetWidth() / d));
          c = Math.min(b.GetMapHeight(), Math.floor(c.GetHeight() / f));
          q -= k / d;
          c -= m / f;
          q > h && (q = h);
          c > g && (c = g);
          h = this._tiles;
          g = this._quads;
          var v = 0;
          for (var r = 0; r < c; ++r) {
            var n = h[r];
            for (var p = 0; p < q; ++p) {
              var u = n[p];
              if (-1 !== u) {
                var w = void 0;
                v < g.length
                  ? (w = g[v])
                  : ((w = e.New(e.Plugins.Tilemap.TileQuad)), g.push(w));
                w.Update(u, d, f, p, r, k, m, b);
                ++v;
              }
            }
          }
          v < g.length && e.truncateArray(g, v);
          g = null;
          v = !1;
          b = this._collisionRects;
          e.clearArray(b);
          for (r = 0; r < c; ++r) {
            n = h[r];
            for (p = 0; p < q; ++p) {
              u = n[p];
              w = a.GetTilePoly(u);
              const y = a.IsTilePolyEnabled(w);
              -1 !== u && y
                ? !g || w || v
                  ? (g && b.push(g),
                    (g = e.New(e.Plugins.Tilemap.TileCollisionRect)),
                    g.Update(u, w, d, f, p, r, k, m),
                    (v = !!w))
                  : g.ExtendRight(d)
                : g && (b.push(g), (g = null), (v = !1));
            }
            g && (b.push(g), (g = null), (v = !1));
          }
          a = b.length;
          for (d = 0; d < a; ++d)
            if (((k = b[d]), !k.HasPoly()))
              for (k = k.GetRect(), m = d + 1; m < a; ++m)
                (q = b[m]),
                  (c = q.GetRect()),
                  c.getTop() < k.getBottom() ||
                    c.getTop() > k.getBottom() ||
                    c.getRight() > k.getRight() ||
                    c.getLeft() > k.getLeft() ||
                    q.HasPoly() ||
                    c.getLeft() !== k.getLeft() ||
                    c.getRight() !== k.getRight() ||
                    (b.splice(m, 1), --a, k.setBottom(k.getBottom() + f), --m);
          this._isQuadMapValid = !0;
        }
      }
    }
    SetTileAt(b, a, c) {
      this._tiles[a][b] !== c &&
        ((this._tiles[a][b] = c),
        (this._isQuadMapValid = !1),
        this._sdkInst.SetTileChanged());
    }
    GetTilesArr() {
      return this._tiles;
    }
    GetCollisionRects() {
      return this._collisionRects;
    }
    Draw(b, a, c, d) {
      const f = this._sdkInst,
        h = this._quads;
      for (let g = 0, k = h.length; g < k; ++g) h[g].Draw(b, a, c, d, f);
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = Object.freeze([
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
    ]);
  e.Plugins.Tilemap.AutoTiling = class {
    constructor(a, c) {
      this._sdkInst = a;
      this._sdkType = c;
      this._brushAdapterInstances = [null, null];
      this._brushAdapterConstructors = [
        e.Plugins.Tilemap.AutoTiling16,
        e.Plugins.Tilemap.AutoTiling47,
      ];
      this._probabilityTable = new e.ProbabilityTable();
    }
    get AUTO_TILING_PATCH() {
      return b;
    }
    get IGNORE_INDEX() {
      return -999;
    }
    get FORCE_INDEX() {
      return -998;
    }
    get EMPTY_INDEX() {
      return -1;
    }
    get PAINT_MODE() {
      return 0;
    }
    get ERASE_MODE() {
      return 1;
    }
    GetSdkIntance() {
      return this._sdkInst;
    }
    GetSdkType() {
      return this._sdkType;
    }
    SetAutoTile(a, c, d) {
      this._SetAutoTileMode(d, 0);
      this._SetAutoTilePatch(a, c, this._GetAutoTilePatch(a, c, d));
    }
    EraseAutoTile(a, c, d) {
      this._SetAutoTileMode(d, 1);
      this._EraseTile(a, c);
      this._SetAutoTilePatch(a, c, this._GetAutoTilePatch(a, c, d));
    }
    GetTile(a, c) {
      return this.GetSdkIntance().GetTileAt(a, c);
    }
    DoesTileExist(a, c, d) {
      a = this.GetTile(a, c);
      return !!this.IsTileValid(a, !0, a, d);
    }
    IsTileValid(a, c, d, f) {
      return -1 === a
        ? 0
        : c && -998 === a
        ? 1
        : c && f && !this._IsTileIndexInBrush(d, f)
        ? 0
        : 1;
    }
    GetTileIndex(a, c, d, f) {
      a = f.tileData[a];
      if (!a.length) return -1;
      if (1 === a.length) return a[0][0];
      const h = this.GetTile(c, d);
      if (this.IsTileValid(h) && a.some((g) => h === g[0])) return h;
      this._probabilityTable.Clear();
      for (let [g, k] of a)
        "number" !== typeof k && (k = 1), this._probabilityTable.AddItem(k, g);
      return this._probabilityTable.Sample();
    }
    _SetTile(a, c, d) {
      -1 !== a && this.GetSdkIntance().SetTileAt(a, c, d);
    }
    _EraseTile(a, c) {
      this.GetSdkIntance().SetTileAt(a, c, -1);
    }
    _IsTileIndexInBrush(a, c) {
      for (const d of c.tileData) for (const [f] of d) if (f === a) return !0;
      return !1;
    }
    _SetAutoTilePatch(a, c, d) {
      d &&
        (this._SetTile(a - 1, c - 1, d[0][0]),
        this._SetTile(a, c - 1, d[1][0]),
        this._SetTile(a + 1, c - 1, d[2][0]),
        this._SetTile(a - 1, c, d[0][1]),
        this._SetTile(a, c, d[1][1]),
        this._SetTile(a + 1, c, d[2][1]),
        this._SetTile(a - 1, c + 1, d[0][2]),
        this._SetTile(a, c + 1, d[1][2]),
        this._SetTile(a + 1, c + 1, d[2][2]));
    }
    _GetBrushType(a) {
      return this.GetSdkType().GetBrushData(a).type;
    }
    _MaybeCreateBrushAdapter(a) {
      a = this._GetBrushType(a);
      this._brushAdapterInstances[a] ||
        (this._brushAdapterInstances[a] = new this._brushAdapterConstructors[a](
          this
        ));
    }
    _SetAutoTileMode(a, c) {
      this._MaybeCreateBrushAdapter(a);
      a = this._GetBrushType(a);
      this._brushAdapterInstances[a] &&
        this._brushAdapterInstances[a].SetMode(c);
    }
    _GetAutoTilePatch(a, c, d) {
      this._MaybeCreateBrushAdapter(d);
      d = this.GetSdkType().GetBrushData(d);
      if (this._brushAdapterInstances[d.type])
        return this._brushAdapterInstances[d.type].BuildPatch(a, c, d);
    }
  };
}
("use strict");
self.C3.Plugins.Tilemap.AutoTiling16 = class {
  constructor(e) {
    this._auto = e;
    this._mode = e.PAINT_MODE;
  }
  SetMode(e) {
    this._mode = e;
  }
  BuildPatch(e, b, a) {
    return this._Build4BitAutoTilePatch(e, b, a);
  }
  _Build4BitAutoTilePatch(e, b, a) {
    const c =
        this._mode === this._auto.PAINT_MODE
          ? this._4BitAutoTiling(e, b, void 0, a)
          : this._auto.EMPTY_INDEX,
      d = this._Get4BitAutoTile(e, b - 1, "s", a),
      f = this._Get4BitAutoTile(e - 1, b, "e", a),
      h = this._Get4BitAutoTile(e + 1, b, "w", a),
      g = this._Get4BitAutoTile(e, b + 1, "n", a),
      k = this._auto.AUTO_TILING_PATCH;
    k[0][0] = this._auto.IGNORE_INDEX;
    k[1][0] = this._Get4BitTileIndex(d, e, b - 1, a);
    k[2][0] = this._auto.IGNORE_INDEX;
    k[0][1] = this._Get4BitTileIndex(f, e - 1, b, a);
    k[1][1] = this._Get4BitTileIndex(c, e, b, a);
    k[2][1] = this._Get4BitTileIndex(h, e + 1, b, a);
    k[0][2] = this._auto.IGNORE_INDEX;
    k[1][2] = this._Get4BitTileIndex(g, e, b + 1, a);
    k[2][2] = this._auto.IGNORE_INDEX;
    return k;
  }
  _Get4BitAutoTile(e, b, a, c) {
    return this._auto.DoesTileExist(e, b, c)
      ? this._4BitAutoTiling(e, b, a, c)
      : this._auto.IGNORE_INDEX;
  }
  _4BitAutoTiling(e, b, a, c) {
    this._mode === this._auto.ERASE_MODE && (a = void 0);
    const d = this._auto.GetTile(e, b - 1);
    var f = this._auto.GetTile(e - 1, b),
      h = this._auto.GetTile(e + 1, b);
    e = this._auto.GetTile(e, b + 1);
    const g = "w" === a ? this._auto.FORCE_INDEX : f,
      k = "e" === a ? this._auto.FORCE_INDEX : h;
    b = "s" === a ? this._auto.FORCE_INDEX : e;
    a = this._auto.IsTileValid(
      "n" === a ? this._auto.FORCE_INDEX : d,
      !0,
      d,
      c
    );
    f = this._auto.IsTileValid(g, !0, f, c);
    h = this._auto.IsTileValid(k, !0, h, c);
    c = this._auto.IsTileValid(b, !0, e, c);
    return 1 * a + 2 * f + 4 * h + 8 * c;
  }
  _Get4BitTileIndex(e, b, a, c) {
    return e === this._auto.IGNORE_INDEX || e === this._auto.EMPTY_INDEX
      ? e
      : this._auto.GetTileIndex(e, b, a, c);
  }
};
{
  ("use strict");
  const e = self.C3,
    b = new Map([
      [2, 1],
      [8, 2],
      [10, 3],
      [11, 4],
      [16, 5],
      [18, 6],
      [22, 7],
      [24, 8],
      [26, 9],
      [27, 10],
      [30, 11],
      [31, 12],
      [64, 13],
      [66, 14],
      [72, 15],
      [74, 16],
      [75, 17],
      [80, 18],
      [82, 19],
      [86, 20],
      [88, 21],
      [90, 22],
      [91, 23],
      [94, 24],
      [95, 25],
      [104, 26],
      [106, 27],
      [107, 28],
      [120, 29],
      [122, 30],
      [123, 31],
      [126, 32],
      [127, 33],
      [208, 34],
      [210, 35],
      [214, 36],
      [216, 37],
      [218, 38],
      [219, 39],
      [222, 40],
      [223, 41],
      [248, 42],
      [250, 43],
      [251, 44],
      [254, 45],
      [255, 46],
      [0, 47],
    ]);
  e.Plugins.Tilemap.AutoTiling47 = class {
    constructor(a) {
      this._auto = a;
      this._mode = a.PAINT_MODE;
    }
    SetMode(a) {
      this._mode = a;
    }
    BuildPatch(a, c, d) {
      return this._Build8BitAutoTilePatch(a, c, d);
    }
    _Build8BitAutoTilePatch(a, c, d) {
      const f =
          this._mode === this._auto.PAINT_MODE
            ? this._8BitAutoTiling(a, c, void 0, d)
            : this._auto.EMPTY_INDEX,
        h = this._Get8BitAutoTile(a - 1, c - 1, "se", d),
        g = this._Get8BitAutoTile(a, c - 1, "s", d),
        k = this._Get8BitAutoTile(a + 1, c - 1, "sw", d),
        m = this._Get8BitAutoTile(a - 1, c, "e", d),
        q = this._Get8BitAutoTile(a + 1, c, "w", d),
        v = this._Get8BitAutoTile(a - 1, c + 1, "ne", d),
        r = this._Get8BitAutoTile(a, c + 1, "n", d),
        n = this._Get8BitAutoTile(a + 1, c + 1, "nw", d),
        p = this._auto.AUTO_TILING_PATCH;
      p[0][0] = this._Get8BitTileIndex(h, a - 1, c - 1, d);
      p[1][0] = this._Get8BitTileIndex(g, a, c - 1, d);
      p[2][0] = this._Get8BitTileIndex(k, a + 1, c - 1, d);
      p[0][1] = this._Get8BitTileIndex(m, a - 1, c, d);
      p[1][1] = this._Get8BitTileIndex(f, a, c, d);
      p[2][1] = this._Get8BitTileIndex(q, a + 1, c, d);
      p[0][2] = this._Get8BitTileIndex(v, a - 1, c + 1, d);
      p[1][2] = this._Get8BitTileIndex(r, a, c + 1, d);
      p[2][2] = this._Get8BitTileIndex(n, a + 1, c + 1, d);
      return p;
    }
    _Get8BitAutoTile(a, c, d, f) {
      return this._auto.DoesTileExist(a, c, f)
        ? this._8BitAutoTiling(a, c, d, f)
        : this._auto.IGNORE_INDEX;
    }
    _8BitAutoTiling(a, c, d, f) {
      this._mode === this._auto.ERASE_MODE && (d = void 0);
      const h = this._auto.GetTile(a, c - 1);
      var g = this._auto.GetTile(a - 1, c),
        k = this._auto.GetTile(a + 1, c),
        m = this._auto.GetTile(a, c + 1),
        q = this._auto.GetTile(a - 1, c - 1),
        v = this._auto.GetTile(a + 1, c - 1),
        r = this._auto.GetTile(a - 1, c + 1);
      a = this._auto.GetTile(a + 1, c + 1);
      const n = "w" === d ? this._auto.FORCE_INDEX : g,
        p = "e" === d ? this._auto.FORCE_INDEX : k,
        u = "s" === d ? this._auto.FORCE_INDEX : m,
        w = "nw" === d ? this._auto.FORCE_INDEX : q,
        y = "ne" === d ? this._auto.FORCE_INDEX : v,
        B = "sw" === d ? this._auto.FORCE_INDEX : r;
      c = "se" === d ? this._auto.FORCE_INDEX : a;
      d = this._auto.IsTileValid(
        "n" === d ? this._auto.FORCE_INDEX : h,
        !0,
        h,
        f
      );
      g = this._auto.IsTileValid(n, !0, g, f);
      k = this._auto.IsTileValid(p, !0, k, f);
      m = this._auto.IsTileValid(u, !0, m, f);
      q = d && g ? this._auto.IsTileValid(w, !0, q, f) : 0;
      v = d && k ? this._auto.IsTileValid(y, !0, v, f) : 0;
      r = m && g ? this._auto.IsTileValid(B, !0, r, f) : 0;
      f = m && k ? this._auto.IsTileValid(c, !0, a, f) : 0;
      return 1 * q + 2 * d + 4 * v + 8 * g + 16 * k + 32 * r + 64 * m + 128 * f;
    }
    _Get8BitTileIndex(a, c, d, f) {
      return a === this._auto.IGNORE_INDEX || a === this._auto.EMPTY_INDEX
        ? a
        : this._auto.GetTileIndex(b.get(a), c, d, f);
    }
  };
}
("use strict");
{
  const e = self.C3;
  e.Plugins.gamepad = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
      this._isSupported = !1;
      this._runtime.AddLoadPromise(
        this._runtime
          .PostComponentMessageToDOMAsync("gamepad", "is-supported")
          .then((a) => (this._isSupported = !!a))
      );
    }
    Release() {
      super.Release();
    }
    IsSupported() {
      return this._isSupported;
    }
  };
}
{
  const e = self.C3;
  e.Plugins.gamepad.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3;
  class b {
    constructor(c, d) {
      this._index = c;
      this._id = d;
      this._state = new a();
      this._oldState = new a();
      this._buttonsPressed = [];
      this._buttonsReleased = [];
    }
    GetID() {
      return this._id;
    }
    Update(c, d) {
      const f = this._oldState;
      this._oldState = this._state;
      this._state = f;
      this._state.Update(c, d);
      e.resizeArray(this._buttonsPressed, this._state.GetButtonCount(), !1);
      e.resizeArray(this._buttonsReleased, this._state.GetButtonCount(), !1);
      for (let h = 0, g = this._state.GetButtonCount(); h < g; ++h)
        (c = this._oldState.GetButtonAt(h)),
          (d = this._state.GetButtonAt(h)),
          0.5 <= d && 0.5 > c && (this._buttonsPressed[h] = !0),
          0.5 > d && 0.5 <= c && (this._buttonsReleased[h] = !0);
    }
    GetButtonCount() {
      return this._state.GetButtonCount();
    }
    GetAxisCount() {
      return this._state.GetAxisCount();
    }
    HasButtonBecomePressed(c) {
      c = Math.floor(c);
      return 0 > c || c >= this._buttonsPressed.length
        ? !1
        : this._buttonsPressed[c];
    }
    HasButtonBecomeReleased(c) {
      c = Math.floor(c);
      return 0 > c || c >= this._buttonsReleased.length
        ? !1
        : this._buttonsReleased[c];
    }
    ResetButtonPressAndReleaseFlags() {
      this._buttonsPressed.fill(!1);
      this._buttonsReleased.fill(!1);
    }
    GetButtonAt(c) {
      return this._state.GetButtonAt(c);
    }
    IsButtonDown(c) {
      return 0.5 <= this._state.GetButtonAt(c);
    }
    GetAxisAt(c) {
      return this._state.GetAxisAt(c);
    }
  }
  class a {
    constructor() {
      this._buttons = [];
      this._axes = [];
    }
    Update(c, d) {
      const f = this._buttons;
      let h = 0;
      for (let g = c.length; h < g; ++h) {
        const k = c[h];
        h === f.length ? f.push(k.value) : (f[h] = k.value);
      }
      h < f.length && e.truncateArray(f, h);
      e.shallowAssignArray(this._axes, d);
    }
    GetButtonCount() {
      return this._buttons.length;
    }
    GetAxisCount() {
      return this._axes.length;
    }
    GetButtonAt(c) {
      c = Math.floor(c);
      return 0 > c || c >= this._buttons.length ? 0 : this._buttons[c];
    }
    GetAxisAt(c) {
      c = Math.floor(c);
      return 0 > c || c >= this._axes.length ? 0 : this._axes[c];
    }
  }
  e.Plugins.gamepad.Instance = class extends e.SDKInstanceBase {
    constructor(c, d) {
      super(c, "gamepad");
      this._deadZone = 25;
      this._lastButton = 0;
      this._lastIndex = -1;
      this._gamepads = new Map();
      d && (this._deadZone = d[0]);
      this.AddDOMMessageHandler("gamepad-connected", (f) =>
        this._OnGamepadConnected(f)
      );
      this.AddDOMMessageHandler("gamepad-disconnected", (f) =>
        this._OnGamepadDisconnected(f)
      );
      this.AddDOMMessageHandler("input-update", (f) => this._OnInputUpdate(f));
      c = this.GetRuntime().Dispatcher();
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(c, "tick2", () => this._OnTick2())
      );
      this.PostToDOM("ready");
    }
    Release() {
      super.Release();
    }
    _OnGamepadConnected(c) {
      const d = c.index;
      this._lastIndex = d;
      c = c.id;
      this._gamepads.has(d) ||
        (this._gamepads.set(d, new b(d, c)),
        this.Trigger(e.Plugins.gamepad.Cnds.OnGamepadConnected),
        (this._lastIndex = -1));
    }
    _OnGamepadDisconnected(c) {
      this._lastIndex = c = c.index;
      this.Trigger(e.Plugins.gamepad.Cnds.OnGamepadDisconnected);
      this._gamepads.delete(c);
      this._lastIndex = -1;
    }
    _OnInputUpdate(c) {
      for (const d of c) this._OnGamepadInputUpdate(d);
    }
    _OnGamepadInputUpdate(c) {
      var d = c.index;
      this._gamepads.has(d) || this._OnGamepadConnected(c);
      d = this._gamepads.get(d);
      d.Update(c.buttons, c.axes);
      for (let f = 0, h = d.GetButtonCount(); f < h; ++f)
        d.HasButtonBecomePressed(f) && (this._lastButton = f);
    }
    _GetGamepadByIndex(c) {
      return this._gamepads.get(Math.floor(c)) || null;
    }
    _OnTick2() {
      for (const c of this._gamepads.values())
        c.ResetButtonPressAndReleaseFlags();
    }
    GetDebuggerProperties() {
      return [
        {
          title: "plugins.gamepad.name",
          properties: [
            {
              name: "plugins.gamepad.debugger.last-button",
              value: this._lastButton,
            },
          ],
        },
      ];
    }
  };
}
{
  const e = self.C3;
  e.Plugins.gamepad.Cnds = {
    SupportsGamepad() {
      return this.GetPlugin().IsSupported();
    },
    OnGamepadConnected() {
      return !0;
    },
    OnGamepadDisconnected() {
      return !0;
    },
    IsButtonDown(b, a) {
      b = this._GetGamepadByIndex(b);
      if (!b) return !1;
      if ((b = b.IsButtonDown(a))) this._lastButton = a;
      return b;
    },
    OnButtonDown(b, a) {
      b = this._GetGamepadByIndex(b);
      if (!b) return !1;
      if ((b = b.HasButtonBecomePressed(a))) this._lastButton = a;
      return b;
    },
    OnButtonUp(b, a) {
      b = this._GetGamepadByIndex(b);
      if (!b) return !1;
      if ((b = b.HasButtonBecomeReleased(a))) this._lastButton = a;
      return b;
    },
    HasGamepads() {
      return 0 < this._gamepads.size;
    },
    CompareAxis(b, a, c, d) {
      a = Math.floor(a);
      const f = this._GetGamepadByIndex(b);
      if (!f) return !1;
      b = f.GetAxisAt(a);
      a = 0 === a % 2 ? f.GetAxisAt(a + 1) : f.GetAxisAt(a - 1);
      b *= 100;
      Math.hypot(b, 100 * a) <= this._deadZone && (b = 0);
      return e.compare(b, c, d);
    },
    OnAnyButtonDown(b) {
      b = this._GetGamepadByIndex(b);
      if (!b) return !1;
      for (let a = 0, c = b.GetButtonCount(); a < c; ++a)
        if (b.HasButtonBecomePressed(a)) return (this._lastButton = a), !0;
      return !1;
    },
    OnAnyButtonUp(b) {
      b = this._GetGamepadByIndex(b);
      if (!b) return !1;
      for (let a = 0, c = b.GetButtonCount(); a < c; ++a)
        if (b.HasButtonBecomeReleased(a)) return (this._lastButton = a), !0;
      return !1;
    },
    IsButtonIndexDown(b, a) {
      a = Math.floor(a);
      b = this._GetGamepadByIndex(b);
      if (!b) return !1;
      if ((b = b.IsButtonDown(a))) this._lastButton = a;
      return b;
    },
    OnButtonIndexDown(b, a) {
      a = Math.floor(a);
      b = this._GetGamepadByIndex(b);
      if (!b) return !1;
      if ((b = b.HasButtonBecomePressed(a))) this._lastButton = a;
      return b;
    },
    OnButtonIndexUp(b, a) {
      a = Math.floor(a);
      b = this._GetGamepadByIndex(b);
      if (!b) return !1;
      if ((b = b.HasButtonBecomeReleased(a))) this._lastButton = a;
      return b;
    },
  };
}
{
  const e = self.C3;
  e.Plugins.gamepad.Acts = {
    Vibrate(b, a, c, d) {
      this.PostToDOM("vibrate", {
        index: b,
        duration: a,
        weakMag: e.clamp(c / 100, 0, 1),
        strongMag: e.clamp(d / 100, 0, 1),
      });
    },
    ResetVibrate(b) {
      this.PostToDOM("reset-vibrate", { index: b });
    },
  };
}
self.C3.Plugins.gamepad.Exps = {
  GamepadCount() {
    return this._gamepads.size;
  },
  GamepadID(e) {
    return (e = this._GetGamepadByIndex(e)) ? e.GetID() : "";
  },
  GamepadIndex() {
    return this._lastIndex;
  },
  GamepadAxes(e) {
    e = this._GetGamepadByIndex(e);
    if (!e) return "";
    let b = "";
    for (let a = 0, c = e.GetAxisCount(); a < c; ++a)
      b += `Axis ${a}: ${Math.round(100 * e.GetAxisAt(a))}\n`;
    return b;
  },
  GamepadButtons(e) {
    e = this._GetGamepadByIndex(e);
    if (!e) return "";
    let b = "";
    for (let a = 0, c = e.GetButtonCount(); a < c; ++a)
      b += `Button ${a}: ${Math.round(100 * e.GetButtonAt(a))}\n`;
    return b;
  },
  RawButton(e, b) {
    return (e = this._GetGamepadByIndex(e)) ? e.GetButtonAt(Math.floor(b)) : 0;
  },
  RawAxis(e, b) {
    return (e = this._GetGamepadByIndex(e)) ? e.GetAxisAt(Math.floor(b)) : 0;
  },
  RawButtonCount(e) {
    return (e = this._GetGamepadByIndex(e)) ? e.GetButtonCount() : 0;
  },
  RawAxisCount(e) {
    return (e = this._GetGamepadByIndex(e)) ? e.GetAxisCount() : 0;
  },
  Button(e, b) {
    return (e = this._GetGamepadByIndex(e))
      ? 100 * e.GetButtonAt(Math.floor(b))
      : 0;
  },
  Axis(e, b) {
    b = Math.floor(b);
    const a = this._GetGamepadByIndex(e);
    if (!a) return 0;
    e = a.GetAxisAt(b);
    b = 0 === b % 2 ? a.GetAxisAt(b + 1) : a.GetAxisAt(b - 1);
    e *= 100;
    Math.hypot(e, 100 * b) <= this._deadZone && (e = 0);
    return e;
  },
  LastButton() {
    return this._lastButton;
  },
};
("use strict");
{
  const e = self.C3;
  e.Plugins.Keyboard = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Keyboard.Type = class extends e.SDKTypeBase {
    constructor(c) {
      super(c);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
      return self.IKeyboardObjectType;
    }
  };
  let b = null;
  function a() {
    return b.GetSingleGlobalInstance().GetSdkInstance();
  }
  self.IKeyboardObjectType = class extends self.IObjectClass {
    constructor(c) {
      super(c);
      b = c;
      c.GetRuntime()._GetCommonScriptInterfaces().keyboard = this;
    }
    isKeyDown(c) {
      const d = a();
      if ("string" === typeof c) return d.IsKeyDown(c);
      if ("number" === typeof c) return d.IsKeyCodeDown(c);
      throw new TypeError("expected string or number");
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Keyboard.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b);
      this._keysDownByString = new Set();
      this._keysDownByWhich = new Set();
      this._triggerWhich = 0;
      this._triggerTypedKey = this._triggerString = "";
      b = this.GetRuntime().Dispatcher();
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(b, "keydown", (c) => this._OnKeyDown(c.data)),
        e.Disposable.From(b, "keyup", (c) => this._OnKeyUp(c.data)),
        e.Disposable.From(b, "window-blur", () =>
          this._OnWindowOrKeyboardBlur()
        ),
        e.Disposable.From(b, "keyboard-blur", () =>
          this._OnWindowOrKeyboardBlur()
        )
      );
    }
    Release() {
      super.Release();
    }
    _OnKeyDown(b) {
      const a = b.which,
        c = b.code || a.toString();
      b = b.key;
      this._keysDownByString.has(c) ||
        (this._keysDownByString.add(c),
        this._keysDownByWhich.add(a),
        (this._triggerString = c),
        (this._triggerWhich = a),
        (this._triggerTypedKey = b),
        this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKey),
        this.Trigger(e.Plugins.Keyboard.Cnds.OnKey),
        this.Trigger(e.Plugins.Keyboard.Cnds.OnLeftRightKeyPressed),
        this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCode));
    }
    _OnKeyUp(b) {
      const a = b.which,
        c = b.code || a.toString();
      b = b.key;
      this._keysDownByString.delete(c);
      this._keysDownByWhich.delete(a);
      this._triggerString = c;
      this._triggerWhich = a;
      this._triggerTypedKey = b;
      this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKeyReleased);
      this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyReleased);
      this.Trigger(e.Plugins.Keyboard.Cnds.OnLeftRightKeyReleased);
      this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
    }
    _OnWindowOrKeyboardBlur() {
      for (const b of this._keysDownByWhich)
        this._keysDownByWhich.delete(b),
          (this._triggerWhich = b),
          this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKeyReleased),
          this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyReleased),
          this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
      this._keysDownByString.clear();
    }
    IsKeyDown(b) {
      return this._keysDownByString.has(b);
    }
    IsKeyCodeDown(b) {
      return this._keysDownByWhich.has(b);
    }
    SaveToJson() {
      return { tk: this._triggerWhich, tkk: this._triggerTypedKey };
    }
    LoadFromJson(b) {
      this._triggerWhich = b.tk;
      b.hasOwnProperty("tkk") && (this._triggerTypedKey = b.tkk);
    }
    GetDebuggerProperties() {
      return [
        {
          title: "plugins.keyboard.name",
          properties: [
            {
              name: "plugins.keyboard.debugger.last-key-code",
              value: this._triggerWhich,
            },
            {
              name: "plugins.keyboard.debugger.last-key-string",
              value: e.Plugins.Keyboard.Exps.StringFromKeyCode(
                this._triggerWhich
              ),
            },
            {
              name: "plugins.keyboard.debugger.last-typed-key",
              value: this._triggerTypedKey,
            },
          ],
        },
      ];
    }
  };
}
{
  const e =
    "ShiftLeft ShiftRight ControlLeft ControlRight AltLeft AltRight MetaLeft MetaRight".split(
      " "
    );
  self.C3.Plugins.Keyboard.Cnds = {
    IsKeyDown(b) {
      return this._keysDownByWhich.has(b);
    },
    OnKey(b) {
      return this._triggerWhich === b;
    },
    OnAnyKey() {
      return !0;
    },
    OnAnyKeyReleased() {
      return !0;
    },
    OnKeyReleased(b) {
      return this._triggerWhich === b;
    },
    IsKeyCodeDown(b) {
      b = Math.floor(b);
      return this._keysDownByWhich.has(b);
    },
    OnKeyCode(b) {
      return this._triggerWhich === b;
    },
    OnKeyCodeReleased(b) {
      return this._triggerWhich === b;
    },
    OnLeftRightKeyPressed(b) {
      return this._triggerString === e[b];
    },
    OnLeftRightKeyReleased(b) {
      return this._triggerString === e[b];
    },
    IsLeftRightKeyDown(b) {
      return this._keysDownByString.has(e[b]);
    },
  };
}
self.C3.Plugins.Keyboard.Acts = {};
{
  function e(b) {
    b = Math.floor(b);
    switch (b) {
      case 8:
        return "backspace";
      case 9:
        return "tab";
      case 13:
        return "enter";
      case 16:
        return "shift";
      case 17:
        return "control";
      case 18:
        return "alt";
      case 19:
        return "pause";
      case 20:
        return "capslock";
      case 27:
        return "esc";
      case 33:
        return "pageup";
      case 34:
        return "pagedown";
      case 35:
        return "end";
      case 36:
        return "home";
      case 37:
        return "\u2190";
      case 38:
        return "\u2191";
      case 39:
        return "\u2192";
      case 40:
        return "\u2193";
      case 45:
        return "insert";
      case 46:
        return "del";
      case 91:
        return "left window key";
      case 92:
        return "right window key";
      case 93:
        return "select";
      case 96:
        return "numpad 0";
      case 97:
        return "numpad 1";
      case 98:
        return "numpad 2";
      case 99:
        return "numpad 3";
      case 100:
        return "numpad 4";
      case 101:
        return "numpad 5";
      case 102:
        return "numpad 6";
      case 103:
        return "numpad 7";
      case 104:
        return "numpad 8";
      case 105:
        return "numpad 9";
      case 106:
        return "numpad *";
      case 107:
        return "numpad +";
      case 109:
        return "numpad -";
      case 110:
        return "numpad .";
      case 111:
        return "numpad /";
      case 112:
        return "F1";
      case 113:
        return "F2";
      case 114:
        return "F3";
      case 115:
        return "F4";
      case 116:
        return "F5";
      case 117:
        return "F6";
      case 118:
        return "F7";
      case 119:
        return "F8";
      case 120:
        return "F9";
      case 121:
        return "F10";
      case 122:
        return "F11";
      case 123:
        return "F12";
      case 144:
        return "numlock";
      case 145:
        return "scroll lock";
      case 186:
        return ";";
      case 187:
        return "=";
      case 188:
        return ",";
      case 189:
        return "-";
      case 190:
        return ".";
      case 191:
        return "/";
      case 192:
        return "'";
      case 219:
        return "[";
      case 220:
        return "\\";
      case 221:
        return "]";
      case 222:
        return "#";
      case 223:
        return "`";
      default:
        return String.fromCharCode(b);
    }
  }
  self.C3.Plugins.Keyboard.Exps = {
    LastKeyCode() {
      return this._triggerWhich;
    },
    StringFromKeyCode(b) {
      return e(b);
    },
    TypedKey() {
      return this._triggerTypedKey;
    },
  };
}
("use strict");
{
  const e = self.C3;
  e.Plugins.Mouse = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Mouse.Type = class extends e.SDKTypeBase {
    constructor(c) {
      super(c);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
      return self.IMouseObjectType;
    }
  };
  let b = null;
  function a() {
    return b.GetSingleGlobalInstance().GetSdkInstance();
  }
  self.IMouseObjectType = class extends self.IObjectClass {
    constructor(c) {
      super(c);
      b = c;
      c.GetRuntime()._GetCommonScriptInterfaces().mouse = this;
    }
    getMouseX(c) {
      return a().GetMousePositionForLayer(c)[0];
    }
    getMouseY(c) {
      return a().GetMousePositionForLayer(c)[1];
    }
    getMousePosition(c) {
      return a().GetMousePositionForLayer(c);
    }
    isMouseButtonDown(c) {
      return a().IsMouseButtonDown(c);
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Mouse.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b, "mouse");
      this._buttonMap = [!1, !1, !1];
      this._triggerDir =
        this._triggerType =
        this._triggerButton =
        this._mouseYcanvas =
        this._mouseXcanvas =
          0;
      this._hasPointerLock = !1;
      this._movementY = this._movementX = 0;
      this.AddDOMMessageHandlers([
        ["pointer-lock-change", (c) => this._OnPointerLockChange(c)],
        ["pointer-lock-error", (c) => this._OnPointerLockError(c)],
      ]);
      b = this.GetRuntime().Dispatcher();
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(b, "pointermove", (c) => this._OnPointerMove(c.data)),
        e.Disposable.From(b, "pointerdown", (c) => this._OnPointerDown(c.data)),
        e.Disposable.From(b, "pointerup", (c) => this._OnPointerUp(c.data)),
        e.Disposable.From(b, "dblclick", (c) => this._OnDoubleClick(c.data)),
        e.Disposable.From(b, "wheel", (c) => this._OnMouseWheel(c.data)),
        e.Disposable.From(b, "window-blur", () => this._OnWindowBlur())
      );
    }
    Release() {
      super.Release();
    }
    _OnPointerDown(b) {
      "mouse" === b.pointerType &&
        ((this._mouseXcanvas = b.pageX - this._runtime.GetCanvasClientX()),
        (this._mouseYcanvas = b.pageY - this._runtime.GetCanvasClientY()),
        this._CheckButtonChanges(b.lastButtons, b.buttons));
    }
    _OnPointerMove(b) {
      this._movementX = b.movementX;
      this._movementY = b.movementY;
      this.Trigger(e.Plugins.Mouse.Cnds.OnMovement);
      this._movementY = this._movementX = 0;
      "mouse" === b.pointerType &&
        ((this._mouseXcanvas = b.pageX - this._runtime.GetCanvasClientX()),
        (this._mouseYcanvas = b.pageY - this._runtime.GetCanvasClientY()),
        this._CheckButtonChanges(b.lastButtons, b.buttons));
    }
    _OnPointerUp(b) {
      "mouse" === b.pointerType &&
        this._CheckButtonChanges(b.lastButtons, b.buttons);
    }
    _CheckButtonChanges(b, a) {
      this._CheckButtonChange(b, a, 1, 0);
      this._CheckButtonChange(b, a, 4, 1);
      this._CheckButtonChange(b, a, 2, 2);
    }
    _CheckButtonChange(b, a, c, d) {
      !(b & c) && a & c
        ? this._OnMouseDown(d)
        : b & c && !(a & c) && this._OnMouseUp(d);
    }
    _OnMouseDown(b) {
      this._buttonMap[b] = !0;
      this.Trigger(e.Plugins.Mouse.Cnds.OnAnyClick);
      this._triggerButton = b;
      this._triggerType = 0;
      this.Trigger(e.Plugins.Mouse.Cnds.OnClick);
      this.Trigger(e.Plugins.Mouse.Cnds.OnObjectClicked);
    }
    _OnMouseUp(b) {
      this._buttonMap[b] &&
        ((this._buttonMap[b] = !1),
        (this._triggerButton = b),
        this.Trigger(e.Plugins.Mouse.Cnds.OnRelease));
    }
    _OnDoubleClick(b) {
      this._triggerButton = b.button;
      this._triggerType = 1;
      this.Trigger(e.Plugins.Mouse.Cnds.OnClick);
      this.Trigger(e.Plugins.Mouse.Cnds.OnObjectClicked);
    }
    _OnMouseWheel(b) {
      this._triggerDir = 0 > b.deltaY ? 1 : 0;
      this.Trigger(e.Plugins.Mouse.Cnds.OnWheel);
    }
    _OnWindowBlur() {
      for (
        let b = 0, a = this._buttonMap.length;
        b < a && this._buttonMap[b];
        ++b
      )
        (this._buttonMap[b] = !1),
          (this._triggerButton = b),
          this.Trigger(e.Plugins.Mouse.Cnds.OnRelease);
    }
    GetMousePositionForLayer(b) {
      const a = this._runtime.GetMainRunningLayout(),
        c = this._mouseXcanvas,
        d = this._mouseYcanvas;
      return "undefined" === typeof b
        ? a.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(c, d)
        : (b = a.GetLayer(b))
        ? b.CanvasCssToLayer(c, d)
        : [0, 0];
    }
    IsMouseButtonDown(b) {
      b = Math.floor(b);
      return !!this._buttonMap[b];
    }
    _IsMouseOverCanvas() {
      return (
        0 <= this._mouseXcanvas &&
        0 <= this._mouseYcanvas &&
        this._mouseXcanvas < this._runtime.GetCanvasCssWidth() &&
        this._mouseYcanvas < this._runtime.GetCanvasCssHeight()
      );
    }
    _OnPointerLockChange(b) {
      this._UpdatePointerLockState(b["has-pointer-lock"]);
    }
    _OnPointerLockError(b) {
      this._UpdatePointerLockState(b["has-pointer-lock"]);
      this.Trigger(e.Plugins.Mouse.Cnds.OnPointerLockError);
    }
    _UpdatePointerLockState(b) {
      this._hasPointerLock !== b &&
        ((this._hasPointerLock = b)
          ? this.Trigger(e.Plugins.Mouse.Cnds.OnPointerLocked)
          : this.Trigger(e.Plugins.Mouse.Cnds.OnPointerUnlocked));
    }
    GetDebuggerProperties() {
      return [
        {
          title: "plugins.mouse.name",
          properties: [
            {
              name: "plugins.mouse.debugger.absolute-position",
              value: this._mouseXcanvas + "," + this._mouseYcanvas,
            },
            {
              name: "plugins.mouse.debugger.left-button",
              value: this._buttonMap[0],
            },
            {
              name: "plugins.mouse.debugger.middle-button",
              value: this._buttonMap[1],
            },
            {
              name: "plugins.mouse.debugger.right-button",
              value: this._buttonMap[2],
            },
          ],
        },
        {
          title: "plugins.mouse.debugger.position-on-each-layer",
          properties: this._runtime
            .GetMainRunningLayout()
            .GetLayers()
            .map((b) => ({
              name: "$" + b.GetName(),
              value: b
                .CanvasCssToLayer(this._mouseXcanvas, this._mouseYcanvas)
                .join(", "),
            })),
        },
      ];
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Mouse.Cnds = {
    OnClick(b, a) {
      return this._triggerButton === b && this._triggerType === a;
    },
    OnAnyClick() {
      return !0;
    },
    IsButtonDown(b) {
      return this._buttonMap[b];
    },
    OnRelease(b) {
      return this._triggerButton === b;
    },
    IsOverObject(b) {
      if (!this._IsMouseOverCanvas()) return !1;
      const a = this._runtime.GetCurrentCondition().IsInverted(),
        c = this._mouseXcanvas,
        d = this._mouseYcanvas;
      return e.xor(
        this._runtime
          .GetCollisionEngine()
          .TestAndSelectCanvasPointOverlap(b, c, d, a),
        a
      );
    },
    OnObjectClicked(b, a, c) {
      if (
        b !== this._triggerButton ||
        a !== this._triggerType ||
        !this._IsMouseOverCanvas()
      )
        return !1;
      b = this._mouseXcanvas;
      a = this._mouseYcanvas;
      return this._runtime
        .GetCollisionEngine()
        .TestAndSelectCanvasPointOverlap(c, b, a, !1);
    },
    OnWheel(b) {
      return this._triggerDir === b;
    },
    OnPointerLocked() {
      return !0;
    },
    OnPointerUnlocked() {
      return !0;
    },
    OnPointerLockError() {
      return !0;
    },
    HasPointerLock() {
      return this._hasPointerLock;
    },
    OnMovement() {
      return !0;
    },
  };
}
{
  const e = self.C3;
  let b = null;
  const a = "auto pointer text crosshair move help wait none".split(" ");
  e.Plugins.Mouse.Acts = {
    SetCursor(c) {
      c = a[c];
      b !== c && ((b = c), this.PostToDOM("cursor", c));
    },
    SetCursorSprite(c) {
      if (!e.Platform.IsMobile && c && (c = c.GetFirstPicked())) {
        var d = c.GetWorldInfo(),
          f = c.GetCurrentImageInfo();
        d &&
          f &&
          b !== f &&
          ((b = f),
          f
            .ExtractImageToCanvas()
            .then((h) => e.CanvasToBlob(h))
            .then((h) => {
              h = `url(${URL.createObjectURL(h)}) ${Math.round(
                d.GetOriginX() * f.GetWidth()
              )} ${Math.round(d.GetOriginY() * f.GetHeight())}, auto`;
              this.PostToDOM("cursor", "");
              this.PostToDOM("cursor", h);
            }));
      }
    },
    RequestPointerLock() {
      this._PostToDOMMaybeSync("request-pointer-lock");
    },
    ReleasePointerLock() {
      this.PostToDOM("release-pointer-lock");
    },
  };
}
self.C3.Plugins.Mouse.Exps = {
  X(e) {
    return this.GetMousePositionForLayer(e)[0];
  },
  Y(e) {
    return this.GetMousePositionForLayer(e)[1];
  },
  AbsoluteX() {
    return this._mouseXcanvas;
  },
  AbsoluteY() {
    return this._mouseYcanvas;
  },
  MovementX() {
    return this._movementX;
  },
  MovementY() {
    return this._movementY;
  },
};
("use strict");
{
  const e = self.C3;
  e.Plugins.Touch = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3,
    b = self.C3X;
  e.Plugins.Touch.Type = class extends e.SDKTypeBase {
    constructor(d) {
      super(d);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
      return self.ITouchObjectType;
    }
  };
  let a = null;
  function c() {
    return a.GetSingleGlobalInstance().GetSdkInstance();
  }
  self.ITouchObjectType = class extends self.IObjectClass {
    constructor(d) {
      super(d);
      a = d;
      d.GetRuntime()._GetCommonScriptInterfaces().touch = this;
    }
    requestPermission(d) {
      b.RequireString(d);
      const f = c();
      if ("orientation" === d) return f._RequestPermission(0);
      if ("motion" === d) return f._RequestPermission(1);
      throw Error("invalid type");
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Touch.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b, "touch");
      this._touches = new Map();
      this._isMouseDown = this._useMouseInput = !1;
      this._getTouchIndex =
        this._curTouchY =
        this._curTouchX =
        this._triggerPermission =
        this._triggerId =
        this._triggerIndex =
        this._accWithGZ =
        this._accWithGY =
        this._accWithGX =
        this._accZ =
        this._accY =
        this._accX =
        this._orientGamma =
        this._orientBeta =
        this._orientAlpha =
        this._orientCompassHeading =
          0;
      this._permissionPromises = [];
      a && (this._useMouseInput = a[0]);
      this.AddDOMMessageHandler("permission-result", (c) =>
        this._OnPermissionResult(c)
      );
      b = this.GetRuntime().Dispatcher();
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(b, "pointerdown", (c) => this._OnPointerDown(c.data)),
        e.Disposable.From(b, "pointermove", (c) => this._OnPointerMove(c.data)),
        e.Disposable.From(b, "pointerup", (c) => this._OnPointerUp(c.data, !1)),
        e.Disposable.From(b, "pointercancel", (c) =>
          this._OnPointerUp(c.data, !0)
        ),
        e.Disposable.From(b, "deviceorientation", (c) =>
          this._OnDeviceOrientation(c.data)
        ),
        e.Disposable.From(b, "deviceorientationabsolute", (c) =>
          this._OnDeviceOrientationAbsolute(c.data)
        ),
        e.Disposable.From(b, "devicemotion", (c) =>
          this._OnDeviceMotion(c.data)
        ),
        e.Disposable.From(b, "tick2", (c) => this._OnTick2())
      );
    }
    Release() {
      this._touches.clear();
      super.Release();
    }
    _OnPointerDown(b) {
      if ("mouse" === b.pointerType)
        if (this._useMouseInput) this._isMouseDown = !0;
        else return;
      const a = b.pointerId;
      if (!this._touches.has(a)) {
        var c = b.pageX - this._runtime.GetCanvasClientX();
        b = b.pageY - this._runtime.GetCanvasClientY();
        var d = performance.now(),
          f = this._touches.size;
        this._triggerIndex = f;
        this._triggerId = a;
        var h = e.New(e.Plugins.Touch.TouchInfo);
        h.Init(d, c, b, a, f);
        this._touches.set(a, h);
        this.Trigger(e.Plugins.Touch.Cnds.OnNthTouchStart);
        this.Trigger(e.Plugins.Touch.Cnds.OnTouchStart);
        this._curTouchX = c;
        this._curTouchY = b;
        this.Trigger(e.Plugins.Touch.Cnds.OnTouchObject);
      }
    }
    _OnPointerMove(b) {
      if ("mouse" !== b.pointerType || this._isMouseDown) {
        var a = this._touches.get(b.pointerId);
        if (a) {
          var c = performance.now();
          if (!(2 > c - a.GetTime())) {
            var d = b.pageX - this._runtime.GetCanvasClientX(),
              f = b.pageY - this._runtime.GetCanvasClientY();
            a.Update(c, d, f, b.width, b.height, b.pressure);
          }
        }
      }
    }
    _OnPointerUp(b, a) {
      if ("mouse" === b.pointerType)
        if (this._isMouseDown) this._isMouseDown = !1;
        else return;
      const c = performance.now();
      b = b.pointerId;
      const d = this._touches.get(b);
      d &&
        ((this._triggerIndex = d.GetStartIndex()),
        (this._triggerId = d.GetId()),
        this.Trigger(e.Plugins.Touch.Cnds.OnNthTouchEnd),
        this.Trigger(e.Plugins.Touch.Cnds.OnTouchEnd),
        a ||
          ((a = d.ShouldTriggerTap(c)),
          "single-tap" === a
            ? (this.Trigger(e.Plugins.Touch.Cnds.OnTapGesture),
              (this._curTouchX = d.GetX()),
              (this._curTouchY = d.GetY()),
              this.Trigger(e.Plugins.Touch.Cnds.OnTapGestureObject))
            : "double-tap" === a &&
              (this.Trigger(e.Plugins.Touch.Cnds.OnDoubleTapGesture),
              (this._curTouchX = d.GetX()),
              (this._curTouchY = d.GetY()),
              this.Trigger(e.Plugins.Touch.Cnds.OnDoubleTapGestureObject))),
        d.Release(),
        this._touches.delete(b));
    }
    _RequestPermission(b) {
      this._PostToDOMMaybeSync("request-permission", { type: b });
      return new Promise((a, c) => {
        this._permissionPromises.push({ type: b, resolve: a, reject: c });
      });
    }
    _OnPermissionResult(b) {
      const a = b.result,
        c = b.type;
      this._triggerPermission = c;
      b = this._permissionPromises.filter((d) => d.type === c);
      for (const d of b) d.resolve(a ? "granted" : "denied");
      this._permissionPromises = this._permissionPromises.filter(
        (d) => d.type !== c
      );
      a
        ? (this.Trigger(e.Plugins.Touch.Cnds.OnPermissionGranted),
          0 === c
            ? this._runtime.RequestDeviceOrientationEvent()
            : this._runtime.RequestDeviceMotionEvent())
        : this.Trigger(e.Plugins.Touch.Cnds.OnPermissionDenied);
    }
    _OnDeviceOrientation(b) {
      "number" === typeof b.webkitCompassHeading
        ? (this._orientCompassHeading = b.webkitCompassHeading)
        : b.absolute && (this._orientCompassHeading = b.alpha);
      this._orientAlpha = b.alpha;
      this._orientBeta = b.beta;
      this._orientGamma = b.gamma;
    }
    _OnDeviceOrientationAbsolute(b) {
      this._orientCompassHeading = b.alpha;
    }
    _OnDeviceMotion(b) {
      const a = b.acceleration;
      a && ((this._accX = a.x), (this._accY = a.y), (this._accZ = a.z));
      if ((b = b.accelerationIncludingGravity))
        (this._accWithGX = b.x),
          (this._accWithGY = b.y),
          (this._accWithGZ = b.z);
    }
    _OnTick2() {
      const b = performance.now();
      let a = 0;
      for (const c of this._touches.values())
        c.GetTime() <= b - 50 && c._SetLastTime(b),
          c.ShouldTriggerHold(b) &&
            ((this._triggerIndex = c.GetStartIndex()),
            (this._triggerId = c.GetId()),
            (this._getTouchIndex = a),
            this.Trigger(e.Plugins.Touch.Cnds.OnHoldGesture),
            (this._curTouchX = c.GetX()),
            (this._curTouchY = c.GetY()),
            this.Trigger(e.Plugins.Touch.Cnds.OnHoldGestureObject),
            (this._getTouchIndex = 0)),
          ++a;
    }
    _GetTouchByIndex(b) {
      b = Math.floor(b);
      for (const a of this._touches.values()) {
        if (0 === b) return a;
        --b;
      }
      return null;
    }
    _IsClientPosOnCanvas(b, a) {
      return (
        0 <= b &&
        0 <= a &&
        b < this._runtime.GetCanvasCssWidth() &&
        a < this._runtime.GetCanvasCssHeight()
      );
    }
    GetDebuggerProperties() {
      return [
        {
          title: "plugins.touch.debugger.touches",
          properties: [...this._touches.values()].map((b) => ({
            name: "$" + b.GetId(),
            value: b.GetX() + ", " + b.GetY(),
          })),
        },
      ];
    }
  };
}
{
  const e = self.C3,
    b = [];
  e.Plugins.Touch.Cnds = {
    OnTouchStart() {
      return !0;
    },
    OnTouchEnd() {
      return !0;
    },
    IsInTouch() {
      return 0 < this._touches.size;
    },
    OnTouchObject(a) {
      return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY)
        ? this._runtime
            .GetCollisionEngine()
            .TestAndSelectCanvasPointOverlap(
              a,
              this._curTouchX,
              this._curTouchY,
              !1
            )
        : !1;
    },
    IsTouchingObject(a) {
      if (!a) return !1;
      const c = a.GetCurrentSol();
      var d = c.GetInstances();
      for (const f of d) {
        d = f.GetWorldInfo();
        const h = d.GetLayer();
        for (const g of this._touches.values()) {
          if (!this._IsClientPosOnCanvas(g.GetX(), g.GetY())) continue;
          const [k, m] = h.CanvasCssToLayer(
            g.GetX(),
            g.GetY(),
            d.GetTotalZElevation()
          );
          if (h.IsSelfAndParentsInteractive() && d.ContainsPoint(k, m)) {
            b.push(f);
            break;
          }
        }
      }
      return b.length
        ? (c.SetArrayPicked(b), a.ApplySolToContainer(), e.clearArray(b), !0)
        : !1;
    },
    CompareTouchSpeed(a, c, d) {
      return (a = this._GetTouchByIndex(a))
        ? e.compare(a.GetSpeed(), c, d)
        : !1;
    },
    OrientationSupported() {
      return !0;
    },
    MotionSupported() {
      return !0;
    },
    CompareOrientation(a, c, d) {
      this._runtime.RequestDeviceOrientationEvent();
      return e.compare(
        0 === a
          ? this._orientAlpha
          : 1 === a
          ? this._orientBeta
          : this._orientGamma,
        c,
        d
      );
    },
    CompareAcceleration(a, c, d) {
      this._runtime.RequestDeviceMotionEvent();
      return e.compare(
        0 === a
          ? this._accWithGX
          : 1 === a
          ? this._accWithGY
          : 2 === a
          ? this._accWithGZ
          : 3 === a
          ? this._accX
          : 4 === a
          ? this._accY
          : this._accZ,
        c,
        d
      );
    },
    OnNthTouchStart(a) {
      a = Math.floor(a);
      return a === this._triggerIndex;
    },
    OnNthTouchEnd(a) {
      a = Math.floor(a);
      return a === this._triggerIndex;
    },
    HasNthTouch(a) {
      a = Math.floor(a);
      return this._touches.size >= a + 1;
    },
    OnHoldGesture() {
      return !0;
    },
    OnTapGesture() {
      return !0;
    },
    OnDoubleTapGesture() {
      return !0;
    },
    OnHoldGestureObject(a) {
      return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY)
        ? this._runtime
            .GetCollisionEngine()
            .TestAndSelectCanvasPointOverlap(
              a,
              this._curTouchX,
              this._curTouchY,
              !1
            )
        : !1;
    },
    OnTapGestureObject(a) {
      return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY)
        ? this._runtime
            .GetCollisionEngine()
            .TestAndSelectCanvasPointOverlap(
              a,
              this._curTouchX,
              this._curTouchY,
              !1
            )
        : !1;
    },
    OnDoubleTapGestureObject(a) {
      return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY)
        ? this._runtime
            .GetCollisionEngine()
            .TestAndSelectCanvasPointOverlap(
              a,
              this._curTouchX,
              this._curTouchY,
              !1
            )
        : !1;
    },
    OnPermissionGranted(a) {
      return this._triggerPermission === a;
    },
    OnPermissionDenied(a) {
      return this._triggerPermission === a;
    },
  };
}
self.C3.Plugins.Touch.Acts = {
  RequestPermission(e) {
    this._RequestPermission(e);
  },
};
{
  const e = self.C3;
  e.Plugins.Touch.Exps = {
    TouchCount() {
      return this._touches.size;
    },
    X(b) {
      const a = this._GetTouchByIndex(this._getTouchIndex);
      return a
        ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !0)
        : 0;
    },
    Y(b) {
      const a = this._GetTouchByIndex(this._getTouchIndex);
      return a
        ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !1)
        : 0;
    },
    XAt(b, a) {
      return (b = this._GetTouchByIndex(b))
        ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !0)
        : 0;
    },
    YAt(b, a) {
      return (b = this._GetTouchByIndex(b))
        ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !1)
        : 0;
    },
    XForID(b, a) {
      return (b = this._touches.get(b))
        ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !0)
        : 0;
    },
    YForID(b, a) {
      return (b = this._touches.get(b))
        ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !1)
        : 0;
    },
    AbsoluteX() {
      const b = this._GetTouchByIndex(0);
      return b ? b.GetX() : 0;
    },
    AbsoluteY() {
      const b = this._GetTouchByIndex(0);
      return b ? b.GetY() : 0;
    },
    AbsoluteXAt(b) {
      return (b = this._GetTouchByIndex(b)) ? b.GetX() : 0;
    },
    AbsoluteYAt(b) {
      return (b = this._GetTouchByIndex(b)) ? b.GetY() : 0;
    },
    AbsoluteXForID(b) {
      return (b = this._touches.get(b)) ? b.GetX() : 0;
    },
    AbsoluteYForID(b) {
      return (b = this._touches.get(b)) ? b.GetY() : 0;
    },
    SpeedAt(b) {
      return (b = this._GetTouchByIndex(b)) ? b.GetSpeed() : 0;
    },
    SpeedForID(b) {
      return (b = this._touches.get(b)) ? b.GetSpeed() : 0;
    },
    AngleAt(b) {
      return (b = this._GetTouchByIndex(b)) ? e.toDegrees(b.GetAngle()) : 0;
    },
    AngleForID(b) {
      return (b = this._touches.get(b)) ? e.toDegrees(b.GetAngle()) : 0;
    },
    CompassHeading() {
      this._runtime.RequestDeviceOrientationEvent();
      return this._orientCompassHeading;
    },
    Alpha() {
      this._runtime.RequestDeviceOrientationEvent();
      return this._orientAlpha;
    },
    Beta() {
      this._runtime.RequestDeviceOrientationEvent();
      return this._orientBeta;
    },
    Gamma() {
      this._runtime.RequestDeviceOrientationEvent();
      return this._orientGamma;
    },
    AccelerationXWithG() {
      this._runtime.RequestDeviceMotionEvent();
      return this._accWithGX;
    },
    AccelerationYWithG() {
      this._runtime.RequestDeviceMotionEvent();
      return this._accWithGY;
    },
    AccelerationZWithG() {
      this._runtime.RequestDeviceMotionEvent();
      return this._accWithGZ;
    },
    AccelerationX() {
      this._runtime.RequestDeviceMotionEvent();
      return this._accX;
    },
    AccelerationY() {
      this._runtime.RequestDeviceMotionEvent();
      return this._accY;
    },
    AccelerationZ() {
      this._runtime.RequestDeviceMotionEvent();
      return this._accZ;
    },
    TouchIndex() {
      return this._triggerIndex;
    },
    TouchID() {
      return this._triggerId;
    },
    WidthForID(b) {
      return (b = this._touches.get(b)) ? b.GetWidth() : 0;
    },
    HeightForID(b) {
      return (b = this._touches.get(b)) ? b.GetHeight() : 0;
    },
    PressureForID(b) {
      return (b = this._touches.get(b)) ? b.GetPressure() : 0;
    },
  };
}
{
  ("use strict");
  const e = self.C3;
  let b = -1e3,
    a = -1e3,
    c = -1e4;
  e.Plugins.Touch.TouchInfo = class extends e.DefendedBase {
    constructor() {
      super();
      this._pressure =
        this._height =
        this._width =
        this._lastY =
        this._lastX =
        this._y =
        this._x =
        this._startY =
        this._startX =
        this._lastTime =
        this._time =
        this._startTime =
        this._startIndex =
        this._pointerId =
          0;
      this._isTooFarForHold = this._hasTriggeredHold = !1;
    }
    Release() {}
    Init(d, f, h, g, k) {
      this._pointerId = g;
      this._startIndex = k;
      this._startTime = this._lastTime = this._time = d;
      this._startX = f;
      this._startY = h;
      this._x = f;
      this._y = h;
      this._lastX = f;
      this._lastY = h;
    }
    Update(d, f, h, g, k, m) {
      this._lastTime = this._time;
      this._time = d;
      this._lastX = this._x;
      this._lastY = this._y;
      this._x = f;
      this._y = h;
      this._width = g;
      this._height = k;
      this._pressure = m;
      !this._isTooFarForHold &&
        15 <= e.distanceTo(this._startX, this._startY, this._x, this._y) &&
        (this._isTooFarForHold = !0);
    }
    GetId() {
      return this._pointerId;
    }
    GetStartIndex() {
      return this._startIndex;
    }
    GetTime() {
      return this._time;
    }
    _SetLastTime(d) {
      this._lastTime = d;
    }
    GetX() {
      return this._x;
    }
    GetY() {
      return this._y;
    }
    GetSpeed() {
      const d = e.distanceTo(this._x, this._y, this._lastX, this._lastY),
        f = (this._time - this._lastTime) / 1e3;
      return 0 < f ? d / f : 0;
    }
    GetAngle() {
      return e.angleTo(this._lastX, this._lastY, this._x, this._y);
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    GetPressure() {
      return this._pressure;
    }
    ShouldTriggerHold(d) {
      return this._hasTriggeredHold
        ? !1
        : 500 <= d - this._startTime &&
          !this._isTooFarForHold &&
          15 > e.distanceTo(this._startX, this._startY, this._x, this._y)
        ? (this._hasTriggeredHold = !0)
        : !1;
    }
    ShouldTriggerTap(d) {
      if (this._hasTriggeredHold) return "";
      if (
        333 >= d - this._startTime &&
        !this._isTooFarForHold &&
        15 > e.distanceTo(this._startX, this._startY, this._x, this._y)
      ) {
        if (666 >= d - c && 25 > e.distanceTo(b, a, this._x, this._y))
          return (a = b = -1e3), (c = -1e4), "double-tap";
        b = this._x;
        a = this._y;
        c = d;
        return "single-tap";
      }
      return "";
    }
    GetPositionForLayer(d, f, h) {
      return "undefined" === typeof f
        ? d
            .GetLayerByIndex(0)
            .CanvasCssToLayer_DefaultTransform(this._x, this._y)[h ? 0 : 1]
        : (d = d.GetLayer(f))
        ? d.CanvasCssToLayer(this._x, this._y)[h ? 0 : 1]
        : 0;
    }
  };
}
("use strict");
{
  const e = self.C3;
  e.Plugins.TiledBg = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  function b(a) {
    switch (a) {
      case 0:
        return "clamp-to-edge";
      case 2:
        return "mirror-repeat";
    }
    return "repeat";
  }
  e.Plugins.TiledBg.Type = class extends e.SDKTypeBase {
    constructor(a, c) {
      super(a);
      this._wrapY = this._wrapX = "repeat";
      c && ((this._wrapX = b(c[0])), (this._wrapY = b(c[1])));
    }
    Release() {
      super.Release();
    }
    OnCreate() {
      this.GetImageInfo().LoadAsset(this._runtime);
    }
    LoadTextures(a) {
      return this.GetImageInfo().LoadStaticTexture(a, {
        sampling: this._runtime.GetSampling(),
        wrapX: this._wrapX,
        wrapY: this._wrapY,
      });
    }
    ReleaseTextures() {
      this.GetImageInfo().ReleaseTexture();
    }
  };
}
{
  const e = self.C3,
    b = self.C3X,
    a = e.New(e.Rect),
    c = e.New(e.Quad),
    d = e.New(e.Rect),
    f = e.New(e.Quad);
  e.Plugins.TiledBg.Instance = class extends e.SDKWorldInstanceBase {
    constructor(g, k) {
      super(g);
      this._imageOffsetY = this._imageOffsetX = 0;
      this._imageScaleY = this._imageScaleX = 1;
      this._imageAngle = 0;
      this._ownImageInfo = null;
      k &&
        (this.GetWorldInfo().SetVisible(!!k[0]),
        (this._imageOffsetX = k[4]),
        (this._imageOffsetY = k[5]),
        (this._imageScaleX = k[6]),
        (this._imageScaleY = k[7]),
        (this._imageAngle = e.toRadians(k[8])));
    }
    Release() {
      this._ReleaseOwnImage();
      super.Release();
    }
    _ReleaseOwnImage() {
      this._ownImageInfo &&
        (this._ownImageInfo.Release(), (this._ownImageInfo = null));
    }
    CalculateTextureCoordsFor3DFace(g, k, m) {
      var q = this.GetCurrentImageInfo();
      const v = q.GetWidth();
      q = q.GetHeight();
      const r = this._imageOffsetX / v,
        n = this._imageOffsetY / q,
        p = this._imageAngle;
      d.set(0, 0, g / (v * this._imageScaleX), k / (q * this._imageScaleY));
      d.offset(-r, -n);
      0 === p ? m.setFromRect(d) : m.setFromRotatedRect(d, -p);
    }
    Draw(g) {
      var k = this.GetCurrentImageInfo(),
        m = k.GetTexture();
      if (null !== m) {
        g.SetTexture(m);
        m = k.GetWidth();
        k = k.GetHeight();
        var q = this._imageOffsetX / m,
          v = this._imageOffsetY / k,
          r = this.GetWorldInfo();
        d.set(
          0,
          0,
          r.GetWidth() / (m * this._imageScaleX),
          r.GetHeight() / (k * this._imageScaleY)
        );
        d.offset(-q, -v);
        r.HasMesh() ? this._DrawMesh(r, g) : this._DrawStandard(r, g);
      }
    }
    _DrawStandard(g, k) {
      let m = g.GetBoundingQuad();
      this._runtime.IsPixelRoundingEnabled() && (m = g.PixelRoundQuad(m));
      0 === this._imageAngle
        ? k.Quad3(m, d)
        : (f.setFromRotatedRect(d, -this._imageAngle), k.Quad4(m, f));
    }
    _DrawMesh(g, k) {
      const m = g.GetTransformedMesh();
      if (g.IsMeshChanged()) {
        g.CalculateBbox(a, c, !1);
        let q = c;
        this._runtime.IsPixelRoundingEnabled() && (q = g.PixelRoundQuad(q));
        let v = d;
        0 !== this._imageAngle &&
          (f.setFromRotatedRect(d, -this._imageAngle), (v = f));
        m.CalculateTransformedMesh(g.GetSourceMesh(), q, v);
        g.SetMeshChanged(!1);
      }
      m.Draw(k);
    }
    GetCurrentImageInfo() {
      return this._ownImageInfo || this._objectClass.GetImageInfo();
    }
    IsOriginalSizeKnown() {
      return !0;
    }
    GetTexture() {
      return this.GetCurrentImageInfo().GetTexture();
    }
    _SetMeshChanged() {
      this.GetWorldInfo().SetMeshChanged(!0);
    }
    _SetImageOffsetX(g) {
      this._imageOffsetX !== g &&
        ((this._imageOffsetX = g),
        this._runtime.UpdateRender(),
        this._SetMeshChanged());
    }
    _GetImageOffsetX() {
      return this._imageOffsetX;
    }
    _SetImageOffsetY(g) {
      this._imageOffsetY !== g &&
        ((this._imageOffsetY = g),
        this._runtime.UpdateRender(),
        this._SetMeshChanged());
    }
    _GetImageOffsetY() {
      return this._imageOffsetY;
    }
    _SetImageScaleX(g) {
      this._imageScaleX !== g &&
        ((this._imageScaleX = g),
        this._runtime.UpdateRender(),
        this._SetMeshChanged());
    }
    _GetImageScaleX() {
      return this._imageScaleX;
    }
    _SetImageScaleY(g) {
      this._imageScaleY !== g &&
        ((this._imageScaleY = g),
        this._runtime.UpdateRender(),
        this._SetMeshChanged());
    }
    _GetImageScaleY() {
      return this._imageScaleY;
    }
    _SetImageAngle(g) {
      this._imageAngle !== g &&
        ((this._imageAngle = g),
        this._runtime.UpdateRender(),
        this._SetMeshChanged());
    }
    _GetImageAngle() {
      return this._imageAngle;
    }
    GetPropertyValueByIndex(g) {
      switch (g) {
        case 4:
          return this._GetImageOffsetX();
        case 5:
          return this._GetImageOffsetY();
        case 6:
          return this._GetImageScaleX();
        case 7:
          return this._GetImageScaleY();
        case 8:
          return this._GetImageAngle();
      }
    }
    SetPropertyValueByIndex(g, k) {
      switch (g) {
        case 4:
          this._SetImageOffsetX(k);
          break;
        case 5:
          this._SetImageOffsetY(k);
          break;
        case 6:
          this._SetImageScaleX(k);
          break;
        case 7:
          this._SetImageScaleY(k);
          break;
        case 8:
          this._SetImageAngle(k);
      }
    }
    GetScriptInterfaceClass() {
      return self.ITiledBackgroundInstance;
    }
  };
  const h = new WeakMap();
  self.ITiledBackgroundInstance = class extends self.IWorldInstance {
    constructor() {
      super();
      h.set(this, self.IInstance._GetInitInst().GetSdkInstance());
    }
    set imageOffsetX(g) {
      b.RequireFiniteNumber(g);
      h.get(this)._SetImageOffsetX(g);
    }
    get imageOffsetX() {
      return h.get(this)._GetImageOffsetX();
    }
    set imageOffsetY(g) {
      b.RequireFiniteNumber(g);
      h.get(this)._SetImageOffsetY(g);
    }
    get imageOffsetY() {
      return h.get(this)._GetImageOffsetY();
    }
    set imageScaleX(g) {
      b.RequireFiniteNumber(g);
      h.get(this)._SetImageScaleX(g);
    }
    get imageScaleX() {
      return h.get(this)._GetImageScaleX();
    }
    set imageScaleY(g) {
      b.RequireFiniteNumber(g);
      h.get(this)._SetImageScaleY(g);
    }
    get imageScaleY() {
      return h.get(this)._GetImageScaleY();
    }
    set imageAngle(g) {
      b.RequireFiniteNumber(g);
      h.get(this)._SetImageAngle(g);
    }
    get imageAngle() {
      return h.get(this)._GetImageAngle();
    }
    set imageAngleDegrees(g) {
      b.RequireFiniteNumber(g);
      h.get(this)._SetImageAngle(e.toRadians(g));
    }
    get imageAngleDegrees() {
      return e.toDegrees(h.get(this)._GetImageAngle());
    }
    get imageWidth() {
      return h.get(this).GetCurrentImageInfo().GetWidth();
    }
    get imageHeight() {
      return h.get(this).GetCurrentImageInfo().GetHeight();
    }
  };
}
self.C3.Plugins.TiledBg.Cnds = {
  OnURLLoaded() {
    return !0;
  },
  OnURLFailed() {
    return !0;
  },
};
{
  const e = self.C3;
  e.Plugins.TiledBg.Acts = {
    SetImageOffsetX(b) {
      this._SetImageOffsetX(b);
    },
    SetImageOffsetY(b) {
      this._SetImageOffsetY(b);
    },
    SetImageScaleX(b) {
      this._SetImageScaleX(b / 100);
    },
    SetImageScaleY(b) {
      this._SetImageScaleY(b / 100);
    },
    SetImageAngle(b) {
      this._SetImageAngle(e.toRadians(b));
    },
    SetEffect(b) {
      this.GetWorldInfo().SetBlendMode(b);
      this._runtime.UpdateRender();
    },
    async LoadURL(b, a) {
      if (!this._ownImageInfo || this._ownImageInfo.GetURL() !== b) {
        a = this._runtime;
        var c = e.New(e.ImageInfo);
        try {
          await c.LoadDynamicAsset(a, b);
          if (!c.IsLoaded()) throw Error("image failed to load");
          if (this.WasReleased()) return c.Release(), null;
          if (
            !(await c.LoadStaticTexture(a.GetRenderer(), {
              sampling: this._runtime.GetSampling(),
              wrapX: "repeat",
              wrapY: "repeat",
            }))
          )
            return;
        } catch (d) {
          console.error("Load image from URL failed: ", d);
          this.Trigger(e.Plugins.TiledBg.Cnds.OnURLFailed);
          return;
        }
        this.WasReleased()
          ? c.Release()
          : (this._ReleaseOwnImage(),
            (this._ownImageInfo = c),
            a.UpdateRender(),
            await this.TriggerAsync(e.Plugins.TiledBg.Cnds.OnURLLoaded));
      }
    },
  };
}
{
  const e = self.C3;
  e.Plugins.TiledBg.Exps = {
    ImageWidth() {
      return this.GetCurrentImageInfo().GetWidth();
    },
    ImageHeight() {
      return this.GetCurrentImageInfo().GetHeight();
    },
    ImageOffsetX() {
      return this._imageOffsetX;
    },
    ImageOffsetY() {
      return this._imageOffsetY;
    },
    ImageScaleX() {
      return 100 * this._imageScaleX;
    },
    ImageScaleY() {
      return 100 * this._imageScaleY;
    },
    ImageAngle() {
      return e.toDegrees(this._imageAngle);
    },
  };
}
("use strict");
{
  const e = self.C3;
  e.Plugins.Timeline = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Timeline.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3;
  e.Plugins.Timeline.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b);
      this.GetRuntime().GetTimelineManager().SetPluginInstance(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  let b = null,
    a = null;
  e.Plugins.Timeline.Cnds = {
    SetTriggerTimeline(c) {
      b = c;
    },
    GetTriggerTimeline() {
      return b;
    },
    SetTriggerKeyframe(c) {
      a = c;
    },
    GetTriggerKeyframe() {
      return a;
    },
    OnTimelineStarted(c) {
      return b === c;
    },
    OnTimelineStartedByName(c) {
      const d = this._runtime.GetTimelineManager();
      for (const f of d.GetTimelinesByName(c))
        if (e.equalsNoCase(b.GetName(), f.GetName())) return !0;
      return !1;
    },
    OnTimelineStartedByTags(c) {
      const d = this._runtime.GetTimelineManager();
      for (const f of d.GetTimelinesByTags(c))
        if (f.HasTags(b.GetTags())) return !0;
      return !1;
    },
    OnAnyTimelineStarted() {
      return !0;
    },
    OnTimelineFinished(c) {
      return b === c;
    },
    OnTimelineFinishedByName(c) {
      const d = this._runtime.GetTimelineManager();
      for (const f of d.GetTimelinesByName(c))
        if (e.equalsNoCase(b.GetName(), f.GetName())) return !0;
      return !1;
    },
    OnTimelineFinishedByTags(c) {
      const d = this._runtime.GetTimelineManager();
      for (const f of d.GetTimelinesByTags(c))
        if (f.HasTags(b.GetTags())) return !0;
      return !1;
    },
    OnAnyTimelineFinished() {
      return !0;
    },
    IsPlaying(c) {
      return c.IsPlaying();
    },
    IsPlayingByName(c) {
      const d = this._runtime.GetTimelineManager();
      for (const f of d.GetTimelinesByName(c)) if (f.IsPlaying()) return !0;
      return !1;
    },
    IsPlayingByTags(c) {
      const d = this._runtime.GetTimelineManager();
      for (const f of d.GetTimelinesByTags(c)) if (f.IsPlaying()) return !0;
      return !1;
    },
    IsAnyPlaying() {
      return [...this._runtime.GetTimelineManager().GetTimelines()].some((c) =>
        c.IsPlaying()
      );
    },
    IsPaused(c) {
      return c.IsPaused();
    },
    IsPausedByName(c) {
      const d = this._runtime.GetTimelineManager();
      for (const f of d.GetTimelinesByName(c)) if (f.IsPaused()) return !0;
      return !1;
    },
    IsPausedByTags(c) {
      const d = this._runtime.GetTimelineManager();
      for (const f of d.GetTimelinesByTags(c)) if (f.IsPaused()) return !0;
      return !1;
    },
    IsAnyPaused() {
      return [...this._runtime.GetTimelineManager().GetTimelines()].some((c) =>
        c.IsPaused()
      );
    },
    OnTimeSet(c) {
      return b === c;
    },
    OnTimeSetByName(c) {
      const d = this._runtime.GetTimelineManager();
      for (const f of d.GetTimelinesByName(c)) if (b === f) return !0;
      return !1;
    },
    OnTimeSetByTags(c) {
      const d = this._runtime.GetTimelineManager();
      for (const f of d.GetTimelinesByTags(c)) if (b === f) return !0;
      return !1;
    },
    OnAnyKeyframeReached() {
      return !!a;
    },
    OnKeyframeReached(c, d) {
      if (!a || 0 === a.GetTags().length || !c) return !1;
      c = c ? c.split(" ") : [];
      if (0 === d) {
        for (const f of c) if (a.HasTag(f)) return !0;
        return !1;
      }
      for (const f of c) if (!a.HasTag(f)) return !1;
      return !0;
    },
  };
}
{
  const e = self.C3,
    b = new Map(),
    a = (d, f) => {
      for (const h of d) f.SetTrackInstance(h.trackId, h.instance);
    },
    c = () => {
      const d = [];
      for (const [f, h] of b.entries()) {
        const g = f.GetCurrentSol().GetInstances(),
          k = h.trackIds.length;
        for (let m = 0; m < k; m++)
          g[h.startIndex + m] &&
            d.push({ trackId: h.trackIds[m], instance: g[h.startIndex + m] });
        h.startIndex += k;
      }
      return d;
    };
  e.Plugins.Timeline.Acts = {
    async PlayTimeline(d, f, h) {
      if (d) {
        var g = this._runtime.GetTimelineManager(),
          k = [];
        if (b.size) {
          let q = c();
          do
            if (q.length) {
              var m = g.GetTimelineOfTemplateForInstances(d, q);
              m ||
                ((m = g.CreateFromTemplate(d)),
                m.ClearTrackInstances(),
                a(q, m));
              m.SetTags(f);
              m.Play() && k.push(m.GetPlayPromise());
              q = c();
            }
          while (q.length);
        } else d.SetTags(f), d.Play() && k.push(d.GetPlayPromise());
        h || b.clear();
        await Promise.all(k);
      } else h || b.clear();
    },
    async PlayTimelineByName(d, f) {
      const h = this._runtime.GetTimelineManager(),
        g = [];
      for (const k of h.GetTimelinesByName(d))
        g.push(e.Plugins.Timeline.Acts.PlayTimeline.call(this, k, f, !0));
      b.clear();
      await Promise.all(g);
    },
    async PlayAllTimelines() {
      const d = this._runtime.GetTimelineManager(),
        f = [];
      for (const h of d.GetTimelines()) h.Play() && f.push(h.GetPlayPromise());
      b.clear();
      await Promise.all(f);
    },
    PauseTimeline(d) {
      d && d.Stop();
    },
    PauseTimelineByName(d) {
      const f = this._runtime.GetTimelineManager();
      for (const h of f.GetTimelinesByName(d))
        e.Plugins.Timeline.Acts.PauseTimeline.call(this, h);
    },
    PauseTimelineByTags(d) {
      const f = this._runtime.GetTimelineManager();
      for (const h of f.GetTimelinesByTags(d))
        e.Plugins.Timeline.Acts.PauseTimeline.call(this, h);
    },
    PauseAllTimelines() {
      const d = this._runtime.GetTimelineManager();
      for (const f of d.GetTimelines()) f.Stop();
    },
    ResumeTimeline(d) {
      d && d.Resume();
    },
    ResumeTimelineByName(d) {
      const f = this._runtime.GetTimelineManager();
      for (const h of f.GetTimelinesByName(d))
        e.Plugins.Timeline.Acts.ResumeTimeline.call(this, h);
    },
    ResumeTimelineByTags(d) {
      const f = this._runtime.GetTimelineManager();
      for (const h of f.GetTimelinesByTags(d))
        e.Plugins.Timeline.Acts.ResumeTimeline.call(this, h);
    },
    ResumeAllTimelines() {
      const d = this._runtime.GetTimelineManager();
      for (const f of d.GetTimelines()) f.Resume();
    },
    StopTimeline(d) {
      d && d.Reset();
    },
    StopTimelineByName(d) {
      const f = this._runtime.GetTimelineManager();
      for (const h of f.GetTimelinesByName(d))
        e.Plugins.Timeline.Acts.StopTimeline.call(this, h);
    },
    StopTimelineByTags(d) {
      const f = this._runtime.GetTimelineManager();
      for (const h of f.GetTimelinesByTags(d))
        e.Plugins.Timeline.Acts.StopTimeline.call(this, h);
    },
    StopAllTimelines() {
      const d = this._runtime.GetTimelineManager();
      for (const f of d.GetTimelines()) f.Reset();
    },
    SetTimelineTime(d, f) {
      if (d)
        if (e.IsFiniteNumber(f)) d.SetTime(f);
        else if (e.IsString(f)) {
          const h = d.GetKeyframeWithTags(f);
          h
            ? d.SetTime(h.GetTime())
            : e.Plugins.Timeline.Acts.SetTimelineTime.call(this, d, Number(f));
        }
    },
    SetTimelineTimeByName(d, f) {
      const h = this._runtime.GetTimelineManager();
      for (const g of h.GetTimelinesByName(d))
        e.Plugins.Timeline.Acts.SetTimelineTime.call(this, g, f);
    },
    SetTimelineTimeByTags(d, f) {
      const h = this._runtime.GetTimelineManager();
      for (const g of h.GetTimelinesByTags(d))
        e.Plugins.Timeline.Acts.SetTimelineTime.call(this, g, f);
    },
    SetTimelinePlaybackRate(d, f) {
      d && d.SetPlaybackRate(f);
    },
    SetTimelinePlaybackRateByName(d, f) {
      const h = this._runtime.GetTimelineManager();
      for (const g of h.GetTimelinesByName(d))
        e.Plugins.Timeline.Acts.SetTimelinePlaybackRate.call(this, g, f);
    },
    SetTimelinePlaybackRateByTags(d, f) {
      const h = this._runtime.GetTimelineManager();
      for (const g of h.GetTimelinesByTags(d))
        e.Plugins.Timeline.Acts.SetTimelinePlaybackRate.call(this, g, f);
    },
    SetInstance(d, f) {
      b.has(d) || b.set(d, { startIndex: 0, trackIds: [] });
      b.get(d).trackIds.push(f);
    },
  };
}
{
  const e = self.C3;
  e.Plugins.Timeline.Exps = {
    Time(b) {
      const a = this._runtime.GetTimelineManager();
      for (const c of a.GetTimelinesByName(b)) return c.GetTime();
      for (const c of a.GetTimelinesByTags(b)) return c.GetTime();
      return 0;
    },
    TotalTime(b) {
      const a = this._runtime.GetTimelineManager();
      for (const c of a.GetTimelinesByName(b)) return c.GetTotalTime();
      for (const c of a.GetTimelinesByTags(b)) return c.GetTotalTime();
      return 0;
    },
    Progress(b) {
      const a = this._runtime.GetTimelineManager();
      for (const c of a.GetTimelinesByName(b))
        return c.GetTime() / c.GetTotalTime();
      for (const c of a.GetTimelinesByTags(b))
        return c.GetTime() / c.GetTotalTime();
      return 0;
    },
    KeyframeTags() {
      const b = e.Plugins.Timeline.Cnds.GetTriggerKeyframe();
      return b ? b.GetTags().join(" ") : "";
    },
    TimelineName() {
      const b = e.Plugins.Timeline.Cnds.GetTriggerTimeline();
      return b ? b.GetName() : "";
    },
    TimelineTags() {
      const b = e.Plugins.Timeline.Cnds.GetTriggerTimeline();
      return b ? b.GetStringTags() : "";
    },
    Value(b, a) {
      const c = this._runtime.GetTimelineManager();
      for (const f of c.GetTimelinesByName(b)) {
        var d = f.GetTrackByName(a);
        if (d) {
          if ((d = d.GetPropertyTrack("value")))
            return d.GetSourceAdapterValue();
        } else if ((d = f.GetTrackById(a)))
          if ((d = d.GetPropertyTrack("value")))
            return d.GetSourceAdapterValue();
      }
      for (const f of c.GetTimelinesByTags(b))
        if ((b = f.GetTrackByName(a))) {
          if ((b = b.GetPropertyTrack("value")))
            return b.GetSourceAdapterValue();
        } else if ((b = f.GetTrackById(a)))
          if ((b = b.GetPropertyTrack("value")))
            return b.GetSourceAdapterValue();
      return 0;
    },
  };
}
("use strict");
{
  const e = self.C3;
  e.Plugins.PlatformInfo = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.PlatformInfo.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3;
  e.Plugins.PlatformInfo.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b, "platform-info");
      this._windowOuterHeight =
        this._windowOuterWidth =
        this._screenHeight =
        this._screenWidth =
          0;
      this._safeAreaInset = [0, 0, 0, 0];
      this._isWakeLockActive = this._supportsWakeLock = !1;
      this.AddDOMMessageHandlers([
        ["window-resize", (c) => this._OnWindowResize(c)],
        ["wake-lock-acquired", (c) => this._OnWakeLockAcquired(c)],
        ["wake-lock-error", (c) => this._OnWakeLockError(c)],
        ["wake-lock-released", (c) => this._OnWakeLockReleased(c)],
      ]);
      navigator.connection &&
        navigator.connection.addEventListener("change", () =>
          this._OnNetworkChange()
        );
      this._runtime.AddLoadPromise(
        this.PostToDOMAsync("get-initial-state").then((c) => {
          this._screenWidth = c.screenWidth;
          this._screenHeight = c.screenHeight;
          this._windowOuterWidth = c.windowOuterWidth;
          this._windowOuterHeight = c.windowOuterHeight;
          this._safeAreaInset = c.safeAreaInset;
          this._supportsWakeLock = c.supportsWakeLock;
        })
      );
    }
    Release() {
      super.Release();
    }
    _OnWindowResize(b) {
      this._windowOuterWidth = b.windowOuterWidth;
      this._windowOuterHeight = b.windowOuterHeight;
      this._safeAreaInset = b.safeAreaInset;
    }
    async _OnNetworkChange() {
      await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnNetworkChange);
    }
    async _OnWakeLockAcquired() {
      this._isWakeLockActive = !0;
      await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockAcquired);
    }
    async _OnWakeLockError() {
      this._isWakeLockActive = !1;
      await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockError);
    }
    async _OnWakeLockReleased() {
      this._isWakeLockActive = !1;
      await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockReleased);
    }
  };
}
{
  const e = self.C3;
  e.Plugins.PlatformInfo.Cnds = {
    IsOnMobile() {
      return e.Platform.IsMobile;
    },
    IsOnWindows() {
      return "Windows" === e.Platform.OS;
    },
    IsOnMacOS() {
      return "Mac OS X" === e.Platform.OS;
    },
    IsOnLinux() {
      return "Linux" === e.Platform.OS;
    },
    IsOnChromeOS() {
      return "Chrome OS" === e.Platform.OS;
    },
    IsOnAndroid() {
      return "Android" === e.Platform.OS;
    },
    IsOniOS() {
      return "iOS" === e.Platform.OS;
    },
    IsWebExport() {
      const b = this._runtime.GetExportType();
      return (
        "html5" === b ||
        "scirra-arcade" === b ||
        "preview" === b ||
        "instant-games" === b
      );
    },
    IsCordovaExport() {
      return this._runtime.IsCordova();
    },
    IsNWjsExport() {
      return "nwjs" === this._runtime.GetExportType();
    },
    IsWindowsUWPExport() {
      return "windows-uwp" === this._runtime.GetExportType();
    },
    IsWindowsWebView2Export() {
      return "windows-webview2" === this._runtime.GetExportType();
    },
    IsMacOSWKWebView2Export() {
      return "macos-wkwebview" === this._runtime.GetExportType();
    },
    OnNetworkChange() {
      return !0;
    },
    OnWakeLockAcquired() {
      return !0;
    },
    OnWakeLockError() {
      return !0;
    },
    OnWakeLockReleased() {
      return !0;
    },
    IsWakeLockActive() {
      return this._isWakeLockActive;
    },
    IsWakeLockSupported() {
      return this._supportsWakeLock;
    },
  };
}
self.C3.Plugins.PlatformInfo.Acts = {
  RequestWakeLock() {
    this._supportsWakeLock && this._PostToDOMMaybeSync("request-wake-lock");
  },
  ReleaseWakeLock() {
    this._supportsWakeLock &&
      ((this._isWakeLockActive = !1), this.PostToDOM("release-wake-lock"));
  },
};
self.C3.Plugins.PlatformInfo.Exps = {
  Renderer() {
    let e;
    e = this._runtime.GetWebGPURenderer()
      ? "webgpu"
      : "webgl" + this._runtime.GetWebGLRenderer().GetWebGLVersionNumber();
    this._runtime.GetRenderer().HasMajorPerformanceCaveat() &&
      (e += "-software");
    return e;
  },
  RendererDetail() {
    return this._runtime.GetWebGLRenderer().GetUnmaskedRenderer();
  },
  DevicePixelRatio() {
    return self.devicePixelRatio;
  },
  ScreenWidth() {
    return this._screenWidth;
  },
  ScreenHeight() {
    return this._screenHeight;
  },
  WindowInnerWidth() {
    return this._runtime.GetCanvasManager().GetLastWidth();
  },
  WindowInnerHeight() {
    return this._runtime.GetCanvasManager().GetLastHeight();
  },
  WindowOuterWidth() {
    return this._windowOuterWidth;
  },
  WindowOuterHeight() {
    return this._windowOuterHeight;
  },
  CanvasCssWidth() {
    return this._runtime.GetCanvasManager().GetCssWidth();
  },
  CanvasCssHeight() {
    return this._runtime.GetCanvasManager().GetCssHeight();
  },
  CanvasDeviceWidth() {
    return this._runtime.GetCanvasManager().GetDeviceWidth();
  },
  CanvasDeviceHeight() {
    return this._runtime.GetCanvasManager().GetDeviceHeight();
  },
  Downlink() {
    return navigator.connection ? navigator.connection.downlink || 0 : 0;
  },
  DownlinkMax() {
    return navigator.connection ? navigator.connection.downlinkMax || 0 : 0;
  },
  ConnectionType() {
    return navigator.connection
      ? navigator.connection.type || "unknown"
      : "unknown";
  },
  ConnectionEffectiveType() {
    return navigator.connection
      ? navigator.connection.effectiveType || "unknown"
      : "unknown";
  },
  ConnectionRTT() {
    return navigator.connection ? navigator.connection.rtt || 0 : 0;
  },
  HardwareConcurrency() {
    return navigator.hardwareConcurrency || 0;
  },
  DeviceMemory() {
    return navigator.deviceMemory || 0;
  },
  SafeAreaInsetTop() {
    return this._safeAreaInset[0];
  },
  SafeAreaInsetRight() {
    return this._safeAreaInset[1];
  },
  SafeAreaInsetBottom() {
    return this._safeAreaInset[2];
  },
  SafeAreaInsetLeft() {
    return this._safeAreaInset[3];
  },
};
("use strict");
{
  const e = self.C3;
  e.Plugins.AJAX = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.AJAX.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3;
  e.Plugins.AJAX.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b);
      this._curTag = this._lastData = "";
      this._progress = 0;
      this._timeout = -1;
      this._nextRequestHeaders = new Map();
      this._nextReponseBinaryData = null;
      this._nextRequestOverrideMimeType = "";
      this._nwjsAppFolder = this._nwjsPath = this._nwjsFs = null;
      if ((this._isNWjs = "nwjs" === this._runtime.GetExportType()))
        (this._nwjsFs = require("fs")),
          (this._nwjsPath = require("path")),
          (this._nwjsAppFolder =
            this._nwjsPath.dirname((self.process || nw.process).execPath) +
            "\\");
    }
    Release() {
      super.Release();
    }
    async _TriggerError(b, a, c) {
      console.error(
        `[Construct 3] AJAX request to '${a}' (tag '${b}') failed: `,
        c
      );
      this._curTag = b;
      await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnAnyError);
      await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnError);
    }
    async _TriggerComplete(b) {
      this._curTag = b;
      await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnAnyComplete);
      await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnComplete);
    }
    async _OnProgress(b, a) {
      a.lengthComputable &&
        ((this._progress = a.loaded / a.total),
        (this._curTag = b),
        await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnProgress));
    }
    _OnError(b, a, c) {
      if (this._isNWjs) {
        var d = this._nwjsFs,
          f = this._nwjsAppFolder + a;
        d.existsSync(f)
          ? d.readFile(f, { encoding: "utf8" }, (h, g) => {
              h
                ? this._TriggerError(b, a, h)
                : ((this._lastData = g.replace(/\r\n/g, "\n")),
                  this._TriggerComplete(b));
            })
          : this._TriggerError(b, a, c);
      } else this._TriggerError(b, a, c);
    }
    async _DoCordovaRequest(b, a) {
      const c = this._runtime.GetAssetManager(),
        d = this._nextReponseBinaryData;
      this._nextReponseBinaryData = null;
      try {
        if (d) {
          const f = await c.CordovaFetchLocalFileAsArrayBuffer(a);
          d.SetArrayBufferTransfer(f);
          this._lastData = "";
        } else
          this._lastData = (await c.CordovaFetchLocalFileAsText(a)).replace(
            /\r\n/g,
            "\n"
          );
        this._TriggerComplete(b);
      } catch (f) {
        this._TriggerError(b, a, f);
      }
    }
    _DoRequest(b, a, c, d) {
      return new Promise((f) => {
        const h = (k) => {
            this._OnError(b, a, k);
            f();
          },
          g = this._nextReponseBinaryData;
        this._nextReponseBinaryData = null;
        try {
          const k = new XMLHttpRequest();
          k.onreadystatechange = () => {
            if (4 === k.readyState) {
              this._lastData = g
                ? ""
                : (k.responseText || "").replace(/\r\n/g, "\n");
              if (400 <= k.status)
                this._TriggerError(b, a, k.status + k.statusText);
              else {
                const m =
                  this._lastData.length ||
                  (g && k.response instanceof ArrayBuffer);
                (this._isNWjs && !m) ||
                  (!this._isNWjs && 0 === k.status && !m) ||
                  (g && g.SetArrayBufferTransfer(k.response),
                  this._TriggerComplete(b));
              }
              f();
            }
          };
          k.onerror = h;
          k.ontimeout = h;
          k.onabort = h;
          k.onprogress = (m) => this._OnProgress(b, m);
          k.open(c, a);
          0 <= this._timeout &&
            "undefined" !== typeof k.timeout &&
            (k.timeout = this._timeout);
          k.responseType = g ? "arraybuffer" : "text";
          d &&
            !this._nextRequestHeaders.has("Content-Type") &&
            ("string" !== typeof d
              ? k.setRequestHeader("Content-Type", "application/octet-stream")
              : k.setRequestHeader(
                  "Content-Type",
                  "application/x-www-form-urlencoded"
                ));
          for (const [m, q] of this._nextRequestHeaders)
            try {
              k.setRequestHeader(m, q);
            } catch (v) {
              console.error(
                `[Construct 3] AJAX: Failed to set header '${m}: ${q}': `,
                v
              );
            }
          this._nextRequestHeaders.clear();
          if (this._nextRequestOverrideMimeType) {
            try {
              k.overrideMimeType(this._nextRequestOverrideMimeType);
            } catch (m) {
              console.error(
                "[Construct 3] AJAX: failed to override MIME type: ",
                m
              );
            }
            this._nextRequestOverrideMimeType = "";
          }
          d ? k.send(d) : k.send();
        } catch (k) {
          h(k);
        }
      });
    }
    GetDebuggerProperties() {
      return [
        {
          title: "plugins.ajax.debugger.title",
          properties: [
            { name: "plugins.ajax.debugger.last-data", value: this._lastData },
          ],
        },
      ];
    }
    SaveToJson() {
      return { lastData: this._lastData };
    }
    LoadFromJson(b) {
      this._lastData = b.lastData;
      this._curTag = "";
      this._progress = 0;
    }
  };
}
{
  const e = self.C3;
  e.Plugins.AJAX.Cnds = {
    OnComplete(b) {
      return e.equalsNoCase(this._curTag, b);
    },
    OnAnyComplete() {
      return !0;
    },
    OnError(b) {
      return e.equalsNoCase(this._curTag, b);
    },
    OnAnyError() {
      return !0;
    },
    OnProgress(b) {
      return e.equalsNoCase(this._curTag, b);
    },
  };
}
{
  const e = self.C3;
  e.Plugins.AJAX.Acts = {
    async Request(b, a) {
      this._runtime.IsCordova() &&
      e.IsRelativeURL(a) &&
      this._runtime.GetAssetManager().IsFileProtocol()
        ? await this._DoCordovaRequest(b, a)
        : this._runtime.IsPreview() && e.IsRelativeURL(a)
        ? ((a = this._runtime
            .GetAssetManager()
            .GetLocalUrlAsBlobUrl(a.toLowerCase())),
          await this._DoRequest(b, a, "GET", null))
        : await this._DoRequest(b, a, "GET", null);
    },
    async RequestFile(b, a) {
      this._runtime.IsCordova() &&
      this._runtime.GetAssetManager().IsFileProtocol()
        ? await this._DoCordovaRequest(b, a)
        : await this._DoRequest(
            b,
            this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(a),
            "GET",
            null
          );
    },
    async Post(b, a, c, d) {
      await this._DoRequest(b, a, d, c);
    },
    async PostBinary(b, a, c, d) {
      c &&
        (c = c.GetFirstPicked(this._inst)) &&
        ((c = c.GetSdkInstance().GetArrayBufferReadOnly()),
        await this._DoRequest(b, a, d, c));
    },
    SetTimeout(b) {
      this._timeout = 1e3 * b;
    },
    SetHeader(b, a) {
      this._nextRequestHeaders.set(b, a);
    },
    SetResponseBinary(b) {
      b &&
        (b = b.GetFirstPicked(this._inst)) &&
        (this._nextReponseBinaryData = b.GetSdkInstance());
    },
    OverrideMIMEType(b) {
      this._nextRequestOverrideMimeType = b;
    },
  };
}
self.C3.Plugins.AJAX.Exps = {
  LastData() {
    return this._lastData;
  },
  Progress() {
    return this._progress;
  },
  Tag() {
    return this._curTag;
  },
};
("use strict");
{
  const e = self.C3;
  e.Plugins.Arr = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.Arr.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3,
    b = self.C3X,
    a = self.IInstance;
  function c(f, h, g) {
    if (h < f.length) e.truncateArray(f, h);
    else if (h > f.length)
      if ("function" === typeof g)
        for (var k = f.length; k < h; ++k) f.push(g());
      else for (k = f.length; k < h; ++k) f.push(g);
  }
  e.Plugins.Arr.Instance = class extends e.SDKInstanceBase {
    constructor(f, h) {
      super(f);
      this._cx = 10;
      this._cz = this._cy = 1;
      this._arr = null;
      this._forX = [];
      this._forY = [];
      this._forZ = [];
      this._forDepth = -1;
      h && ((this._cx = h[0]), (this._cy = h[1]), (this._cz = h[2]));
      this._arr = e.MakeFilledArray(this._cx, () =>
        e.MakeFilledArray(this._cy, () => e.MakeFilledArray(this._cz, 0))
      );
    }
    Release() {
      this._arr = null;
      super.Release();
    }
    At(f, h, g) {
      f = Math.floor(f);
      h = Math.floor(h);
      g = Math.floor(g);
      return 0 <= f &&
        f < this._cx &&
        0 <= h &&
        h < this._cy &&
        0 <= g &&
        g < this._cz
        ? this._arr[f][h][g]
        : 0;
    }
    Set(f, h, g, k) {
      f = Math.floor(f);
      h = Math.floor(h);
      g = Math.floor(g);
      0 <= f &&
        f < this._cx &&
        0 <= h &&
        h < this._cy &&
        0 <= g &&
        g < this._cz &&
        (this._arr[f][h][g] = k);
    }
    SetSize(f, h, g) {
      f = Math.floor(f);
      h = Math.floor(h);
      g = Math.floor(g);
      0 > f && (f = 0);
      0 > h && (h = 0);
      0 > g && (g = 0);
      if (this._cx !== f || this._cy !== h || this._cz !== g) {
        this._cx = f;
        this._cy = h;
        this._cz = g;
        var k = this._arr;
        c(k, f, () => e.MakeFilledArray(h, () => e.MakeFilledArray(g, 0)));
        for (let m = 0; m < f; ++m) {
          c(k[m], h, () => e.MakeFilledArray(g, 0));
          for (let q = 0; q < h; ++q) c(k[m][q], g, 0);
        }
      }
    }
    GetWidth() {
      return this._cx;
    }
    GetHeight() {
      return this._cy;
    }
    GetDepth() {
      return this._cz;
    }
    GetDebuggerProperties() {
      const f = [
          {
            title: "plugins.arr.debugger.array-properties.title",
            properties: [
              {
                name: "plugins.arr.properties.width.name",
                value: this._cx,
                onedit: (g) => this.SetSize(g, this._cy, this._cz),
              },
              {
                name: "plugins.arr.properties.height.name",
                value: this._cy,
                onedit: (g) => this.SetSize(this._cx, g, this._cz),
              },
              {
                name: "plugins.arr.properties.depth.name",
                value: this._cz,
                onedit: (g) => this.SetSize(this._cx, this._cy, g),
              },
              {
                name: "plugins.arr.properties.elements.name",
                value: this._cx * this._cy * this._cz,
              },
            ],
          },
        ],
        h = [];
      if (1 === this._cy && 1 === this._cz)
        for (let g = 0; g < this._cx; ++g)
          h.push({
            name: "$" + g,
            value: this._arr[g][0][0],
            onedit: (k) => (this._arr[g][0][0] = k),
          });
      else
        for (let g = 0; g < this._cx; ++g)
          h.push({ name: "$" + g, value: this._arr[g].toString() });
      h.length &&
        f.push({
          title: "plugins.arr.debugger.array-data.title",
          properties: h,
        });
      return f;
    }
    GetAsJsonString() {
      return JSON.stringify({
        c2array: !0,
        size: [this._cx, this._cy, this._cz],
        data: this._arr,
      });
    }
    SaveToJson() {
      return { size: [this._cx, this._cy, this._cz], data: this._arr };
    }
    LoadFromJson(f) {
      const h = f.size;
      this._cx = h[0];
      this._cy = h[1];
      this._cz = h[2];
      this._arr = f.data;
    }
    _GetForX() {
      return 0 <= this._forDepth && this._forDepth < this._forX.length
        ? this._forX[this._forDepth]
        : 0;
    }
    _GetForY() {
      return 0 <= this._forDepth && this._forDepth < this._forY.length
        ? this._forY[this._forDepth]
        : 0;
    }
    _GetForZ() {
      return 0 <= this._forDepth && this._forDepth < this._forZ.length
        ? this._forZ[this._forDepth]
        : 0;
    }
    GetScriptInterfaceClass() {
      return self.IArrayInstance;
    }
  };
  const d = new WeakMap();
  self.IArrayInstance = class extends a {
    constructor() {
      super();
      d.set(this, a._GetInitInst().GetSdkInstance());
    }
    get width() {
      return d.get(this).GetWidth();
    }
    get height() {
      return d.get(this).GetHeight();
    }
    get depth() {
      return d.get(this).GetDepth();
    }
    setSize(f, h = 1, g = 1) {
      b.RequireFiniteNumber(f);
      b.RequireFiniteNumber(h);
      b.RequireFiniteNumber(g);
      d.get(this).SetSize(f, h, g);
    }
    getAt(f, h = 0, g = 0) {
      b.RequireFiniteNumber(f);
      b.RequireFiniteNumber(h);
      b.RequireFiniteNumber(g);
      return d.get(this).At(f, h, g);
    }
    setAt(f, h, g = 0, k = 0) {
      b.RequireFiniteNumber(h);
      b.RequireFiniteNumber(g);
      b.RequireFiniteNumber(k);
      if ("number" !== typeof f && "string" !== typeof f)
        throw new TypeError("invalid type");
      d.get(this).Set(h, g, k, f);
    }
  };
}
{
  const e = self.C3;
  function b(a, c, d, f, h) {
    a.PushCopySol(d);
    c.Retrigger(f, h);
    a.PopSol(d);
  }
  e.Plugins.Arr.Cnds = {
    CompareX(a, c, d) {
      return e.compare(this.At(a, 0, 0), c, d);
    },
    CompareXY(a, c, d, f) {
      return e.compare(this.At(a, c, 0), d, f);
    },
    CompareXYZ(a, c, d, f, h) {
      return e.compare(this.At(a, c, d), f, h);
    },
    ArrForEach(a) {
      const c = this._runtime,
        d = c.GetEventSheetManager(),
        f = c.GetCurrentEvent(),
        h = f.GetSolModifiers(),
        g = c.GetEventStack(),
        k = g.GetCurrentStackFrame(),
        m = g.Push(f),
        q = ++this._forDepth,
        v = this._forX;
      var r = this._forY,
        n = this._forZ;
      const p = this._cx,
        u = this._cy;
      var w = this._cz;
      q === this._forX.length
        ? (v.push(0), r.push(0), n.push(0))
        : ((v[q] = 0), (r[q] = 0), (n[q] = 0));
      c.SetDebuggingEnabled(!1);
      if (0 === a)
        for (a = 0; a < p; ++a)
          for (let y = 0; y < u; ++y)
            for (let B = 0; B < w; ++B)
              (v[q] = a), (r[q] = y), (n[q] = B), b(d, f, h, k, m);
      else if (1 === a)
        for (n = 0; n < p; ++n)
          for (w = 0; w < u; ++w) (v[q] = n), (r[q] = w), b(d, f, h, k, m);
      else for (r = 0; r < p; ++r) (v[q] = r), b(d, f, h, k, m);
      c.SetDebuggingEnabled(!0);
      this._forDepth--;
      g.Pop();
      return !1;
    },
    CompareCurrent(a, c) {
      return e.compare(
        this.At(this._GetForX(), this._GetForY(), this._GetForZ()),
        a,
        c
      );
    },
    Contains(a) {
      const c = this._cx,
        d = this._cy,
        f = this._cz,
        h = this._arr;
      for (let g = 0; g < c; ++g)
        for (let k = 0; k < d; ++k)
          for (let m = 0; m < f; ++m) if (h[g][k][m] === a) return !0;
      return !1;
    },
    IsEmpty() {
      return 0 === this._cx || 0 === this._cy || 0 === this._cz;
    },
    CompareSize(a, c, d) {
      let f = 0;
      switch (a) {
        case 0:
          f = this._cx;
          break;
        case 1:
          f = this._cy;
          break;
        case 2:
          f = this._cz;
      }
      return e.compare(f, c, d);
    },
  };
}
{
  const e = self.C3;
  function b(a, c) {
    if ("number" === typeof a && "number" === typeof c) return a - c;
    a = a.toString();
    c = c.toString();
    return a < c ? -1 : a > c ? 1 : 0;
  }
  e.Plugins.Arr.Acts = {
    Clear(a) {
      const c = this._cx,
        d = this._cy,
        f = this._cz,
        h = this._arr;
      for (let g = 0; g < c; ++g)
        for (let k = 0; k < d; ++k) for (let m = 0; m < f; ++m) h[g][k][m] = a;
    },
    SetSize(a, c, d) {
      this.SetSize(a, c, d);
    },
    SetX(a, c) {
      this.Set(a, 0, 0, c);
    },
    SetXY(a, c, d) {
      this.Set(a, c, 0, d);
    },
    SetXYZ(a, c, d, f) {
      this.Set(a, c, d, f);
    },
    Push(a, c, d) {
      var f = this._cx,
        h = this._cy;
      const g = this._cz,
        k = this._arr;
      if (0 === d)
        (f = e.MakeFilledArray(h, () => e.MakeFilledArray(g, c))),
          0 === a ? k.push(f) : k.unshift(f),
          this._cx++;
      else if (1 === d) {
        for (h = 0; h < f; ++h)
          (d = e.MakeFilledArray(g, c)),
            0 === a ? k[h].push(d) : k[h].unshift(d);
        this._cy++;
      } else {
        for (d = 0; d < f; ++d)
          for (let m = 0; m < h; ++m)
            0 === a ? k[d][m].push(c) : k[d][m].unshift(c);
        this._cz++;
      }
    },
    Pop(a, c) {
      const d = this._cx;
      var f = this._cy,
        h = this._cz;
      const g = this._arr;
      if (0 === c) 0 !== d && (0 === a ? g.pop() : g.shift(), this._cx--);
      else if (1 === c) {
        if (0 !== f) {
          for (f = 0; f < d; ++f) 0 === a ? g[f].pop() : g[f].shift();
          this._cy--;
        }
      } else if (0 !== h) {
        for (c = 0; c < d; ++c)
          for (h = 0; h < f; ++h) 0 === a ? g[c][h].pop() : g[c][h].shift();
        this._cz--;
      }
    },
    Reverse(a) {
      const c = this._cx;
      var d = this._cy,
        f = this._cz;
      const h = this._arr;
      if (0 !== c && 0 !== d && 0 !== f)
        if (0 === a) h.reverse();
        else if (1 === a) for (d = 0; d < c; ++d) h[d].reverse();
        else for (a = 0; a < c; ++a) for (f = 0; f < d; ++f) h[a][f].reverse();
    },
    Sort(a) {
      const c = this._cx;
      var d = this._cy,
        f = this._cz;
      const h = this._arr;
      if (0 !== c && 0 !== d && 0 !== f)
        if (0 === a) h.sort((g, k) => b(g[0][0], k[0][0]));
        else if (1 === a)
          for (d = 0; d < c; ++d) h[d].sort((g, k) => b(g[0], k[0]));
        else for (a = 0; a < c; ++a) for (f = 0; f < d; ++f) h[a][f].sort(b);
    },
    Delete(a, c) {
      a = Math.floor(a);
      if (!(0 > a)) {
        var d = this._cx,
          f = this._cy,
          h = this._cz,
          g = this._arr;
        if (0 === c) a >= d || (g.splice(a, 1), this._cx--);
        else if (1 === c) {
          if (!(a >= f)) {
            for (f = 0; f < d; ++f) g[f].splice(a, 1);
            this._cy--;
          }
        } else if (!(a >= h)) {
          for (c = 0; c < d; ++c) for (h = 0; h < f; ++h) g[c][h].splice(a, 1);
          this._cz--;
        }
      }
    },
    Insert(a, c, d) {
      c = Math.floor(c);
      if (!(0 > c)) {
        var f = this._cx,
          h = this._cy,
          g = this._cz,
          k = this._arr;
        if (0 === d)
          c > f ||
            (k.splice(
              c,
              0,
              e.MakeFilledArray(h, () => e.MakeFilledArray(g, a))
            ),
            this._cx++);
        else if (1 === d) {
          if (!(c > h)) {
            for (h = 0; h < f; ++h) k[h].splice(c, 0, e.MakeFilledArray(g, a));
            this._cy++;
          }
        } else if (!(c > g)) {
          for (d = 0; d < f; ++d)
            for (let m = 0; m < h; ++m) k[d][m].splice(c, 0, a);
          this._cz++;
        }
      }
    },
    JSONLoad(a) {
      let c = null;
      try {
        c = JSON.parse(a);
      } catch (d) {
        console.error("[Construct 3] Failed to parse JSON: ", d);
        return;
      }
      c.c2array &&
        ((a = c.size),
        (this._cx = a[0]),
        (this._cy = a[1]),
        (this._cz = a[2]),
        (this._arr = c.data));
    },
    JSONDownload(a) {
      const c = URL.createObjectURL(
        new Blob([this.GetAsJsonString()], { type: "application/json" })
      );
      this._runtime.InvokeDownload(c, a);
    },
  };
}
self.C3.Plugins.Arr.Exps = {
  At(e, b, a) {
    return this.At(e, b || 0, a || 0);
  },
  Width() {
    return this._cx;
  },
  Height() {
    return this._cy;
  },
  Depth() {
    return this._cz;
  },
  CurX() {
    return this._GetForX();
  },
  CurY() {
    return this._GetForY();
  },
  CurZ() {
    return this._GetForZ();
  },
  CurValue() {
    return this.At(this._GetForX(), this._GetForY(), this._GetForZ());
  },
  Front() {
    return this.At(0, 0, 0);
  },
  Back() {
    return this.At(this._cx - 1, 0, 0);
  },
  IndexOf(e) {
    const b = this._arr;
    for (let a = 0, c = this._cx; a < c; ++a) if (b[a][0][0] === e) return a;
    return -1;
  },
  LastIndexOf(e) {
    const b = this._arr;
    for (let a = this._cx - 1; 0 <= a; --a) if (b[a][0][0] === e) return a;
    return -1;
  },
  AsJSON() {
    return this.GetAsJsonString();
  },
};
("use strict");
{
  const e = self.C3;
  e.Plugins.sliderbar = class extends e.SDKDOMPluginBase {
    constructor(b) {
      super(b, "sliderbar");
      this.AddElementMessageHandler("click", (a, c) => a._OnClick(c));
      this.AddElementMessageHandler("change", (a, c) => a._OnChange(c));
      this.AddElementMessageHandler("input", (a, c) => a._OnInput(c));
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.sliderbar.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3,
    b = self.C3X;
  e.Plugins.sliderbar.Instance = class extends e.SDKDOMInstanceBase {
    constructor(c, d) {
      super(c, "sliderbar");
      this._min = this._value = 0;
      this._max = 100;
      this._step = 1;
      this._title = "";
      this._isEnabled = !0;
      this._className = this._id = "";
      d &&
        ((this._value = d[0]),
        (this._min = d[1]),
        (this._max = d[2]),
        (this._step = d[3]),
        (this._title = d[4]),
        this.GetWorldInfo().SetVisible(d[5]),
        (this._isEnabled = d[6]),
        (this._id = d[7]),
        (this._className = d[8]));
      this.CreateElement({ id: this._id, className: this._className });
    }
    Release() {
      super.Release();
    }
    GetElementState() {
      return {
        value: this._value,
        min: this._min,
        max: this._max,
        step: this._step,
        title: this._title,
        isEnabled: this._isEnabled,
      };
    }
    async _OnClick(c) {
      this.DispatchScriptEvent("click", !0);
      await this.TriggerAsync(e.Plugins.sliderbar.Cnds.OnClicked);
    }
    async _OnChange(c) {
      this._value = c.value;
      this.DispatchScriptEvent("change", !0);
      await this.TriggerAsync(e.Plugins.sliderbar.Cnds.OnChanged);
    }
    _OnInput(c) {
      this._value = c.value;
    }
    Draw(c) {}
    _SetValue(c) {
      this._value !== c && ((this._value = c), this.UpdateElementState());
    }
    _GetValue() {
      return this._value;
    }
    _SetMaximum(c) {
      this._max !== c && ((this._max = c), this.UpdateElementState());
    }
    _GetMaximum() {
      return this._max;
    }
    _SetMinimum(c) {
      this._min !== c && ((this._min = c), this.UpdateElementState());
    }
    _GetMinimum() {
      return this._min;
    }
    _SetTooltip(c) {
      this._title !== c && ((this._title = c), this.UpdateElementState());
    }
    _GetTooltip() {
      return this._title;
    }
    _SetStep(c) {
      this._step !== c && ((this._step = c), this.UpdateElementState());
    }
    _GetStep() {
      return this._step;
    }
    _SetEnabled(c) {
      c = !!c;
      this._isEnabled !== c &&
        ((this._isEnabled = c), this.UpdateElementState());
    }
    _IsEnabled() {
      return this._isEnabled;
    }
    SaveToJson() {
      return {
        v: this._value,
        min: this._min,
        max: this._max,
        s: this._step,
        t: this._title,
        e: this._isEnabled,
        id: this._id,
      };
    }
    LoadFromJson(c) {
      this._value = c.v;
      this._min = c.min;
      this._max = c.max;
      this._step = c.s;
      this._title = c.t;
      this._isEnabled = c.e;
      this._id = c.id;
      this.UpdateElementState();
    }
    GetPropertyValueByIndex(c) {
      switch (c) {
        case 0:
          return this._GetValue();
        case 1:
          return this._GetMinimum();
        case 2:
          return this._GetMaximum();
        case 3:
          return this._GetStep();
        case 4:
          return this._GetTooltip();
        case 6:
          return this._IsEnbled();
      }
    }
    SetPropertyValueByIndex(c, d) {
      switch (c) {
        case 0:
          this._SetValue(d);
          break;
        case 1:
          this._SetMinimum(d);
          break;
        case 2:
          this._SetMaximum(d);
          break;
        case 3:
          this._SetStep(d);
          break;
        case 4:
          this._SetTooltip(d);
          break;
        case 6:
          this._SetEnabled(d);
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: "plugins.sliderbar.name",
          properties: [
            {
              name: "plugins.sliderbar.properties.value.name",
              value: this._GetValue(),
              onedit: (c) => this._SetValue(c),
            },
            {
              name: "plugins.sliderbar.properties.minimum.name",
              value: this._GetMinimum(),
              onedit: (c) => this._SetMinimum(c),
            },
            {
              name: "plugins.sliderbar.properties.maximum.name",
              value: this._GetMaximum(),
              onedit: (c) => this._SetMaximum(c),
            },
            {
              name: "plugins.sliderbar.properties.step.name",
              value: this._GetStep(),
              onedit: (c) => this._SetStep(c),
            },
          ],
        },
      ];
    }
    GetScriptInterfaceClass() {
      return self.ISliderBarInstance;
    }
  };
  const a = new WeakMap();
  self.ISliderBarInstance = class extends self.IDOMInstance {
    constructor() {
      super();
      a.set(this, self.IInstance._GetInitInst().GetSdkInstance());
    }
    set value(c) {
      b.RequireFiniteNumber(c);
      a.get(this)._SetValue(c);
    }
    get value() {
      return a.get(this)._GetValue();
    }
    set maximum(c) {
      b.RequireFiniteNumber(c);
      a.get(this)._SetMaximum(c);
    }
    get maximum() {
      return a.get(this)._GetMaximum();
    }
    set minimum(c) {
      b.RequireFiniteNumber(c);
      a.get(this)._SetMinimum(c);
    }
    get minimum() {
      return a.get(this)._GetMinimum();
    }
    set step(c) {
      b.RequireFiniteNumber(c);
      a.get(this)._SetStep(c);
    }
    get step() {
      return a.get(this)._GetStep();
    }
    set tooltip(c) {
      b.RequireString(c);
      a.get(this)._SetTooltip(c);
    }
    get tooltip() {
      return a.get(this)._GetTooltip();
    }
    set isEnabled(c) {
      a.get(this)._SetEnabled(c);
    }
    get isEnabled() {
      return a.get(this)._IsEnabled();
    }
  };
}
{
  const e = self.C3;
  e.Plugins.sliderbar.Cnds = {
    OnClicked() {
      return !0;
    },
    OnChanged() {
      return !0;
    },
    CompareValue(b, a) {
      return e.compare(this._GetValue(), b, a);
    },
  };
}
self.C3.Plugins.sliderbar.Acts = {
  SetTooltip(e) {
    this._SetTooltip(e);
  },
  SetValue(e) {
    this._SetValue(e);
  },
  SetMaximum(e) {
    this._SetMaximum(e);
  },
  SetMinimum(e) {
    this._SetMinimum(e);
  },
  SetStep(e) {
    this._SetStep(e);
  },
};
self.C3.Plugins.sliderbar.Exps = {
  Value() {
    return this._GetValue();
  },
  Maximum() {
    return this._GetMaximum();
  },
  Minimum() {
    return this._GetMinimum();
  },
  Step() {
    return this._GetStep();
  },
};
("use strict");
{
  const e = self.C3;
  e.Plugins.Avix_PokiSDK_ForC3 = class extends e.SDKPluginBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
("use strict");
{
  const e = self.C3;
  e.Plugins.Avix_PokiSDK_ForC3.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
("use strict");
{
  const e = self.C3;
  e.Plugins.Avix_PokiSDK_ForC3.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b, "avix-pokisdk-forc3");
      this._adBlockDetected = this._pokiSDKLoaded = !1;
      this._lastError = "";
      this._debugModeActive = this._lastAdRewardedSuccess = !1;
      this._lastTriggeredTag = "";
      this._commercialBreakPossible = !1;
      this._pokiEnabled = !0;
      this._debugOnPreview = !1;
      this._loadingNotification = 0;
      this._preventScroll = this._automaticSuspend = !0;
      this._adblockSim = !1;
      a &&
        ([
          this._pokiEnabled,
          this._debugOnPreview,
          this._loadingNotification,
          this._automaticSuspend,
          this._preventScroll,
          this._adblockSim,
        ] = a);
      this.AddDOMMessageHandlers([
        ["SuspendRuntime", this.SuspendRuntime.bind(this)],
        ["ResumeRuntime", this.ResumeRuntime.bind(this)],
        [
          "SetCommercialBreakConstraint",
          this.SetCommercialBreakConstraint.bind(this),
        ],
      ]);
      if (0 === this._loadingNotification)
        runOnStartup(async (c) => {
          c.addEventListener("beforeprojectstart", () => {
            this.PostToDOMAsync("GameLoadingFinished");
          });
        });
      else if (1 === this._loadingNotification) {
        let c = !0;
        runOnStartup(async (d) => {
          const f = () => {
            c
              ? (c = !1)
              : (this.PostToDOMAsync("GameLoadingFinished"),
                d.getAllLayouts().forEach((h) => {
                  h.removeEventListener("beforelayoutstart", f);
                }));
          };
          d.getAllLayouts().forEach((h) =>
            h.addEventListener("beforelayoutstart", f)
          );
        });
      }
      this._pokiEnabled &&
        ((this._debugModeActive =
          this._debugOnPreview && this._runtime.IsPreview()),
        this._runtime.AddLoadPromise(
          this.PostToDOMAsync("InitPoki", {
            debugMode: this._debugModeActive,
            preventScroll: this._preventScroll,
          })
            .then(({ loaded: c, adBlock: d }) => {
              this._adBlockDetected = d;
              this._pokiSDKLoaded = c;
              this._adblockSim &&
                this._runtime.IsPreview() &&
                (this._adBlockDetected = !0);
              this._pokiSDKLoaded
                ? this._adBlockDetected &&
                  (this._lastError = "User is likely to have an AdBlock active")
                : (this._lastError = "Poki SDK did not load");
            })
            .catch(console.error)
        ));
    }
    SuspendRuntime() {
      this._automaticSuspend && this._runtime.SetSuspended(!0);
    }
    ResumeRuntime() {
      this._automaticSuspend &&
        0 < this._runtime._suspendCount &&
        this._runtime.SetSuspended(!1);
    }
    SetCommercialBreakConstraint({ constrained: b }) {
      this._commercialBreakPossible = !b;
      this.Trigger(
        self.C3.Plugins.Avix_PokiSDK_ForC3.Cnds.OnCommercialBreakPossible
      );
    }
    Release() {
      super.Release();
    }
  };
}
("use strict");
self.C3.Plugins.Avix_PokiSDK_ForC3.Cnds = {
  OnCommercialBreakComplete(e) {
    return "" === e || e === this._lastTriggeredTag;
  },
  OnRewardedBreakComplete(e) {
    return "" === e || e === this._lastTriggeredTag;
  },
  OnCommercialBreakPossible() {
    return this._commercialBreakPossible && !this._adBlockDetected;
  },
  CommercialBreakPossible() {
    return this._pokiSDKLoaded && this._pokiEnabled
      ? this._commercialBreakPossible && !this._adBlockDetected
      : !1;
  },
  LastAdRewardSuccess() {
    return this._lastAdRewardedSuccess;
  },
  PokiSDKLoaded() {
    return this._pokiSDKLoaded;
  },
  PokiPluginEnabled() {
    return this._pokiEnabled;
  },
  AdBlockDetected() {
    return this._adBlockDetected;
  },
  PokiDebugMode() {
    return this._debugModeActive;
  },
};
("use strict");
self.C3.Plugins.Avix_PokiSDK_ForC3.Acts = {
  NotifyLoadingFinished() {
    2 !== this._loadingNotification &&
      console.log(
        "If you use the Notify Loading Finished action, you should configure the Poki Plugin, set the Loading Notification Mode to Manual."
      );
    this.PostToDOMAsync("GameLoadingFinished");
  },
  NotifyGameplayStart() {
    this.PostToDOMAsync("NotifyGameplayStart");
  },
  NotifyGameplayStop() {
    this.PostToDOMAsync("NotifyGameplayStop");
  },
  SetDebugMode(e) {
    this._debugModeActive = e;
    this.PostToDOMAsync("SetDebugMode", { enable: e });
  },
  HappyTime(e) {
    this.PostToDOMAsync("HappyTime", { intensity: e });
  },
  async RequestCommercialBreak(e) {
    if (this._adblockSim && this._runtime.IsPreview()) await Promise.resolve();
    else {
      var { err: b } = await this.PostToDOMAsync("RequestCommercialBreak");
      b && (this._lastError = b);
    }
    this._lastTriggeredTag = e;
    this.Trigger(
      self.C3.Plugins.Avix_PokiSDK_ForC3.Cnds.OnCommercialBreakComplete
    );
  },
  async RequestRewardedBreak(e) {
    if (this._adblockSim && this._runtime.IsPreview())
      await Promise.resolve(),
        (this._lastTriggeredTag = e),
        (this._lastAdRewardedSuccess = !1);
    else {
      var { result: b, err: a } = await this.PostToDOMAsync(
        "RequestRewardedBreak"
      );
      a && (this._lastError = a);
      this._lastTriggeredTag = e;
      this._lastAdRewardedSuccess = b;
    }
    this.Trigger(
      self.C3.Plugins.Avix_PokiSDK_ForC3.Cnds.OnRewardedBreakComplete
    );
  },
};
("use strict");
self.C3.Plugins.Avix_PokiSDK_ForC3.Exps = {
  LastAdRewardSuccess() {
    return this._lastAdRewardedSuccess;
  },
  CommercialBreakPossible() {
    return this._pokiSDKLoaded && this._pokiEnabled
      ? this._commercialBreakPossible && !this._adBlockDetected
      : !1;
  },
  AdBlockDetected() {
    return this._adBlockDetected;
  },
  LastError() {
    return this._lastError;
  },
  PokiSDKLoaded() {
    return this._pokiSDKLoaded;
  },
  PokiPluginEnabled() {
    return this._pokiEnabled;
  },
  PokiDebugMode() {
    return this._debugModeActive;
  },
};
("use strict");
{
  const e = self.C3;
  e.Behaviors.Tween = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Tween.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3,
    b = e.Behaviors.Tween;
  b.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(a, c) {
      super(a);
      this._allowMultiple = !1;
      this._enabled = !0;
      c && ((this._allowMultiple = !1), (this._enabled = !!c[0]));
      this._activeTweens = new Map();
      this._disabledTweens = [];
      this._waitingForReleaseTweens = new Map();
      this._waitingForReleaseTweensJson =
        this._disabledTweensJson =
        this._activeTweensJson =
        this._finishingTween =
          null;
      this._finishingTweenName = "";
      this._enabled && this._StartTicking2();
      this._afterLoad = (d) => this._OnAfterLoad(d);
      this.GetRuntime()
        .Dispatcher()
        .addEventListener("afterload", this._afterLoad);
    }
    Release() {
      this.GetRuntime()
        .Dispatcher()
        .removeEventListener("afterload", this._afterLoad);
      this._afterLoad = null;
      this._finishingTween &&
        (this.ReleaseAndCompleteTween(this._finishingTween),
        (this._finishingTween = null));
      this.ReleaseAndCompleteTweens();
      this._tweens = null;
      this.ClearDisabledList();
      this._disabledTweens = null;
      this._ReleaseWaitingTweens();
      this._waitingForReleaseTweens = null;
      super.Release();
    }
    SetEnabled(a) {
      (this._enabled = a) ? this._StartTicking2() : this._StopTicking2();
    }
    GetEnabled() {
      return this._enabled;
    }
    AddToDisabledList(a) {
      this._disabledTweens.push(a);
    }
    IsInDisabledList(a) {
      return this._disabledTweens.includes(a);
    }
    ClearDisabledList() {
      e.clearArray(this._disabledTweens);
    }
    GetFinishingTween() {
      return this._finishingTween;
    }
    IsInstanceValid() {
      const a = this.GetObjectInstance();
      return a ? !a.IsDestroyed() : !1;
    }
    GetTween(a, c, d = !1) {
      if ((c = c ? this.PropertyTweens(c, d) : this.AllTweens(d)) && c.length)
        for (const f of c) if (f.HasTags(a)) return f;
    }
    GetTweenIncludingWaitingForRelease(a, c) {
      return this.GetTween(a, c, !0);
    }
    *GetTweens(a, c, d = !1) {
      if ((c = c ? this.PropertyTweens(c, d) : this.AllTweens(d)) && c.length)
        for (const f of c) f.HasTags(a) && (yield f);
    }
    *GetTweensIncludingWaitingForRelease(a, c) {
      yield* this.GetTweens(a, c, !0);
    }
    PropertyTweens(a, c) {
      if (c)
        return (
          (c = this._activeTweens.get(a)),
          (a = this._waitingForReleaseTweens.get(a)),
          c || (c = []),
          a || (a = []),
          c.concat(a).filter((d) => d)
        );
      (a = this._activeTweens.get(a)) || (a = []);
      return a.filter((d) => d);
    }
    AllTweens(a) {
      if (a) {
        a = [...this._activeTweens.values()].flat();
        const c = [...this._waitingForReleaseTweens.values()].flat();
        return a.concat(c).filter((d) => d);
      }
      return [...this._activeTweens.values()].flat().filter((c) => c);
    }
    AllTweensIncludingWaitingForRelease() {
      return this.AllTweens(!0);
    }
    SaveToJson() {
      return {
        s: !1,
        e: !!this._enabled,
        at: this._SaveActiveTweensToJson(),
        dt: this._SaveDisabledTweensToJson(),
        wt: this._SaveWaitingForReleaseTweensToJson(),
        ft: this._SaveFinishingTweenToJson(),
      };
    }
    LoadFromJson(a) {
      a &&
        ((this._activeTweensJson = a.at),
        (this._disabledTweensJson = a.dt),
        (this._waitingForReleaseTweensJson = a.wt),
        (this._finishingTweenName = a.ft),
        (this._allowMultiple = !1),
        (this._enabled = !!a.e));
    }
    _OnAfterLoad(a) {
      a = this.GetRuntime().GetTimelineManager();
      this._PopulateTweenMap(this._activeTweensJson, this._activeTweens, a);
      if (this._disabledTweensJson) {
        e.clearArray(this._disabledTweens);
        for (const c of this._disabledTweensJson)
          this._PopulateTweenArray(this._disabledTweens, c, a);
      }
      this._PopulateTweenMap(
        this._waitingForReleaseTweensJson,
        this._waitingForReleaseTweens,
        a
      );
      this._finishingTween = this._GetTween(this._finishingTweenName, a);
      this._enabled ? this._StartTicking2() : this._StopTicking2();
    }
    _PopulateTweenMap(a, c, d) {
      if (a)
        for (const h in a) {
          let g = c.get(h);
          g ? e.clearArray(g) : (g = []);
          var f = a[h];
          for (const k of f)
            this._PopulateTweenArray(g, k.name, d)
              ? this._LoadTweenFromJson(k.name, k, d)
              : ((f = e.TweenState.Build({
                  runtime: this.GetRuntime(),
                  json: k,
                })),
                f.AddCompletedCallback((m) => this._FinishTriggers(m)),
                d.AddScheduledTimeline(f),
                this._PopulateTweenArray(g, f, d));
          c.set(h, g);
        }
    }
    _GetTween(a, c) {
      return c.GetScheduledOrPlayingTimelineByName(a);
    }
    _PopulateTweenArray(a, c, d) {
      if ("string" === typeof c) {
        if ((c = this._GetTween(c, d))) return !!a.push(c);
      } else return !!a.push(c);
      return !1;
    }
    _LoadTweenFromJson(a, c, d) {
      "string" === typeof a
        ? (a = this._GetTween(a, d)) && a._LoadFromJson(c)
        : a._LoadFromJson(c);
    }
    _SaveActiveTweensToJson() {
      const a = {};
      for (const [c, d] of this._activeTweens)
        a[c] = d.map((f) => f._SaveToJson());
      return a;
    }
    _SaveDisabledTweensToJson() {
      return this._disabledTweens.map((a) => a.GetName());
    }
    _SaveWaitingForReleaseTweensToJson() {
      const a = {};
      for (const [c, d] of this._waitingForReleaseTweens)
        a[c] = d.map((f) => f._SaveToJson());
      return a;
    }
    _SaveFinishingTweenToJson() {
      return this._finishingTween ? this._finishingTween.GetName() : "";
    }
    Tick2() {
      this._ReleaseWaitingTweens();
    }
    CreateTween(a) {
      var c = b.Config.GetPropertyTracksConfig(
        a.property,
        a.startValue,
        a.endValue,
        a.ease,
        a.resultMode,
        this.GetObjectInstance()
      );
      const d = b.Maps.GetPropertyFromIndex(a.property);
      b.Maps.IsValueId(d) || this.ReleaseTweens(a.property);
      c = e.TweenState.Build({
        runtime: this.GetRuntime(),
        id: d,
        tags: a.tags,
        time: a.time,
        instance: this.GetObjectInstance(),
        releaseOnComplete: !!a.releaseOnComplete,
        loop: !!a.loop,
        pingPong: !!a.pingPong,
        initialValueMode: a.initialValueMode,
        propertyTracksConfig: c,
      });
      c.AddCompletedCallback((f) => this._FinishTriggers(f));
      this._AddTween(c, a.property);
      return c;
    }
    ReleaseTween(a, c = !1) {
      var d = a.GetId();
      if (this._activeTweens.has(d) && (d = this._activeTweens.get(d))) {
        const f = d.indexOf(a);
        -1 !== f && d.splice(f, 1);
      }
      a.IsReleased() ||
        this._IsInWaitingList(a) ||
        (a.Stop(c), this._AddToWaitingList(a));
    }
    ReleaseTweens(a, c = !1) {
      if (e.IsFiniteNumber(a)) {
        var d = b.Maps.GetPropertyFromIndex(a);
        if (this._activeTweens.has(d)) {
          d = this._activeTweens.get(d);
          var f = this.GetFinishingTween();
          for (var h of d)
            h === f ||
              h.IsReleased() ||
              this._IsInWaitingList(h) ||
              (h.Stop(c), h.Release());
          e.clearArray(d);
        }
      } else {
        h = this.GetFinishingTween();
        for (d of this.AllTweens())
          d === h ||
            d.IsReleased() ||
            this._IsInWaitingList(d) ||
            (d.Stop(c), d.Release());
        for (f of this._activeTweens.keys())
          e.clearArray(this._activeTweens.get(f)), this._activeTweens.delete(f);
        this._activeTweens.clear();
      }
    }
    ReleaseAndCompleteTween(a) {
      this.ReleaseTween(a, !0);
    }
    ReleaseAndCompleteTweens() {
      this.ReleaseTweens(NaN, !0);
    }
    GetPropertyValueByIndex(a) {
      switch (a) {
        case 0:
          return this._enabled;
      }
    }
    SetPropertyValueByIndex(a, c) {
      switch (a) {
        case 0:
          this._enabled = !!c;
      }
    }
    _GetBehaviorType(a) {
      a = a.GetInstance().GetBehaviorInstances();
      for (const c of a)
        if (
          ((a = c.GetBehaviorType()),
          a.GetInstanceSdkCtor() === this.constructor)
        )
          return a;
    }
    Trigger(a, c, d, f) {
      return this._runtime ? super.Trigger(a) : c.Trigger(a, d, f);
    }
    _FinishTriggers(a) {
      this._finishingTween = a;
      b.Cnds.SetFinishingTween(a);
      let c, d;
      if (this.GetRuntime())
        (c = this._inst),
          (d = this._runtime),
          this.Trigger(b.Cnds.OnTweensFinished),
          this.Trigger(b.Cnds.OnAnyTweensFinished),
          this.ReleaseTween(a);
      else {
        c = a.GetInstance();
        if (!c || (c && c.IsDestroyed())) return;
        d = c.GetRuntime();
        const f = this._GetBehaviorType(a);
        this.Trigger(b.Cnds.OnTweensFinished, d, c, f);
        this.Trigger(b.Cnds.OnAnyTweensFinished, d, c, f);
        a.Stop();
      }
      this._finishingTween = null;
      b.Cnds.SetFinishingTween(null);
      a.GetDestroyInstanceOnComplete() && d.DestroyInstance(c);
    }
    _AddTween(a, c) {
      c = b.Maps.GetPropertyFromIndex(c);
      this._activeTweens.has(c) || this._activeTweens.set(c, []);
      this._activeTweens.get(c).push(a);
    }
    _AddToWaitingList(a) {
      const c = a.GetId();
      this._waitingForReleaseTweens.has(c) ||
        this._waitingForReleaseTweens.set(c, []);
      this._waitingForReleaseTweens.get(c).push(a);
    }
    _IsInWaitingList(a) {
      const c = a.GetId();
      return this._waitingForReleaseTweens.has(c)
        ? this._waitingForReleaseTweens.get(c).includes(a)
        : !1;
    }
    _ReleaseWaitingTweens() {
      if (this._waitingForReleaseTweens.size) {
        for (const a of this._waitingForReleaseTweens.values()) {
          for (const c of a) c.IsReleased() || c.Release();
          e.clearArray(a);
        }
        this._waitingForReleaseTweens.clear();
      }
    }
  };
}
{
  const e = self.C3;
  let b = null;
  e.Behaviors.Tween.Cnds = {
    SetFinishingTween(a) {
      b = a;
    },
    OnTweensFinished(a) {
      return b.HasTags(a);
    },
    OnAnyTweensFinished() {
      return !0;
    },
    IsPlaying(a) {
      return ((a = [...this.GetTweensIncludingWaitingForRelease(a)]), a.length)
        ? a.some(e.TweenState.IsPlaying)
        : !1;
    },
    IsAnyPlaying() {
      const a = [...this.AllTweensIncludingWaitingForRelease()];
      return a && a.length ? a.some(e.TweenState.IsPlaying) : !1;
    },
    IsPaused(a) {
      return ((a = [...this.GetTweensIncludingWaitingForRelease(a)]), a.length)
        ? a.some(e.TweenState.IsPaused)
        : !1;
    },
    IsAnyPaused() {
      const a = [...this.AllTweensIncludingWaitingForRelease()];
      return a && a.length ? a.some(e.TweenState.IsPaused) : !1;
    },
  };
}
{
  const e = self.C3,
    b = self.Ease,
    a = e.Behaviors.Tween;
  a.Acts = {
    SetEnabled(c) {
      this.SetEnabled(!!c);
      for (const d of this.AllTweens())
        c
          ? this.IsInDisabledList(d) && d.Resume()
          : ((d.IsPlaying() || d.IsScheduled()) && this.AddToDisabledList(d),
            d.Stop());
      c && this.ClearDisabledList();
    },
    async TweenOneProperty(...c) {
      this.GetEnabled() &&
        this.IsInstanceValid() &&
        ((c = this.CreateTween(a.TweenArguments.OneProperty(this, ...c))),
        c.Play() && (await c.GetPlayPromise()));
    },
    async TweenTwoProperties(...c) {
      this.GetEnabled() &&
        this.IsInstanceValid() &&
        ((c = this.CreateTween(a.TweenArguments.TwoProperties(this, ...c))),
        c.Play() && (await c.GetPlayPromise()));
    },
    async TweenValue(...c) {
      this.GetEnabled() &&
        this.IsInstanceValid() &&
        ((c = this.CreateTween(a.TweenArguments.ValueProperty(this, ...c))),
        c.Play() && (await c.GetPlayPromise()));
    },
    PauseTweens(c) {
      if (this.GetEnabled() && this.IsInstanceValid())
        for (const d of this.GetTweens(c)) d.Stop();
    },
    PauseAllTweens() {
      if (this.GetEnabled() && this.IsInstanceValid())
        for (const c of this.AllTweens()) c.Stop();
    },
    ResumeTweens(c) {
      if (this.GetEnabled() && this.IsInstanceValid())
        for (const d of this.GetTweens(c)) d.Resume();
    },
    ResumeAllTweens() {
      if (this.GetEnabled() && this.IsInstanceValid())
        for (const c of this.AllTweens()) c.Resume();
    },
    StopTweens(c) {
      if (this.GetEnabled() && this.IsInstanceValid())
        for (const d of this.GetTweens(c)) this.ReleaseTween(d);
    },
    StopAllTweens() {
      if (this.GetEnabled() && this.IsInstanceValid())
        for (const c of this.AllTweens()) this.ReleaseTween(c);
    },
    SetOnePropertyTweensEndValue(c, d, f) {
      if (this.GetEnabled() && this.IsInstanceValid()) {
        d = e.Behaviors.Tween.Maps.GetSinglePropertyFromIndex(d);
        for (const h of this.GetTweens(c))
          h.BeforeSetEndValues([d]), h.SetEndValue(f, d);
      }
    },
    SetTwoPropertiesTweensEndValue(c, d, f, h) {
      if (this.GetEnabled() && this.IsInstanceValid()) {
        d = e.Behaviors.Tween.Maps.GetRealProperties(d);
        for (const g of this.GetTweens(c))
          g.BeforeSetEndValues(d),
            g.SetEndValue(f, d[0]),
            g.SetEndValue(h, d[1]);
      }
    },
    SetValuePropertyTweensStartValue(c, d) {
      if (this.GetEnabled() && this.IsInstanceValid())
        for (const f of this.GetTweens(c, "value")) f.SetStartValue(d, "value");
    },
    SetValuePropertyTweensEndValue(c, d) {
      if (this.GetEnabled() && this.IsInstanceValid())
        for (const f of this.GetTweens(c, "value"))
          f.BeforeSetEndValues(["value"]), f.SetEndValue(d, "value");
    },
    SetTweensEase(c, d) {
      if (this.GetEnabled() && this.IsInstanceValid()) {
        d = b.GetEaseFromIndex(d);
        for (const f of this.GetTweens(c)) f.SetEase(d);
      }
    },
    SetAllTweensEase(c) {
      if (this.GetEnabled() && this.IsInstanceValid()) {
        c = b.GetEaseFromIndex(c);
        for (const d of this.AllTweens()) d.SetEase(c);
      }
    },
    SetTweensTime(c, d) {
      if (this.GetEnabled() && this.IsInstanceValid())
        for (const f of this.GetTweens(c)) f.SetTime(d);
    },
    SetAllTweensTime(c) {
      if (this.GetEnabled() && this.IsInstanceValid())
        for (const d of this.AllTweens()) d.SetTime(c);
    },
    SetTweensPlaybackRate(c, d) {
      if (this.GetEnabled() && this.IsInstanceValid())
        for (const f of this.GetTweens(c)) f.SetPlaybackRate(d);
    },
    SetAllTweensPlaybackRate(c) {
      if (this.GetEnabled() && this.IsInstanceValid())
        for (const d of this.AllTweens()) d.SetPlaybackRate(c);
    },
    SetTweensDestroyOnComplete(c, d) {
      if (this.GetEnabled() && this.IsInstanceValid())
        for (const f of this.GetTweens(c)) f.SetDestroyInstanceOnComplete(!!d);
    },
    SetAllTweensDestroyOnComplete(c) {
      if (this.GetEnabled() && this.IsInstanceValid())
        for (const d of this.AllTweens()) d.SetDestroyInstanceOnComplete(!!c);
    },
  };
}
self.C3.Behaviors.Tween.Exps = {
  Time(e) {
    return (e = this.GetTweenIncludingWaitingForRelease(e)) ? e.GetTime() : 0;
  },
  Progress(e) {
    return (e = this.GetTweenIncludingWaitingForRelease(e))
      ? e.GetTime() / e.GetTotalTime()
      : 0;
  },
  Value(e) {
    return (e = this.GetTweenIncludingWaitingForRelease(e, "value"))
      ? e.GetPropertyTrack("value").GetSourceAdapterValue()
      : 0;
  },
  Tags() {
    return this.GetFinishingTween()
      ? this.GetFinishingTween().GetStringTags()
      : "";
  },
};
{
  ("use strict");
  const e = self.C3,
    b = self.Ease,
    a = ["position", "size", "scale"],
    c =
      "offsetX offsetY offsetWidth offsetHeight offsetAngle offsetOpacity offsetColor offsetZElevation offsetScaleX offsetScaleY".split(
        " "
      ),
    d = ["value"],
    f = [].concat(a).concat(c).concat(d),
    h = {
      position: ["offsetX", "offsetY"],
      size: ["offsetWidth", "offsetHeight"],
      scale: ["offsetScaleX", "offsetScaleY"],
    },
    g = Object.assign(
      {},
      f.reduce((k, m) => Object.assign({}, k, { [m]: [m] }), {}),
      h
    );
  e.Behaviors.Tween.Maps = class {
    constructor() {}
    static GetEases() {
      return [...b.GetRuntimeEaseNames()];
    }
    static GetEaseFromIndex(k) {
      return [...b.GetRuntimeEaseNames()][k];
    }
    static GetPropertyFromIndex(k) {
      return f[k];
    }
    static GetPropertyIndexFromName(k) {
      return f.indexOf(k);
    }
    static GetPairPropertyFromIndex(k) {
      return a[k];
    }
    static GetSinglePropertyFromIndex(k) {
      return c[k];
    }
    static GetValuePropertyFromIndex(k) {
      return d[k];
    }
    static GetPairProperties(k) {
      return h[k];
    }
    static GetRealProperties(k) {
      return e.IsString(k) ? g[k] : g[f[k]];
    }
    static IsPairId(k) {
      return !!h[k];
    }
    static IsColorId(k) {
      return "offsetColor" === k;
    }
    static IsAngleId(k) {
      return "offsetAngle" === k;
    }
    static IsOpacityId(k) {
      return "offsetOpacity" === k;
    }
    static IsValueId(k) {
      return "value" === k;
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = e.Behaviors.Tween,
    a = new Map();
  b.Config = class {
    constructor() {}
    static GetPropertyTracksConfig(c, d, f, h, g, k) {
      0 === a.size && this._CreateConfigObjects();
      var m = b.PropertyTypes.Pick(c);
      m = a.get(m);
      e.IsFiniteNumber(c) && (c = b.Maps.GetPropertyFromIndex(c));
      return this._GetConfig(m, c, d, f, h, g, k);
    }
    static TransformValue(c, d) {
      return e.Behaviors.Tween.GetPropertyTracksConfig(c).valueGetter(d);
    }
    static _CreateConfigObjects() {
      const c = b.PropertyTypes,
        d = b.ValueGetters;
      this._AddConfigObject(c.PAIR, this._GetPairConfig, d._GetPropertyValue);
      this._AddConfigObject(
        c.COLOR,
        this._GetColorConfig,
        d._GetColorPropertyValue
      );
      this._AddConfigObject(
        c.ANGLE,
        this._GetAngleConfig,
        d._GetPropertyAngleValue
      );
      this._AddConfigObject(c.VALUE, this._GetValueConfig, d._GetPropertyValue);
      this._AddConfigObject(
        c.OTHER,
        this._GetCommonConfig,
        d._GetPropertyValue
      );
    }
    static _AddConfigObject(c, d, f) {
      a.set(c, this._CreateConfigObject(c, d, f));
    }
    static _CreateConfigObject(c, d, f) {
      return { name: c, configFunc: d, valueGetter: f };
    }
    static _GetConfig(c, d, f, h, g, k, m) {
      return c.configFunc(d, c.valueGetter(f), c.valueGetter(h), g, k, m);
    }
    static _GetPairConfig(c, d, f, h, g, k) {
      return b.Maps.GetPairProperties(c).map((m, q) => ({
        sourceId: "world-instance",
        property: m,
        type: "float",
        valueType: "numeric",
        startValue: d[q],
        endValue: f[q],
        ease: b.Maps.GetEaseFromIndex(h),
        resultMode: g,
      }));
    }
    static _GetColorConfig(c, d, f, h, g, k) {
      return e.Plugins.Text && k.GetPlugin() instanceof e.Plugins.Text
        ? {
            sourceId: "plugin",
            sourceArgs: [7],
            property: "color",
            type: "color",
            valueType: "color",
            startValue: d,
            endValue: f,
            ease: b.Maps.GetEaseFromIndex(h),
            resultMode: g,
          }
        : {
            sourceId: "world-instance",
            property: c,
            type: "color",
            valueType: "color",
            startValue: d,
            endValue: f,
            ease: b.Maps.GetEaseFromIndex(h),
            resultMode: g,
          };
    }
    static _GetAngleConfig(c, d, f, h, g, k) {
      return {
        sourceId: "world-instance",
        property: c,
        type: "angle",
        valueType: "angle",
        startValue: d,
        endValue: f,
        ease: b.Maps.GetEaseFromIndex(h),
        resultMode: g,
      };
    }
    static _GetCommonConfig(c, d, f, h, g, k) {
      return {
        sourceId: "world-instance",
        property: c,
        type: "float",
        valueType: "numeric",
        startValue: d,
        endValue: f,
        ease: b.Maps.GetEaseFromIndex(h),
        resultMode: g,
      };
    }
    static _GetValueConfig(c, d, f, h, g, k) {
      return {
        sourceId: "value",
        property: c,
        type: "float",
        valueType: "numeric",
        startValue: d,
        endValue: f,
        ease: b.Maps.GetEaseFromIndex(h),
        resultMode: g,
      };
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = e.Behaviors.Tween,
    a = Object.assign(
      {},
      { resultMode: "absolute" },
      {
        tags: "",
        property: "",
        time: 0,
        ease: 0,
        releaseOnComplete: 0,
        loop: !1,
        pingPong: !1,
      }
    ),
    c = Object.assign({}, a, {
      initialValueMode: "current-state",
      startValue: 0,
      endValue: 0,
    }),
    d = Object.assign({}, a, {
      initialValueMode: "current-state",
      startValue: [0, 0],
      endValue: [0, 0],
    }),
    f = Object.assign({}, a, {
      initialValueMode: "current-state",
      startValue: [0, 0, 0],
      endValue: [0, 0, 0],
    }),
    h = Object.assign({}, c, { initialValueMode: "start-value" });
  b.TweenArguments = class {
    constructor() {}
    static _SetCommonProperties(g, k, m, q, v, r, n) {
      g.tags = k;
      g.time = m;
      g.ease = q;
      g.releaseOnComplete = v;
      g.loop = r;
      g.pingPong = n;
    }
    static OneProperty(g, k, m, q, v, r, n, p, u) {
      g = b.Maps.GetSinglePropertyFromIndex(m);
      m = b.Maps.IsColorId(g) ? f : c;
      this._SetCommonProperties(m, k, v, r, n, p, u);
      b.Maps.IsColorId(g)
        ? ((f.endValue[0] = e.GetRValue(q)),
          (f.endValue[1] = e.GetGValue(q)),
          (f.endValue[2] = e.GetBValue(q)),
          (f.property = b.Maps.GetPropertyIndexFromName(g)))
        : b.Maps.IsOpacityId(g)
        ? (c.endValue = q / 100)
        : (c.endValue = q);
      m.property = b.Maps.GetPropertyIndexFromName(g);
      return m;
    }
    static TwoProperties(g, k, m, q, v, r, n, p, u, w) {
      this._SetCommonProperties(d, k, r, n, p, u, w);
      g = b.Maps.GetPairPropertyFromIndex(m);
      d.endValue[0] = q;
      d.endValue[1] = v;
      d.property = b.Maps.GetPropertyIndexFromName(g);
      return d;
    }
    static ValueProperty(g, k, m, q, v, r, n, p, u) {
      this._SetCommonProperties(h, k, v, r, n, p, u);
      h.startValue = m;
      h.endValue = q;
      h.property = b.Maps.GetPropertyIndexFromName("value");
      return h;
    }
  };
}
{
  ("use strict");
  const e = self.C3,
    b = e.Behaviors.Tween,
    a = [];
  b.PropertyTypes = class {
    constructor() {}
    static Pick(c) {
      0 === a.length &&
        (a.push({ checkFunc: b.Maps.IsPairId, result: this.PAIR }),
        a.push({ checkFunc: b.Maps.IsColorId, result: this.COLOR }),
        a.push({ checkFunc: b.Maps.IsAngleId, result: this.ANGLE }),
        a.push({ checkFunc: b.Maps.IsValueId, result: this.VALUE }),
        a.push({ checkFunc: () => !0, result: this.OTHER }));
      e.IsFiniteNumber(c) &&
        (c = e.Behaviors.Tween.Maps.GetPropertyFromIndex(c));
      for (const d of a) if (d.checkFunc(c)) return d.result;
    }
    static get PAIR() {
      return "pair";
    }
    static get COLOR() {
      return "color";
    }
    static get ANGLE() {
      return "angle";
    }
    static get VALUE() {
      return "value";
    }
    static get OTHER() {
      return "other";
    }
  };
}
{
  ("use strict");
  const e = self.C3;
  e.Behaviors.Tween.ValueGetters = class {
    constructor() {}
    static _GetPropertyAngleValue(b) {
      b = e.toRadians(parseFloat(b));
      return e.clampAngle(b);
    }
    static _GetColorPropertyValue(b) {
      return b.slice(0);
    }
    static _GetPropertyValue(b) {
      return b;
    }
  };
}
("use strict");
{
  const e = self.C3;
  e.Behaviors.Bullet = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Bullet.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3,
    b = self.C3X,
    a = self.IBehaviorInstance;
  e.Behaviors.Bullet.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(d, f) {
      super(d);
      d = this.GetWorldInfo();
      this._g = this._acc = this._speed = 0;
      this._isStepping = this._setAngle = this._bounceOffSolid = !1;
      this._isEnabled = !0;
      this._dy = this._dx = 0;
      this._lastX = d.GetX();
      this._lastY = d.GetY();
      this._lastKnownAngle = d.GetAngle();
      this._travelled = 0;
      this._stepSize = Math.min(
        Math.abs(d.GetWidth()),
        Math.abs(d.GetHeight()) / 2
      );
      this._stopStepping = !1;
      f &&
        ((this._speed = f[0]),
        (this._acc = f[1]),
        (this._g = f[2]),
        (this._bounceOffSolid = !!f[3]),
        (this._setAngle = !!f[4]),
        (this._isStepping = !!f[5]),
        (this._isEnabled = !!f[6]));
      f = d.GetAngle();
      this._dx = Math.cos(f) * this._speed;
      this._dy = Math.sin(f) * this._speed;
      this._isEnabled &&
        (this._StartTicking(),
        this._bounceOffSolid && this._StartPostTicking());
    }
    Release() {
      super.Release();
    }
    SaveToJson() {
      const d = {
        dx: this._dx,
        dy: this._dy,
        lx: this._lastX,
        ly: this._lastY,
        lka: this._lastKnownAngle,
        t: this._travelled,
      };
      0 !== this._acc && (d.acc = this._acc);
      0 !== this._g && (d.g = this._g);
      this._isStepping && (d.st = this._isStepping);
      this._isEnabled || (d.e = this._isEnabled);
      this._bounceOffSolid && (d.bos = this._bounceOffSolid);
      this._setAngle && (d.sa = this._setAngle);
      return d;
    }
    LoadFromJson(d) {
      this._dx = d.dx;
      this._dy = d.dy;
      this._lastX = d.lx;
      this._lastY = d.ly;
      this._lastKnownAngle = d.lka;
      this._travelled = d.t;
      this._acc = d.hasOwnProperty("acc") ? d.acc : 0;
      this._g = d.hasOwnProperty("g") ? d.g : 0;
      this._isStepping = d.hasOwnProperty("st") ? d.st : !1;
      this._bounceOffSolid = d.hasOwnProperty("bos") ? d.bos : !1;
      this._setAngle = d.hasOwnProperty("sa") ? d.sa : !1;
      this._SetEnabled(d.hasOwnProperty("e") ? d.e : !0);
    }
    Tick() {
      if (this._isEnabled) {
        var d = this._runtime.GetDt(this._inst),
          f = this._inst.GetWorldInfo();
        if (f.GetAngle() !== this._lastKnownAngle) {
          var h = f.GetAngle();
          if (this._setAngle) {
            var g = e.distanceTo(0, 0, this._dx, this._dy);
            this._dx = Math.cos(h) * g;
            this._dy = Math.sin(h) * g;
          }
          this._lastKnownAngle = h;
        }
        h = g = 0;
        if (0 !== this._acc) {
          let k = e.distanceTo(0, 0, this._dx, this._dy),
            m;
          m =
            0 === this._dx && 0 === this._dy
              ? f.GetAngle()
              : e.angleTo(0, 0, this._dx, this._dy);
          k += this._acc * d;
          g = Math.cos(m) * this._acc;
          h = Math.sin(m) * this._acc;
          0 > k && (h = g = k = 0);
          this._dx = Math.cos(m) * k;
          this._dy = Math.sin(m) * k;
        }
        0 !== this._g && ((this._dy += this._g * d), (h += this._g));
        this._lastX = f.GetX();
        this._lastY = f.GetY();
        if (0 !== this._dx || 0 !== this._dy)
          (g = this._dx * d + 0.5 * g * d * d),
            (d = this._dy * d + 0.5 * h * d * d),
            (h = e.distanceTo(0, 0, g, d)),
            this._MoveBy(g, d, h),
            (this._travelled += h),
            !this._setAngle ||
              (0 === g && 0 === d) ||
              ((d = e.angleTo(0, 0, g, d)),
              f.SetAngle(d),
              (this._lastKnownAngle = f.GetAngle())),
            f.SetBboxChanged();
      }
    }
    _MoveBy(d, f, h) {
      const g = this.GetWorldInfo();
      if (!this._isStepping || h <= this._stepSize)
        g.OffsetXY(d, f),
          g.SetBboxChanged(),
          this._isStepping && this.Trigger(e.Behaviors.Bullet.Cnds.OnStep);
      else {
        this._stopStepping = !1;
        var k = g.GetX(),
          m = g.GetY(),
          q = k + d,
          v = m + f;
        f = e.angleTo(0, 0, d, f);
        d = Math.cos(f) * this._stepSize;
        f = Math.sin(f) * this._stepSize;
        h = Math.floor(h / this._stepSize);
        for (let r = 1; r <= h; ++r)
          if (
            (g.SetXY(k + d * r, m + f * r),
            g.SetBboxChanged(),
            this.Trigger(e.Behaviors.Bullet.Cnds.OnStep),
            this._inst.IsDestroyed() || this._stopStepping)
          )
            return;
        g.SetXY(q, v);
        g.SetBboxChanged();
        this.Trigger(e.Behaviors.Bullet.Cnds.OnStep);
      }
    }
    PostTick() {
      if (
        this._isEnabled &&
        this._bounceOffSolid &&
        (0 !== this._dx || 0 !== this._dy)
      ) {
        var d = this._runtime.GetDt(this._inst),
          f = this._inst.GetWorldInfo(),
          h = this._runtime.GetCollisionEngine(),
          g = h.TestOverlapSolid(this._inst);
        if (g) {
          h.RegisterCollision(this._inst, g);
          g = e.distanceTo(0, 0, this._dx, this._dy);
          const k = h.CalculateBounceAngle(
            this._inst,
            this._lastX,
            this._lastY
          );
          this._dx = Math.cos(k) * g;
          this._dy = Math.sin(k) * g;
          f.OffsetXY(this._dx * d, this._dy * d);
          f.SetBboxChanged();
          this._setAngle &&
            (f.SetAngle(k),
            (this._lastKnownAngle = f.GetAngle()),
            f.SetBboxChanged());
          h.PushOutSolid(
            this._inst,
            this._dx / g,
            this._dy / g,
            Math.max(2.5 * g * d, 30)
          ) || h.PushOutSolidNearest(this._inst, 100);
        }
      }
    }
    GetPropertyValueByIndex(d) {
      switch (d) {
        case 0:
          return this._GetSpeed();
        case 1:
          return this._GetAcceleration();
        case 2:
          return this._GetGravity();
        case 4:
          return this._setAngle;
        case 5:
          return this._isStepping;
        case 6:
          return this._IsEnabled();
      }
    }
    SetPropertyValueByIndex(d, f) {
      switch (d) {
        case 0:
          this._SetSpeed(f);
          break;
        case 1:
          this._acc = f;
          break;
        case 2:
          this._g = f;
          break;
        case 4:
          this._setAngle = !!f;
          break;
        case 5:
          this._isStepping = !!f;
          break;
        case 6:
          this._SetEnabled(!!f);
      }
    }
    _SetSpeed(d) {
      const f = e.angleTo(0, 0, this._dx, this._dy);
      this._dx = Math.cos(f) * d;
      this._dy = Math.sin(f) * d;
    }
    _GetSpeed() {
      return e.round6dp(e.distanceTo(0, 0, this._dx, this._dy));
    }
    _SetAcceleration(d) {
      this._acc = d;
    }
    _GetAcceleration() {
      return this._acc;
    }
    _SetGravity(d) {
      this._g = d;
    }
    _GetGravity() {
      return this._g;
    }
    _SetAngleOfMotion(d) {
      const f = e.distanceTo(0, 0, this._dx, this._dy);
      this._dx = Math.cos(d) * f;
      this._dy = Math.sin(d) * f;
    }
    _GetAngleOfMotion() {
      return e.angleTo(0, 0, this._dx, this._dy);
    }
    _SetBounceOffSolids(d) {
      d = !!d;
      this._bounceOffSolid !== d &&
        ((this._bounceOffSolid = d),
        this._isEnabled &&
          (this._bounceOffSolid
            ? this._StartPostTicking()
            : this._StopPostTicking()));
    }
    _IsBounceOffSolids() {
      return this._bounceOffSolid;
    }
    _SetDistanceTravelled(d) {
      this._travelled = d;
    }
    _GetDistanceTravelled() {
      return this._travelled;
    }
    _SetEnabled(d) {
      (this._isEnabled = !!d)
        ? (this._StartTicking(),
          this._bounceOffSolid && this._StartPostTicking())
        : (this._StopTicking(), this._StopPostTicking());
    }
    _IsEnabled() {
      return this._isEnabled;
    }
    GetDebuggerProperties() {
      return [
        {
          title: "$" + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: "behaviors.bullet.debugger.vector-x",
              value: this._dx,
              onedit: (d) => (this._dx = d),
            },
            {
              name: "behaviors.bullet.debugger.vector-y",
              value: this._dy,
              onedit: (d) => (this._dy = d),
            },
            {
              name: "behaviors.bullet.properties.speed.name",
              value: this._GetSpeed(),
              onedit: (d) => this._SetSpeed(d),
            },
            {
              name: "behaviors.bullet.debugger.angle-of-motion",
              value: e.toDegrees(this._GetAngleOfMotion()),
            },
            {
              name: "behaviors.bullet.properties.gravity.name",
              value: this._GetGravity(),
              onedit: (d) => this._SetGravity(d),
            },
            {
              name: "behaviors.bullet.properties.acceleration.name",
              value: this._GetAcceleration(),
              onedit: (d) => this._SetAcceleration(d),
            },
            {
              name: "behaviors.bullet.debugger.distance-travelled",
              value: this._GetDistanceTravelled(),
            },
            {
              name: "behaviors.bullet.properties.enabled.name",
              value: this._IsEnabled(),
              onedit: (d) => this._SetEnabled(d),
            },
          ],
        },
      ];
    }
    GetScriptInterfaceClass() {
      return self.IBulletBehaviorInstance;
    }
  };
  const c = new WeakMap();
  self.IBulletBehaviorInstance = class extends a {
    constructor() {
      super();
      c.set(this, a._GetInitInst().GetSdkInstance());
    }
    get speed() {
      return c.get(this)._GetSpeed();
    }
    set speed(d) {
      b.RequireFiniteNumber(d);
      c.get(this)._SetSpeed(d);
    }
    get acceleration() {
      return c.get(this)._GetAcceleration();
    }
    set acceleration(d) {
      b.RequireFiniteNumber(d);
      c.get(this)._SetAcceleration(d);
    }
    get gravity() {
      return c.get(this)._GetGravity();
    }
    set gravity(d) {
      b.RequireFiniteNumber(d);
      c.get(this)._SetGravity(d);
    }
    get angleOfMotion() {
      return c.get(this)._GetAngleOfMotion();
    }
    set angleOfMotion(d) {
      b.RequireFiniteNumber(d);
      c.get(this)._SetAngleOfMotion(d);
    }
    get bounceOffSolids() {
      return c.get(this)._IsBounceOffSolids();
    }
    set bounceOffSolids(d) {
      c.get(this)._SetBounceOffSolids(!!d);
    }
    get distanceTravelled() {
      return c.get(this)._GetDistanceTravelled();
    }
    set distanceTravelled(d) {
      b.RequireFiniteNumber(d);
      c.get(this)._SetDistanceTravelled(d);
    }
    get isEnabled() {
      return c.get(this)._IsEnabled();
    }
    set isEnabled(d) {
      c.get(this)._SetEnabled(d);
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Bullet.Cnds = {
    CompareSpeed(b, a) {
      return e.compare(
        Math.sqrt(this._dx * this._dx + this._dy * this._dy),
        b,
        a
      );
    },
    CompareTravelled(b, a) {
      return e.compare(this._GetDistanceTravelled(), b, a);
    },
    OnStep() {
      return !0;
    },
    IsEnabled() {
      return this._IsEnabled();
    },
  };
}
{
  const e = self.C3;
  e.Behaviors.Bullet.Acts = {
    SetSpeed(b) {
      this._SetSpeed(b);
    },
    SetAcceleration(b) {
      this._SetAcceleration(b);
    },
    SetGravity(b) {
      this._SetGravity(b);
    },
    SetAngleOfMotion(b) {
      this._SetAngleOfMotion(e.toRadians(b));
    },
    Bounce(b) {
      if (b && (b = b.GetFirstPicked(this._inst))) {
        var a = this._inst.GetWorldInfo(),
          c = this._runtime.GetCollisionEngine(),
          d = this._runtime.GetDt(this._inst),
          f = e.distanceTo(0, 0, this._dx, this._dy),
          h = c.CalculateBounceAngle(this._inst, this._lastX, this._lastY, b);
        this._dx = Math.cos(h) * f;
        this._dy = Math.sin(h) * f;
        a.OffsetXY(this._dx * d, this._dy * d);
        a.SetBboxChanged();
        this._setAngle &&
          (a.SetAngle(h),
          (this._lastKnownAngle = a.GetAngle()),
          a.SetBboxChanged());
        0 !== f &&
          (this._bounceOffSolid
            ? c.PushOutSolid(
                this._inst,
                this._dx / f,
                this._dy / f,
                Math.max(2.5 * f * d, 30)
              ) || c.PushOutSolidNearest(this._inst, 100)
            : c.PushOut(
                this._inst,
                this._dx / f,
                this._dy / f,
                Math.max(2.5 * f * d, 30),
                b
              ));
      }
    },
    SetBounceOffSolids(b) {
      this._SetBounceOffSolids(b);
    },
    SetDistanceTravelled(b) {
      this._SetDistanceTravelled(b);
    },
    SetEnabled(b) {
      this._SetEnabled(b);
    },
    StopStepping() {
      this._stopStepping = !0;
    },
  };
}
{
  const e = self.C3;
  e.Behaviors.Bullet.Exps = {
    Speed() {
      return this._GetSpeed();
    },
    Acceleration() {
      return this._GetAcceleration();
    },
    AngleOfMotion() {
      return e.toDegrees(this._GetAngleOfMotion());
    },
    DistanceTravelled() {
      return this._GetDistanceTravelled();
    },
    Gravity() {
      return this._GetGravity();
    },
  };
}
("use strict");
{
  const e = self.C3;
  e.Behaviors.solid = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.solid.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3,
    b = new Set();
  e.Behaviors.solid.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(a, c) {
      super(a);
      this.SetEnabled(!0);
      c && (this.SetEnabled(c[0]), this.SetTags(c[1]));
    }
    Release() {
      super.Release();
    }
    SetEnabled(a) {
      this._inst._SetSolidEnabled(!!a);
    }
    IsEnabled() {
      return this._inst._IsSolidEnabled();
    }
    SetTags(a) {
      const c = this._inst.GetSavedDataMap();
      if (a.trim()) {
        var d = c.get("solidTags");
        d || ((d = new Set()), c.set("solidTags", d));
        d.clear();
        for (const f of a.split(" ")) f && d.add(f.toLowerCase());
      } else c.delete("solidTags");
    }
    GetTags() {
      return this._inst.GetSavedDataMap().get("solidTags") || b;
    }
    SaveToJson() {
      return { e: this.IsEnabled() };
    }
    LoadFromJson(a) {
      this.SetEnabled(a.e);
    }
    GetPropertyValueByIndex(a) {
      switch (a) {
        case 0:
          return this.IsEnabled();
      }
    }
    SetPropertyValueByIndex(a, c) {
      switch (a) {
        case 0:
          this.SetEnabled(c);
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: "$" + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: "behaviors.solid.properties.enabled.name",
              value: this.IsEnabled(),
              onedit: (a) => this.SetEnabled(a),
            },
          ],
        },
      ];
    }
  };
}
self.C3.Behaviors.solid.Cnds = {
  IsEnabled() {
    return this.IsEnabled();
  },
};
self.C3.Behaviors.solid.Acts = {
  SetEnabled(e) {
    this.SetEnabled(e);
  },
  SetTags(e) {
    this.SetTags(e);
  },
};
self.C3.Behaviors.solid.Exps = {};
("use strict");
{
  const e = self.C3;
  e.Behaviors.Sin = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Sin.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3,
    b = self.C3X,
    a = self.IBehaviorInstance,
    c = 2 * Math.PI,
    d = Math.PI / 2,
    f = (3 * Math.PI) / 2,
    h = [0, 1, 8, 3, 4, 2, 5, 6, 9, 7];
  e.Behaviors.Sin.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(q, v) {
      super(q);
      this._mag = this._period = this._wave = this._movement = this._i = 0;
      this._isEnabled = !0;
      this._ratio =
        this._lastKnownValue2 =
        this._lastKnownValue =
        this._initialValue2 =
        this._initialValue =
        this._magnitudeRandom =
        this._periodOffsetRandom =
        this._periodRandom =
        this._baseMag =
        this._basePeriodOffset =
        this._basePeriod =
          0;
      v &&
        ((this._movement = h[v[0]]),
        (this._wave = v[1]),
        (this._periodRandom = this._runtime.Random() * v[3]),
        (this._basePeriod = v[2]),
        (this._period = v[2]),
        (this._period += this._periodRandom),
        (this._basePeriodOffset = v[4]),
        0 !== this._period &&
          ((this._periodOffsetRandom = this._runtime.Random() * v[5]),
          (this._i = (v[4] / this._period) * c),
          (this._i += (this._periodOffsetRandom / this._period) * c)),
        (this._magnitudeRandom = this._runtime.Random() * v[7]),
        (this._baseMag = v[6]),
        (this._mag = v[6]),
        (this._mag += this._magnitudeRandom),
        (this._isEnabled = !!v[8]));
      5 === this._movement && (this._mag = e.toRadians(this._mag));
      this.Init();
      this._isEnabled && this._StartTicking();
    }
    Release() {
      super.Release();
    }
    SaveToJson() {
      return {
        i: this._i,
        e: this._isEnabled,
        mv: this._movement,
        w: this._wave,
        p: this._period,
        mag: this._mag,
        iv: this._initialValue,
        iv2: this._initialValue2,
        r: this._ratio,
        lkv: this._lastKnownValue,
        lkv2: this._lastKnownValue2,
      };
    }
    LoadFromJson(q) {
      this._i = q.i;
      this._SetEnabled(q.e);
      this._movement = q.mv;
      this._wave = q.w;
      this._period = q.p;
      this._mag = q.mag;
      this._initialValue = q.iv;
      this._initialValue2 = q.iv2;
      this._ratio = q.r;
      this._lastKnownValue = q.lkv;
      this._lastKnownValue2 = q.lkv2;
    }
    Init() {
      const q = this._inst.GetWorldInfo();
      switch (this._movement) {
        case 0:
          this._initialValue = q.GetX();
          break;
        case 1:
          this._initialValue = q.GetY();
          break;
        case 2:
          this._initialValue = q.GetWidth();
          this._ratio = q.GetHeight() / q.GetWidth();
          break;
        case 3:
          this._initialValue = q.GetWidth();
          break;
        case 4:
          this._initialValue = q.GetHeight();
          break;
        case 5:
          this._initialValue = q.GetAngle();
          break;
        case 6:
          this._initialValue = q.GetOpacity();
          break;
        case 7:
          this._initialValue = 0;
          break;
        case 8:
          this._initialValue = q.GetX();
          this._initialValue2 = q.GetY();
          break;
        case 9:
          this._initialValue = q.GetZElevation();
      }
      this._lastKnownValue = this._initialValue;
      this._lastKnownValue2 = this._initialValue2;
    }
    WaveFunc(q) {
      q %= c;
      switch (this._wave) {
        case 0:
          return Math.sin(q);
        case 1:
          return q <= d
            ? q / d
            : q <= f
            ? 1 - (2 * (q - d)) / Math.PI
            : (q - f) / d - 1;
        case 2:
          return (2 * q) / c - 1;
        case 3:
          return (-2 * q) / c + 1;
        case 4:
          return q < Math.PI ? -1 : 1;
      }
      return 0;
    }
    Tick() {
      const q = this._runtime.GetDt(this._inst);
      this._isEnabled &&
        0 !== q &&
        ((this._i =
          0 === this._period ? 0 : (this._i + (q / this._period) * c) % c),
        this._UpdateFromPhase());
    }
    _UpdateFromPhase() {
      const q = this._inst.GetWorldInfo();
      switch (this._movement) {
        case 0:
          q.GetX() !== this._lastKnownValue &&
            (this._initialValue += q.GetX() - this._lastKnownValue);
          q.SetX(this._initialValue + this.WaveFunc(this._i) * this._mag);
          this._lastKnownValue = q.GetX();
          break;
        case 1:
          q.GetY() !== this._lastKnownValue &&
            (this._initialValue += q.GetY() - this._lastKnownValue);
          q.SetY(this._initialValue + this.WaveFunc(this._i) * this._mag);
          this._lastKnownValue = q.GetY();
          break;
        case 2:
          q.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
          q.SetHeight(q.GetWidth() * this._ratio);
          break;
        case 3:
          q.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
          break;
        case 4:
          q.SetHeight(this._initialValue + this.WaveFunc(this._i) * this._mag);
          break;
        case 5:
          q.GetAngle() !== this._lastKnownValue &&
            (this._initialValue = e.clampAngle(
              this._initialValue + (q.GetAngle() - this._lastKnownValue)
            ));
          q.SetAngle(this._initialValue + this.WaveFunc(this._i) * this._mag);
          this._lastKnownValue = q.GetAngle();
          break;
        case 6:
          q.SetOpacity(
            this._initialValue + (this.WaveFunc(this._i) * this._mag) / 100
          );
          break;
        case 8:
          q.GetX() !== this._lastKnownValue &&
            (this._initialValue += q.GetX() - this._lastKnownValue);
          q.GetY() !== this._lastKnownValue2 &&
            (this._initialValue2 += q.GetY() - this._lastKnownValue2);
          q.SetX(
            this._initialValue +
              Math.cos(q.GetAngle()) * this.WaveFunc(this._i) * this._mag
          );
          q.SetY(
            this._initialValue2 +
              Math.sin(q.GetAngle()) * this.WaveFunc(this._i) * this._mag
          );
          this._lastKnownValue = q.GetX();
          this._lastKnownValue2 = q.GetY();
          break;
        case 9:
          q.SetZElevation(
            this._initialValue + this.WaveFunc(this._i) * this._mag
          );
      }
      q.SetBboxChanged();
    }
    _OnSpriteFrameChanged(q, v) {}
    _SetPeriod(q) {
      this._period = q;
    }
    _GetPeriod() {
      return this._period;
    }
    _SetMagnitude(q) {
      this._mag = q;
    }
    _SetMagnitude_ConvertAngle(q) {
      5 === this._movement && (q = e.toRadians(q));
      this._SetMagnitude(q);
    }
    _GetMagnitude() {
      return this._mag;
    }
    _GetMagnitude_ConvertAngle() {
      let q = this._GetMagnitude();
      5 === this._movement && (q = e.toDegrees(q));
      return q;
    }
    _SetMovement(q) {
      5 === this._movement && 5 !== q && (this._mag = e.toDegrees(this._mag));
      this._movement = q;
      this.Init();
    }
    _GetMovement() {
      return this._movement;
    }
    _SetWave(q) {
      this._wave = q;
    }
    _GetWave() {
      return this._wave;
    }
    _SetPhase(q) {
      this._i = e.clamp(q, 0, 2 * Math.PI);
      this._UpdateFromPhase();
    }
    _GetPhase() {
      return this._i;
    }
    _SetEnabled(q) {
      (this._isEnabled = !!q) ? this._StartTicking() : this._StopTicking();
    }
    _IsEnabled() {
      return this._isEnabled;
    }
    GetPropertyValueByIndex(q) {
      switch (q) {
        case 0:
          return this._movement;
        case 1:
          return this._wave;
        case 2:
          return this._basePeriod;
        case 6:
          return this._baseMag;
        case 8:
          return this._isEnabled;
      }
    }
    SetPropertyValueByIndex(q, v) {
      switch (q) {
        case 0:
          this._movement = h[v];
          this.Init();
          break;
        case 1:
          this._wave = v;
          break;
        case 2:
          this._basePeriod = v;
          this._period = this._basePeriod + this._periodRandom;
          this._isEnabled ||
            (0 !== this._period
              ? ((this._i = (this._basePeriodOffset / this._period) * c),
                (this._i += (this._periodOffsetRandom / this._period) * c))
              : (this._i = 0));
          break;
        case 6:
          this._baseMag = v;
          this._mag = this._baseMag + this._magnitudeRandom;
          5 === this._movement && (this._mag = e.toRadians(this._mag));
          break;
        case 8:
          this._isEnabled = !!v;
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: "$" + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: "behaviors.sin.properties.enabled.name",
              value: this._IsEnabled(),
              onedit: (q) => this._SetEnabled(q),
            },
            {
              name: "behaviors.sin.properties.period.name",
              value: this._GetPeriod(),
              onedit: (q) => this._SetPeriod(q),
            },
            {
              name: "behaviors.sin.properties.magnitude.name",
              value: this._GetMagnitude_ConvertAngle(),
              onedit: (q) => this._SetMagnitude_ConvertAngle(q),
            },
            {
              name: "behaviors.sin.debugger.value",
              value:
                this.WaveFunc(this._GetPhase()) *
                this._GetMagnitude_ConvertAngle(),
            },
          ],
        },
      ];
    }
    GetScriptInterfaceClass() {
      return self.ISineBehaviorInstance;
    }
  };
  const g = new WeakMap(),
    k =
      "horizontal vertical size width height angle opacity value-only forwards-backwards z-elevation".split(
        " "
      ),
    m = ["sine", "triangle", "sawtooth", "reverse-sawtooth", "square"];
  self.ISineBehaviorInstance = class extends a {
    constructor() {
      super();
      g.set(this, a._GetInitInst().GetSdkInstance());
    }
    set period(q) {
      b.RequireFiniteNumber(q);
      g.get(this)._SetPeriod(q);
    }
    get period() {
      return g.get(this)._GetPeriod();
    }
    set magnitude(q) {
      b.RequireFiniteNumber(q);
      g.get(this)._SetMagnitude(q);
    }
    get magnitude() {
      return g.get(this)._GetMagnitude();
    }
    set phase(q) {
      g.get(this)._SetPhase(q);
    }
    get phase() {
      return g.get(this)._GetPhase();
    }
    set movement(q) {
      b.RequireString(q);
      q = k.indexOf(q);
      if (-1 === q) throw Error("invalid movement");
      g.get(this)._SetMovement(q);
    }
    get movement() {
      return k[g.get(this)._GetMovement()];
    }
    set wave(q) {
      b.RequireString(q);
      q = m.indexOf(q);
      if (-1 === q) throw Error("invalid wave");
      g.get(this)._SetWave(q);
    }
    get wave() {
      return m[g.get(this)._GetWave()];
    }
    get value() {
      const q = g.get(this);
      return q.WaveFunc(q._GetPhase()) * q._GetMagnitude();
    }
    updateInitialState() {
      g.get(this).Init();
    }
    set isEnabled(q) {
      g.get(this)._SetEnabled(!!q);
    }
    get isEnabled() {
      return g.get(this)._IsEnabled();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Sin.Cnds = {
    IsEnabled() {
      return this._IsEnabled();
    },
    CompareMovement(b) {
      return this._GetMovement() === b;
    },
    ComparePeriod(b, a) {
      return e.compare(this._GetPeriod(), b, a);
    },
    CompareMagnitude(b, a) {
      return e.compare(this._GetMagnitude_ConvertAngle(), b, a);
    },
    CompareWave(b) {
      return this._GetWave() === b;
    },
  };
}
self.C3.Behaviors.Sin.Acts = {
  SetEnabled(e) {
    this._SetEnabled(0 !== e);
  },
  SetPeriod(e) {
    this._SetPeriod(e);
  },
  SetMagnitude(e) {
    this._SetMagnitude_ConvertAngle(e);
  },
  SetMovement(e) {
    this._SetMovement(e);
  },
  SetWave(e) {
    this._wave = e;
  },
  SetPhase(e) {
    const b = 2 * Math.PI;
    this._SetPhase((e * b) % b);
  },
  UpdateInitialState() {
    this.Init();
  },
};
self.C3.Behaviors.Sin.Exps = {
  CyclePosition() {
    return this._GetPhase() / (2 * Math.PI);
  },
  Period() {
    return this._GetPeriod();
  },
  Magnitude() {
    return this._GetMagnitude_ConvertAngle();
  },
  Value() {
    return this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle();
  },
};
("use strict");
{
  const e = self.C3;
  e.Behaviors.Orbit = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Orbit.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3;
  e.Behaviors.Orbit.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b);
      this._acceleration = this._speed = 0;
      this._isEnabled = !0;
      this._offsetAngle = this._majorAxis = this._minorAxis = 0;
      this._matchRotation = !1;
      this._targetY = this._targetX = 0;
      this._targetObject = null;
      this._targetUid = -1;
      this._totalAbsoluteRotation = this._totalRotation = this._rotation = 0;
      a &&
        ((this._speed = e.toRadians(a[0])),
        (this._acceleration = e.toRadians(a[1])),
        (this._isEnabled = a[6]),
        (this._minorAxis = a[2]),
        (this._majorAxis = a[3]),
        (this._offsetAngle = e.toRadians(a[4])),
        (this._matchRotation = a[5]));
      b = this._runtime.Dispatcher();
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(b, "instancedestroy", (c) =>
          this._OnInstanceDestroyed(c.instance)
        ),
        e.Disposable.From(b, "afterload", (c) => this._OnAfterLoad())
      );
      this._SetEnabled(this._isEnabled);
      b = this._inst.GetWorldInfo();
      this._targetX = b.GetX();
      this._targetY = b.GetY();
      this._rotation = b.GetAngle();
    }
    Release() {
      this._targetObject = null;
      super.Release();
    }
    SaveToJson() {
      return {
        s: this._speed,
        a: this._acceleration,
        r: this._rotation,
        e: this._isEnabled,
        a1: this._majorAxis,
        a2: this._minorAxis,
        oa: this._offsetAngle,
        mr: this._matchRotation,
        tx: this._targetX,
        ty: this._targetY,
        tuid: this._targetObject ? this._targetObject.GetUID() : -1,
      };
    }
    LoadFromJson(b) {
      this._speed = b.s;
      this._acceleration = b.a;
      this._rotation = b.r;
      this._majorAxis = b.a1;
      this._minorAxis = b.a2;
      this._offsetAngle = b.oa;
      this._matchRotation = b.mr;
      this._targetX = b.tx;
      this._targetY = b.ty;
      this._targetUid = b.tuid;
      this._SetEnabled(b.e);
    }
    _OnAfterLoad() {
      -1 === this._targetUid
        ? (this._targetObject = null)
        : ((this._targetObject = this._runtime.GetInstanceByUID(
            this._targetUid
          )),
          (this._targetUid = -1));
    }
    _OnInstanceDestroyed(b) {
      this._targetObject === b && (this._targetObject = null);
    }
    _Initialise() {
      if (this._shouldInitialise) {
        var b = this._inst.GetWorldInfo();
        this._targetX = b.GetX();
        this._targetY = b.GetY();
        this._rotation = b.GetAngle();
        this._shouldInitialise = !1;
      }
    }
    _UpdateTarget() {
      if (this._targetObject) {
        var b = this._targetObject.GetWorldInfo();
        this._targetX = b.GetX();
        this._targetY = b.GetY();
      }
    }
    _ShouldTickLate() {
      return !!this._targetObject;
    }
    Tick() {
      this._TickInternal();
    }
    Tick2() {
      this._TickInternal();
    }
    _TickInternal() {
      if (this._isEnabled) {
        var b = this._runtime.GetDt(this._inst);
        if (0 !== b) {
          0 !== this._acceleration && (this._speed += this._acceleration * b);
          var a = this._inst.GetWorldInfo();
          b *= this._speed;
          this._rotation = e.clampAngle(this._rotation + b);
          this._totalRotation += b;
          this._totalAbsoluteRotation += Math.abs(b);
          b = this._minorAxis * Math.cos(this._rotation);
          var c = this._majorAxis * Math.sin(this._rotation),
            d = Math.cos(this._offsetAngle),
            f = Math.sin(this._offsetAngle);
          this._UpdateTarget();
          a.SetXY(
            this._targetX + (b * d - c * f),
            this._targetY + (b * f + c * d)
          );
          this._matchRotation &&
            a.SetAngle(this._rotation + this._offsetAngle + 0.5 * Math.PI);
          a.SetBboxChanged();
        }
      }
    }
    GetPropertyValueByIndex(b) {
      switch (b) {
        case 0:
          return e.toDegrees(this._speed);
        case 1:
          return e.toDegrees(this._acceleration);
        case 6:
          return this._isEnabled;
        case 2:
          return this._minorAxis;
        case 3:
          return this._majorAxis;
        case 4:
          return this._offsetAngle;
        case 5:
          return this._matchRotation;
      }
    }
    SetPropertyValueByIndex(b, a) {
      switch (b) {
        case 0:
          this._speed = e.toRadians(a);
          break;
        case 1:
          this._acceleration = e.toRadians(a);
          break;
        case 6:
          this._SetEnabled(a);
          break;
        case 2:
          this._minorAxis = a;
          break;
        case 3:
          this._majorAxis = a;
          break;
        case 4:
          this._offsetAngle = a;
          break;
        case 5:
          this._matchRotation = a;
      }
    }
    _SetEnabled(b) {
      this._isEnabled = !!b;
      this._ShouldTickLate()
        ? this._isEnabled
          ? this._StartTicking2()
          : this._StopTicking2()
        : this._isEnabled
        ? this._StartTicking()
        : this._StopTicking();
    }
    GetDebuggerProperties() {
      return [
        {
          title: "$" + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: "behaviors.orbit.debugger.rotation",
              value: e.toDegrees(this._rotation),
            },
            {
              name: "behaviors.orbit.debugger.total-rotation",
              value: e.toDegrees(this._totalRotation),
            },
            {
              name: "behaviors.orbit.debugger.total-absolute-rotation",
              value: e.toDegrees(this._totalAbsoluteRotation),
            },
            {
              name: "behaviors.orbit.properties.speed.name",
              value: e.toDegrees(this._speed),
              onedit: (b) => (this._speed = e.toRadians(b)),
            },
            {
              name: "behaviors.orbit.properties.acceleration.name",
              value: e.toDegrees(this._acceleration),
              onedit: (b) => (this._acceleration = e.toRadians(b)),
            },
            {
              name: "behaviors.orbit.properties.primary-axis.name",
              value: this._majorAxis,
              onedit: (b) => (this._majorAxis = b),
            },
            {
              name: "behaviors.orbit.properties.secondary-axis.name",
              value: this._minorAxis,
              onedit: (b) => (this._minorAxis = b),
            },
            {
              name: "behaviors.orbit.properties.offset-angle.name",
              value: e.toDegrees(this._offsetAngle),
              onedit: (b) => (this._offsetAngle = e.toRadians(b)),
            },
            {
              name: "behaviors.orbit.properties.match-rotation.name",
              value: this._matchRotation,
              onedit: (b) => (this._matchRotation = !!b),
            },
            {
              name: "behaviors.orbit.properties.enabled.name",
              value: this._isEnabled,
              onedit: (b) => this._SetEnabled(b),
            },
          ],
        },
      ];
    }
  };
}
self.C3.Behaviors.Orbit.Cnds = {
  IsEnabled() {
    return this._isEnabled;
  },
};
{
  const e = self.C3;
  e.Behaviors.Orbit.Acts = {
    SetSpeed(b) {
      this._speed = e.toRadians(b);
    },
    SetTarget(b, a) {
      this._targetObject = null;
      this._targetX = b;
      this._targetY = a;
    },
    SetRotation(b) {
      this._rotation = e.toRadians(b);
    },
    SetOffsetAngle(b) {
      this._offsetAngle = e.toRadians(b);
    },
    SetRadius(b, a) {
      this._minorAxis = b;
      this._majorAxis = a;
    },
    SetMatchRotation(b) {
      this._matchRotation = !!b;
    },
    Pin(b) {
      if (b && (b = b.GetFirstPicked(this._inst)) && b.GetWorldInfo()) {
        var a = this._isEnabled;
        a && this._SetEnabled(!1);
        this._targetObject = b;
        a && this._SetEnabled(!0);
      }
    },
    Unpin() {
      const b = this._isEnabled;
      b && this._SetEnabled(!1);
      this._targetObject = null;
      b && this._SetEnabled(!0);
    },
    SetAcceleration(b) {
      this._acceleration = e.toRadians(b);
    },
    SetEnabled(b) {
      this._SetEnabled(b);
    },
    ResetTotalRotation() {
      this._totalAbsoluteRotation = this._totalRotation = 0;
    },
  };
}
{
  const e = self.C3;
  e.Behaviors.Orbit.Exps = {
    Speed() {
      return e.toDegrees(this._speed);
    },
    Acceleration() {
      return e.toDegrees(this._acceleration);
    },
    PrimaryRadius() {
      return this._majorAxis;
    },
    SecondaryRadius() {
      return this._minorAxis;
    },
    OffsetAngle() {
      return e.toDegrees(this._offsetAngle);
    },
    Rotation() {
      return e.toDegrees(this._rotation);
    },
    TotalRotation() {
      return e.toDegrees(this._totalRotation);
    },
    TotalAbsoluteRotation() {
      return e.toDegrees(this._totalAbsoluteRotation);
    },
    TargetX() {
      return this._targetX;
    },
    TargetY() {
      return this._targetY;
    },
    DistanceToTarget() {
      return Math.sqrt(
        (this._minorAxis * Math.cos(this._rotation)) ** 2 +
          (this._majorAxis * Math.sin(this._rotation)) ** 2
      );
    },
  };
}
("use strict");
{
  const e = self.C3;
  e.Behaviors.Timer = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Timer.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3;
  e.Behaviors.Timer.SingleTimer = class {
    constructor(b, a, c, d) {
      this._current = e.New(e.KahanSum);
      this._current.Set(b || 0);
      this._total = e.New(e.KahanSum);
      this._total.Set(a || 0);
      this._duration = c || 0;
      this._isRegular = !!d;
      this._isPaused = !1;
    }
    GetCurrentTime() {
      return this._current.Get();
    }
    GetTotalTime() {
      return this._total.Get();
    }
    GetDuration() {
      return this._duration;
    }
    SetPaused(b) {
      this._isPaused = !!b;
    }
    IsPaused() {
      return this._isPaused;
    }
    Add(b) {
      this._current.Add(b);
      this._total.Add(b);
    }
    HasFinished() {
      return this._current.Get() >= this._duration;
    }
    Update() {
      if (this.HasFinished())
        if (this._isRegular) this._current.Subtract(this._duration);
        else return !0;
      return !1;
    }
    SaveToJson() {
      return {
        c: this._current.Get(),
        t: this._total.Get(),
        d: this._duration,
        r: this._isRegular,
        p: this._isPaused,
      };
    }
    LoadFromJson(b) {
      this._current.Set(b.c);
      this._total.Set(b.t);
      this._duration = b.d;
      this._isRegular = !!b.r;
      this._isPaused = !!b.p;
    }
  };
  e.Behaviors.Timer.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b);
      this._timers = new Map();
    }
    Release() {
      this._timers.clear();
      super.Release();
    }
    _UpdateTickState() {
      0 < this._timers.size
        ? (this._StartTicking(), this._StartTicking2())
        : (this._StopTicking(), this._StopTicking2());
    }
    SaveToJson() {
      const b = {};
      for (const [a, c] of this._timers.entries()) b[a] = c.SaveToJson();
      return b;
    }
    LoadFromJson(b) {
      this._timers.clear();
      for (const [a, c] of Object.entries(b))
        (b = new e.Behaviors.Timer.SingleTimer()),
          b.LoadFromJson(c),
          this._timers.set(a, b);
      this._UpdateTickState();
    }
    Tick() {
      const b = this._runtime.GetDt(this._inst);
      for (const a of this._timers.values()) a.IsPaused() || a.Add(b);
    }
    Tick2() {
      for (const [b, a] of this._timers.entries())
        a.Update() && this._timers.delete(b);
    }
    GetDebuggerProperties() {
      return [
        {
          title: "behaviors.timer.debugger.timers",
          properties: [...this._timers.entries()].map((b) => ({
            name: "$" + b[0],
            value: `${Math.round(10 * b[1].GetCurrentTime()) / 10} / ${
              Math.round(10 * b[1].GetDuration()) / 10
            }`,
          })),
        },
      ];
    }
  };
}
self.C3.Behaviors.Timer.Cnds = {
  OnTimer(e) {
    return (e = this._timers.get(e.toLowerCase())) ? e.HasFinished() : !1;
  },
  IsTimerRunning(e) {
    return this._timers.has(e.toLowerCase());
  },
  IsTimerPaused(e) {
    return (e = this._timers.get(e.toLowerCase())) && e.IsPaused();
  },
};
{
  const e = self.C3;
  e.Behaviors.Timer.Acts = {
    StartTimer(b, a, c) {
      b = new e.Behaviors.Timer.SingleTimer(0, 0, b, 1 === a);
      this._timers.set(c.toLowerCase(), b);
      this._UpdateTickState();
    },
    StopTimer(b) {
      this._timers.delete(b.toLowerCase());
      this._UpdateTickState();
    },
    PauseResumeTimer(b, a) {
      (b = this._timers.get(b.toLowerCase())) && b.SetPaused(0 === a);
    },
  };
}
self.C3.Behaviors.Timer.Exps = {
  CurrentTime(e) {
    return (e = this._timers.get(e.toLowerCase())) ? e.GetCurrentTime() : 0;
  },
  TotalTime(e) {
    return (e = this._timers.get(e.toLowerCase())) ? e.GetTotalTime() : 0;
  },
  Duration(e) {
    return (e = this._timers.get(e.toLowerCase())) ? e.GetDuration() : 0;
  },
};
("use strict");
{
  const e = self.C3;
  e.Behaviors.Rotate = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Rotate.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3;
  e.Behaviors.Rotate.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b);
      this._acceleration = this._speed = 0;
      this._isEnabled = !0;
      a &&
        ((this._speed = e.toRadians(a[0])),
        (this._acceleration = e.toRadians(a[1])),
        (this._isEnabled = a[2]));
      this._isEnabled && this._StartTicking();
    }
    Release() {
      super.Release();
    }
    SaveToJson() {
      return { s: this._speed, a: this._acceleration, e: this._isEnabled };
    }
    LoadFromJson(b) {
      this._speed = b.s;
      this._acceleration = b.a;
      this._SetEnabled(b.e);
    }
    Tick() {
      if (this._isEnabled) {
        var b = this._runtime.GetDt(this._inst);
        if (
          0 !== b &&
          (0 !== this._acceleration && (this._speed += this._acceleration * b),
          0 !== this._speed)
        ) {
          const a = this._inst.GetWorldInfo();
          a.SetAngle(a.GetAngle() + this._speed * b);
          a.SetBboxChanged();
        }
      }
    }
    GetPropertyValueByIndex(b) {
      switch (b) {
        case 0:
          return e.toDegrees(this._speed);
        case 1:
          return e.toDegrees(this._acceleration);
        case 2:
          return this._isEnabled;
      }
    }
    SetPropertyValueByIndex(b, a) {
      switch (b) {
        case 0:
          this._speed = e.toRadians(a);
          break;
        case 1:
          this._acceleration = e.toRadians(a);
          break;
        case 2:
          this._SetEnabled(a);
      }
    }
    _SetEnabled(b) {
      (this._isEnabled = !!b) ? this._StartTicking() : this._StopTicking();
    }
    GetDebuggerProperties() {
      return [
        {
          title: "$" + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: "behaviors.rotate.properties.speed.name",
              value: e.toDegrees(this._speed),
              onedit: (b) => (this._speed = e.toRadians(b)),
            },
            {
              name: "behaviors.rotate.properties.acceleration.name",
              value: e.toDegrees(this._acceleration),
              onedit: (b) => (this._acceleration = e.toRadians(b)),
            },
            {
              name: "behaviors.rotate.properties.enabled.name",
              value: this._isEnabled,
              onedit: (b) => this._SetEnabled(b),
            },
          ],
        },
      ];
    }
  };
}
self.C3.Behaviors.Rotate.Cnds = {
  IsEnabled() {
    return this._isEnabled;
  },
};
{
  const e = self.C3;
  e.Behaviors.Rotate.Acts = {
    SetSpeed(b) {
      this._speed = e.toRadians(b);
    },
    SetAcceleration(b) {
      this._acceleration = e.toRadians(b);
    },
    SetEnabled(b) {
      this._SetEnabled(b);
    },
  };
}
{
  const e = self.C3;
  e.Behaviors.Rotate.Exps = {
    Speed() {
      return e.toDegrees(this._speed);
    },
    Acceleration() {
      return e.toDegrees(this._acceleration);
    },
  };
}
("use strict");
{
  const e = self.C3;
  e.Behaviors.Pin = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Pin.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3;
  e.Behaviors.Pin.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b);
      this._pinInst = null;
      this._pinUid = -1;
      this._mode = "";
      this._propSet = new Set();
      this._lastKnownAngle =
        this._dz =
        this._dAngle =
        this._dHeight =
        this._dWidth =
        this._dy =
        this._dx =
        this._pinImagePoint =
        this._pinAngle =
        this._pinDist =
          0;
      this._destroy = !1;
      a && (this._destroy = a[0]);
      b = this._runtime.Dispatcher();
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(b, "instancedestroy", (c) =>
          this._OnInstanceDestroyed(c.instance)
        ),
        e.Disposable.From(b, "afterload", (c) => this._OnAfterLoad())
      );
    }
    Release() {
      this._pinInst = null;
      super.Release();
    }
    _SetPinInst(b) {
      b
        ? ((this._pinInst = b), this._StartTicking2())
        : ((this._pinInst = null), this._StopTicking2());
    }
    _Pin(b, a, c) {
      if (b && (b = b.GetFirstPicked(this._inst)))
        if (
          ((this._mode = a),
          this._SetPinInst(b),
          (a = this._inst.GetWorldInfo()),
          (b = b.GetWorldInfo()),
          "properties" === this._mode)
        ) {
          const d = this._propSet;
          d.clear();
          for (const f of c) d.add(f);
          this._dx = a.GetX() - b.GetX();
          this._dy = a.GetY() - b.GetY();
          this._dAngle = a.GetAngle() - b.GetAngle();
          this._lastKnownAngle = a.GetAngle();
          this._dz = a.GetZElevation() - b.GetZElevation();
          d.has("x") &&
            d.has("y") &&
            ((this._pinAngle =
              e.angleTo(b.GetX(), b.GetY(), a.GetX(), a.GetY()) - b.GetAngle()),
            (this._pinDist = e.distanceTo(
              b.GetX(),
              b.GetY(),
              a.GetX(),
              a.GetY()
            )));
          d.has("width-abs")
            ? (this._dWidth = a.GetWidth() - b.GetWidth())
            : d.has("width-scale") &&
              (this._dWidth = a.GetWidth() / b.GetWidth());
          d.has("height-abs")
            ? (this._dHeight = a.GetHeight() - b.GetHeight())
            : d.has("height-scale") &&
              (this._dHeight = a.GetHeight() / b.GetHeight());
        } else
          this._pinDist = e.distanceTo(b.GetX(), b.GetY(), a.GetX(), a.GetY());
    }
    SaveToJson() {
      const b = this._propSet,
        a = this._mode,
        c = {
          uid: this._pinInst ? this._pinInst.GetUID() : -1,
          m: a,
          d: this._destroy,
        };
      if ("rope" === a || "bar" === a) c.pd = this._pinDist;
      else if ("properties" === a) {
        c.ps = [...this._propSet];
        b.has("imagepoint")
          ? (c.ip = this._pinImagePoint)
          : b.has("x") && b.has("y")
          ? ((c.pa = this._pinAngle), (c.pd = this._pinDist))
          : (b.has("x") && (c.dx = this._dx), b.has("y") && (c.dy = this._dy));
        b.has("angle") &&
          ((c.da = this._dAngle), (c.lka = this._lastKnownAngle));
        if (b.has("width-abs") || b.has("width-scale")) c.dw = this._dWidth;
        if (b.has("height-abs") || b.has("height-scale")) c.dh = this._dHeight;
        b.has("z") && (c.dz = this._dz);
      }
      return c;
    }
    LoadFromJson(b) {
      const a = b.m,
        c = this._propSet;
      c.clear();
      this._pinUid = b.uid;
      if ("number" === typeof a) this._LoadFromJson_Legacy(b);
      else if (
        ((this._mode = a),
        b.hasOwnProperty("d") && (this._destroy = !!b.d),
        "rope" === a || "bar" === a)
      )
        this._pinDist = b.pd;
      else if ("properties" === a) {
        for (const d of b.ps) c.add(d);
        c.has("imagepoint")
          ? (this._pinImagePoint = b.ip)
          : c.has("x") && c.has("y")
          ? ((this._pinAngle = b.pa), (this._pinDist = b.pd))
          : (c.has("x") && (this._dx = b.dx), c.has("y") && (this._dy = b.dy));
        c.has("angle") &&
          ((this._dAngle = b.da), (this._lastKnownAngle = b.lka || 0));
        if (c.has("width-abs") || c.has("width-scale")) this._dWidth = b.dw;
        if (c.has("height-abs") || c.has("height-scale")) this._dHeight = b.dh;
        c.has("z") && (this._dz = b.dz);
      }
    }
    _LoadFromJson_Legacy(b) {
      const a = this._propSet,
        c = b.msa,
        d = b.tsa,
        f = b.pa,
        h = b.pd;
      switch (b.m) {
        case 0:
          this._mode = "properties";
          a.add("x").add("y").add("angle");
          this._pinAngle = f;
          this._pinDist = h;
          this._dAngle = c - d;
          this._lastKnownAngle = b.lka;
          break;
        case 1:
          this._mode = "properties";
          a.add("x").add("y");
          this._pinAngle = f;
          this._pinDist = h;
          break;
        case 2:
          this._mode = "properties";
          a.add("angle");
          this._dAngle = c - d;
          this._lastKnownAngle = b.lka;
          break;
        case 3:
          this._mode = "rope";
          this._pinDist = b.pd;
          break;
        case 4:
          (this._mode = "bar"), (this._pinDist = b.pd);
      }
    }
    _OnAfterLoad() {
      -1 === this._pinUid
        ? this._SetPinInst(null)
        : (this._SetPinInst(this._runtime.GetInstanceByUID(this._pinUid)),
          (this._pinUid = -1));
    }
    _OnInstanceDestroyed(b) {
      this._pinInst === b &&
        (this._SetPinInst(null),
        this._destroy && this._runtime.DestroyInstance(this._inst));
    }
    Tick2() {
      var b = this._pinInst;
      if (b) {
        var a = b.GetWorldInfo(),
          c = this._inst.GetWorldInfo(),
          d = this._mode,
          f = !1;
        if ("rope" === d || "bar" === d) {
          if (
            ((b = e.distanceTo(c.GetX(), c.GetY(), a.GetX(), a.GetY())),
            b > this._pinDist || ("bar" === d && b < this._pinDist))
          )
            (f = e.angleTo(a.GetX(), a.GetY(), c.GetX(), c.GetY())),
              c.SetXY(
                a.GetX() + Math.cos(f) * this._pinDist,
                a.GetY() + Math.sin(f) * this._pinDist
              ),
              (f = !0);
        } else {
          d = this._propSet;
          if (d.has("imagepoint")) {
            const [h, g] = b.GetImagePoint(this._pinImagePoint);
            c.EqualsXY(h, g) || (c.SetXY(h, g), (f = !0));
          } else if (d.has("x") && d.has("y")) {
            b =
              a.GetX() +
              Math.cos(a.GetAngle() + this._pinAngle) * this._pinDist;
            const h =
              a.GetY() +
              Math.sin(a.GetAngle() + this._pinAngle) * this._pinDist;
            c.EqualsXY(b, h) || (c.SetXY(b, h), (f = !0));
          } else
            (b = a.GetX() + this._dx),
              d.has("x") && b !== c.GetX() && (c.SetX(b), (f = !0)),
              (b = a.GetY() + this._dy),
              d.has("y") && b !== c.GetY() && (c.SetY(b), (f = !0));
          d.has("angle") &&
            (this._lastKnownAngle !== c.GetAngle() &&
              (this._dAngle = e.clampAngle(
                this._dAngle + (c.GetAngle() - this._lastKnownAngle)
              )),
            (b = e.clampAngle(a.GetAngle() + this._dAngle)),
            b !== c.GetAngle() && (c.SetAngle(b), (f = !0)),
            (this._lastKnownAngle = c.GetAngle()));
          d.has("width-abs") &&
            ((b = a.GetWidth() + this._dWidth),
            b !== c.GetWidth() && (c.SetWidth(b), (f = !0)));
          d.has("width-scale") &&
            ((b = a.GetWidth() * this._dWidth),
            b !== c.GetWidth() && (c.SetWidth(b), (f = !0)));
          d.has("height-abs") &&
            ((b = a.GetHeight() + this._dHeight),
            b !== c.GetHeight() && (c.SetHeight(b), (f = !0)));
          d.has("height-scale") &&
            ((b = a.GetHeight() * this._dHeight),
            b !== c.GetHeight() && (c.SetHeight(b), (f = !0)));
          d.has("z") &&
            ((b = a.GetZElevation() + this._dz),
            b !== c.GetZElevation() &&
              (c.SetZElevation(b), this._runtime.UpdateRender()));
        }
        f && c.SetBboxChanged();
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: "$" + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: "behaviors.pin.debugger.is-pinned",
              value: !!this._pinInst,
            },
            {
              name: "behaviors.pin.debugger.pinned-uid",
              value: this._pinInst ? this._pinInst.GetUID() : 0,
            },
          ],
        },
      ];
    }
  };
}
self.C3.Behaviors.Pin.Cnds = {
  IsPinned() {
    return !!this._pinInst;
  },
  WillDestroy() {
    return this._destroy;
  },
};
self.C3.Behaviors.Pin.Acts = {
  PinByDistance(e, b) {
    this._Pin(e, 0 === b ? "rope" : "bar");
  },
  PinByProperties(e, b, a, c, d, f, h) {
    const g = [];
    b && g.push("x");
    a && g.push("y");
    c && g.push("angle");
    h && g.push("z");
    1 === d ? g.push("width-abs") : 2 === d && g.push("width-scale");
    1 === f ? g.push("height-abs") : 2 === f && g.push("height-scale");
    0 !== g.length && this._Pin(e, "properties", g);
  },
  PinByImagePoint(e, b, a, c, d, f) {
    const h = ["imagepoint"];
    a && h.push("angle");
    f && h.push("z");
    1 === c ? h.push("width-abs") : 2 === c && h.push("width-scale");
    1 === d ? h.push("height-abs") : 2 === d && h.push("height-scale");
    this._pinImagePoint = b;
    this._Pin(e, "properties", h);
  },
  SetPinDistance(e) {
    if ("rope" === this._mode || "bar" === this._mode)
      this._pinDist = Math.max(e, 0);
  },
  SetDestroy(e) {
    this._destroy = e;
  },
  Unpin() {
    this._SetPinInst(null);
    this._mode = "";
    this._propSet.clear();
    this._pinImagePoint = "";
  },
  Pin(e, b) {
    switch (b) {
      case 0:
        this._Pin(e, "properties", ["x", "y", "angle"]);
        break;
      case 1:
        this._Pin(e, "properties", ["x", "y"]);
        break;
      case 2:
        this._Pin(e, "properties", ["angle"]);
        break;
      case 3:
        this._Pin(e, "rope");
        break;
      case 4:
        this._Pin(e, "bar");
    }
  },
};
self.C3.Behaviors.Pin.Exps = {
  PinnedUID() {
    return this._pinInst ? this._pinInst.GetUID() : -1;
  },
};
("use strict");
{
  const e = self.C3;
  e.Behaviors.Platform = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Platform.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3,
    b = self.C3X,
    a = self.IBehaviorInstance;
  function c(h, g, k, m, q) {
    return e.clamp(h * q + 0.5 * m * q * q, g * q, k * q);
  }
  e.Behaviors.Platform.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(h, g) {
      super(h);
      this._keyboardDisposables = null;
      this._simJump =
        this._simRight =
        this._simLeft =
        this._ignoreInput =
        this._canDoubleJump =
        this._doubleJumped =
        this._jumped =
        this._jumpKey =
        this._rightKey =
        this._leftKey =
          !1;
      this._lastFloorObject = null;
      this._loadFloorUid = -1;
      this._lastFloorY = this._lastFloorX = 0;
      this._wasOnFloor = this._floorIsJumpthru = !1;
      this._wasOverJumpthru = !!this._runtime
        .GetCollisionEngine()
        .TestOverlapJumpthru(this._inst);
      this._loadJumpthruUid = -1;
      this._animMode = "stopped";
      this._fallThrough = 0;
      this._isFirstTick = !0;
      this._rightY =
        this._rightX =
        this._downY =
        this._downX =
        this._dy =
        this._dx =
          0;
      this._g1 = this._g = 1500;
      this._ga = e.toRadians(90);
      this._maxSpeed = 330;
      this._dec = this._acc = 1500;
      this._jumpStrength = 650;
      this._maxFall = 1e3;
      this._enableDoubleJump = !1;
      this._sustainTime = this._jumpSustain = 0;
      this._defaultControls = !0;
      this._ceilingCollisionMode = 0;
      this._isEnabled = !0;
      g &&
        ((this._maxSpeed = g[0]),
        (this._acc = g[1]),
        (this._dec = g[2]),
        (this._jumpStrength = g[3]),
        (this._g = g[4]),
        (this._maxFall = g[5]),
        (this._enableDoubleJump = !!g[6]),
        (this._jumpSustain = g[7] / 1e3),
        (this._defaultControls = !!g[8]),
        (this._isEnabled = !!g[9]));
      h = this._runtime.Dispatcher();
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(h, "instancedestroy", (k) =>
          this._OnInstanceDestroyed(k.instance)
        ),
        e.Disposable.From(h, "afterload", (k) => this._OnAfterLoad())
      );
      this._defaultControls && this._BindEvents();
      this._isEnabled && this._StartPostTicking();
      this._UpdateGravity();
      this._inst.GetUnsavedDataMap().set("isPlatformBehavior", !0);
    }
    Release() {
      this._keyboardDisposables &&
        (this._keyboardDisposables.Release(),
        (this._keyboardDisposables = null));
      this._wasOverJumpthru = this._lastFloorObject = null;
      super.Release();
    }
    _BindEvents() {
      if (!this._keyboardDisposables) {
        var h = this._runtime.Dispatcher();
        this._keyboardDisposables = new e.CompositeDisposable(
          e.Disposable.From(h, "keydown", (g) => this._OnKeyDown(g.data)),
          e.Disposable.From(h, "keyup", (g) => this._OnKeyUp(g.data)),
          e.Disposable.From(h, "window-blur", () =>
            this._OnWindowOrKeyboardBlur()
          ),
          e.Disposable.From(h, "keyboard-blur", () =>
            this._OnWindowOrKeyboardBlur()
          )
        );
      }
    }
    _UnBindEvents() {
      this._keyboardDisposables &&
        (this._keyboardDisposables.Release(),
        (this._keyboardDisposables = null));
    }
    _OnInstanceDestroyed(h) {
      this._lastFloorObject === h && (this._lastFloorObject = null);
      this._wasOverJumpthru === h && (this._wasOverJumpthru = null);
    }
    _OnKeyDown(h) {
      switch (h.key) {
        case "ArrowLeft":
          this._leftKey = !0;
          break;
        case "ArrowRight":
          this._rightKey = !0;
          break;
        case "ArrowUp":
          this._jumpKey = !0;
      }
    }
    _OnKeyUp(h) {
      switch (h.key) {
        case "ArrowLeft":
          this._leftKey = !1;
          break;
        case "ArrowRight":
          this._rightKey = !1;
          break;
        case "ArrowUp":
          this._jumped = this._jumpKey = !1;
      }
    }
    _OnWindowOrKeyboardBlur() {
      this._jumped = this._jumpKey = this._rightKey = this._leftKey = !1;
    }
    SaveToJson() {
      return {
        ii: this._ignoreInput,
        lfx: this._lastFloorX,
        lfy: this._lastFloorY,
        lfo: this._lastFloorObject ? this._lastFloorObject.GetUID() : -1,
        am: this._animMode,
        en: this._isEnabled,
        fall: this._fallThrough,
        ft: this._isFirstTick,
        dx: this._dx,
        dy: this._dy,
        ms: this._maxSpeed,
        acc: this._acc,
        dec: this._dec,
        js: this._jumpStrength,
        g: this._g,
        g1: this._g1,
        mf: this._maxFall,
        wof: this._wasOnFloor,
        woj: this._wasOverJumpthru ? this._wasOverJumpthru.GetUID() : -1,
        ga: this._ga,
        edj: this._enableDoubleJump,
        cdj: this._canDoubleJump,
        dj: this._doubleJumped,
        sus: this._jumpSustain,
        dc: this._defaultControls,
        cc: this._ceilingCollisionMode,
      };
    }
    LoadFromJson(h) {
      this._ignoreInput = h.ii;
      this._lastFloorX = h.lfx;
      this._lastFloorY = h.lfy;
      this._loadFloorUid = h.lfo;
      this._animMode = h.am;
      const g = h.en;
      this._fallThrough = h.fall;
      this._isFirstTick = h.ft;
      this._dx = h.dx;
      this._dy = h.dy;
      this._maxSpeed = h.ms;
      this._acc = h.acc;
      this._dec = h.dec;
      this._jumpStrength = h.js;
      this._g = h.g;
      this._g1 = h.g1;
      this._maxFall = h.mf;
      this._wasOnFloor = h.wof;
      this._loadJumpthruUid = h.woj;
      this._ga = h.ga;
      this._enableDoubleJump = h.edj;
      this._canDoubleJump = h.cdj;
      this._doubleJumped = h.dj;
      this._jumpSustain = h.sus;
      this._defaultControls = h.dc;
      this._ceilingCollisionMode = h.cc || 0;
      this._simJump =
        this._simRight =
        this._simLeft =
        this._jumped =
        this._jumpKey =
        this._rightKey =
        this._leftKey =
          !1;
      this._sustainTime = 0;
      this._defaultControls ? this._BindEvents() : this._UnBindEvents();
      this._SetEnabled(g);
      this._UpdateGravity();
    }
    _OnAfterLoad() {
      this._lastFloorObject =
        -1 === this._loadFloorUid
          ? null
          : this._runtime.GetInstanceByUID(this._loadFloorUid);
      this._wasOverJumpthru =
        -1 === this._loadJumpthruUid
          ? null
          : this._runtime.GetInstanceByUID(this._loadJumpthruUid);
    }
    _UpdateGravity() {
      this._downX = Math.cos(this._ga);
      this._downY = Math.sin(this._ga);
      this._rightX = Math.cos(this._ga - Math.PI / 2);
      this._rightY = Math.sin(this._ga - Math.PI / 2);
      this._downX = e.round6dp(this._downX);
      this._downY = e.round6dp(this._downY);
      this._rightX = e.round6dp(this._rightX);
      this._rightY = e.round6dp(this._rightY);
      this._g1 = this._g;
      0 > this._g &&
        ((this._downX *= -1),
        (this._downY *= -1),
        (this._g = Math.abs(this._g)));
    }
    _GetGDir() {
      return 0 > this._g ? -1 : 1;
    }
    _IsOnFloor() {
      var h = this._inst.GetWorldInfo();
      const g = this._runtime.GetCollisionEngine(),
        k = this._inst;
      var m = this._lastFloorObject;
      const q = h.GetX(),
        v = h.GetY();
      h.OffsetXY(this._downX, this._downY);
      h.SetBboxChanged();
      if (
        !m ||
        !g.TestOverlap(k, m) ||
        (m.GetObjectClass().HasSolidBehavior() &&
          !g.IsSolidCollisionAllowed(m, k)) ||
        (m.GetObjectClass().HasJumpthruBehavior() && !m._IsJumpthruEnabled())
      ) {
        let r = g.TestOverlapSolid(k);
        m = null;
        r || 0 !== this._fallThrough || (m = g.TestOverlapJumpthru(k, !0));
        h.SetXY(q, v);
        h.SetBboxChanged();
        if (r) {
          if (g.TestOverlap(k, r)) return null;
          this._floorIsJumpthru = !1;
          return r;
        }
        if (m && m.length) {
          h = 0;
          for (let n = 0, p = m.length; n < p; ++n)
            (m[h] = m[n]), g.TestOverlap(k, m[n]) || ++h;
          if (1 <= h) return (this._floorIsJumpthru = !0), m[0];
        }
        return null;
      }
      h.SetXY(q, v);
      h.SetBboxChanged();
      return m;
    }
    PostTick() {
      if (this._isEnabled) {
        var h = this._runtime.GetDt(this._inst);
        this._jumpKey || this._simJump || (this._jumped = !1);
        var g = this._leftKey || this._simLeft,
          k = this._rightKey || this._simRight,
          m = this._jumpKey || this._simJump,
          q = m && !this._jumped;
        this._simJump = this._simRight = this._simLeft = !1;
        this._ignoreInput && (q = m = k = g = !1);
        m || (this._sustainTime = 0);
        this._HandleFirstTick();
        var [v, , r] = this._TrackMovingPlatform(),
          n = this._IsOnFloor(),
          p = n && !this._wasOnFloor,
          u;
        [u, n] = this._MaybePushOutSolid(n);
        if (!u) {
          this._TrackFloor(n, r, v, m);
          q = this._HandleJump(n, q, m);
          n || this._ApplyJumpGravity(q, m, h);
          this._wasOnFloor = !!n;
          g = this._ApplyHorizontalAcceleration(g, k, h);
          k = !1;
          m = 0;
          0 !== this._dx && (k = this._HandleHorizontalMovement(h, g, n, q));
          if (0 !== this._dy) {
            const [w, y] = this._HandleVerticalMovement(h, n);
            k = k || w;
            m = y;
          }
          !k && p && 0 > this._dy && 0 < m && ((this._dy = 0), (k = !0));
          this._HandleAnimationTriggers(n, k, q);
          0 < this._fallThrough && this._fallThrough--;
          this._wasOverJumpthru = this._runtime
            .GetCollisionEngine()
            .TestOverlapJumpthru(this._inst);
        }
      }
    }
    _HandleFirstTick() {
      if (this._isFirstTick) {
        var h = this._inst,
          g = this._runtime.GetCollisionEngine();
        (g.TestOverlapSolid(h) || g.TestOverlapJumpthru(h)) &&
          g.PushOutSolid(h, -this._downX, -this._downY, 4, !0);
        this._isFirstTick = !1;
      }
    }
    _TrackMovingPlatform() {
      var h = this._lastFloorObject,
        g = h ? h.GetWorldInfo() : null;
      let k = 0,
        m = 0;
      var q = !1;
      if (
        h &&
        0 === this._dy &&
        (g.GetY() !== this._lastFloorY || g.GetX() !== this._lastFloorX)
      ) {
        h = this._inst;
        q = h.GetWorldInfo();
        const v = this._runtime.GetCollisionEngine(),
          r = g.GetX();
        g = g.GetY();
        k = r - this._lastFloorX;
        m = g - this._lastFloorY;
        q.OffsetXY(k, m);
        q.SetBboxChanged();
        this._lastFloorX = r;
        this._lastFloorY = g;
        q = !0;
        if ((g = v.TestOverlapSolid(h)))
          v.RegisterCollision(h, g),
            v.PushOutSolid(h, -k, -m, 2.5 * Math.hypot(k, m));
      }
      return [k, m, q];
    }
    _MaybePushOutSolid(h) {
      let g = !1;
      var k = this._inst,
        m = k.GetWorldInfo();
      const q = this._runtime.GetCollisionEngine(),
        v = q.TestOverlapSolid(k);
      if (!v) return [!1, h];
      const r = Math.abs(m.GetWidth());
      m = Math.abs(m.GetHeight());
      k.GetSavedDataMap().get("inputPredicted")
        ? q.PushOutSolid(k, -this._downX, -this._downY, 10, !1)
        : q.PushOutSolid(k, -this._downX, -this._downY, m / 8)
        ? (q.RegisterCollision(k, v),
          (this._lastFloorObject = h = v),
          (k = v.GetWorldInfo()),
          (this._lastFloorX = k.GetX()),
          (this._lastFloorY = k.GetY()),
          (this._floorIsJumpthru = !1))
        : q.PushOutSolidAxis(k, this._rightX, this._rightY, r / 2) ||
          q.PushOutSolidAxis(k, this._downX, this._downY, m / 2) ||
          q.PushOutSolidNearest(k, Math.max(r, m) / 2)
        ? q.RegisterCollision(k, v)
        : (g = !0);
      return [g, h];
    }
    _TrackFloor(h, g, k, m) {
      const q = this._inst,
        v = this._runtime.GetCollisionEngine();
      if (h) {
        m = this._downX;
        const r = this._downY,
          n = this._rightX,
          p = this._rightY;
        this._canDoubleJump = this._doubleJumped = !1;
        0 < this._dy &&
          (this._wasOnFloor ||
            (v.PushInFractional(q, -m, -r, h, 16), (this._wasOnFloor = !0)),
          (this._dy = 0));
        this._lastFloorObject !== h
          ? ((this._lastFloorObject = h),
            (k = h.GetWorldInfo()),
            (this._lastFloorX = k.GetX()),
            (this._lastFloorY = k.GetY()),
            v.RegisterCollision(q, h))
          : g &&
            (h = v.TestOverlapSolid(q)) &&
            (v.RegisterCollision(q, h),
            0 !== k &&
              (0 < k ? v.PushOutSolid(q, -n, -p) : v.PushOutSolid(q, n, p)),
            v.PushOutSolid(q, -m, -r));
      } else m || (this._canDoubleJump = !0);
    }
    _HandleJump(h, g, k) {
      if (
        (h && g) ||
        (!h &&
          this._enableDoubleJump &&
          k &&
          this._canDoubleJump &&
          !this._doubleJumped)
      ) {
        g = this._inst;
        k = g.GetWorldInfo();
        const m = this._runtime.GetCollisionEngine(),
          q = k.GetX(),
          v = k.GetY();
        k.OffsetXY(-this._downX, -this._downY);
        k.SetBboxChanged();
        m.TestOverlapSolid(g)
          ? (g = !1)
          : ((this._sustainTime = this._jumpSustain),
            this.Trigger(e.Behaviors.Platform.Cnds.OnJump),
            (this._animMode = "jumping"),
            (this._dy = -this._jumpStrength),
            (g = !0),
            h ? (this._jumped = !0) : (this._doubleJumped = !0));
        k.SetXY(q, v);
        k.SetBboxChanged();
      }
      return g;
    }
    _ApplyJumpGravity(h, g, k) {
      g && 0 < this._sustainTime
        ? ((this._dy = -this._jumpStrength), (this._sustainTime -= k))
        : ((this._lastFloorObject = null),
          (this._dy += this._g * k),
          this._dy > this._maxFall && (this._dy = this._maxFall));
      h && (this._jumped = !0);
    }
    _ApplyHorizontalAcceleration(h, g, k) {
      const m = this._acc,
        q = this._dec;
      h === g &&
        (0 > this._dx
          ? ((this._dx += q * k), 0 < this._dx && (this._dx = 0))
          : 0 < this._dx &&
            ((this._dx -= q * k), 0 > this._dx && (this._dx = 0)));
      let v = 0;
      h && !g && (v = 0 < this._dx ? -(m + q) : -m);
      g && !h && (v = 0 > this._dx ? m + q : m);
      this._dx += v * k;
      this._dx = e.clamp(this._dx, -this._maxSpeed, this._maxSpeed);
      return v;
    }
    _HandleHorizontalMovement(h, g, k, m) {
      const q = this._inst;
      var v = q.GetWorldInfo();
      const r = this._runtime.GetCollisionEngine(),
        n = this._downX,
        p = this._downY,
        u = this._rightX,
        w = this._rightY;
      var y = this._maxSpeed;
      let B = !1;
      var E = v.GetX();
      let z = v.GetY();
      var D = c(this._dx, -y, y, g, h) * u;
      const J = c(this._dx, -y, y, g, h) * w;
      v.OffsetXY(
        u * (1 < this._dx ? 1 : -1) - n,
        w * (1 < this._dx ? 1 : -1) - p
      );
      v.SetBboxChanged();
      g = !1;
      y = r.TestOverlapSolid(q);
      v.SetXY(E + D, z + J);
      v.SetBboxChanged();
      let C = r.TestOverlapSolid(q);
      !C &&
        k &&
        (C = r.TestOverlapJumpthru(q)) &&
        (v.SetXY(E, z),
        v.SetBboxChanged(),
        r.TestOverlap(q, C) ? ((C = null), (g = !1)) : (g = !0),
        v.SetXY(E + D, z + J),
        v.SetBboxChanged());
      C
        ? ((D = Math.abs(this._dx * h) + 2),
          y || !r.PushOutSolid(q, -n, -p, D, g, C))
          ? (r.RegisterCollision(q, C),
            (D = Math.max(Math.abs(this._dx * h * 2.5), 30)),
            r.PushOutSolid(
              q,
              u * (0 > this._dx ? 1 : -1),
              w * (0 > this._dx ? 1 : -1),
              D,
              !1
            )
              ? !k ||
                g ||
                this._floorIsJumpthru ||
                ((E = v.GetX()),
                (z = v.GetY()),
                v.OffsetXY(n, p),
                r.TestOverlapSolid(q)
                  ? r.PushOutSolid(q, -n, -p, 3, !1) ||
                    (v.SetXY(E, z), v.SetBboxChanged())
                  : (v.SetXY(E, z), v.SetBboxChanged()))
              : (v.SetXY(E, z), v.SetBboxChanged()),
            g || (this._dx = 0))
          : !y &&
            !m &&
            Math.abs(this._dy) < Math.abs(this._jumpStrength / 4) &&
            ((this._dy = 0), k || (B = !0))
        : ((E = this._IsOnFloor()),
          k && !E
            ? ((h = Math.ceil(Math.abs(this._dx * h)) + 2),
              (E = v.GetX()),
              (z = v.GetY()),
              v.OffsetXY(n * h, p * h),
              v.SetBboxChanged(),
              r.TestOverlapSolid(q) || r.TestOverlapJumpthru(q)
                ? r.PushOutSolid(q, -n, -p, h + 2, !0)
                : (v.SetXY(E, z), v.SetBboxChanged()))
            : E &&
              (!k &&
                this._floorIsJumpthru &&
                ((this._lastFloorObject = E),
                (v = E.GetWorldInfo()),
                (this._lastFloorX = v.GetX()),
                (this._lastFloorY = v.GetY()),
                (this._dy = 0),
                (B = !0)),
              0 === this._dy && r.PushInFractional(q, -n, -p, E, 16)));
      return B;
    }
    _HandleVerticalMovement(h, g) {
      const k = this._inst,
        m = k.GetWorldInfo(),
        q = this._runtime.GetCollisionEngine(),
        v = this._downX,
        r = this._downY;
      let n = !1,
        p = m.GetX(),
        u = m.GetY();
      const w = c(this._dy, -Infinity, this._maxFall, this._g, h);
      m.OffsetXY(w * v, w * r);
      var y = m.GetX();
      const B = m.GetY();
      m.SetBboxChanged();
      let E = q.TestOverlapSolid(k);
      var z = !1;
      if (!E && 0 < this._dy && !g) {
        if (
          (z = 0 < this._fallThrough ? null : q.TestOverlapJumpthru(k, !0)) &&
          z.length
        ) {
          if (this._wasOverJumpthru) {
            m.SetXY(p, u);
            m.SetBboxChanged();
            g = 0;
            for (let D = 0, J = z.length; D < J; ++D)
              (z[g] = z[D]), q.TestOverlap(k, z[D]) || ++g;
            e.truncateArray(z, g);
            m.SetXY(y, B);
            m.SetBboxChanged();
          }
          1 <= z.length && (E = z[0]);
        }
        z = !!E;
      }
      if (E)
        if (
          (q.RegisterCollision(k, E),
          (this._sustainTime = 0),
          (y = 1.1),
          z && !this._wasOverJumpthru && (y = 2),
          q.PushOutSolid(
            k,
            v * (0 > this._dy ? 1 : -1),
            r * (0 > this._dy ? 1 : -1),
            Math.max(Math.abs(this._dy * h * y), 2),
            z,
            E
          ))
        ) {
          this._lastFloorObject = E;
          h = E.GetWorldInfo();
          this._lastFloorX = h.GetX();
          this._lastFloorY = h.GetY();
          (this._floorIsJumpthru = z) && (n = !0);
          if (0 < this._dy || 0 === this._ceilingCollisionMode) this._dy = 0;
          0 > this._dy &&
            1 === this._ceilingCollisionMode &&
            q.PushInFractional(k, v, r, E, 32);
        } else
          m.SetXY(p, u),
            m.SetBboxChanged(),
            (this._wasOnFloor = !0),
            z || (this._dy = 0);
      return [n, w];
    }
    _HandleAnimationTriggers(h, g, k) {
      "falling" !== this._animMode &&
        0 < this._dy &&
        !h &&
        (this.Trigger(e.Behaviors.Platform.Cnds.OnFall),
        (this._animMode = "falling"));
      (h || g) &&
        0 <= this._dy &&
        ("falling" === this._animMode || g || (k && 0 === this._dy)
          ? (this.Trigger(e.Behaviors.Platform.Cnds.OnLand),
            (this._animMode =
              0 === this._dx && 0 === this._dy ? "stopped" : "moving"))
          : ("stopped" !== this._animMode &&
              0 === this._dx &&
              0 === this._dy &&
              (this.Trigger(e.Behaviors.Platform.Cnds.OnStop),
              (this._animMode = "stopped")),
            "moving" === this._animMode ||
              (0 === this._dx && 0 === this._dy) ||
              k ||
              (this.Trigger(e.Behaviors.Platform.Cnds.OnMove),
              (this._animMode = "moving"))));
    }
    _IsMoving() {
      return 0 !== this._GetVectorX() || 0 !== this._GetVectorY();
    }
    _CheckIfStandingOnFloor() {
      if (0 !== this._dy) return !1;
      const h = this._inst;
      var g = this.GetWorldInfo();
      const k = this._runtime.GetCollisionEngine(),
        m = g.GetX(),
        q = g.GetY();
      g.OffsetXY(this._downX, this._downY);
      g.SetBboxChanged();
      const v = k.TestOverlapSolid(h);
      let r = null;
      v || 0 !== this._fallThrough || (r = k.TestOverlapJumpthru(h, !0));
      g.SetXY(m, q);
      g.SetBboxChanged();
      if (v) return !k.TestOverlap(h, v);
      if (r && r.length) {
        g = 0;
        for (let n = 0, p = r.length; n < p; ++n)
          (r[g] = r[n]), k.TestOverlap(h, r[n]) || g++;
        if (1 <= g) return !0;
      }
      return !1;
    }
    _IsByWall(h) {
      const g = this._inst,
        k = this.GetWorldInfo(),
        m = this._runtime.GetCollisionEngine(),
        q = k.GetX(),
        v = k.GetY();
      0 === h
        ? k.OffsetXY(2 * -this._rightX, 2 * -this._rightY)
        : k.OffsetXY(2 * this._rightX, 2 * this._rightY);
      k.SetBboxChanged();
      if (!m.TestOverlapSolid(g)) return k.SetXY(q, v), k.SetBboxChanged(), !1;
      k.OffsetXY(3 * -this._downX, 3 * -this._downY);
      k.SetBboxChanged();
      h = !!m.TestOverlapSolid(g);
      k.SetXY(q, v);
      k.SetBboxChanged();
      return h;
    }
    _FallThroughJumpThru() {
      const h = this.GetWorldInfo(),
        g = h.GetX(),
        k = h.GetY();
      h.OffsetXY(this._downX, this._downY);
      h.SetBboxChanged();
      const m = this._runtime
        .GetCollisionEngine()
        .TestOverlapJumpthru(this._inst, !1);
      h.SetXY(g, k);
      h.SetBboxChanged();
      m && ((this._fallThrough = 3), (this._lastFloorObject = null));
    }
    _ResetDoubleJump(h) {
      this._doubleJumped = !h;
    }
    _GetSpeed() {
      return Math.hypot(this._dx, this._dy);
    }
    _GetMovingAngle() {
      return Math.atan2(this._dy, this._dx);
    }
    _IsJumping() {
      return 0 > this._dy;
    }
    _IsFalling() {
      return 0 < this._dy;
    }
    _SetMaxSpeed(h) {
      this._maxSpeed = Math.max(h, 0);
    }
    _GetMaxSpeed() {
      return this._maxSpeed;
    }
    _SetAcceleration(h) {
      this._acc = Math.max(h, 0);
    }
    _GetAcceleration() {
      return this._acc;
    }
    _SetDeceleration(h) {
      this._dec = Math.max(h, 0);
    }
    _GetDeceleration() {
      return this._dec;
    }
    _SetJumpStrength(h) {
      this._jumpStrength = Math.max(h, 0);
    }
    _GetJumpStrength() {
      return this._jumpStrength;
    }
    _SetMaxFallSpeed(h) {
      this._maxFall = Math.max(h, 0);
    }
    _GetMaxFallSpeed() {
      return this._maxFall;
    }
    _SetGravity(h) {
      if (this._g1 !== h) {
        this._g = h;
        this._UpdateGravity();
        h = this._runtime.GetCollisionEngine();
        var g = this.GetWorldInfo();
        h.TestOverlapSolid(this._inst) &&
          (h.PushOutSolid(this._inst, this._downX, this._downY, 10),
          g.OffsetXY(2 * this._downX, 2 * this._downY),
          g.SetBboxChanged());
        this._lastFloorObject = null;
      }
    }
    _GetGravity() {
      return this._g;
    }
    _SetGravityAngle(h) {
      h = e.clampAngle(h);
      this._ga !== h &&
        ((this._ga = h), this._UpdateGravity(), (this._lastFloorObject = null));
    }
    _GetGravityAngle() {
      return this._ga;
    }
    _SetDoubleJumpEnabled(h) {
      this._enableDoubleJump = !!h;
    }
    _IsDoubleJumpEnabled() {
      return this._enableDoubleJump;
    }
    _SetJumpSustain(h) {
      this._jumpSustain = h;
    }
    _GetJumpSustain() {
      return this._jumpSustain;
    }
    _SetCeilingCollisionMode(h) {
      this._ceilingCollisionMode = h;
    }
    _GetCeilingCollisionMode() {
      return this._ceilingCollisionMode;
    }
    _SetVectorX(h) {
      this._dx = h;
    }
    _GetVectorX() {
      return this._dx;
    }
    _SetVectorY(h) {
      this._dy = h;
    }
    _GetVectorY() {
      return this._dy;
    }
    _SimulateControl(h) {
      if (this._isEnabled)
        switch (h) {
          case 0:
            this._simLeft = !0;
            break;
          case 1:
            this._simRight = !0;
            break;
          case 2:
            this._simJump = !0;
        }
    }
    _SetDefaultControls(h) {
      h = !!h;
      this._defaultControls !== h &&
        ((this._defaultControls = h)
          ? this._BindEvents()
          : (this._UnBindEvents(), this._OnWindowOrKeyboardBlur()));
    }
    _IsDefaultControls() {
      return this._defaultControls;
    }
    _SetIgnoreInput(h) {
      this._ignoreInput = !!h;
    }
    _IsIgnoreInput() {
      return this._ignoreInput;
    }
    _SetEnabled(h) {
      h = !!h;
      this._isEnabled !== h &&
        ((this._isEnabled = h)
          ? this._StartPostTicking()
          : (this._StopPostTicking(),
            (this._lastFloorObject = null),
            (this._simJump = this._simRight = this._simLeft = !1)));
    }
    _IsEnabled() {
      return this._isEnabled;
    }
    GetPropertyValueByIndex(h) {
      switch (h) {
        case 0:
          return this._GetMaxSpeed();
        case 1:
          return this._GetAcceleration();
        case 2:
          return this._GetDeceleration();
        case 3:
          return this._GetJumpStrength();
        case 4:
          return this._GetGravity();
        case 5:
          return this._GetMaxFallSpeed();
        case 6:
          return this._IsDoubleJumpEnabled();
        case 7:
          return 1e3 * this._GetJumpSustain();
        case 8:
          return this._IsDefaultControls();
        case 9:
          return this._IsEnabled();
      }
    }
    SetPropertyValueByIndex(h, g) {
      switch (h) {
        case 0:
          this._SetMaxSpeed(g);
          break;
        case 1:
          this._SetAcceleration(g);
          break;
        case 2:
          this._SetDeceleration(g);
          break;
        case 3:
          this._SetJumpStrength(g);
          break;
        case 4:
          this._SetGravity(g);
          break;
        case 5:
          this._SetMaxFallSpeed(g);
          break;
        case 6:
          this._SetDoubleJumpEnabled(!!g);
          break;
        case 7:
          this._SetJumpSustain(g / 1e3);
          break;
        case 8:
          this._SetDefaultControls(!!g);
          break;
        case 9:
          this._SetEnabled(!!g);
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: "$" + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: "behaviors.platform.debugger.vector-x",
              value: this._GetVectorX(),
              onedit: (h) => this._SetVectorX(h),
            },
            {
              name: "behaviors.platform.debugger.vector-y",
              value: this._GetVectorY(),
              onedit: (h) => this._SetVectorY(h),
            },
            {
              name: "behaviors.platform.properties.max-speed.name",
              value: this._GetMaxSpeed(),
              onedit: (h) => this._SetMaxSpeed(h),
            },
            {
              name: "behaviors.platform.properties.acceleration.name",
              value: this._GetAcceleration(),
              onedit: (h) => this._SetAcceleration(h),
            },
            {
              name: "behaviors.platform.properties.deceleration.name",
              value: this._GetDeceleration(),
              onedit: (h) => this._SetDeceleration(h),
            },
            {
              name: "behaviors.platform.properties.jump-strength.name",
              value: this._GetJumpStrength(),
              onedit: (h) => this._SetJumpStrength(h),
            },
            {
              name: "behaviors.platform.properties.gravity.name",
              value: this._GetGravity(),
              onedit: (h) => this._SetGravity(h),
            },
            {
              name: "behaviors.platform.debugger.gravity-angle",
              value: e.toDegrees(this._GetGravityAngle()),
              onedit: (h) => this._SetGravityAngle(e.toRadians(h)),
            },
            {
              name: "behaviors.platform.properties.max-fall-speed.name",
              value: this._GetMaxFallSpeed(),
              onedit: (h) => this._SetMaxFallSpeed(h),
            },
            {
              name: "behaviors.platform.debugger.animation-mode",
              value: ["behaviors.platform.debugger.anim-" + this._animMode],
            },
            {
              name: "behaviors.platform.properties.enabled.name",
              value: this._IsEnabled(),
              onedit: (h) => this._SetEnabled(h),
            },
          ],
        },
      ];
    }
    GetScriptInterfaceClass() {
      return self.IPlatformBehaviorInstance;
    }
  };
  const d = new WeakMap(),
    f = new Map([
      ["left", 0],
      ["right", 1],
      ["jump", 2],
    ]);
  self.IPlatformBehaviorInstance = class extends a {
    constructor() {
      super();
      d.set(this, a._GetInitInst().GetSdkInstance());
    }
    fallThrough() {
      d.get(this)._FallThroughJumpThru();
    }
    resetDoubleJump(h) {
      d.get(this)._ResetDoubleJump(!!h);
    }
    simulateControl(h) {
      b.RequireString(h);
      h = f.get(h);
      if ("number" !== typeof h) throw Error("invalid control");
      d.get(this)._SimulateControl(h);
    }
    get speed() {
      return d.get(this)._GetSpeed();
    }
    get maxSpeed() {
      return d.get(this)._GetMaxSpeed();
    }
    set maxSpeed(h) {
      b.RequireFiniteNumber(h);
      d.get(this)._SetMaxSpeed(h);
    }
    get acceleration() {
      return d.get(this)._GetAcceleration();
    }
    set acceleration(h) {
      b.RequireFiniteNumber(h);
      d.get(this)._SetAcceleration(h);
    }
    get deceleration() {
      return d.get(this)._GetDeceleration();
    }
    set deceleration(h) {
      b.RequireFiniteNumber(h);
      d.get(this)._SetDeceleration(h);
    }
    get jumpStrength() {
      return d.get(this)._GetJumpStrength();
    }
    set jumpStrength(h) {
      b.RequireFiniteNumber(h);
      d.get(this)._SetJumpStrength(h);
    }
    get maxFallSpeed() {
      return d.get(this)._GetMaxFallSpeed();
    }
    set maxFallSpeed(h) {
      b.RequireFiniteNumber(h);
      d.get(this)._SetMaxFallSpeed(h);
    }
    get gravity() {
      return d.get(this)._GetGravity();
    }
    set gravity(h) {
      b.RequireFiniteNumber(h);
      d.get(this)._SetGravity(h);
    }
    get gravityAngle() {
      return d.get(this)._GetGravityAngle();
    }
    set gravityAngle(h) {
      b.RequireFiniteNumber(h);
      d.get(this)._SetGravityAngle(h);
    }
    get isDoubleJumpEnabled() {
      return d.get(this)._IsDoubleJumpEnabled();
    }
    set isDoubleJumpEnabled(h) {
      d.get(this)._SetDoubleJumpEnabled(!!h);
    }
    get jumpSustain() {
      return d.get(this)._GetJumpSustain();
    }
    set jumpSustain(h) {
      b.RequireFiniteNumber(h);
      d.get(this)._SetJumpSustain(h);
    }
    get ceilingCollisionMode() {
      return 0 === d.get(this)._GetCeilingCollisionMode()
        ? "stop"
        : "preserve-momentum";
    }
    set ceilingCollisionMode(h) {
      b.RequireString(h);
      const g = d.get(this);
      if ("stop" === h) g._SetCeilingCollisionMode(0);
      else if ("preserve-momentum" === h) g._SetCeilingCollisionMode(1);
      else throw Error("invalid mode");
    }
    get isOnFloor() {
      return d.get(this)._CheckIfStandingOnFloor();
    }
    isByWall(h) {
      b.RequireString(h);
      const g = d.get(this);
      if ("left" === h) return g._IsByWall(0);
      if ("right" === h) return g._IsByWall(1);
      throw Error("invalid side");
    }
    get isMoving() {
      return d.get(this)._IsMoving();
    }
    get isJumping() {
      return d.get(this)._IsJumping();
    }
    get isFalling() {
      return d.get(this)._IsFalling();
    }
    get vectorX() {
      return d.get(this)._GetVectorX();
    }
    set vectorX(h) {
      b.RequireFiniteNumber(h);
      d.get(this)._SetVectorX(h);
    }
    get vectorY() {
      return d.get(this)._GetVectorY();
    }
    set vectorY(h) {
      b.RequireFiniteNumber(h);
      d.get(this)._SetVectorY(h);
    }
    get isDefaultControls() {
      return d.get(this)._IsDefaultControls();
    }
    set isDefaultControls(h) {
      d.get(this)._SetDefaultControls(!!h);
    }
    get isIgnoringInput() {
      return d.get(this)._IsIgnoreInput();
    }
    set isIgnoringInput(h) {
      d.get(this)._SetIgnoreInput(!!h);
    }
    get isEnabled() {
      return d.get(this)._IsEnabled();
    }
    set isEnabled(h) {
      d.get(this)._SetEnabled(!!h);
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Platform.Cnds = {
    IsMoving() {
      return this._IsMoving();
    },
    CompareSpeed(b, a) {
      return e.compare(this._GetSpeed(), b, a);
    },
    IsOnFloor() {
      return this._CheckIfStandingOnFloor();
    },
    IsByWall(b) {
      return this._IsByWall(b);
    },
    IsJumping() {
      return this._IsJumping();
    },
    IsFalling() {
      return this._IsFalling();
    },
    IsDoubleJumpEnabled() {
      return this._IsDoubleJumpEnabled();
    },
    OnJump() {
      return !0;
    },
    OnFall() {
      return !0;
    },
    OnStop() {
      return !0;
    },
    OnMove() {
      return !0;
    },
    OnLand() {
      return !0;
    },
    IsEnabled() {
      return this._IsEnabled();
    },
  };
}
{
  const e = self.C3;
  e.Behaviors.Platform.Acts = {
    SetMaxSpeed(b) {
      this._SetMaxSpeed(b);
    },
    SetAcceleration(b) {
      this._SetAcceleration(b);
    },
    SetDeceleration(b) {
      this._SetDeceleration(b);
    },
    SetJumpStrength(b) {
      this._SetJumpStrength(b);
    },
    SetMaxFallSpeed(b) {
      this._SetMaxFallSpeed(b);
    },
    SetGravity(b) {
      this._SetGravity(b);
    },
    SimulateControl(b) {
      this._SimulateControl(b);
    },
    SetIgnoreInput(b) {
      this._SetIgnoreInput(!!b);
    },
    SetVectorX(b) {
      this._SetVectorX(b);
    },
    SetVectorY(b) {
      this._SetVectorY(b);
    },
    SetGravityAngle(b) {
      this._SetGravityAngle(e.toRadians(b));
    },
    SetEnabled(b) {
      this._SetEnabled(0 !== b);
    },
    FallThrough() {
      this._FallThroughJumpThru();
    },
    SetDoubleJumpEnabled(b) {
      this._SetDoubleJumpEnabled(0 !== b);
    },
    SetJumpSustain(b) {
      this._SetJumpSustain(b / 1e3);
    },
    SetCeilingCollision(b) {
      this._SetCeilingCollisionMode(b);
    },
    SetDefaultControls(b) {
      this._SetDefaultControls(b);
    },
    ResetDoubleJump(b) {
      this._ResetDoubleJump(b);
    },
  };
}
{
  const e = self.C3;
  e.Behaviors.Platform.Exps = {
    Speed() {
      return this._GetSpeed();
    },
    MaxSpeed() {
      return this._GetMaxSpeed();
    },
    Acceleration() {
      return this._GetAcceleration();
    },
    Deceleration() {
      return this._GetDeceleration();
    },
    JumpStrength() {
      return this._GetJumpStrength();
    },
    Gravity() {
      return this._GetGravity();
    },
    GravityAngle() {
      return e.toDegrees(this._GetGravityAngle());
    },
    MaxFallSpeed() {
      return this._GetMaxFallSpeed();
    },
    MovingAngle() {
      return e.toDegrees(this._GetMovingAngle());
    },
    VectorX() {
      return this._GetVectorX();
    },
    VectorY() {
      return this._GetVectorY();
    },
    JumpSustain() {
      return 1e3 * this._GetJumpSustain();
    },
  };
}
("use strict");
{
  const e = self.C3;
  e.Behaviors.Flash = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Flash.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3;
  e.Behaviors.Flash.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b);
      this._timeLeft =
        this._stageTimeLeft =
        this._stage =
        this._offTime =
        this._onTime =
          0;
      this._StartTicking();
    }
    Release() {
      super.Release();
    }
    SaveToJson() {
      return {
        on: this._onTime,
        off: this._offTime,
        s: this._stage,
        stl: this._stageTimeLeft,
        tl: this._timeLeft,
      };
    }
    LoadFromJson(b) {
      this._onTime = b.on;
      this._offTime = b.off;
      this._stage = b.s;
      this._stageTimeLeft = b.stl;
      this._timeLeft = null === b.tl ? Infinity : b.tl;
    }
    Tick() {
      if (!(0 >= this._timeLeft)) {
        var b = this._runtime.GetDt(this._inst);
        this._timeLeft -= b;
        if (0 >= this._timeLeft)
          return (
            (this._timeLeft = 0),
            this._inst.GetWorldInfo().SetVisible(!0),
            this._runtime.UpdateRender(),
            this.DebugTrigger(e.Behaviors.Flash.Cnds.OnFlashEnded)
          );
        this._stageTimeLeft -= b;
        0 >= this._stageTimeLeft &&
          (0 === this._stage
            ? (this._inst.GetWorldInfo().SetVisible(!1),
              (this._stage = 1),
              (this._stageTimeLeft += this._offTime))
            : (this._inst.GetWorldInfo().SetVisible(!0),
              (this._stage = 0),
              (this._stageTimeLeft += this._onTime)),
          this._runtime.UpdateRender());
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: "$" + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: "behaviors.flash.debugger.on-time",
              value: this._onTime,
              onedit: (b) => (this._onTime = b),
            },
            {
              name: "behaviors.flash.debugger.off-time",
              value: this._offTime,
              onedit: (b) => (this._offTime = b),
            },
            {
              name: "behaviors.flash.debugger.is-flashing",
              value: 0 < this._timeLeft,
            },
            {
              name: "behaviors.flash.debugger.time-left",
              value: this._timeLeft,
            },
          ],
        },
      ];
    }
  };
}
self.C3.Behaviors.Flash.Cnds = {
  IsFlashing() {
    return 0 < this._timeLeft;
  },
  OnFlashEnded() {
    return !0;
  },
};
self.C3.Behaviors.Flash.Acts = {
  Flash(e, b, a) {
    this._onTime = e;
    this._offTime = b;
    this._stage = 1;
    this._stageTimeLeft = b;
    this._timeLeft = a;
    this._inst.GetWorldInfo().SetVisible(!1);
    this._runtime.UpdateRender();
  },
  StopFlashing() {
    this._timeLeft = 0;
    this._inst.GetWorldInfo().SetVisible(!0);
    this._runtime.UpdateRender();
  },
};
self.C3.Behaviors.Flash.Exps = {};
("use strict");
{
  const e = self.C3;
  e.Behaviors.scrollto = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
      this._shakeMode = this._shakeEnd = this._shakeStart = this._shakeMag = 0;
    }
    Release() {
      super.Release();
    }
    SetShakeMagnitude(b) {
      this._shakeMag = b;
    }
    GetShakeMagnitude() {
      return this._shakeMag;
    }
    SetShakeStart(b) {
      this._shakeStart = b;
    }
    GetShakeStart() {
      return this._shakeStart;
    }
    SetShakeEnd(b) {
      this._shakeEnd = b;
    }
    GetShakeEnd() {
      return this._shakeEnd;
    }
    SetShakeMode(b) {
      this._shakeMode = b;
    }
    GetShakeMode() {
      return this._shakeMode;
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.scrollto.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3;
  e.Behaviors.scrollto.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b);
      this._isEnabled = !0;
      a && (this._isEnabled = a[0]);
      this._isEnabled && this._StartTicking2();
    }
    Release() {
      super.Release();
    }
    SaveToJson() {
      const b = this.GetBehavior();
      return {
        e: this._isEnabled,
        smg: b.GetShakeMagnitude(),
        ss: b.GetShakeStart(),
        se: b.GetShakeEnd(),
        smd: b.GetShakeMode(),
      };
    }
    LoadFromJson(b) {
      const a = this.GetBehavior();
      a.SetShakeMagnitude(b.smg);
      a.SetShakeStart(b.ss);
      a.SetShakeEnd(b.se);
      a.SetShakeMode(b.smd);
      (this._isEnabled = b.e) ? this._StartTicking2() : this._StopTicking2();
    }
    IsEnabled() {
      return this._isEnabled;
    }
    Tick2() {
      if (this.IsEnabled()) {
        this._runtime.GetDt(this._inst);
        var b = this.GetBehavior(),
          a = b.GetInstances(),
          c = 0,
          d = 0,
          f = 0;
        for (var h of a)
          (a = h.GetBehaviorInstanceFromCtor(e.Behaviors.scrollto)) &&
            a.GetSdkInstance().IsEnabled() &&
            ((a = h.GetWorldInfo()), (c += a.GetX()), (d += a.GetY()), ++f);
        h = this._inst.GetWorldInfo().GetLayout();
        var g = this._runtime.GetGameTime(),
          k = (a = 0);
        g >= b.GetShakeStart() &&
          g < b.GetShakeEnd() &&
          ((a =
            b.GetShakeMagnitude() * Math.min(this._runtime.GetTimeScale(), 1)),
          0 === b.GetShakeMode() &&
            (a *=
              1 -
              (g - b.GetShakeStart()) / (b.GetShakeEnd() - b.GetShakeStart())),
          (b = this._runtime.Random() * Math.PI * 2),
          (g = this._runtime.Random() * a),
          (a = Math.cos(b) * g),
          (k = Math.sin(b) * g));
        h.SetScrollX(c / f + a);
        h.SetScrollY(d / f + k);
      }
    }
    GetPropertyValueByIndex(b) {
      switch (b) {
        case 0:
          return this._isEnabled;
      }
    }
    SetPropertyValueByIndex(b, a) {
      switch (b) {
        case 0:
          (this._isEnabled = !!a)
            ? this._StartTicking2()
            : this._StopTicking2();
      }
    }
  };
}
self.C3.Behaviors.scrollto.Cnds = {
  IsEnabled() {
    return this._isEnabled;
  },
};
self.C3.Behaviors.scrollto.Acts = {
  Shake(e, b, a) {
    const c = this.GetBehavior();
    c.SetShakeMagnitude(e);
    c.SetShakeStart(this._runtime.GetGameTime());
    c.SetShakeEnd(this._runtime.GetGameTime() + b);
    c.SetShakeMode(a);
  },
  SetEnabled(e) {
    (this._isEnabled = 0 !== e) ? this._StartTicking2() : this._StopTicking2();
  },
};
self.C3.Behaviors.scrollto.Exps = {};
("use strict");
{
  const e = self.C3;
  e.Behaviors.MoveTo = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.MoveTo.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3,
    b = self.C3X,
    a = self.IBehaviorInstance;
  e.Behaviors.MoveTo.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(d, f) {
      super(d);
      this._maxSpeed = 200;
      this._dec = this._acc = 600;
      this._rotateSpeed = 0;
      this._setAngle = !0;
      this._stopOnSolids = !1;
      this._isEnabled = !0;
      this._speed = 0;
      this._movingAngle = this.GetWorldInfo().GetAngle();
      this._waypoints = [];
      f &&
        ((this._maxSpeed = f[0]),
        (this._acc = f[1]),
        (this._dec = f[2]),
        (this._rotateSpeed = e.toRadians(f[3])),
        (this._setAngle = f[4]),
        (this._stopOnSolids = f[5]),
        (this._isEnabled = f[6]));
    }
    Release() {
      super.Release();
    }
    SaveToJson() {
      return {
        ms: this._maxSpeed,
        acc: this._acc,
        dec: this._dec,
        rs: this._rotateSpeed,
        sa: this._setAngle,
        sos: this._stopOnSolids,
        s: this._speed,
        ma: this._movingAngle,
        wp: this._waypoints.map((d) => ({ x: d.x, y: d.y })),
        e: this._isEnabled,
      };
    }
    LoadFromJson(d) {
      this._maxSpeed = d.ms;
      this._acc = d.acc;
      this._dec = d.dec;
      this._rotateSpeed = d.rs;
      this._setAngle = d.sa;
      this._stopOnSolids = d.sos;
      this._speed = d.s;
      this._movingAngle = d.ma;
      this._waypoints = d.wp.map((f) => ({ x: f.x, y: f.y }));
      this._SetEnabled(d.e);
      this._isEnabled && 0 < this._waypoints.length && this._StartTicking();
    }
    _AddWaypoint(d, f, h) {
      h && e.clearArray(this._waypoints);
      this._waypoints.push({ x: d, y: f });
      this._isEnabled && this._StartTicking();
    }
    _GetWaypointCount() {
      return this._waypoints.length;
    }
    _GetWaypointXAt(d) {
      d = Math.floor(d);
      return 0 > d || d >= this._waypoints.length ? 0 : this._waypoints[d].x;
    }
    _GetWaypointYAt(d) {
      d = Math.floor(d);
      return 0 > d || d >= this._waypoints.length ? 0 : this._waypoints[d].y;
    }
    _IsMoving() {
      return 0 < this._waypoints.length;
    }
    _Stop() {
      e.clearArray(this._waypoints);
      this._speed = 0;
      this._StopTicking();
    }
    _GetTargetX() {
      return 0 < this._waypoints.length ? this._waypoints[0].x : 0;
    }
    _GetTargetY() {
      return 0 < this._waypoints.length ? this._waypoints[0].y : 0;
    }
    _SetSpeed(d) {
      this._IsMoving() && (this._speed = Math.min(d, this._maxSpeed));
    }
    _GetSpeed() {
      return this._speed;
    }
    _SetMaxSpeed(d) {
      this._maxSpeed = Math.max(d, 0);
      this._SetSpeed(this._speed);
    }
    _GetMaxSpeed() {
      return this._maxSpeed;
    }
    _IsRotationEnabled() {
      return 0 !== this._rotateSpeed;
    }
    Tick() {
      if (this._isEnabled && this._IsMoving()) {
        var d = this._runtime.GetDt(this._inst),
          f = this._inst.GetWorldInfo(),
          h = f.GetX(),
          g = f.GetY(),
          k = f.GetAngle(),
          m = this._speed,
          q = this._maxSpeed,
          v = this._acc,
          r = this._dec,
          n = this._GetTargetX(),
          p = this._GetTargetY(),
          u = e.angleTo(h, g, n, p),
          w = !1;
        0 < r &&
          1 === this._waypoints.length &&
          ((w = ((0.5 * m * m) / r) * 1.0001),
          (w = e.distanceSquared(h, g, n, p) <= w * w)) &&
          ((q = e.distanceTo(h, g, n, p)),
          (this._speed = q = m = Math.sqrt(2 * r * q)));
        if (this._IsRotationEnabled()) {
          var y = e.angleDiff(this._movingAngle, u);
          if (y > Number.EPSILON) {
            const B = y / this._rotateSpeed;
            y *= e.distanceTo(f.GetX(), f.GetY(), n, p) / (2 * Math.sin(y));
            q = Math.min(q, e.clamp(y / B, 0, this._maxSpeed));
          }
        }
        m = Math.min(m * d + 0.5 * (w ? -r : v) * d * d, q * d);
        if (w) {
          if (
            0 < r &&
            ((this._speed = Math.max(this._speed - r * d, 0)),
            0 === this._speed)
          ) {
            this._OnArrived(f, n, p);
            return;
          }
        } else this._speed = 0 === v ? q : Math.min(this._speed + v * d, q);
        e.distanceSquared(f.GetX(), f.GetY(), n, p) <= m * m
          ? this._OnArrived(f, n, p)
          : (this._IsRotationEnabled()
              ? (this._movingAngle = e.angleRotate(
                  this._movingAngle,
                  u,
                  this._rotateSpeed * d
                ))
              : (this._movingAngle = u),
            f.OffsetXY(
              Math.cos(this._movingAngle) * m,
              Math.sin(this._movingAngle) * m
            ),
            this._setAngle && f.SetAngle(this._movingAngle),
            f.SetBboxChanged(),
            this._CheckSolidCollision(h, g, k));
      }
    }
    _OnArrived(d, f, h) {
      d.SetXY(f, h);
      d.SetBboxChanged();
      this._waypoints.shift();
      0 === this._waypoints.length && ((this._speed = 0), this._StopTicking());
      this.DispatchScriptEvent("arrived");
      this.Trigger(e.Behaviors.MoveTo.Cnds.OnArrived);
    }
    _CheckSolidCollision(d, f, h) {
      const g = this._runtime.GetCollisionEngine();
      if (this._stopOnSolids && g.TestOverlapSolid(this._inst)) {
        this._Stop();
        const m = this._inst.GetWorldInfo();
        var k = m.GetX();
        const q = m.GetY(),
          v = e.angleTo(k, q, d, f);
        k = e.distanceTo(k, q, d, f);
        g.PushOutSolid(this._inst, Math.cos(v), Math.sin(v), Math.max(k, 1)) ||
          (m.SetXY(d, f), m.SetAngle(h), m.SetBboxChanged());
        this.DispatchScriptEvent("hitsolid");
        this.Trigger(e.Behaviors.MoveTo.Cnds.OnHitSolid);
      }
    }
    _IsSetAngle() {
      return this._setAngle;
    }
    _SetSetAngle(d) {
      this._setAngle = !!d;
    }
    _SetAngleOfMotion(d) {
      this._movingAngle = d;
      this._isEnabled &&
        this._setAngle &&
        !this._IsMoving() &&
        ((d = this.GetWorldInfo()),
        d.SetAngle(this._movingAngle),
        d.SetBboxChanged());
    }
    _GetAngleOfMotion() {
      return this._movingAngle;
    }
    _SetAcceleration(d) {
      this._acc = Math.max(d, 0);
    }
    _GetAcceleration() {
      return this._acc;
    }
    _SetDeceleration(d) {
      this._dec = Math.max(d, 0);
    }
    _GetDeceleration() {
      return this._dec;
    }
    _SetRotateSpeed(d) {
      this._rotateSpeed = Math.max(d, 0);
    }
    _GetRotateSpeed() {
      return this._rotateSpeed;
    }
    _SetStopOnSolids(d) {
      this._stopOnSolids = !!d;
    }
    _IsStopOnSolids() {
      return this._stopOnSolids;
    }
    _SetEnabled(d) {
      d = !!d;
      this._isEnabled !== d &&
        ((this._isEnabled = d) && this._IsMoving()
          ? this._StartTicking()
          : this._StopTicking());
    }
    _IsEnabled() {
      return this._isEnabled;
    }
    GetPropertyValueByIndex(d) {
      switch (d) {
        case 0:
          return this._GetMaxSpeed();
        case 1:
          return this._GetAcceleration();
        case 2:
          return this._GetDeceleration();
        case 3:
          return e.toDegrees(this._GetRotateSpeed());
        case 4:
          return this._IsSetAngle();
        case 5:
          return this._IsStopOnSolids();
        case 6:
          return this._IsEnabled();
      }
    }
    SetPropertyValueByIndex(d, f) {
      switch (d) {
        case 0:
          this._SetMaxSpeed(f);
          break;
        case 1:
          this._SetAcceleration(f);
          break;
        case 2:
          this._SetDeceleration(f);
          break;
        case 3:
          this._SetRotateSpeed(e.toRadians(f));
          break;
        case 4:
          this._SetSetAngle(f);
          break;
        case 5:
          this._SetStopOnSolids(f);
          break;
        case 6:
          this._SetEnabled(f);
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: "$" + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: "behaviors.moveto.debugger.speed",
              value: this._GetSpeed(),
              onedit: (d) => this._SetSpeed(d),
            },
            {
              name: "behaviors.moveto.debugger.angle-of-motion",
              value: e.toDegrees(this._GetAngleOfMotion()),
              onedit: (d) => (this._movingAngle = e.toRadians(d)),
            },
            {
              name: "behaviors.moveto.debugger.target-x",
              value: this._GetTargetX(),
            },
            {
              name: "behaviors.moveto.debugger.target-y",
              value: this._GetTargetY(),
            },
            {
              name: "behaviors.moveto.debugger.waypoint-count",
              value: this._GetWaypointCount(),
            },
            {
              name: "behaviors.moveto.properties.max-speed.name",
              value: this._GetMaxSpeed(),
              onedit: (d) => this._SetMaxSpeed(d),
            },
            {
              name: "behaviors.moveto.properties.acceleration.name",
              value: this._GetAcceleration(),
              onedit: (d) => this._SetAcceleration(d),
            },
            {
              name: "behaviors.moveto.properties.deceleration.name",
              value: this._GetDeceleration(),
              onedit: (d) => this._SetDeceleration(d),
            },
            {
              name: "behaviors.moveto.properties.rotate-speed.name",
              value: e.toDegrees(this._GetRotateSpeed()),
              onedit: (d) => this._SetRotateSpeed(e.toRadians(d)),
            },
            {
              name: "behaviors.moveto.properties.enabled.name",
              value: this._IsEnabled(),
              onedit: (d) => this._SetEnabled(d),
            },
          ],
        },
      ];
    }
    GetScriptInterfaceClass() {
      return self.IMoveToBehaviorInstance;
    }
  };
  const c = new WeakMap();
  self.IMoveToBehaviorInstance = class extends a {
    constructor() {
      super();
      c.set(this, a._GetInitInst().GetSdkInstance());
    }
    moveToPosition(d, f, h = !0) {
      b.RequireFiniteNumber(d);
      b.RequireFiniteNumber(f);
      c.get(this)._AddWaypoint(d, f, !!h);
    }
    getTargetX() {
      return c.get(this)._GetTargetX();
    }
    getTargetY() {
      return c.get(this)._GetTargetY();
    }
    getTargetPosition() {
      const d = c.get(this);
      return [d._GetTargetX(), d._GetTargetY()];
    }
    getWaypointCount() {
      return c.get(this)._GetWaypointCount();
    }
    getWaypointX(d) {
      b.RequireFiniteNumber(d);
      return c.get(this)._GetWaypointXAt(d);
    }
    getWaypointY(d) {
      b.RequireFiniteNumber(d);
      return c.get(this)._GetWaypointYAt(d);
    }
    getWaypoint(d) {
      b.RequireFiniteNumber(d);
      const f = c.get(this);
      return [f._GetWaypointXAt(d), f._GetWaypointYAt(d)];
    }
    stop() {
      c.get(this)._Stop();
    }
    get isMoving() {
      return c.get(this)._IsMoving();
    }
    get speed() {
      return c.get(this)._GetSpeed();
    }
    set speed(d) {
      b.RequireFiniteNumber(d);
      c.get(this)._SetSpeed(d);
    }
    get maxSpeed() {
      return c.get(this)._GetMaxSpeed();
    }
    set maxSpeed(d) {
      b.RequireFiniteNumber(d);
      c.get(this)._SetMaxSpeed(d);
    }
    get acceleration() {
      return c.get(this)._GetAcceleration();
    }
    set acceleration(d) {
      b.RequireFiniteNumber(d);
      c.get(this)._SetAcceleration(d);
    }
    get deceleration() {
      return c.get(this)._GetDeceleration();
    }
    set deceleration(d) {
      b.RequireFiniteNumber(d);
      c.get(this)._SetDeceleration(d);
    }
    get angleOfMotion() {
      return c.get(this)._GetAngleOfMotion();
    }
    set angleOfMotion(d) {
      b.RequireFiniteNumber(d);
      c.get(this)._SetAngleOfMotion(d);
    }
    get rotateSpeed() {
      return c.get(this)._GetRotateSpeed();
    }
    set rotateSpeed(d) {
      b.RequireFiniteNumber(d);
      c.get(this)._SetRotateSpeed(d);
    }
    get isStopOnSolids() {
      return c.get(this)._IsStopOnSolids();
    }
    set isStopOnSolids(d) {
      c.get(this)._SetStopOnSolids(d);
    }
    get isEnabled() {
      return c.get(this)._IsEnabled();
    }
    set isEnabled(d) {
      c.get(this)._SetEnabled(d);
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.MoveTo.Cnds = {
    IsMoving() {
      return this._IsMoving();
    },
    CompareSpeed(b, a) {
      return e.compare(this._GetSpeed(), b, a);
    },
    IsEnabled() {
      return this._IsEnabled();
    },
    OnArrived() {
      return !0;
    },
    OnHitSolid() {
      return !0;
    },
  };
}
{
  const e = self.C3;
  e.Behaviors.MoveTo.Acts = {
    MoveToPosition(b, a, c) {
      this._AddWaypoint(b, a, 0 === c);
    },
    MoveToObject(b, a, c) {
      if (b && (b = b.GetPairedInstance(this._inst)) && b.GetWorldInfo()) {
        var [d, f] = b.GetImagePoint(a);
        this._AddWaypoint(d, f, 0 === c);
      }
    },
    MoveAlongPathfindingPath(b) {
      var a = this._inst.GetBehaviorSdkInstanceFromCtor(
        e.Behaviors.Pathfinding
      );
      if (a && ((a = a._GetPath()), 0 !== a.length))
        for (let c = 0, d = a.length; c < d; ++c) {
          const f = a[c];
          this._AddWaypoint(f.x, f.y, 0 === c && 0 === b);
        }
    },
    MoveAlongTimeline(b, a, c) {
      if ((a = a ? b.GetTrackById(a) : e.first(b.GetTracks())))
        if (
          ((b = a.GetPropertyTrack("offsetX")),
          (a = a.GetPropertyTrack("offsetY")),
          b && a)
        ) {
          var d = [...b.GetPropertyKeyframeValues()],
            f = [...a.GetPropertyKeyframeValues()];
          if (0 !== d.length && 0 !== f.length) {
            var h = 0,
              g = 0,
              k = this._inst.GetWorldInfo();
            "relative" === b.GetResultMode() && (h = k.GetX());
            "relative" === a.GetResultMode() && (g = k.GetY());
            for (let m = 0, q = Math.min(d.length, f.length); m < q; ++m)
              this._AddWaypoint(d[m] + h, f[m] + g, 0 === m && 0 === c);
          }
        }
    },
    MoveAlongTimelineByName(b, a, c) {
      (b = this._runtime.GetTimelineManager().GetTimelineByName(b)) &&
        e.Behaviors.MoveTo.Acts.MoveAlongTimeline.call(this, b, a, c);
    },
    Stop() {
      this._Stop();
    },
    SetMovingAngle(b) {
      this._SetAngleOfMotion(e.toRadians(b));
    },
    SetSpeed(b) {
      this._SetSpeed(b);
    },
    SetMaxSpeed(b) {
      this._SetMaxSpeed(b);
    },
    SetAcceleration(b) {
      this._SetAcceleration(b);
    },
    SetDeceleration(b) {
      this._SetDeceleration(b);
    },
    SetRotateSpeed(b) {
      this._SetRotateSpeed(e.toRadians(b));
    },
    SetStopOnSolids(b) {
      this._SetStopOnSolids(b);
    },
    SetEnabled(b) {
      this._SetEnabled(b);
    },
  };
}
{
  const e = self.C3;
  e.Behaviors.MoveTo.Exps = {
    Speed() {
      return this._GetSpeed();
    },
    MaxSpeed() {
      return this._GetMaxSpeed();
    },
    Acceleration() {
      return this._GetAcceleration();
    },
    Deceleration() {
      return this._GetDeceleration();
    },
    MovingAngle() {
      return e.toDegrees(this._GetAngleOfMotion());
    },
    RotateSpeed() {
      return e.toDegrees(this._GetRotateSpeed());
    },
    TargetX() {
      return this._GetTargetX();
    },
    TargetY() {
      return this._GetTargetY();
    },
    WaypointCount() {
      return this._GetWaypointCount();
    },
    WaypointXAt(b) {
      return this._GetWaypointXAt(b);
    },
    WaypointYAt(b) {
      return this._GetWaypointYAt(b);
    },
  };
}
("use strict");
{
  const e = self.C3;
  e.Behaviors.LOS = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.LOS.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
      this._obstacleTypes = [];
    }
    Release() {
      e.clearArray(this._obstacleTypes);
      super.Release();
    }
    OnCreate() {}
    GetObstacleTypes() {
      return this._obstacleTypes;
    }
    FindLOSBehavior(b) {
      const a = this.GetBehaviorType();
      for (const c of b.GetBehaviorInstances())
        if (c.GetBehaviorType() === a) return c.GetSdkInstance();
      return null;
    }
  };
}
{
  const e = self.C3,
    b = self.C3X,
    a = self.IBehaviorInstance,
    c = [];
  e.Behaviors.LOS.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(f, h) {
      super(f);
      this._obstacleMode = 0;
      this._range = 1e4;
      this._cone = e.toRadians(360);
      this._useCollisionCells = !0;
      this._ray = new e.Ray();
      h &&
        ((this._obstacleMode = h[0]),
        (this._range = h[1]),
        (this._cone = e.toRadians(h[2])),
        (this._useCollisionCells = h[3]));
    }
    Release() {
      super.Release();
    }
    SaveToJson() {
      return {
        r: this._range,
        c: this._cone,
        om: this._obstacleMode,
        ucc: this._useCollisionCells,
        t: this.GetSdkType()
          .GetObstacleTypes()
          .map((f) => f.GetSID()),
      };
    }
    LoadFromJson(f) {
      this._range = f.r;
      this._cone = f.c;
      this._obstacleMode = f.om || 0;
      this._useCollisionCells = !!f.ucc;
      const h = this.GetSdkType().GetObstacleTypes();
      e.clearArray(h);
      for (const g of f.t)
        (f = this._runtime.GetObjectClassBySID(g)) && h.push(f);
    }
    HasLOSToInstance(f, h) {
      const g = f.GetUID(),
        [k, m] = f.GetImagePoint(h);
      return this.HasLOSTo(k, m) || this._ray.hitUid === g;
    }
    HasLOSTo(f, h) {
      const g = this.GetWorldInfo();
      let k = g.GetAngle();
      0 > g.GetWidth() && (k += Math.PI);
      return this.HasLOSBetweenPositions(g.GetX(), g.GetY(), k, f, h);
    }
    HasLOSBetweenPositions(f, h, g, k, m) {
      var q = this._range;
      if (e.distanceSquared(f, h, k, m) > q * q) return !1;
      q = e.angleTo(f, h, k, m);
      return e.angleDiff(g, q) > this._cone / 2
        ? !1
        : !this.CastRay(f, h, k, m, this._useCollisionCells).DidCollide();
    }
    _GetCollisionCandidates(f, h) {
      if (h) {
        h = this.GetWorldInfo().GetLayer();
        var g = this._runtime.GetCollisionEngine();
        0 === this._obstacleMode
          ? g.GetSolidCollisionCandidates(h, f.rect, c)
          : g.GetObjectClassesCollisionCandidates(
              h,
              this._GetObstacleTypes(),
              f.rect,
              c
            );
        return c;
      }
      if (0 === this._obstacleMode)
        return (f = this._runtime.GetSolidBehavior()) ? f.GetInstances() : c;
      for (g of this._GetObstacleTypes()) e.appendArray(c, g.GetInstances());
      return c;
    }
    _GetObstacleTypes() {
      return this.GetSdkType().GetObstacleTypes();
    }
    CastRay(f, h, g, k, m) {
      f = this._ray.Set(f, h, g, k);
      m = this._GetCollisionCandidates(f, m);
      h = this._runtime.GetCollisionEngine();
      g = 0 === this._obstacleMode;
      k = this._inst;
      for (let q = 0, v = m.length; q < v; ++q) {
        const r = m[q];
        r !== k &&
          ((g && !h.IsSolidCollisionAllowed(r, k)) ||
            h.TestRayIntersectsInstance(r, f));
      }
      f.Complete();
      e.clearArray(c);
      return f;
    }
    _GetRay() {
      return this._ray;
    }
    _GetRayHitX() {
      const f = this._ray;
      return f.DidCollide() ? f.hitX : 0;
    }
    _GetRayHitY() {
      const f = this._ray;
      return f.DidCollide() ? f.hitY : 0;
    }
    _GetRayHitDistance() {
      const f = this._ray;
      return f.DidCollide() ? f.distance : 0;
    }
    _GetRayHitUID() {
      const f = this._ray;
      return f.DidCollide() ? f.hitUid : -1;
    }
    _GetRayNormalX(f) {
      const h = this._ray;
      return h.DidCollide() ? h.hitX + f * h.normalX : 0;
    }
    _GetRayNormalY(f) {
      const h = this._ray;
      return h.DidCollide() ? h.hitY + f * h.normalY : 0;
    }
    _GetRayNormalAngle() {
      const f = this._ray;
      return f.DidCollide() ? f.hitNormal : 0;
    }
    _GetRayReflectionX(f) {
      const h = this._ray;
      return h.DidCollide() ? h.hitX + f * h.reflectionX : 0;
    }
    _GetRayReflectionY(f) {
      const h = this._ray;
      return h.DidCollide() ? h.hitY + f * h.reflectionY : 0;
    }
    _GetRayReflectionAngle() {
      const f = this._ray;
      return f.DidCollide() ? Math.atan2(f.reflectionY, f.reflectionX) : 0;
    }
    _SetRange(f) {
      this._range = f;
    }
    _GetRange() {
      return this._range;
    }
    _SetConeOfView(f) {
      this._cone = f;
    }
    _GetConeOfView() {
      return this._cone;
    }
    GetPropertyValueByIndex(f) {
      switch (f) {
        case 0:
          return this._obstacleMode;
        case 1:
          return this._range;
        case 2:
          return e.toDegrees(this._cone);
        case 3:
          return this._useCollisionCells;
      }
    }
    SetPropertyValueByIndex(f, h) {
      switch (f) {
        case 0:
          this._obstacleMode = h;
          break;
        case 1:
          this._range = h;
          break;
        case 2:
          this._cone = e.toRadians(h);
          break;
        case 3:
          this._useCollisionCells = !!h;
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: "$" + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: "behaviors.los.properties.range.name",
              value: this._GetRange(),
              onedit: (f) => this._SetRange(f),
            },
            {
              name: "behaviors.los.properties.cone-of-view.name",
              value: e.toDegrees(this._GetConeOfView()),
              onedit: (f) => this._SetConeOfView(e.toRadians(f)),
            },
          ],
        },
      ];
    }
    GetScriptInterfaceClass() {
      return self.ILOSBehaviorInstance;
    }
  };
  const d = new WeakMap();
  self.ILOSBehaviorInstance = class extends a {
    constructor() {
      super();
      const f = a._GetInitInst().GetSdkInstance();
      d.set(this, f);
      this.ray = new self.ILOSBehaviorRay(f);
    }
    set range(f) {
      b.RequireFiniteNumber(f);
      d.get(this)._SetRange(f);
    }
    get range() {
      return d.get(this)._GetRange();
    }
    set coneOfView(f) {
      b.RequireFiniteNumber(f);
      d.get(this)._SetConeOfView(f);
    }
    get coneOfView() {
      return d.get(this)._GetConeOfView();
    }
    hasLOStoPosition(f, h) {
      b.RequireNumber(f);
      b.RequireNumber(h);
      return d.get(this).HasLOSTo(f, h);
    }
    hasLOSBetweenPositions(f, h, g, k, m) {
      b.RequireNumber(f);
      b.RequireNumber(h);
      b.RequireNumber(g);
      b.RequireNumber(k);
      b.RequireNumber(m);
      return d.get(this).HasLOSBetweenPositions(f, h, g, k, m);
    }
    castRay(f, h, g, k, m = !0) {
      b.RequireNumber(f);
      b.RequireNumber(h);
      b.RequireNumber(g);
      b.RequireNumber(k);
      d.get(this).CastRay(f, h, g, k, m);
      return this.ray;
    }
  };
  self.ILOSBehaviorRay = class {
    constructor(f) {
      d.set(this, f);
    }
    get didCollide() {
      return d.get(this)._GetRay().DidCollide();
    }
    get hitX() {
      return d.get(this)._GetRayHitX();
    }
    get hitY() {
      return d.get(this)._GetRayHitY();
    }
    get hitDistance() {
      return d.get(this)._GetRayHitDistance();
    }
    get hitUid() {
      return d.get(this)._GetRayHitUID();
    }
    getNormalX(f) {
      b.RequireFiniteNumber(f);
      return d.get(this)._GetRayNormalX(f);
    }
    getNormalY(f) {
      b.RequireFiniteNumber(f);
      return d.get(this)._GetRayNormalY(f);
    }
    get normalAngle() {
      return d.get(this)._GetRayNormalAngle();
    }
    getReflectionX(f) {
      b.RequireFiniteNumber(f);
      return d.get(this)._GetRayReflectionX(f);
    }
    getReflectionY(f) {
      b.RequireFiniteNumber(f);
      return d.get(this)._GetRayReflectionY(f);
    }
    get reflectionAngle() {
      return d.get(this)._GetRayReflectionAngle();
    }
  };
}
{
  const e = self.C3,
    b = new Set(),
    a = new Set();
  e.Behaviors.LOS.Cnds = {
    HasLOSToPosition(c, d) {
      return this.HasLOSTo(c, d);
    },
    RayIntersected() {
      return this._ray.DidCollide();
    },
    HasLOSBetweenPositions(c, d, f, h, g) {
      return this.HasLOSBetweenPositions(c, d, e.toRadians(f), h, g);
    },
    HasLOSToObject(c, d) {
      if (!c) return !1;
      var f = this._runtime.GetCurrentCondition();
      const h = f.GetEventBlock().IsOrBlock();
      var g = f.GetRuntime();
      const k = f.GetObjectClass().GetCurrentSol();
      c = c.GetCurrentSol();
      let m = k.GetInstances(),
        q = c.GetInstances();
      k.IsSelectAll()
        ? e.clearArray(k._GetOwnElseInstances())
        : h &&
          (m =
            g.IsCurrentConditionFirst() &&
            !k._GetOwnElseInstances().length &&
            k._GetOwnInstances().length
              ? k._GetOwnInstances()
              : k._GetOwnElseInstances());
      c.IsSelectAll()
        ? e.clearArray(c._GetOwnElseInstances())
        : h &&
          (q =
            g.IsCurrentConditionFirst() &&
            !c._GetOwnElseInstances().length &&
            c._GetOwnInstances().length
              ? c._GetOwnInstances()
              : c._GetOwnElseInstances());
      f = f.IsInverted();
      g = this.GetSdkType();
      for (const v of m) {
        let r = !1;
        const n = g.FindLOSBehavior(v);
        if (0 === q.length) f && (r = !0);
        else
          for (const p of q)
            v !== p &&
              e.xor(n.HasLOSToInstance(p, d), f) &&
              ((r = !0), a.add(p));
        r && b.add(v);
      }
      h
        ? (m === k._GetOwnElseInstances()
            ? k.TransferElseInstancesToOwn(b)
            : (k.AddElseInstances(b, m), k.SetSetPicked(b)),
          q === c._GetOwnElseInstances()
            ? c.TransferElseInstancesToOwn(a)
            : (c.AddElseInstances(a, q), c.SetSetPicked(a)))
        : (k.SetSetPicked(b), c.SetSetPicked(a));
      b.clear();
      a.clear();
      return k.HasAnyInstances();
    },
  };
}
{
  const e = self.C3;
  e.Behaviors.LOS.Acts = {
    SetRange(b) {
      this._SetRange(b);
    },
    SetCone(b) {
      this._SetConeOfView(e.toRadians(b));
    },
    CastRay(b, a, c, d, f) {
      this.CastRay(b, a, c, d, f);
    },
    AddObstacle(b) {
      const a = this.GetSdkType().GetObstacleTypes();
      if (!a.includes(b)) {
        for (const c of a) if (c.IsFamily() && c.FamilyHasMember(b)) return;
        a.push(b);
      }
    },
    ClearObstacles() {
      e.clearArray(this.GetSdkType().GetObstacleTypes());
    },
  };
}
{
  const e = self.C3;
  e.Behaviors.LOS.Exps = {
    Range() {
      return this._GetRange();
    },
    ConeOfView() {
      return e.toDegrees(this._GetConeOfView());
    },
    HitX() {
      return this._GetRayHitX();
    },
    HitY() {
      return this._GetRayHitY();
    },
    HitDistance() {
      return this._GetRayHitDistance();
    },
    HitUID() {
      return this._GetRayHitUID();
    },
    NormalX(b) {
      return this._GetRayNormalX(b);
    },
    NormalY(b) {
      return this._GetRayNormalY(b);
    },
    NormalAngle() {
      return e.toDegrees(this._GetRayNormalAngle());
    },
    ReflectionX(b) {
      return this._GetRayReflectionX(b);
    },
    ReflectionY(b) {
      return this._GetRayReflectionY(b);
    },
    ReflectionAngle() {
      return e.toDegrees(this._GetRayReflectionAngle());
    },
  };
}
("use strict");
{
  const e = self.C3;
  e.Behaviors.jumpthru = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.jumpthru.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3;
  e.Behaviors.jumpthru.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b);
      this.SetEnabled(!0);
      a && this.SetEnabled(a[0]);
    }
    Release() {
      super.Release();
    }
    SetEnabled(b) {
      this._inst._SetJumpthruEnabled(!!b);
    }
    IsEnabled() {
      return this._inst._IsJumpthruEnabled();
    }
    SaveToJson() {
      return { e: this.IsEnabled() };
    }
    LoadFromJson(b) {
      this.SetEnabled(b.e);
    }
    GetPropertyValueByIndex(b) {
      switch (b) {
        case 0:
          return this.IsEnabled();
      }
    }
    SetPropertyValueByIndex(b, a) {
      switch (b) {
        case 0:
          this.SetEnabled(a);
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: "$" + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: "behaviors.jumpthru.properties.enabled.name",
              value: this.IsEnabled(),
              onedit: (b) => this.SetEnabled(b),
            },
          ],
        },
      ];
    }
  };
}
self.C3.Behaviors.jumpthru.Cnds = {
  IsEnabled() {
    return this.IsEnabled();
  },
};
self.C3.Behaviors.jumpthru.Acts = {
  SetEnabled(e) {
    this.SetEnabled(e);
  },
};
self.C3.Behaviors.jumpthru.Exps = {};
("use strict");
{
  const e = self.C3;
  e.Behaviors.Turret = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Turret.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
      this._targetTypes = [];
    }
    Release() {
      e.clearArray(this._targetTypes);
      super.Release();
    }
    OnCreate() {}
    GetTargetTypes() {
      return this._targetTypes;
    }
  };
}
{
  const e = self.C3,
    b = e.New(e.Rect),
    a = [];
  e.Behaviors.Turret.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(c, d) {
      super(c);
      this._range = 300;
      this._rateOfFire = 1;
      this._isRotateEnabled = !0;
      this._rotateSpeed = e.toRadians(180);
      this._targetMode = 0;
      this._predictiveAim = !1;
      this._projectileSpeed = 500;
      this._isEnabled = this._useCollisionCells = !0;
      this._fireTimeCount = this._lastCheckTime = 0;
      this._currentTarget = null;
      this._loadTargetUid = -1;
      this._oldTargetY = this._oldTargetX = 0;
      this._lastSpeeds = [0, 0, 0, 0];
      this._speedsCount = 0;
      this._firstTickWithTarget = !0;
      d &&
        ((this._range = d[0]),
        (this._rateOfFire = d[1]),
        (this._isRotateEnabled = !!d[2]),
        (this._rotateSpeed = e.toRadians(d[3])),
        (this._targetMode = d[4]),
        (this._predictiveAim = !!d[5]),
        (this._projectileSpeed = d[6]),
        (this._useCollisionCells = !!d[7]),
        (this._isEnabled = !!d[8]));
      this._fireTimeCount = this._rateOfFire;
      c = this._runtime.Dispatcher();
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(c, "instancedestroy", (f) =>
          this._OnInstanceDestroyed(f.instance)
        ),
        e.Disposable.From(c, "afterload", (f) => this._OnAfterLoad())
      );
      this._isEnabled && this._StartTicking();
    }
    Release() {
      this._currentTarget = null;
      super.Release();
    }
    _OnAfterLoad() {
      this._currentTarget =
        -1 === this._loadTargetUid
          ? null
          : this._runtime.GetInstanceByUID(this._loadTargetUid);
    }
    _OnInstanceDestroyed(c) {
      this._currentTarget === c && (this._currentTarget = null);
    }
    SaveToJson() {
      return {
        r: this._range,
        rof: this._rateOfFire,
        re: this._isRotateEnabled,
        rs: this._rotateSpeed,
        tm: this._targetMode,
        pa: this._predictiveAim,
        ps: this._projectileSpeed,
        ucc: this._useCollisionCells,
        e: this._isEnabled,
        lct: this._lastCheckTime,
        ftc: this._fireTimeCount,
        t: this._currentTarget ? this._currentTarget.GetUID() : -1,
        ox: this._oldTargetX,
        oy: this._oldTargetY,
        ls: this._lastSpeeds,
        sc: this._speedsCount,
        targs: this.GetSdkType()
          .GetTargetTypes()
          .map((c) => c.GetSID()),
      };
    }
    LoadFromJson(c) {
      this._range = c.r;
      this._rateOfFire = c.rof;
      this._isRotateEnabled = c.re;
      this._rotateSpeed = c.rs;
      this._targetMode = c.tm;
      this._predictiveAim = c.pa;
      this._projectileSpeed = c.ps;
      this._useCollisionCells = c.ucc;
      this._SetEnabled(c.e);
      this._lastCheckTime = c.lct;
      this._fireTimeCount = c.ftc;
      this._loadTargetUid = c.t;
      this._oldTargetX = c.ox;
      this._oldTargetY = c.oy;
      this._lastSpeeds = c.ls;
      this._speedsCount = c.sc;
      const d = this.GetSdkType().GetTargetTypes();
      e.clearArray(d);
      for (const f of c.targs)
        (c = this._runtime.GetObjectClassBySID(f)) && d.push(c);
    }
    AddSpeed(c) {
      4 > this._speedsCount
        ? ((this._lastSpeeds[this._speedsCount] = c), this._speedsCount++)
        : (this._lastSpeeds.shift(), this._lastSpeeds.push(c));
    }
    GetSpeed() {
      let c = 0;
      for (let d = 0; d < this._speedsCount; ++d) c += this._lastSpeeds[d];
      return c / this._speedsCount;
    }
    IsInRange(c) {
      var d = this.GetWorldInfo();
      const f = c.GetWorldInfo();
      c = f.GetX() - d.GetX();
      d = f.GetY() - d.GetY();
      return c * c + d * d <= this._range * this._range;
    }
    LookForFirstTarget() {
      const c = this.GetWorldInfo(),
        d = this.GetSdkType().GetTargetTypes(),
        f = this._runtime.GetCollisionEngine();
      if (this._useCollisionCells)
        b.set(
          c.GetX() - this._range,
          c.GetY() - this._range,
          c.GetX() + this._range,
          c.GetY() + this._range
        ),
          f.GetObjectClassesCollisionCandidates(null, d, b, a);
      else for (const h of d) e.appendArray(a, h.GetInstances());
      for (const h of a)
        if (h !== this._inst && this.IsInRange(h)) {
          this._currentTarget = h;
          e.clearArray(a);
          return;
        }
      e.clearArray(a);
    }
    LookForNearestTarget() {
      var c = this.GetWorldInfo(),
        d = this.GetSdkType().GetTargetTypes(),
        f = this._runtime.GetCollisionEngine();
      const h = c.GetX();
      c = c.GetY();
      let g = this._range * this._range;
      this._currentTarget = null;
      if (this._useCollisionCells)
        b.set(
          h - this._range,
          c - this._range,
          h + this._range,
          c + this._range
        ),
          f.GetObjectClassesCollisionCandidates(null, d, b, a);
      else for (const k of d) e.appendArray(a, k.GetInstances());
      for (const k of a)
        k !== this._inst &&
          ((f = k.GetWorldInfo()),
          (d = h - f.GetX()),
          (f = c - f.GetY()),
          (d = d * d + f * f),
          d < g && ((this._currentTarget = k), (g = d)));
      e.clearArray(a);
    }
    _OnTargetAcquired() {
      this._speedsCount = 0;
      this._firstTickWithTarget = !0;
      const c = this._currentTarget.GetWorldInfo();
      this._oldTargetX = c.GetX();
      this._oldTargetY = c.GetY();
      this.Trigger(e.Behaviors.Turret.Cnds.OnTargetAcquired);
    }
    Tick() {
      if (this._isEnabled) {
        var c = this._runtime.GetDt(this._inst),
          d = this._runtime.GetGameTime(),
          f = this.GetWorldInfo();
        this._currentTarget &&
          !this.IsInRange(this._currentTarget) &&
          ((this._currentTarget = null),
          (this._speedsCount = 0),
          (this._firstTickWithTarget = !0));
        d >= this._lastCheckTime + 0.1 &&
          (((this._lastCheckTime = d),
          0 !== this._targetMode || this._currentTarget)
            ? 1 === this._targetMode &&
              ((d = this._currentTarget),
              this.LookForNearestTarget(),
              this._currentTarget &&
                this._currentTarget !== d &&
                this._OnTargetAcquired())
            : (this.LookForFirstTarget(),
              this._currentTarget && this._OnTargetAcquired()));
        this._fireTimeCount += c;
        if (this._currentTarget) {
          var h = this._currentTarget.GetWorldInfo();
          d = e.angleTo(f.GetX(), f.GetY(), h.GetX(), h.GetY());
          if (this._predictiveAim) {
            var g = f.GetX();
            const k = f.GetY(),
              m = h.GetX();
            h = h.GetY();
            const q = e.angleTo(m, h, this._oldTargetX, this._oldTargetY);
            this._firstTickWithTarget ||
              this.AddSpeed(
                e.distanceTo(m, h, this._oldTargetX, this._oldTargetY) / c
              );
            const v = this.GetSpeed(),
              r = h - k,
              n = m - g;
            g =
              Math.asin(
                (v * Math.sin(q) * (g - m) - v * Math.cos(q) * (k - h)) /
                  this._projectileSpeed /
                  Math.sqrt(r * r + n * n)
              ) -
              Math.atan2(r, -n) +
              Math.PI;
            isNaN(g) || (d = g);
          }
          this._isRotateEnabled &&
            (f.SetAngle(e.angleRotate(f.GetAngle(), d, this._rotateSpeed * c)),
            f.SetBboxChanged());
          this._fireTimeCount >= this._rateOfFire &&
            (!this._isRotateEnabled ||
              0.1 >= e.toDegrees(e.angleDiff(f.GetAngle(), d))) &&
            (!this._predictiveAim || 4 <= this._speedsCount) &&
            ((this._fireTimeCount -= this._rateOfFire),
            this._fireTimeCount >= this._rateOfFire &&
              (this._fireTimeCount = 0),
            this.Trigger(e.Behaviors.Turret.Cnds.OnShoot));
          this._currentTarget &&
            ((h = this._currentTarget.GetWorldInfo()),
            (this._oldTargetX = h.GetX()),
            (this._oldTargetY = h.GetY()));
          this._firstTickWithTarget = !1;
        }
        this._fireTimeCount > this._rateOfFire &&
          (this._fireTimeCount = this._rateOfFire);
      }
    }
    GetPropertyValueByIndex(c) {
      switch (c) {
        case 0:
          return this._range;
        case 1:
          return this._rateOfFire;
        case 2:
          return this._isRotateEnabled;
        case 3:
          return e.toDegrees(this._rotateSpeed);
        case 4:
          return this._targetMode;
        case 5:
          return this._predictiveAim;
        case 6:
          return this._projectileSpeed;
        case 7:
          return this._useCollisionCells;
        case 8:
          return this._isEnabled;
      }
    }
    SetPropertyValueByIndex(c, d) {
      switch (c) {
        case 0:
          this._range = d;
          break;
        case 1:
          this._rateOfFire = d;
          break;
        case 2:
          this._isRotateEnabled = !!d;
          break;
        case 3:
          if (!this._isRotateEnabled) break;
          this._rotateSpeed = e.toRadians(d);
          break;
        case 4:
          this._targetMode = d;
          break;
        case 5:
          this._predictiveAim = !!d;
          break;
        case 6:
          if (!this._predictiveAim) break;
          this._projectileSpeed = d;
          break;
        case 7:
          this._useCollisionCells = !!d;
          break;
        case 8:
          this._SetEnabled(d);
      }
    }
    _SetEnabled(c) {
      (this._isEnabled = !!c) ? this._StartTicking() : this._StopTicking();
    }
    GetDebuggerProperties() {
      return [
        {
          title: "$" + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: "behaviors.turret.properties.range.name",
              value: this._range,
              onedit: (c) => (this._range = c),
            },
            {
              name: "behaviors.turret.properties.rate-of-fire.name",
              value: this._rateOfFire,
              onedit: (c) => (this._rateOfFire = c),
            },
            {
              name: "behaviors.turret.properties.rotate-speed.name",
              value: e.toDegrees(this._rotateSpeed),
              onedit: (c) => (this._rotateSpeed = e.toRadians(c)),
            },
            {
              name: "behaviors.turret.properties.predictive-aim.name",
              value: this._predictiveAim,
              onedit: (c) => (this._predictiveAim = c),
            },
            {
              name: "behaviors.turret.properties.projectile-speed.name",
              value: this._projectileSpeed,
              onedit: (c) => (this._projectileSpeed = c),
            },
            {
              name: "behaviors.turret.debugger.has-target",
              value: !!this._currentTarget,
            },
            {
              name: "behaviors.turret.debugger.target-uid",
              value: this._currentTarget ? this._currentTarget.GetUID() : 0,
            },
            {
              name: "behaviors.turret.properties.enabled.name",
              value: this._isEnabled,
              onedit: (c) => this._SetEnabled(c),
            },
          ],
        },
      ];
    }
  };
}
self.C3.Behaviors.Turret.Cnds = {
  HasTarget() {
    return !!this._currentTarget;
  },
  OnShoot() {
    return !0;
  },
  OnTargetAcquired() {
    return !0;
  },
  IsEnabled() {
    return this._isEnabled;
  },
};
{
  const e = self.C3;
  e.Behaviors.Turret.Acts = {
    AcquireTarget(b) {
      if (b) {
        b = b.GetCurrentSol().GetInstances();
        for (const a of b)
          if (
            this._currentTarget !== a &&
            this._inst !== a &&
            this.IsInRange(a)
          ) {
            this._currentTarget = a;
            this._OnTargetAcquired();
            break;
          }
      }
    },
    AddTarget(b) {
      const a = this.GetSdkType().GetTargetTypes();
      if (!a.includes(b)) {
        for (const c of a) if (c.IsFamily() && c.FamilyHasMember(b)) return;
        a.push(b);
      }
    },
    ClearTargets() {
      e.clearArray(this.GetSdkType().GetTargetTypes());
    },
    UnacquireTarget() {
      this._currentTarget = null;
      this._speedsCount = 0;
      this._firstTickWithTarget = !0;
    },
    SetEnabled(b) {
      this._SetEnabled(0 !== b);
    },
    SetRange(b) {
      this._range = b;
    },
    SetRateOfFire(b) {
      this._rateOfFire = b;
    },
    SetRotate(b) {
      this._isRotateEnabled = 0 !== b;
    },
    SetRotateSpeed(b) {
      this._rotateSpeed = e.toRadians(b);
    },
    SetTargetMode(b) {
      this._targetMode = b;
    },
    SetPredictiveAim(b) {
      this._predictiveAim = 0 !== b;
    },
    SetProjectileSpeed(b) {
      this._projectileSpeed = b;
    },
  };
}
{
  const e = self.C3;
  e.Behaviors.Turret.Exps = {
    TargetUID() {
      return this._currentTarget ? this._currentTarget.GetUID() : 0;
    },
    Range() {
      return this._range;
    },
    RateOfFire() {
      return this._rateOfFire;
    },
    RotateSpeed() {
      return e.toDegrees(this._rotateSpeed);
    },
  };
}
("use strict");
{
  const e = self.C3;
  e.Behaviors.EightDir = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.EightDir.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3,
    b = self.C3X,
    a = self.IBehaviorInstance;
  e.Behaviors.EightDir.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(f, h) {
      super(f);
      this._simRight =
        this._simLeft =
        this._simDown =
        this._simUp =
        this._ignoreInput =
        this._rightKey =
        this._leftKey =
        this._downKey =
        this._upKey =
          !1;
      this._dy = this._dx = 0;
      this._maxSpeed = 200;
      this._acc = 600;
      this._dec = 500;
      this._angleMode = this._directions = 3;
      this._isEnabled = this._defaultControls = !0;
      h &&
        ((this._maxSpeed = h[0]),
        (this._acc = h[1]),
        (this._dec = h[2]),
        (this._directions = h[3]),
        (this._angleMode = h[4]),
        (this._defaultControls = !!h[5]),
        (this._isEnabled = !!h[6]));
      this._isEnabled && this._StartTicking();
      this._defaultControls && this._BindEvents();
    }
    _BindEvents() {
      if (!this._disposables) {
        var f = this._runtime.Dispatcher();
        this._disposables = new e.CompositeDisposable(
          e.Disposable.From(f, "keydown", (h) => this._OnKeyDown(h.data)),
          e.Disposable.From(f, "keyup", (h) => this._OnKeyUp(h.data)),
          e.Disposable.From(f, "window-blur", () =>
            this._OnWindowOrKeyboardBlur()
          ),
          e.Disposable.From(f, "keyboard-blur", () =>
            this._OnWindowOrKeyboardBlur()
          )
        );
      }
    }
    _UnBindEvents() {
      this._disposables &&
        (this._disposables.Release(), (this._disposables = null));
    }
    Release() {
      super.Release();
    }
    SaveToJson() {
      return {
        dx: this._dx,
        dy: this._dy,
        e: this._isEnabled,
        ms: this._maxSpeed,
        acc: this._acc,
        dec: this._dec,
        d: this._directions,
        am: this._angleMode,
        dc: this._defaultControls,
        ii: this._ignoreInput,
      };
    }
    LoadFromJson(f) {
      this._dx = f.dx;
      this._dy = f.dy;
      this._SetEnabled(f.e);
      this._maxSpeed = f.ms;
      this._acc = f.acc;
      this._dec = f.dec;
      this._directions = f.d;
      this._angleMode = f.am;
      this._defaultControls = f.dc;
      this._ignoreInput = f.ii;
      this._simRight =
        this._simLeft =
        this._simDown =
        this._simUp =
        this._rightKey =
        this._leftKey =
        this._downKey =
        this._upKey =
          !1;
      this._defaultControls ? this._BindEvents() : this._UnBindEvents();
    }
    _OnKeyDown(f) {
      switch (f.key) {
        case "ArrowLeft":
          this._leftKey = !0;
          break;
        case "ArrowUp":
          this._upKey = !0;
          break;
        case "ArrowRight":
          this._rightKey = !0;
          break;
        case "ArrowDown":
          this._downKey = !0;
      }
    }
    _OnKeyUp(f) {
      switch (f.key) {
        case "ArrowLeft":
          this._leftKey = !1;
          break;
        case "ArrowUp":
          this._upKey = !1;
          break;
        case "ArrowRight":
          this._rightKey = !1;
          break;
        case "ArrowDown":
          this._downKey = !1;
      }
    }
    _OnWindowOrKeyboardBlur() {
      this._rightKey = this._leftKey = this._downKey = this._upKey = !1;
    }
    Tick() {
      var f = this._runtime.GetDt(this._inst);
      const h = this._runtime.GetCollisionEngine();
      var g = this._leftKey || this._simLeft,
        k = this._rightKey || this._simRight,
        m = this._upKey || this._simUp,
        q = this._downKey || this._simDown;
      this._simDown = this._simUp = this._simRight = this._simLeft = !1;
      if (this._isEnabled) {
        var v = h.TestOverlapSolid(this._inst);
        if (
          v &&
          (h.RegisterCollision(this._inst, v),
          !h.PushOutSolidNearest(this._inst))
        )
          return;
        this._ignoreInput && (g = k = m = q = !1);
        0 === this._directions
          ? (g = k = !1)
          : 1 === this._directions && (m = q = !1);
        2 === this._directions && (m || q) && (g = k = !1);
        g === k &&
          (0 > this._dx
            ? (this._dx = Math.min(this._dx + this._dec * f, 0))
            : 0 < this._dx &&
              (this._dx = Math.max(this._dx - this._dec * f, 0)));
        m === q &&
          (0 > this._dy
            ? (this._dy = Math.min(this._dy + this._dec * f, 0))
            : 0 < this._dy &&
              (this._dy = Math.max(this._dy - this._dec * f, 0)));
        var r = (v = 0);
        g && !k && (v = 0 < this._dx ? -(this._acc + this._dec) : -this._acc);
        k && !g && (v = 0 > this._dx ? this._acc + this._dec : this._acc);
        m && !q && (r = 0 < this._dy ? -(this._acc + this._dec) : -this._acc);
        q && !m && (r = 0 > this._dy ? this._acc + this._dec : this._acc);
        this._dx += v * f;
        this._dy += r * f;
        if (0 !== this._dx || 0 !== this._dy) {
          k = Math.atan2(this._dy, this._dx);
          g = this._maxSpeed * Math.cos(k);
          k = this._maxSpeed * Math.sin(k);
          Math.sqrt(this._dx * this._dx + this._dy * this._dy) >
            this._maxSpeed && ((this._dx = g), (this._dy = k));
          var n = Math.abs(g) * f;
          q = Math.abs(k) * f;
          g = this._inst.GetWorldInfo();
          const p = g.GetX();
          m = g.GetY();
          k = g.GetAngle();
          n = e.clamp(this._dx * f + 0.5 * v * f * f, -n, n);
          g.OffsetX(n);
          g.SetBboxChanged();
          if ((v = h.TestOverlapSolid(this._inst)))
            h.PushOutSolid(
              this._inst,
              0 > this._dx ? 1 : -1,
              0,
              Math.max(Math.abs(Math.floor(n)), 1)
            ) || (g.SetX(p), g.SetBboxChanged()),
              (this._dx = 0),
              h.RegisterCollision(this._inst, v);
          f = e.clamp(this._dy * f + 0.5 * r * f * f, -q, q);
          g.OffsetY(f);
          g.SetBboxChanged();
          if ((v = h.TestOverlapSolid(this._inst)))
            h.PushOutSolid(
              this._inst,
              0,
              0 > this._dy ? 1 : -1,
              Math.max(Math.abs(Math.floor(f)), 1)
            ) || (g.SetY(m), g.SetBboxChanged()),
              (this._dy = 0),
              h.RegisterCollision(this._inst, v);
          f = e.round6dp(this._dx);
          r = e.round6dp(this._dy);
          (0 === f && 0 === r) ||
            !this._inst.GetPlugin().IsRotatable() ||
            (1 === this._angleMode
              ? g.SetAngle(
                  e.toRadians(
                    90 * Math.round(e.toDegrees(Math.atan2(r, f)) / 90)
                  )
                )
              : 2 === this._angleMode
              ? g.SetAngle(
                  e.toRadians(
                    45 * Math.round(e.toDegrees(Math.atan2(r, f)) / 45)
                  )
                )
              : 3 === this._angleMode && g.SetAngle(Math.atan2(r, f)));
          g.SetBboxChanged();
          g.GetAngle() != k &&
            (v = h.TestOverlapSolid(this._inst)) &&
            (g.SetAngle(k),
            g.SetBboxChanged(),
            h.RegisterCollision(this._inst, v));
        }
      }
    }
    GetPropertyValueByIndex(f) {
      switch (f) {
        case 0:
          return this._GetMaxSpeed();
        case 1:
          return this._GetAcceleration();
        case 2:
          return this._GetDeceleration();
        case 3:
          return this._directions;
        case 4:
          return this._angleMode;
        case 5:
          return this._IsDefaultControls();
        case 6:
          return this._IsEnabled();
      }
    }
    SetPropertyValueByIndex(f, h) {
      switch (f) {
        case 0:
          this._SetMaxSpeed(h);
          break;
        case 1:
          this._SetAcceleration(h);
          break;
        case 2:
          this._SetDeceleration(h);
          break;
        case 3:
          this._directions = h;
          break;
        case 4:
          this._angleMode = h;
          break;
        case 5:
          this._SetDefaultControls(!!h);
          break;
        case 6:
          this._SetEnabled(!!h);
      }
    }
    _Stop() {
      this._dy = this._dx = 0;
    }
    _Reverse() {
      this._dx *= -1;
      this._dy *= -1;
    }
    _MaybeClampSpeed() {
      const f = Math.hypot(this._dx, this._dy);
      f > this._maxSpeed && this._SetSpeed(f);
    }
    _SetSpeed(f) {
      f = e.clamp(f, 0, this._maxSpeed);
      const h = Math.atan2(this._dy, this._dx);
      this._dx = f * Math.cos(h);
      this._dy = f * Math.sin(h);
    }
    _GetSpeed() {
      return Math.hypot(this._dx, this._dy);
    }
    _SetMaxSpeed(f) {
      this._maxSpeed = Math.max(f, 0);
    }
    _GetMaxSpeed() {
      return this._maxSpeed;
    }
    _SetAcceleration(f) {
      this._acc = Math.max(f, 0);
    }
    _GetAcceleration() {
      return this._acc;
    }
    _SetDeceleration(f) {
      this._dec = Math.max(f, 0);
    }
    _GetDeceleration() {
      return this._dec;
    }
    _GetMovingAngle() {
      return Math.atan2(this._dy, this._dx);
    }
    _SetVectorX(f) {
      this._dx = f;
      this._MaybeClampSpeed();
    }
    _GetVectorX() {
      return this._dx;
    }
    _SetVectorY(f) {
      this._dy = f;
      this._MaybeClampSpeed();
    }
    _GetVectorY() {
      return this._dy;
    }
    _SimulateControl(f) {
      if (this._isEnabled)
        switch (f) {
          case 0:
            this._simLeft = !0;
            break;
          case 1:
            this._simRight = !0;
            break;
          case 2:
            this._simUp = !0;
            break;
          case 3:
            this._simDown = !0;
        }
    }
    _SetDefaultControls(f) {
      f = !!f;
      this._defaultControls !== f &&
        ((this._defaultControls = f)
          ? this._BindEvents()
          : (this._UnBindEvents(), this._OnWindowOrKeyboardBlur()));
    }
    _IsDefaultControls() {
      return this._defaultControls;
    }
    _SetIgnoreInput(f) {
      this._ignoreInput = !!f;
    }
    _IsIgnoreInput() {
      return this._ignoreInput;
    }
    _SetEnabled(f) {
      (this._isEnabled = !!f)
        ? this._StartTicking()
        : ((this._simDown = this._simUp = this._simRight = this._simLeft = !1),
          this._StopTicking());
    }
    _IsEnabled() {
      return this._isEnabled;
    }
    GetDebuggerProperties() {
      return [
        {
          title: "$" + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: "behaviors.eightdir.debugger.vector-x",
              value: this._GetVectorX(),
              onedit: (f) => this._SetVectorX(f),
            },
            {
              name: "behaviors.eightdir.debugger.vector-y",
              value: this._GetVectorY(),
              onedit: (f) => this._SetVectorY(f),
            },
            {
              name: "behaviors.eightdir.debugger.speed",
              value: this._GetSpeed(),
              onedit: (f) => this._SetSpeed(f),
            },
            {
              name: "behaviors.eightdir.debugger.angle-of-motion",
              value: e.toDegrees(this._GetMovingAngle()),
            },
            {
              name: "behaviors.eightdir.properties.max-speed.name",
              value: this._GetMaxSpeed(),
              onedit: (f) => this._SetMaxSpeed(f),
            },
            {
              name: "behaviors.eightdir.properties.acceleration.name",
              value: this._GetAcceleration(),
              onedit: (f) => this._SetAcceleration(f),
            },
            {
              name: "behaviors.eightdir.properties.deceleration.name",
              value: this._GetDeceleration(),
              onedit: (f) => this._SetDeceleration(f),
            },
            {
              name: "behaviors.eightdir.properties.enabled.name",
              value: this._IsEnabled(),
              onedit: (f) => this._SetEnabled(f),
            },
          ],
        },
      ];
    }
    GetScriptInterfaceClass() {
      return self.I8DirectionBehaviorInstance;
    }
  };
  const c = new WeakMap(),
    d = new Map([
      ["left", 0],
      ["right", 1],
      ["up", 2],
      ["down", 3],
    ]);
  self.I8DirectionBehaviorInstance = class extends a {
    constructor() {
      super();
      c.set(this, a._GetInitInst().GetSdkInstance());
    }
    stop() {
      c.get(this)._Stop();
    }
    reverse() {
      c.get(this)._Reverse();
    }
    simulateControl(f) {
      b.RequireString(f);
      f = d.get(f);
      if ("number" !== typeof f) throw Error("invalid control");
      c.get(this)._SimulateControl(f);
    }
    get speed() {
      return c.get(this)._GetSpeed();
    }
    set speed(f) {
      b.RequireFiniteNumber(f);
      c.get(this)._SetSpeed(f);
    }
    get maxSpeed() {
      return c.get(this)._GetMaxSpeed();
    }
    set maxSpeed(f) {
      b.RequireFiniteNumber(f);
      c.get(this)._SetMaxSpeed(f);
    }
    get acceleration() {
      return c.get(this)._GetAcceleration();
    }
    set acceleration(f) {
      b.RequireFiniteNumber(f);
      c.get(this)._SetAcceleration(f);
    }
    get deceleration() {
      return c.get(this)._GetDeceleration();
    }
    set deceleration(f) {
      b.RequireFiniteNumber(f);
      c.get(this)._SetDeceleration(f);
    }
    get vectorX() {
      return c.get(this)._GetVectorX();
    }
    set vectorX(f) {
      b.RequireFiniteNumber(f);
      c.get(this)._SetVectorX(f);
    }
    get vectorY() {
      return c.get(this)._GetVectorY();
    }
    set vectorY(f) {
      b.RequireFiniteNumber(f);
      c.get(this)._SetVectorY(f);
    }
    get isDefaultControls() {
      return c.get(this)._IsDefaultControls();
    }
    set isDefaultControls(f) {
      c.get(this)._SetDefaultControls(!!f);
    }
    get isIgnoringInput() {
      return c.get(this)._IsIgnoreInput();
    }
    set isIgnoringInput(f) {
      c.get(this)._SetIgnoreInput(!!f);
    }
    get isEnabled() {
      return c.get(this)._IsEnabled();
    }
    set isEnabled(f) {
      c.get(this)._SetEnabled(!!f);
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.EightDir.Cnds = {
    IsMoving() {
      return 1e-10 < this._GetSpeed();
    },
    CompareSpeed(b, a) {
      return e.compare(this._GetSpeed(), b, a);
    },
    IsEnabled() {
      return this._IsEnabled();
    },
  };
}
self.C3.Behaviors.EightDir.Acts = {
  Stop() {
    this._Stop();
  },
  Reverse() {
    this._Reverse();
  },
  SetIgnoreInput(e) {
    this._SetIgnoreInput(e);
  },
  SetSpeed(e) {
    this._SetSpeed(e);
  },
  SetMaxSpeed(e) {
    this._SetMaxSpeed(e);
  },
  SetAcceleration(e) {
    this._SetAcceleration(e);
  },
  SetDeceleration(e) {
    this._SetDeceleration(e);
  },
  SimulateControl(e) {
    this._SimulateControl(e);
  },
  SetEnabled(e) {
    this._SetEnabled(e);
  },
  SetVectorX(e) {
    this._SetVectorX(e);
  },
  SetVectorY(e) {
    this._SetVectorY(e);
  },
  SetDefaultControls(e) {
    this._SetDefaultControls(!!e);
  },
};
{
  const e = self.C3;
  e.Behaviors.EightDir.Exps = {
    Speed() {
      return this._GetSpeed();
    },
    MaxSpeed() {
      return this._GetMaxSpeed();
    },
    Acceleration() {
      return this._GetAcceleration();
    },
    Deceleration() {
      return this._GetDeceleration();
    },
    MovingAngle() {
      return e.toDegrees(this._GetMovingAngle());
    },
    VectorX() {
      return this._GetVectorX();
    },
    VectorY() {
      return this._GetVectorY();
    },
  };
}
("use strict");
{
  const e = self.C3,
    b = self.C3X;
  let a = null,
    c = null,
    d = [],
    f = null,
    h = null;
  function g(m, q, v) {
    var r = m.GetSavedDataMap();
    const n = q.GetSavedDataMap();
    v
      ? ((r = r.get("Physics_DisabledCollisions")) && r.delete(q.GetSID()),
        (q = n.get("Physics_DisabledCollisions")) && q.delete(m.GetSID()))
      : ((v = r.get("Physics_DisabledCollisions")),
        v || ((v = new Set()), r.set("Physics_DisabledCollisions", v)),
        (r = n.get("Physics_DisabledCollisions")),
        r || ((r = new Set()), n.set("Physics_DisabledCollisions", r)),
        v.add(q.GetSID()),
        r.add(m.GetSID()));
  }
  e.Behaviors.Physics = class extends e.SDKBehaviorBase {
    constructor(m) {
      m.scriptInterfaceClass = self.IPhysicsBehavior;
      super(m);
      this._world = null;
      this._worldG = 10;
      this._worldScale = 0.02;
      this._worldManifold = null;
      this._lastUpdateTick = -1;
      this._steppingMode = 1;
      this._velocityIterations = 8;
      this._positionIterations = 3;
      this._allCollisionsEnabled = !0;
      this._runtime.AddLoadPromise(this._LoadBox2DWasm());
    }
    async _LoadBox2DWasm() {
      const m = await this._runtime
        .GetAssetManager()
        .GetProjectFileUrl("box2d.wasm");
      await new Promise((q) => {
        self.Box2DWasmModule({ wasmBinaryFile: m }).then((v) => {
          f = v;
          this._InitBox2DWorld();
          q();
        });
      });
    }
    _InitBox2DWorld() {
      const m = this._runtime.GetCollisionEngine();
      a = e.Behaviors.Physics.GetVec2(0, 0);
      c = e.Behaviors.Physics.GetVec2(0, 0);
      this._world = new f.b2World(
        e.Behaviors.Physics.GetTempVec2A(0, this._worldG),
        !0
      );
      var q = new f.JSContactListener();
      q.BeginContact = (v) => {
        var r = f.wrapPointer(v, f.b2Contact);
        v = e.Behaviors.Physics.Instance.LookupBehInstFromBody(
          r.GetFixtureA().GetBody()
        );
        r = e.Behaviors.Physics.Instance.LookupBehInstFromBody(
          r.GetFixtureB().GetBody()
        );
        m.RegisterCollision(v.GetObjectInstance(), r.GetObjectInstance());
      };
      q.EndContact = () => {};
      q.PreSolve = () => {};
      q.PostSolve = () => {};
      this._world.SetContactListener(q);
      q = new f.JSContactFilter();
      q.ShouldCollide = (v, r) => {
        if (this._allCollisionsEnabled) return !0;
        v = f.wrapPointer(v, f.b2Fixture);
        r = f.wrapPointer(r, f.b2Fixture);
        v = e.Behaviors.Physics.Instance.LookupBehInstFromBody(v.GetBody());
        r = e.Behaviors.Physics.Instance.LookupBehInstFromBody(r.GetBody());
        v = v.GetObjectInstance().GetObjectClass();
        const n = r.GetObjectInstance().GetObjectClass();
        r = v.GetSID();
        const p = n.GetSID();
        return (v = v.GetSavedDataMap().get("Physics_DisabledCollisions")) &&
          v.has(p)
          ? !1
          : (v = n.GetSavedDataMap().get("Physics_DisabledCollisions")) &&
            v.has(r)
          ? !1
          : !0;
      };
      this._world.SetContactFilter(q);
      this._worldManifold = new f.b2WorldManifold();
    }
    Release() {
      super.Release();
    }
    GetBox2D() {
      return f;
    }
    GetWorld() {
      return this._world;
    }
    GetWorldScale() {
      return this._worldScale;
    }
    GetSteppingMode() {
      return this._steppingMode;
    }
    SetSteppingMode(m) {
      this._steppingMode = m;
    }
    SetLastUpdateTick(m) {
      this._lastUpdateTick = m;
    }
    GetLastUpdateTick() {
      return this._lastUpdateTick;
    }
    SetVelocityIterations(m) {
      this._velocityIterations = Math.max(m, 1);
    }
    GetVelocityIterations() {
      return this._velocityIterations;
    }
    SetPositionIterations(m) {
      this._positionIterations = Math.max(m, 1);
    }
    GetPositionIterations() {
      return this._positionIterations;
    }
    SetIterations(m, q) {
      this.SetVelocityIterations(m);
      this.SetPositionIterations(q);
    }
    GetGravity() {
      return this._worldG;
    }
    SetGravity(m) {
      m !== this._worldG &&
        (this._world.SetGravity(e.Behaviors.Physics.GetTempVec2A(0, m)),
        (this._worldG = m),
        this._WakeUpAllPhysicsBodies());
    }
    _WakeUpAllPhysicsBodies() {
      for (const q of this.GetInstances()) {
        var m = e.Behaviors.Physics.Instance.LookupBehInstFromInst(q);
        m && (m = m.GetBody()) && m.SetAwake(!0);
      }
    }
    DisableShouldCollideFastPath() {
      this._allCollisionsEnabled = !1;
    }
    SetCollisionsEnabled(m, q, v) {
      v = !!v;
      if (m && q) {
        if (q.IsFamily()) for (const r of q.GetFamilyMembers()) g(m, r, v);
        else g(m, q, v);
        this.DisableShouldCollideFastPath();
      }
    }
    GetWorldManifold() {
      return this._worldManifold;
    }
    static GetPhysicsCollisionKey() {
      return "Physics_DisabledCollisions";
    }
    static GetVec2(m, q) {
      if (d.length) {
        const v = d.pop();
        v.set_x(m);
        v.set_y(q);
        return v;
      }
      return new f.b2Vec2(m, q);
    }
    static FreeVec2(m) {
      d.push(m);
    }
    static GetTempVec2A(m, q) {
      a.set_x(m);
      a.set_y(q);
      return a;
    }
    static GetTempVec2B(m, q) {
      c.set_x(m);
      c.set_y(q);
      return c;
    }
    static CreatePolygonShape(m) {
      const q = new f.b2PolygonShape(),
        v = f._malloc(8 * m.length);
      var r = 0;
      for (let n = 0; n < m.length; ++n)
        (f.HEAPF32[(v + r) >> 2] = m[n].get_x()),
          (f.HEAPF32[(v + (r + 4)) >> 2] = m[n].get_y()),
          (r += 8);
      r = f.wrapPointer(v, f.b2Vec2);
      q.Set(r, m.length);
      f._free(v);
      return q;
    }
  };
  const k = ["fixed", "variable"];
  self.IPhysicsBehavior = class extends self.IBehavior {
    constructor(m) {
      super(m);
      h = m;
    }
    set worldGravity(m) {
      b.RequireFiniteNumber(m);
      h.SetGravity(m);
    }
    get worldGravity() {
      return h.GetGravity();
    }
    set steppingMode(m) {
      m = k.indexOf(m);
      if (0 > m) throw Error("invalid stepping mode");
      h.SetSteppingMode(k[m]);
    }
    get steppingMode() {
      return k[h.GetSteppingMode()];
    }
    set velocityIterations(m) {
      b.RequireFiniteNumber(m);
      h.SetVelocityIterations(m);
    }
    get velocityIterations() {
      return h.GetVelocityIterations();
    }
    set positionIterations(m) {
      b.RequireFiniteNumber(m);
      h.SetPositionIterations(m);
    }
    get positionIterations() {
      return h.GetPositionIterations();
    }
    setCollisionsEnabled(m, q, v) {
      const r = h.GetRuntime();
      m = r._UnwrapIObjectClass(m);
      q = r._UnwrapIObjectClass(q);
      h.SetCollisionsEnabled(m, q, !!v);
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Physics.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3,
    b = self.C3X,
    a = self.IBehaviorInstance,
    c = new WeakMap(),
    d = new WeakMap(),
    f = new WeakMap(),
    h = e.Behaviors.Physics.GetTempVec2A,
    g = e.Behaviors.Physics.GetTempVec2B,
    k = e.New(e.Rect),
    m = e.New(e.Quad);
  e.Behaviors.Physics.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(r, n) {
      super(r);
      r = this.GetBehavior();
      const p = this.GetWorldInfo();
      this._box2d = r.GetBox2D();
      this._world = r.GetWorld();
      this._worldScale = r.GetWorldScale();
      this._isImmovable = !1;
      this._collisionMask = 0;
      this._preventRotation = !1;
      this._density = 1;
      this._friction = 0.5;
      this._restitution = 0.2;
      this._linearDamping = 0;
      this._angularDamping = 0.01;
      this._isBullet = !1;
      this._isEnabled = !0;
      this._body = null;
      this._fixtures = [];
      this._myJoints = [];
      this._myCreatedJoints = [];
      this._joiningMe = new Set();
      this._lastKnownX = p.GetX();
      this._lastKnownY = p.GetY();
      this._lastKnownAngle = p.GetAngle();
      this._lastHeight = this._lastWidth = 0;
      this._lastTickOverride = !1;
      n &&
        ((this._isImmovable = !!n[0]),
        (this._collisionMask = n[1]),
        (this._preventRotation = !!n[2]),
        (this._density = n[3]),
        (this._friction = n[4]),
        (this._restitution = n[5]),
        (this._linearDamping = n[6]),
        (this._angularDamping = n[7]),
        (this._isBullet = !!n[8]),
        (this._isEnabled = !!n[9]));
      n = this._runtime.Dispatcher();
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(n, "instancedestroy", (u) =>
          this._OnInstanceDestroyed(u.instance)
        ),
        e.Disposable.From(n, "beforeload", () => this._OnBeforeLoad()),
        e.Disposable.From(n, "afterload", () => this._OnAfterLoad())
      );
      d.set(this._inst, this);
      this._isEnabled && this._StartTicking();
    }
    PostCreate() {
      this._CreateBody();
    }
    Release() {
      this._DestroyMyJoints();
      e.clearArray(this._myCreatedJoints);
      this._joiningMe.clear();
      this._body &&
        (this._DestroyFixtures(),
        this._world.DestroyBody(this._body),
        (this._body = null));
      super.Release();
    }
    _CreateFixture(r) {
      if (this._body)
        return (r = this._body.CreateFixture(r)), this._fixtures.push(r), r;
    }
    _DestroyFixtures() {
      if (this._body) {
        for (const r of this._fixtures) this._body.DestroyFixture(r);
        e.clearArray(this._fixtures);
      }
    }
    _GetBoundingQuadExcludingMesh() {
      const r = this.GetWorldInfo();
      return r.HasMesh() ? (r.CalculateBbox(k, m, !1), m) : r.GetBoundingQuad();
    }
    _Destroy(r) {
      this._box2d.destroy(r);
    }
    _CreateBody() {
      if (this._isEnabled) {
        var r = this._box2d.b2FixtureDef,
          n = this._box2d.b2BodyDef,
          p = this.GetWorldInfo();
        if (!this._body) {
          n = new n();
          n.set_type(this._isImmovable ? 0 : 2);
          var u = this._GetBoundingQuadExcludingMesh();
          n.set_position(
            g(u.midX() * this._worldScale, u.midY() * this._worldScale)
          );
          n.set_angle(p.GetAngle());
          n.set_fixedRotation(this._preventRotation);
          n.set_linearDamping(this._linearDamping);
          n.set_angularDamping(this._angularDamping);
          n.set_bullet(this._isBullet);
          this._body = this._world.CreateBody(n);
          this._Destroy(n);
          c.set(this._body, this);
        }
        this._DestroyFixtures();
        r = new r();
        r.set_density(this._density);
        r.set_friction(this._friction);
        r.set_restitution(this._restitution);
        u = p.HasOwnCollisionPoly();
        n = this._collisionMask;
        u || this._inst.HasTilemap() || 0 !== n || (n = 1);
        u = Math.max(Math.abs(p.GetWidth()), 1);
        var w = Math.max(Math.abs(p.GetHeight()), 1);
        0 === n
          ? this._inst.HasTilemap()
            ? this._CreateTilemapFixtures(r)
            : this._CreatePolygonFixture(r, u, w)
          : 1 === n
          ? this._CreateBoundingBoxFixture(r, u, w)
          : this._CreateCircleFixture(r, u, w);
        this._lastWidth = p.GetWidth();
        this._lastHeight = p.GetHeight();
        p.SetPhysicsBodyChanged(!1);
        this._Destroy(r);
      }
    }
    _CreateBoundingBoxFixture(r, n, p) {
      const u = new this._box2d.b2PolygonShape();
      u.SetAsBox(n * this._worldScale * 0.5, p * this._worldScale * 0.5);
      r.set_shape(u);
      this._CreateFixture(r);
      this._Destroy(u);
    }
    _CreateCircleFixture(r, n, p) {
      const u = new this._box2d.b2CircleShape();
      u.set_m_radius(Math.min(n, p) * this._worldScale * 0.5);
      r.set_shape(u);
      this._CreateFixture(r);
      this._Destroy(u);
    }
    _CreatePolygonFixture(r, n, p) {
      var u = this.GetWorldInfo(),
        w = 0 > u.GetWidth();
      const y = 0 > u.GetHeight(),
        B = this._worldScale;
      var E = u.GetAngle();
      0 !== E && (u.SetAngle(0), u.SetBboxChanged());
      var z = this._GetBoundingQuadExcludingMesh();
      const D = z.midX() - u.GetX();
      z = z.midY() - u.GetY();
      0 !== E && (u.SetAngle(E), u.SetBboxChanged());
      E = u
        .GetCustomTransformedCollisionPoly(w ? -n : n, y ? -p : p, 0)
        .pointsArr();
      const J = E.length / 2;
      u = [];
      for (let C = 0; C < J; ++C)
        u.push(e.Behaviors.Physics.GetVec2(E[2 * C] - D, E[2 * C + 1] - z));
      w !== y && u.reverse();
      w = e.Behaviors.Physics.Separator.Separate(u, n * p);
      for (const C of u) e.Behaviors.Physics.FreeVec2(C);
      if (w.length)
        for (const C of w) {
          for (const H of C) H.set_x(H.get_x() * B), H.set_y(H.get_y() * B);
          n = e.Behaviors.Physics.CreatePolygonShape(C);
          r.set_shape(n);
          this._CreateFixture(r);
          this._Destroy(n);
          for (const H of C) e.Behaviors.Physics.FreeVec2(H);
        }
      else this._CreateBoundingBoxFixture(r, n, p);
    }
    _CreateTilemapFixtures(r) {
      var n = this.GetWorldInfo(),
        p = this._GetBoundingQuadExcludingMesh();
      const u = p.midX() - n.GetX();
      n = p.midY() - n.GetY();
      p = this._worldScale;
      const w = e.Behaviors.Physics.GetVec2,
        y = e.Behaviors.Physics.FreeVec2,
        B = [];
      this._inst.GetSdkInstance().GetAllCollisionRects(B);
      const E = [];
      for (let H = 0, K = B.length; H < K; ++H) {
        var z = B[H],
          D = z.GetRect(),
          J = z.GetPoly();
        if (J) {
          var C = f.get(J);
          if (!C) {
            C = J.pointsArr();
            const P = J.pointCount();
            for (let S = 0; S < P; ++S) E.push(w(C[2 * S], C[2 * S + 1]));
            z = z.GetTileId() & 3758096384;
            (-2147483648 === z ||
              1073741824 === z ||
              536870912 === z ||
              (z & -2147483648 && z & 1073741824 && z & 536870912)) &&
              E.reverse();
            C = e.Behaviors.Physics.Separator.Separate(
              E,
              D.width() * D.height()
            );
            f.set(J, C);
            for (const S of E) y(S);
            e.clearArray(E);
          }
          for (let P = 0, S = C.length; P < S; ++P) {
            J = C[P];
            for (let U = 0, V = J.length; U < V; ++U)
              E.push(
                w(
                  (D.getLeft() + J[U].get_x() - u) * p,
                  (D.getTop() + J[U].get_y() - n) * p
                )
              );
            J = e.Behaviors.Physics.CreatePolygonShape(E);
            r.set_shape(J);
            this._CreateFixture(r);
            this._Destroy(J);
            for (const U of E) y(U);
            e.clearArray(E);
          }
        } else
          E.push(w((D.getLeft() - u) * p, (D.getTop() - n) * p)),
            E.push(w((D.getRight() - u) * p, (D.getTop() - n) * p)),
            E.push(w((D.getRight() - u) * p, (D.getBottom() - n) * p)),
            E.push(w((D.getLeft() - u) * p, (D.getBottom() - n) * p)),
            (D = e.Behaviors.Physics.CreatePolygonShape(E)),
            r.set_shape(D),
            this._CreateFixture(r),
            this._Destroy(D);
        for (const P of E) y(P);
        e.clearArray(E);
      }
    }
    _DestroyBody() {
      this._body &&
        (this._DestroyMyJoints(),
        c.delete(this._body),
        this._DestroyFixtures(),
        this._world.DestroyBody(this._body),
        (this._body = null));
    }
    _DestroyMyJoints() {
      for (const r of this._myJoints) this._world.DestroyJoint(r);
      e.clearArray(this._myJoints);
    }
    _RecreateMyJoints() {
      for (const r of this._myCreatedJoints)
        switch (r.type) {
          case 0:
            this._DoCreateDistanceJoint(...r.params);
            break;
          case 1:
            this._DoCreateRevoluteJoint(...r.params);
            break;
          case 2:
            this._DoCreateLimitedRevoluteJoint(...r.params);
            break;
          case 3:
            this._DoCreatePrismaticJoint(...r.params);
        }
    }
    _GetInstImagePoint(r) {
      var n = this.GetWorldInfo();
      return -1 === r
        ? [n.GetX(), n.GetY()]
        : 0 === r && this._body
        ? ((r = this._body.GetPosition()),
          (n = this._body.GetLocalCenter()),
          [
            (r.get_x() + n.get_x()) / this._worldScale,
            (r.get_y() + n.get_y()) / this._worldScale,
          ])
        : this._inst.GetImagePoint(r);
    }
    _CreateDistanceJoint(r, n, p, u, w) {
      this._isEnabled &&
        n &&
        n !== this._inst &&
        e.Behaviors.Physics.Instance.LookupBehInstFromInst(n) &&
        (this._myCreatedJoints.push({
          type: 0,
          params: [r, n.GetUID(), p, u, w],
        }),
        this._DoCreateDistanceJoint(r, n.GetUID(), p, u, w));
    }
    _DoCreateDistanceJoint(r, n, p, u, w) {
      if (this._isEnabled) {
        var y = this._runtime.GetInstanceByUID(n);
        if (y && y !== this._inst && d.has(y)) {
          n = e.Behaviors.Physics.Instance.LookupBehInstFromInst(y);
          n._joiningMe.add(this._inst);
          this._UpdateBodyToMatchInstance(!1);
          n._UpdateBodyToMatchInstance(!1);
          var [B, E] = this._GetInstImagePoint(r),
            [z, D] = y.GetImagePoint(p);
          r = B - z;
          p = E - D;
          y = this._worldScale;
          var J = new this._box2d.b2DistanceJointDef();
          J.Initialize(
            this._body,
            n.GetBody(),
            h(B * y, E * y),
            g(z * y, D * y)
          );
          J.set_length(Math.hypot(r, p) * y);
          J.set_dampingRatio(u);
          J.set_frequencyHz(w);
          this._myJoints.push(this._world.CreateJoint(J));
          this._Destroy(J);
        }
      }
    }
    _CreateRevoluteJoint(r, n) {
      this._isEnabled &&
        n &&
        n !== this._inst &&
        e.Behaviors.Physics.Instance.LookupBehInstFromInst(n) &&
        (this._myCreatedJoints.push({ type: 1, params: [r, n.GetUID()] }),
        this._DoCreateRevoluteJoint(r, n.GetUID()));
    }
    _DoCreateRevoluteJoint(r, n) {
      if (
        this._isEnabled &&
        (n = this._runtime.GetInstanceByUID(n)) &&
        n !== this._inst &&
        d.has(n)
      ) {
        n = e.Behaviors.Physics.Instance.LookupBehInstFromInst(n);
        n._joiningMe.add(this._inst);
        this._UpdateBodyToMatchInstance(!1);
        n._UpdateBodyToMatchInstance(!1);
        var [p, u] = this._GetInstImagePoint(r);
        r = this._worldScale;
        var w = new this._box2d.b2RevoluteJointDef();
        w.Initialize(this._body, n.GetBody(), h(p * r, u * r));
        this._myJoints.push(this._world.CreateJoint(w));
        this._Destroy(w);
      }
    }
    _CreateLimitedRevoluteJoint(r, n, p, u) {
      this._isEnabled &&
        n &&
        n !== this._inst &&
        e.Behaviors.Physics.Instance.LookupBehInstFromInst(n) &&
        ((p = e.toDegrees(p)),
        (u = e.toDegrees(u)),
        this._myCreatedJoints.push({ type: 2, params: [r, n.GetUID(), p, u] }),
        this._DoCreateLimitedRevoluteJoint(r, n.GetUID(), p, u));
    }
    _DoCreateLimitedRevoluteJoint(r, n, p, u) {
      if (
        this._isEnabled &&
        (n = this._runtime.GetInstanceByUID(n)) &&
        n !== this._inst &&
        d.has(n)
      ) {
        n = e.Behaviors.Physics.Instance.LookupBehInstFromInst(n);
        n._joiningMe.add(this._inst);
        this._UpdateBodyToMatchInstance(!1);
        n._UpdateBodyToMatchInstance(!1);
        var [w, y] = this._GetInstImagePoint(r);
        r = this._worldScale;
        var B = new this._box2d.b2RevoluteJointDef();
        B.Initialize(this._body, n.GetBody(), h(w * r, y * r));
        B.set_enableLimit(!0);
        B.set_lowerAngle(e.toRadians(p));
        B.set_upperAngle(e.toRadians(u));
        this._myJoints.push(this._world.CreateJoint(B));
        this._Destroy(B);
      }
    }
    _CreatePrismaticJoint(r, n, p, u, w, y, B, E, z) {
      this._isEnabled &&
        n &&
        n !== this._inst &&
        e.Behaviors.Physics.Instance.LookupBehInstFromInst(n) &&
        ((p = e.toDegrees(p)),
        (E = e.toDegrees(E)),
        this._myCreatedJoints.push({
          type: 3,
          params: [r, n.GetUID(), p, u, w, y, B, E, z],
        }),
        this._DoCreatePrismaticJoint(r, n.GetUID(), p, u, w, y, B, E, z));
    }
    _DoCreatePrismaticJoint(r, n, p, u, w, y, B, E, z) {
      if (
        this._isEnabled &&
        (n = this._runtime.GetInstanceByUID(n)) &&
        n !== this._inst &&
        d.has(n)
      ) {
        n = e.Behaviors.Physics.Instance.LookupBehInstFromInst(n);
        n._joiningMe.add(this._inst);
        this._UpdateBodyToMatchInstance(!1);
        n._UpdateBodyToMatchInstance(!1);
        var [D, J] = this._GetInstImagePoint(r);
        p = e.toRadians(p);
        r = Math.cos(p);
        p = Math.sin(p);
        var C = this._worldScale,
          H = new this._box2d.b2PrismaticJointDef();
        H.Initialize(this._body, n.GetBody(), h(D * C, J * C), g(r, p));
        H.set_enableLimit(!!u);
        H.set_lowerTranslation(w * C);
        H.set_upperTranslation(y * C);
        H.set_enableMotor(!!B);
        H.set_motorSpeed(e.toRadians(E));
        H.set_maxMotorForce(z);
        this._myJoints.push(this._world.CreateJoint(H));
        this._Destroy(H);
      }
    }
    _RemoveJoints() {
      this._isEnabled &&
        (this._DestroyMyJoints(),
        e.clearArray(this._myCreatedJoints),
        this._joiningMe.clear());
    }
    _OnInstanceDestroyed(r) {
      const n = r.GetUID();
      let p = 0;
      for (let u = 0, w = this._myCreatedJoints.length; u < w; ++u)
        (this._myCreatedJoints[p] = this._myCreatedJoints[u]),
          p < this._myJoints.length && (this._myJoints[p] = this._myJoints[u]),
          this._myCreatedJoints[u].params[1] === n
            ? u < this._myJoints.length &&
              this._world.DestroyJoint(this._myJoints[u])
            : ++p;
      e.truncateArray(this._myCreatedJoints, p);
      p < this._myJoints.length && e.truncateArray(this._myJoints, p);
      this._joiningMe.delete(r);
    }
    GetBody() {
      return this._body;
    }
    static LookupBehInstFromBody(r) {
      return c.get(r) || null;
    }
    static LookupBehInstFromInst(r) {
      return d.get(r) || null;
    }
    SaveToJson() {
      const r = {
        e: this._isEnabled,
        pr: this._preventRotation,
        d: this._density,
        fr: this._friction,
        re: this._restitution,
        ld: this._linearDamping,
        ad: this._angularDamping,
        b: this._isBullet,
        mcj: this._myCreatedJoints,
      };
      if (this._isEnabled) {
        const n = this._body.GetLinearVelocity();
        r.vx = n.get_x();
        r.vy = n.get_y();
        r.om = this._body.GetAngularVelocity();
      }
      return r;
    }
    _OnBeforeLoad() {
      this._DestroyMyJoints();
      e.clearArray(this._myCreatedJoints);
      this._joiningMe.clear();
    }
    LoadFromJson(r) {
      this._DestroyBody();
      this._isEnabled = r.e;
      this._preventRotation = r.pr;
      this._density = r.d;
      this._friction = r.fr;
      this._restitution = r.re;
      this._linearDamping = r.ld;
      this._angularDamping = r.ad;
      this._isBullet = r.b;
      this._myCreatedJoints = r.mcj;
      const n = this.GetWorldInfo();
      this._lastKnownX = n.GetX();
      this._lastKnownY = n.GetY();
      this._lastKnownAngle = n.GetAngle();
      this._lastWidth = n.GetWidth();
      this._lastHeight = n.GetHeight();
      this._isEnabled &&
        (this._CreateBody(),
        this._body.SetLinearVelocity(h(r.vx, r.vy)),
        this._body.SetAngularVelocity(r.om),
        (0 === r.vx && 0 === r.vy && 0 === r.om) || this._body.SetAwake(!0),
        (this._myCreatedJoints = r.mcj));
      this._isEnabled ? this._StartTicking() : this._StopTicking();
    }
    _OnAfterLoad() {
      this._isEnabled && this._RecreateMyJoints();
    }
    Tick() {
      if (this._isEnabled) {
        var r = this._runtime,
          n = this.GetBehavior();
        if (0 === n.GetSteppingMode()) var p = r.GetTimeScale() / 60;
        else (p = r.GetDt(this._inst)), p > 1 / 30 && (p = 1 / 30);
        var u = r.GetTickCountNoSave();
        if (u > n.GetLastUpdateTick() && 0 < r.GetTimeScale()) {
          r = this._runtime.IsDebug();
          let w = 0;
          r && (w = performance.now());
          0 !== p &&
            this._world.Step(
              p,
              n.GetVelocityIterations(),
              n.GetPositionIterations()
            );
          this._world.ClearForces();
          r && self.C3Debugger.AddPhysicsTime(performance.now() - w);
          n.SetLastUpdateTick(u);
        }
        this._UpdateBodyToMatchInstance(!0);
      }
    }
    _UpdateBodyToMatchInstance(r) {
      const n = this._inst.GetWorldInfo();
      var p = this._worldScale;
      (n.GetWidth() !== this._lastWidth ||
        n.GetHeight() !== this._lastHeight ||
        n.IsPhysicsBodyChanged()) &&
        this._CreateBody();
      var u = this._body,
        w = n.GetX() !== this._lastKnownX || n.GetY() !== this._lastKnownY,
        y = n.GetAngle() !== this._lastKnownAngle;
      if (w) {
        var B = this._GetBoundingQuadExcludingMesh();
        const E = B.midX();
        B = B.midY();
        const z = E - this._lastKnownX,
          D = B - this._lastKnownY;
        y
          ? u.SetTransform(h(E * p, B * p), n.GetAngle())
          : u.SetTransform(h(E * p, B * p), u.GetAngle());
        r && (u.SetLinearVelocity(h(z, D)), (this._lastTickOverride = !0));
        u.SetAwake(!0);
      } else
        r &&
          this._lastTickOverride &&
          ((r = this._GetBoundingQuadExcludingMesh()),
          (this._lastTickOverride = !1),
          u.SetLinearVelocity(h(0, 0)),
          u.SetTransform(h(r.midX() * p, r.midY() * p), u.GetAngle()));
      !w &&
        y &&
        (u.SetTransform(u.GetPosition(), n.GetAngle()), u.SetAwake(!0));
      y = u.GetPosition();
      w = y.get_x() / p;
      p = y.get_y() / p;
      u = u.GetAngle();
      if (w !== n.GetX() || p !== n.GetY() || u !== n.GetAngle())
        if (
          (n.SetXY(w, p),
          n.SetAngle(u),
          n.SetBboxChanged(),
          (p = this._GetBoundingQuadExcludingMesh()),
          (u = p.midX() - n.GetX()),
          (p = p.midY() - n.GetY()),
          0 !== u || 0 !== p)
        )
          n.OffsetXY(-u, -p), n.SetBboxChanged();
      this._lastKnownX = n.GetX();
      this._lastKnownY = n.GetY();
      this._lastKnownAngle = n.GetAngle();
    }
    GetPropertyValueByIndex(r) {
      switch (r) {
        case 2:
          return this._IsPreventRotate();
        case 3:
          return this._GetDensity();
        case 4:
          return this._GetFriction();
        case 5:
          return this._GetElasticity();
        case 6:
          return this._GetLinearDamping();
        case 7:
          return this._GetAngularDamping();
        case 8:
          return this._IsBullet();
        case 9:
          return this._IsEnabled();
      }
    }
    SetPropertyValueByIndex(r, n) {
      switch (r) {
        case 2:
          this._SetPreventRotate(n);
          break;
        case 3:
          this._SetDensity(n);
          break;
        case 4:
          this._SetFriction(n);
          break;
        case 5:
          this._SetElasticity(n);
          break;
        case 6:
          this._SetLinearDamping(n);
          break;
        case 7:
          this._SetAngularDamping(n);
          break;
        case 8:
          this._SetBullet(n);
          break;
        case 9:
          this._SetEnabled(n);
      }
    }
    _SetEnabled(r) {
      r = !!r;
      this._isEnabled && !r
        ? (this._DestroyBody(), (this._isEnabled = !1), this._StopTicking())
        : !this._isEnabled &&
          r &&
          ((this._isEnabled = !0), this._CreateBody(), this._StartTicking());
    }
    _IsEnabled() {
      return this._isEnabled;
    }
    GetDebuggerProperties() {
      const r = [
        {
          name: "behaviors.physics.properties.enabled.name",
          value: this._IsEnabled(),
          onedit: (n) => this._SetEnabled(n),
        },
        {
          name: "behaviors.physics.properties.immovable.name",
          value: this._IsImmovable(),
          onedit: (n) => this._SetImmovable(n),
        },
        {
          name: "behaviors.physics.properties.density.name",
          value: this._GetDensity(),
          onedit: (n) => this._SetDensity(n),
        },
        {
          name: "behaviors.physics.properties.friction.name",
          value: this._GetFriction(),
          onedit: (n) => this._SetFriction(n),
        },
        {
          name: "behaviors.physics.properties.elasticity.name",
          value: this._GetElasticity(),
          onedit: (n) => this._SetElasticity(n),
        },
        {
          name: "behaviors.physics.properties.linear-damping.name",
          value: this._GetLinearDamping(),
          onedit: (n) => this._SetLinearDamping(n),
        },
        {
          name: "behaviors.physics.properties.angular-damping.name",
          value: this._GetAngularDamping(),
          onedit: (n) => this._SetAngularDamping(n),
        },
      ];
      this._isEnabled &&
        (r.push({
          name: "behaviors.physics.debugger.is-sleeping",
          value: this._IsSleeping(),
        }),
        r.push({
          name: "behaviors.physics.debugger.velocity-x",
          value: this._GetVelocityX(),
          onedit: (n) => this._SetVelocity(n, this._GetVelocityY()),
        }),
        r.push({
          name: "behaviors.physics.debugger.velocity-y",
          value: this._GetVelocityY(),
          onedit: (n) => this._SetVelocity(this._GetVelocityX(), n),
        }),
        r.push({
          name: "behaviors.physics.debugger.angular-velocity",
          value: e.toDegrees(this._GetAngularVelocity()),
          onedit: (n) => this._SetAngularVelocity(e.toRadians(n)),
        }),
        r.push({
          name: "behaviors.physics.debugger.mass",
          value: this._GetMass(),
        }));
      return [{ title: "$" + this.GetBehaviorType().GetName(), properties: r }];
    }
    _ApplyForce(r, n, p) {
      const [u, w] = this._GetInstImagePoint(p);
      this._DoApplyForce(r, n, u, w);
    }
    _ApplyForceToward(r, n, p, u) {
      const [w, y] = this._GetInstImagePoint(u);
      n = e.angleTo(w, y, n, p);
      this._DoApplyForce(Math.cos(n) * r, Math.sin(n) * r, w, y);
    }
    _ApplyForceAtAngle(r, n, p) {
      const [u, w] = this._GetInstImagePoint(p);
      this._DoApplyForce(Math.cos(n) * r, Math.sin(n) * r, u, w);
    }
    _DoApplyForce(r, n, p, u) {
      if (this._isEnabled) {
        var w = this._worldScale;
        this._body.ApplyForce(h(r, n), g(p * w, u * w), !0);
      }
    }
    _ApplyImpulse(r, n, p) {
      const [u, w] = this._GetInstImagePoint(p);
      this._DoApplyImpulse(r, n, u, w);
    }
    _ApplyImpulseToward(r, n, p, u) {
      const [w, y] = this._GetInstImagePoint(u);
      n = e.angleTo(w, y, n, p);
      this._DoApplyImpulse(Math.cos(n) * r, Math.sin(n) * r, w, y);
    }
    _ApplyImpulseAtAngle(r, n, p) {
      const [u, w] = this._GetInstImagePoint(p);
      this._DoApplyImpulse(Math.cos(n) * r, Math.sin(n) * r, u, w);
    }
    _DoApplyImpulse(r, n, p, u) {
      if (this._isEnabled) {
        var w = this._worldScale;
        this._body.ApplyLinearImpulse(h(r, n), g(p * w, u * w), !0);
        r = this.GetWorldInfo();
        this._lastKnownX = r.GetX();
        this._lastKnownY = r.GetY();
        this._lastTickOverride = !1;
      }
    }
    _ApplyTorque(r) {
      this._isEnabled && this._body.ApplyTorque(r, !0);
    }
    _ApplyTorqueToAngle(r, n) {
      n = e.angleClockwise(this.GetWorldInfo().GetAngle(), n) ? -1 : 1;
      this._ApplyTorque(r * n);
    }
    _ApplyTorqueToPosition(r, n, p) {
      var u = this.GetWorldInfo();
      n = e.angleTo(u.GetX(), u.GetY(), n, p);
      u = e.angleClockwise(u.GetAngle(), n) ? -1 : 1;
      this._ApplyTorque(r * u);
    }
    _SetAngularVelocity(r) {
      this._isEnabled &&
        (this._body.SetAngularVelocity(r), this._body.SetAwake(!0));
    }
    _GetAngularVelocity() {
      return this._isEnabled ? this._body.GetAngularVelocity() : 0;
    }
    _SetVelocity(r, n) {
      if (this._isEnabled) {
        var p = this._worldScale;
        this._body.SetLinearVelocity(h(r * p, n * p));
        this._body.SetAwake(!0);
        r = this.GetWorldInfo();
        this._lastKnownX = r.GetX();
        this._lastKnownY = r.GetY();
        this._lastTickOverride = !1;
      }
    }
    _GetVelocity() {
      if (!this._isEnabled) return [0, 0];
      const r = this._worldScale,
        n = this._body.GetLinearVelocity();
      return [n.get_x() / r, n.get_y() / r];
    }
    _GetVelocityX() {
      return this._isEnabled
        ? this._body.GetLinearVelocity().get_x() / this._worldScale
        : 0;
    }
    _GetVelocityY() {
      return this._isEnabled
        ? this._body.GetLinearVelocity().get_y() / this._worldScale
        : 0;
    }
    _SetDensity(r) {
      if (this._isEnabled && this._density !== r) {
        this._density = r;
        for (const n of this._fixtures) n.SetDensity(r);
        this._body.ResetMassData();
      }
    }
    _GetDensity() {
      return this._isEnabled ? this._density : 0;
    }
    _SetFriction(r) {
      if (this._isEnabled && this._friction !== r) {
        this._friction = r;
        for (var n of this._fixtures) n.SetFriction(r);
        for (
          r = this._body.GetContactList();
          this._box2d.getPointer(r);
          r = r.get_next()
        )
          (n = r.get_contact()) && n.ResetFriction();
      }
    }
    _GetFriction() {
      return this._isEnabled ? this._friction : 0;
    }
    _SetElasticity(r) {
      if (this._isEnabled && this._restitution !== r) {
        this._restitution = r;
        for (const n of this._fixtures) n.SetRestitution(r);
      }
    }
    _GetElasticity() {
      return this._isEnabled ? this._restitution : 0;
    }
    _SetLinearDamping(r) {
      this._isEnabled &&
        this._linearDamping !== r &&
        ((this._linearDamping = r), this._body.SetLinearDamping(r));
    }
    _GetLinearDamping() {
      return this._isEnabled ? this._linearDamping : 0;
    }
    _SetAngularDamping(r) {
      this._isEnabled &&
        this._angularDamping !== r &&
        ((this._angularDamping = r), this._body.SetAngularDamping(r));
    }
    _GetAngularDamping() {
      return this._isEnabled ? this._angularDamping : 0;
    }
    _SetImmovable(r) {
      this._isEnabled &&
        ((r = !!r),
        this._isImmovable !== r &&
          ((this._isImmovable = r),
          this._body.SetType(this._isImmovable ? 0 : 2),
          this._body.SetAwake(!0)));
    }
    _IsImmovable() {
      return this._isImmovable;
    }
    _SetPreventRotate(r) {
      this._isEnabled &&
        ((r = !!r),
        this._preventRotation !== r &&
          ((this._preventRotation = r),
          this._body.SetFixedRotation(this._preventRotation),
          this._body.SetAngularVelocity(0),
          this._body.SetAwake(!0)));
    }
    _IsPreventRotate() {
      return this._preventRotation;
    }
    _SetBullet(r) {
      this._isEnabled &&
        ((r = !!r),
        this._isBullet !== r &&
          ((this._isBullet = r),
          this._body.SetBullet(this._isBullet),
          this._body.SetAwake(!0)));
    }
    _IsBullet() {
      return this._isBullet;
    }
    _GetMass() {
      return this._isEnabled ? this._body.GetMass() / this._worldScale : 0;
    }
    _GetCenterOfMassX() {
      return this._isEnabled
        ? (this._body.GetPosition().get_x() +
            this._body.GetLocalCenter().get_x()) /
            this._worldScale
        : 0;
    }
    _GetCenterOfMassY() {
      return this._isEnabled
        ? (this._body.GetPosition().get_y() +
            this._body.GetLocalCenter().get_y()) /
            this._worldScale
        : 0;
    }
    _GetCenterOfMass() {
      if (!this._isEnabled) return [0, 0];
      const r = this._body.GetPosition(),
        n = this._body.GetLocalCenter(),
        p = this._worldScale;
      return [(r.get_x() + n.get_x()) / p, (r.get_y() + n.get_y()) / p];
    }
    _IsSleeping() {
      return this._isEnabled ? !this._body.IsAwake() : !1;
    }
    _GetContactCount() {
      if (!this._isEnabled) return 0;
      let r = 0;
      for (
        let p = this._body.GetContactList();
        this._box2d.getPointer(p);
        p = p.get_next()
      ) {
        var n = p.get_contact();
        n && ((n = n.GetManifold().get_pointCount()), (r += n));
      }
      return r;
    }
    _GetContactPositionAt(r) {
      r = Math.floor(r);
      if (!this._isEnabled) return [0, 0];
      var n = 0;
      for (
        let u = this._body.GetContactList();
        this._box2d.getPointer(u);
        u = u.get_next()
      ) {
        var p = u.get_contact();
        if (!p) continue;
        const w = p.GetManifold().get_pointCount();
        if (r >= n && r < n + w)
          return (
            (r -= n),
            (n = this.GetBehavior().GetWorldManifold()),
            p.GetWorldManifold(n),
            (p = n.get_points(r)),
            [p.get_x() / this._worldScale, p.get_y() / this._worldScale]
          );
        n += w;
      }
      return [0, 0];
    }
    GetScriptInterfaceClass() {
      return self.IPhysicsBehaviorInstance;
    }
  };
  const q = new WeakMap();
  function v(r, n) {
    return q.get(r).GetRuntime()._UnwrapIWorldInstance(n);
  }
  self.IPhysicsBehaviorInstance = class extends a {
    constructor() {
      super();
      q.set(this, a._GetInitInst().GetSdkInstance());
    }
    get isEnabled() {
      return q.get(this)._IsEnabled();
    }
    set isEnabled(r) {
      q.get(this)._SetEnabled(r);
    }
    applyForce(r, n, p = 0) {
      b.RequireFiniteNumber(r);
      b.RequireFiniteNumber(n);
      q.get(this)._ApplyForce(r, n, p);
    }
    applyForceTowardPosition(r, n, p, u = 0) {
      b.RequireFiniteNumber(r);
      b.RequireFiniteNumber(n);
      b.RequireFiniteNumber(p);
      q.get(this)._ApplyForceToward(r, n, p, u);
    }
    applyForceAtAngle(r, n, p = 0) {
      b.RequireFiniteNumber(r);
      b.RequireFiniteNumber(n);
      q.get(this)._ApplyForceAtAngle(r, n, p);
    }
    applyImpulse(r, n, p = 0) {
      b.RequireFiniteNumber(r);
      b.RequireFiniteNumber(n);
      q.get(this)._ApplyImpulse(r, n, p);
    }
    applyImpulseTowardPosition(r, n, p, u = 0) {
      b.RequireFiniteNumber(r);
      b.RequireFiniteNumber(n);
      b.RequireFiniteNumber(p);
      q.get(this)._ApplyImpulseToward(r, n, p, u);
    }
    applyImpulseAtAngle(r, n, p = 0) {
      b.RequireFiniteNumber(r);
      b.RequireFiniteNumber(n);
      q.get(this)._ApplyImpulseAtAngle(r, n, p);
    }
    applyTorque(r) {
      b.RequireFiniteNumber(r);
      q.get(this)._ApplyTorque(r);
    }
    applyTorqueToAngle(r, n) {
      b.RequireFiniteNumber(r);
      b.RequireFiniteNumber(n);
      q.get(this)._ApplyTorqueToAngle(r, n);
    }
    applyTorqueToPosition(r, n, p) {
      b.RequireFiniteNumber(r);
      b.RequireFiniteNumber(n);
      b.RequireFiniteNumber(p);
      q.get(this)._ApplyTorqueToPosition(r, n, p);
    }
    set angularVelocity(r) {
      b.RequireFiniteNumber(r);
      q.get(this)._SetAngularVelocity(r);
    }
    get angularVelocity() {
      return q.get(this)._GetAngularVelocity();
    }
    setVelocity(r, n) {
      b.RequireFiniteNumber(r);
      b.RequireFiniteNumber(n);
      q.get(this)._SetVelocity(r, n);
    }
    getVelocityX() {
      return q.get(this)._GetVelocityX();
    }
    getVelocityY() {
      return q.get(this)._GetVelocityY();
    }
    getVelocity() {
      return q.get(this)._GetVelocity();
    }
    set density(r) {
      b.RequireFiniteNumber(r);
      q.get(this)._SetDensity(r);
    }
    get density() {
      return q.get(this)._GetDensity();
    }
    set friction(r) {
      b.RequireFiniteNumber(r);
      q.get(this)._SetFriction(r);
    }
    get friction() {
      return q.get(this)._GetFriction();
    }
    set elasticity(r) {
      b.RequireFiniteNumber(r);
      q.get(this)._SetElasticity(r);
    }
    get elasticity() {
      return q.get(this)._GetElasticity();
    }
    set linearDamping(r) {
      b.RequireFiniteNumber(r);
      q.get(this)._SetLinearDamping(r);
    }
    get linearDamping() {
      return q.get(this)._GetLinearDamping();
    }
    set angularDamping(r) {
      b.RequireFiniteNumber(r);
      q.get(this)._SetAngularDamping(r);
    }
    get angularDamping() {
      return q.get(this)._GetAngularDamping();
    }
    set isImmovable(r) {
      q.get(this)._SetImmovable(r);
    }
    get isImmovable() {
      return q.get(this)._IsImmovable();
    }
    set isPreventRotation(r) {
      q.get(this)._SetPreventRotate(r);
    }
    get isPreventRotation() {
      return q.get(this)._IsPreventRotate();
    }
    set isBullet(r) {
      q.get(this)._SetBullet(r);
    }
    get isBullet() {
      return q.get(this)._IsBullet();
    }
    get mass() {
      return q.get(this)._GetMass();
    }
    getCenterOfMassX() {
      return q.get(this)._GetCenterOfMassX();
    }
    getCenterOfMassY() {
      return q.get(this)._GetCenterOfMassY();
    }
    getCenterOfMass() {
      return q.get(this)._GetCenterOfMass();
    }
    getContactCount() {
      return q.get(this)._GetContactCount();
    }
    getContactX(r) {
      b.RequireFiniteNumber(r);
      return q.get(this)._GetContactPositionAt(r)[0];
    }
    getContactY(r) {
      b.RequireFiniteNumber(r);
      return q.get(this)._GetContactPositionAt(r)[1];
    }
    getContact(r) {
      b.RequireFiniteNumber(r);
      return q.get(this)._GetContactPositionAt(r);
    }
    get isSleeping() {
      return q.get(this)._IsSleeping();
    }
    createDistanceJoint(r, n, p, u, w) {
      b.RequireFiniteNumber(u);
      b.RequireFiniteNumber(w);
      n = v(this, n);
      q.get(this)._CreateDistanceJoint(r, n, p, u, w);
    }
    createRevoluteJoint(r, n) {
      n = v(this, n);
      q.get(this)._CreateRevoluteJoint(r, n);
    }
    createLimitedRevoluteJoint(r, n, p, u) {
      b.RequireFiniteNumber(p);
      b.RequireFiniteNumber(u);
      n = v(this, n);
      q.get(this)._CreateLimitedRevoluteJoint(r, n, p, u);
    }
    createPrismaticJoint(r, n, p, u, w, y, B, E, z) {
      n = v(this, n);
      q.get(this)._CreatePrismaticJoint(r, n, p, u, w, y, B, E, z);
    }
    removeAllJoints() {
      q.get(this)._RemoveJoints();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Physics.Cnds = {
    IsSleeping() {
      return this._IsSleeping();
    },
    CompareVelocity(b, a, c) {
      if (!this._isEnabled) return !1;
      if (0 === b) b = this._GetVelocityX();
      else if (1 === b) b = this._GetVelocityY();
      else {
        const [d, f] = this._GetVelocity();
        b = Math.hypot(d, f);
      }
      return e.compare(b, a, c);
    },
    CompareAngularVelocity(b, a) {
      if (!this._isEnabled) return !1;
      const c = e.toDegrees(this._GetAngularVelocity());
      return e.compare(c, b, a);
    },
    CompareMass(b, a) {
      if (!this._isEnabled) return !1;
      const c = this._GetMass();
      return e.compare(c, b, a);
    },
    IsEnabled() {
      return this._IsEnabled();
    },
  };
}
{
  const e = self.C3;
  e.Behaviors.Physics.Acts = {
    ApplyForce(b, a, c) {
      this._ApplyForce(b, a, c);
    },
    ApplyForceToward(b, a, c, d) {
      this._ApplyForceToward(b, a, c, d);
    },
    ApplyForceAtAngle(b, a, c) {
      this._ApplyForceAtAngle(b, e.toRadians(a), c);
    },
    ApplyImpulse(b, a, c) {
      this._ApplyImpulse(b, a, c);
    },
    ApplyImpulseToward(b, a, c, d) {
      this._ApplyImpulseToward(b, a, c, d);
    },
    ApplyImpulseAtAngle(b, a, c) {
      this._ApplyImpulseAtAngle(b, e.toRadians(a), c);
    },
    ApplyTorque(b) {
      this._ApplyTorque(e.toRadians(b));
    },
    ApplyTorqueToAngle(b, a) {
      this._ApplyTorqueToAngle(e.toRadians(b), e.toRadians(a));
    },
    ApplyTorqueToPosition(b, a, c) {
      this._ApplyTorqueToPosition(e.toRadians(b), a, c);
    },
    SetAngularVelocity(b) {
      this._SetAngularVelocity(e.toRadians(b));
    },
    CreateDistanceJoint(b, a, c, d, f) {
      a &&
        ((a = a.GetFirstPicked(this._inst)),
        this._CreateDistanceJoint(b, a, c, d, f));
    },
    CreateRevoluteJoint(b, a) {
      a &&
        ((a = a.GetFirstPicked(this._inst)), this._CreateRevoluteJoint(b, a));
    },
    CreateLimitedRevoluteJoint(b, a, c, d) {
      a &&
        ((a = a.GetFirstPicked(this._inst)),
        this._CreateLimitedRevoluteJoint(b, a, e.toRadians(c), e.toRadians(d)));
    },
    CreatePrismaticJoint(b, a, c, d, f, h, g, k, m) {
      a &&
        ((a = a.GetFirstPicked(this._inst)),
        this._CreatePrismaticJoint(
          b,
          a,
          e.toRadians(c),
          d,
          f,
          h,
          g,
          e.toRadians(k),
          m
        ));
    },
    RemoveJoints() {
      this._RemoveJoints();
    },
    SetWorldGravity(b) {
      this.GetBehavior().SetGravity(b);
    },
    SetSteppingMode(b) {
      this.GetBehavior().SetSteppingMode(b);
    },
    SetIterations(b, a) {
      this.GetBehavior().SetIterations(b, a);
    },
    SetVelocity(b, a) {
      this._SetVelocity(b, a);
    },
    SetDensity(b) {
      this._SetDensity(b);
    },
    SetFriction(b) {
      this._SetFriction(b);
    },
    SetElasticity(b) {
      this._SetElasticity(b);
    },
    SetLinearDamping(b) {
      this._SetLinearDamping(b);
    },
    SetAngularDamping(b) {
      this._SetAngularDamping(b);
    },
    SetImmovable(b) {
      this._SetImmovable(b);
    },
    EnableCollisions(b, a) {
      this.GetBehavior().SetCollisionsEnabled(
        this.GetObjectClass(),
        b,
        0 !== a
      );
    },
    SetPreventRotate(b) {
      this._SetPreventRotate(0 !== b);
    },
    SetBullet(b) {
      this._SetBullet(0 !== b);
    },
    SetEnabled(b) {
      this._SetEnabled(0 !== b);
    },
  };
}
{
  const e = self.C3;
  e.Behaviors.Physics.Exps = {
    VelocityX() {
      return this._GetVelocityX();
    },
    VelocityY() {
      return this._GetVelocityY();
    },
    AngularVelocity() {
      return e.toDegrees(this._GetAngularVelocity());
    },
    Mass() {
      return this._GetMass();
    },
    CenterOfMassX() {
      return this._GetCenterOfMassX();
    },
    CenterOfMassY() {
      return this._GetCenterOfMassY();
    },
    Density() {
      return this._GetDensity();
    },
    Friction() {
      return this._GetFriction();
    },
    Elasticity() {
      return this._GetElasticity();
    },
    LinearDamping() {
      return this._GetLinearDamping();
    },
    AngularDamping() {
      return this._GetAngularDamping();
    },
    ContactCount() {
      return this._GetContactCount();
    },
    ContactXAt(b) {
      return this._GetContactPositionAt(b)[0];
    },
    ContactYAt(b) {
      return this._GetContactPositionAt(b)[1];
    },
  };
}
{
  ("use strict");
  const e = self.C3,
    b = {};
  e.Behaviors.Physics.Separator = b;
  const a = e.Behaviors.Physics.GetVec2,
    c = e.Behaviors.Physics.FreeVec2;
  function d(g) {
    return a(g.get_x(), g.get_y());
  }
  b.det = function (g, k, m, q, v, r) {
    return g * q + m * r + v * k - k * m - q * v - r * g;
  };
  b.hitRay = function (g, k, m, q, v, r, n, p) {
    var u = m - g,
      w = q - k,
      y = n - v;
    const B = p - r;
    y = (y * (r - k) - B * (v - g)) / (w * y - u * B);
    u = g + y * u;
    w = k + y * w;
    g = b.isOnSegment(m, q, g, k, u, w);
    v = b.isOnSegment(u, w, v, r, n, p);
    return g && v ? a(u, w) : null;
  };
  b.isOnSegment = function (g, k, m, q, v, r) {
    return (
      ((m + 0.1 >= g && g >= v - 0.1) || (m - 0.1 <= g && g <= v + 0.1)) &&
      ((q + 0.1 >= k && k >= r - 0.1) || (q - 0.1 <= k && k <= r + 0.1)) &&
      b.isOnLine(g, k, m, q, v, r)
    );
  };
  b.isOnLine = function (g, k, m, q, v, r) {
    return 0.1 < Math.abs(v - m)
      ? 0.1 > Math.abs(((r - q) / (v - m)) * (g - m) + q - k)
      : 0.1 > Math.abs(g - m);
  };
  b.pointsMatch = function (g, k, m, q) {
    return 0.1 > Math.abs(m - g) && 0.1 > Math.abs(q - k);
  };
  b.Separate = function (g, k) {
    g = b.calcShapes(g);
    let m = [];
    for (let q = 0, v = g.length; q < v; ++q) {
      const r = g[q],
        n = [];
      let p = 0;
      for (let u = 0, w = r.length; u < w; ++u) {
        const y = r[u],
          B = r[(u + 1) % w];
        p += y.get_x() * B.get_y() - y.get_y() * B.get_x();
        n.push(a(y.get_x(), y.get_y()));
      }
      p = Math.abs(p / 2);
      if (p >= 0.001 * k) m.push(n);
      else for (let u = 0, w = n.length; u < w; u++) c(n[u]);
    }
    return (m = f(m));
  };
  b.calcShapes = function (g) {
    var k;
    let m;
    var q;
    let v;
    let r, n, p, u;
    let w;
    var y = 0;
    let B = 0,
      E,
      z = [],
      D = [];
    for (D.push(g); D.length; ) {
      g = D[0];
      m = g.length;
      E = !0;
      for (k = 0; k < m; k++) {
        r = k;
        n = k < m - 1 ? k + 1 : k + 1 - m;
        var J = k < m - 2 ? k + 2 : k + 2 - m;
        p = g[r];
        u = g[n];
        J = g[J];
        J = b.det(
          p.get_x(),
          p.get_y(),
          u.get_x(),
          u.get_y(),
          J.get_x(),
          J.get_y()
        );
        if (0 > J) {
          E = !1;
          var C = 1e9;
          for (q = 0; q < m; q++)
            if (q !== r && q !== n) {
              k = q;
              J = q < m - 1 ? q + 1 : 0;
              var H = g[k];
              var K = g[J];
              if (
                (H = b.hitRay(
                  p.get_x(),
                  p.get_y(),
                  u.get_x(),
                  u.get_y(),
                  H.get_x(),
                  H.get_y(),
                  K.get_x(),
                  K.get_y()
                ))
              )
                (K = u.get_x() - H.get_x()),
                  (v = u.get_y() - H.get_y()),
                  (K = K * K + v * v),
                  K < C ? ((B = k), (y = J), (w = H), (C = K)) : c(H);
            }
          if (1e9 === C) return [];
          q = [];
          C = [];
          k = B;
          J = y;
          H = g[k];
          K = g[J];
          y = !1;
          b.pointsMatch(w.get_x(), w.get_y(), K.get_x(), K.get_y()) ||
            (q.push(w), (y = !0));
          b.pointsMatch(w.get_x(), w.get_y(), H.get_x(), H.get_y()) ||
            (C.push(w), (y = !0));
          y || c(w);
          B = -1;
          for (y = r; ; ) {
            if (y !== J) q.push(g[y]);
            else {
              if (0 > B || B >= m) return [];
              b.isOnSegment(
                K.get_x(),
                K.get_y(),
                g[B].get_x(),
                g[B].get_y(),
                p.get_x(),
                p.get_y()
              ) || q.push(g[y]);
              break;
            }
            B = y;
            0 > y - 1 ? (y = m - 1) : y--;
          }
          q.reverse();
          B = -1;
          for (y = n; ; ) {
            if (y !== k) C.push(g[y]);
            else {
              if (0 > B || B >= m) return [];
              y !== k ||
                b.isOnSegment(
                  H.get_x(),
                  H.get_y(),
                  g[B].get_x(),
                  g[B].get_y(),
                  u.get_x(),
                  u.get_y()
                ) ||
                C.push(g[y]);
              break;
            }
            B = y;
            y + 1 > m - 1 ? (y = 0) : y++;
          }
          D.push(q, C);
          D.shift();
          break;
        }
      }
      E && z.push(D.shift());
    }
    return z;
  };
  function f(g) {
    const k = [];
    for (const m of g) 8 >= m.length ? k.push(m) : k.push.apply(k, h(m));
    return k;
  }
  function h(g) {
    const k = [];
    k.push(g.splice(0, 8));
    const m = k[0][0];
    let q = k[0][7];
    for (; g.length; ) {
      const v = g.splice(0, Math.min(g.length, 6));
      let r = v.at(-1);
      v.push(d(m));
      v.push(d(q));
      k.push(v);
      q = r;
    }
    return k;
  }
}
("use strict");
{
  const e = self.C3;
  e.Behaviors.Anchor = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
  };
}
{
  const e = self.C3;
  e.Behaviors.Anchor.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b);
    }
    Release() {
      super.Release();
    }
    OnCreate() {}
  };
}
{
  const e = self.C3;
  e.Behaviors.Anchor.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b);
      this._anchorTop = this._anchorLeft = 2;
      this._anchorBottom = this._anchorRight = 0;
      this._isEnabled = !0;
      b = this._inst.GetWorldInfo().GetBoundingBox();
      this._xLeft = b.getLeft();
      this._yTop = b.getTop();
      this._xRight = this._runtime.GetOriginalViewportWidth() - b.getLeft();
      this._yBottom = this._runtime.GetOriginalViewportHeight() - b.getTop();
      this._rDiff = this._runtime.GetOriginalViewportWidth() - b.getRight();
      this._bDiff = this._runtime.GetOriginalViewportHeight() - b.getBottom();
      a &&
        ((this._anchorLeft = a[0]),
        (this._anchorTop = a[1]),
        (this._anchorRight = a[2]),
        (this._anchorBottom = a[3]),
        (this._isEnabled = !!a[4]));
      a = this._runtime.Dispatcher();
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(a, "layoutchange", () => this._OnLayoutChange())
      );
      this._isEnabled && this._StartTicking();
    }
    Release() {
      super.Release();
    }
    SaveToJson() {
      return {
        xl: this._xLeft,
        yt: this._yTop,
        xr: this._xRight,
        yb: this._yBottom,
        rd: this._rDiff,
        bd: this._bDiff,
        al: this._anchorLeft,
        at: this._anchorTop,
        ar: this._anchorRight,
        ab: this._anchorBottom,
        e: this._isEnabled,
      };
    }
    LoadFromJson(b) {
      this._xLeft = b.xl;
      this._yTop = b.yt;
      this._xRight = b.xr;
      this._yBottom = b.yb;
      this._rDiff = b.rd;
      this._bDiff = b.bd;
      this._anchorLeft = b.al;
      this._anchorTop = b.at;
      this._anchorRight = b.ar;
      this._anchorBottom = b.ab;
      (this._isEnabled = b.e) ? this._StartTicking() : this._StopTicking();
    }
    _UpdatePosition() {
      if (this._isEnabled) {
        var b = this._inst.GetWorldInfo(),
          a = b.GetLayer().GetViewport();
        if (0 === this._anchorLeft) {
          var c = a.getLeft() + this._xLeft - b.GetBoundingBox().getLeft();
          0 !== c && (b.OffsetX(c), b.SetBboxChanged());
        } else
          1 === this._anchorLeft &&
            ((c = a.getRight() - this._xRight - b.GetBoundingBox().getLeft()),
            0 !== c && (b.OffsetX(c), b.SetBboxChanged()));
        0 === this._anchorTop
          ? ((c = a.getTop() + this._yTop - b.GetBoundingBox().getTop()),
            0 !== c && (b.OffsetY(c), b.SetBboxChanged()))
          : 1 === this._anchorTop &&
            ((c = a.getBottom() - this._yBottom - b.GetBoundingBox().getTop()),
            0 !== c && (b.OffsetY(c), b.SetBboxChanged()));
        1 === this._anchorRight &&
          ((c = a.getRight() - this._rDiff - b.GetBoundingBox().getRight()),
          0 !== c &&
            (b.OffsetX(b.GetOriginX() * c),
            b.SetWidth(Math.max(b.GetWidth() + c), 0),
            b.SetBboxChanged(),
            (this._rDiff = a.getRight() - b.GetBoundingBox().getRight())));
        1 === this._anchorBottom &&
          ((c = a.getBottom() - this._bDiff - b.GetBoundingBox().getBottom()),
          0 !== c &&
            (b.OffsetY(b.GetOriginY() * c),
            b.SetHeight(Math.max(b.GetHeight() + c, 0)),
            b.SetBboxChanged(),
            (this._bDiff = a.getBottom() - b.GetBoundingBox().getBottom())));
      }
    }
    Tick() {
      this._UpdatePosition();
    }
    _OnLayoutChange() {
      this._UpdatePosition();
    }
    GetPropertyValueByIndex(b) {
      switch (b) {
        case 0:
          return this._anchorLeft;
        case 1:
          return this._anchorTop;
        case 2:
          return this._anchorRight;
        case 3:
          return this._anchorBottom;
        case 4:
          return this._isEnabled;
      }
    }
    SetPropertyValueByIndex(b, a) {
      switch (b) {
        case 0:
          this._anchorLeft = a;
          break;
        case 1:
          this._anchorTop = a;
          break;
        case 2:
          this._anchorRight = a;
          break;
        case 3:
          this._anchorBottom = a;
          break;
        case 4:
          (this._isEnabled = !!a) ? this._StartTicking() : this._StopTicking();
      }
    }
  };
}
self.C3.Behaviors.Anchor.Cnds = {
  IsEnabled() {
    return this._isEnabled;
  },
};
self.C3.Behaviors.Anchor.Acts = {
  SetEnabled(e) {
    this._isEnabled && 0 === e
      ? ((this._isEnabled = !1), this._StopTicking())
      : this._isEnabled ||
        0 === e ||
        ((e = this._inst.GetWorldInfo().GetBoundingBox()),
        (this._xLeft = e.getLeft()),
        (this._yTop = e.getTop()),
        (this._xRight = this._runtime.GetOriginalViewportWidth() - e.getLeft()),
        (this._yBottom =
          this._runtime.GetOriginalViewportHeight() - e.getTop()),
        (this._rDiff = this._runtime.GetOriginalViewportWidth() - e.getRight()),
        (this._bDiff =
          this._runtime.GetOriginalViewportHeight() - e.getBottom()),
        (this._isEnabled = !0),
        this._StartTicking());
  },
};
self.C3.Behaviors.Anchor.Exps = {};
{
  const e = self.C3;
  self.C3_GetObjectRefTable = function () {
    return [
      e.Plugins.Text,
      e.Plugins.Sprite,
      e.Behaviors.Tween,
      e.Plugins.Spritefont2,
      e.Plugins.Dictionary,
      e.Plugins.Audio,
      e.Plugins.Browser,
      e.Plugins.LocalStorage,
      e.Plugins.NodeWebkit,
      e.Behaviors.Bullet,
      e.Behaviors.solid,
      e.Behaviors.Sin,
      e.Behaviors.Orbit,
      e.Behaviors.Timer,
      e.Behaviors.Rotate,
      e.Plugins.Particles,
      e.Behaviors.Pin,
      e.Plugins.Tilemap,
      e.Plugins.gamepad,
      e.Plugins.Keyboard,
      e.Plugins.Mouse,
      e.Plugins.Touch,
      e.Behaviors.Platform,
      e.Behaviors.Flash,
      e.Plugins.TiledBg,
      e.Behaviors.scrollto,
      e.Behaviors.MoveTo,
      e.Behaviors.LOS,
      e.Plugins.Timeline,
      e.Behaviors.jumpthru,
      e.Plugins.PlatformInfo,
      e.Plugins.AJAX,
      e.Plugins.Arr,
      e.Plugins.sliderbar,
      e.Behaviors.Turret,
      e.Behaviors.EightDir,
      e.Plugins.Avix_PokiSDK_ForC3,
      e.Behaviors.Physics,
      e.Behaviors.Anchor,
      e.Plugins.System.Cnds.IsGroupActive,
      e.Plugins.Sprite.Cnds.OnCreated,
      e.Plugins.Sprite.Acts.SetSize,
      e.Plugins.Sprite.Acts.SetPos,
      e.Plugins.Sprite.Exps.X,
      e.Plugins.Sprite.Exps.Y,
      e.Plugins.Sprite.Acts.AddChild,
      e.Plugins.Sprite.Cnds.CompareInstanceVar,
      e.Plugins.Sprite.Exps.ImagePointX,
      e.Plugins.Sprite.Exps.ImagePointY,
      e.Plugins.Sprite.Cnds.IsBoolInstanceVarSet,
      e.Plugins.Sprite.Acts.MoveToLayer,
      e.Plugins.Sprite.Acts.Destroy,
      e.Plugins.System.Cnds.CompareVar,
      e.Behaviors.Platform.Cnds.IsEnabled,
      e.Plugins.System.Cnds.TriggerOnce,
      e.Behaviors.Platform.Acts.SetEnabled,
      e.Plugins.PlatformInfo.Cnds.IsOnMobile,
      e.Behaviors.MoveTo.Acts.MoveToObject,
      e.Plugins.Browser.Cnds.IsPortraitLandscape,
      e.Behaviors.Tween.Acts.TweenValue,
      e.Plugins.System.Exps.layoutscale,
      e.Plugins.Keyboard.Cnds.OnKey,
      e.Plugins.gamepad.Cnds.OnButtonDown,
      e.Plugins.System.Acts.CreateObject,
      e.Plugins.Audio.Acts.Play,
      e.Plugins.Sprite.Acts.SetVisible,
      e.Plugins.Sprite.Acts.SetInstanceVar,
      e.Plugins.System.Acts.AddVar,
      e.Behaviors.Platform.Acts.SetIgnoreInput,
      e.Behaviors.Platform.Acts.SetGravityAngle,
      e.Plugins.System.Exps.layoutangle,
      e.Behaviors.Platform.Acts.SetGravity,
      e.Behaviors.Platform.Acts.SetMaxFallSpeed,
      e.Behaviors.Platform.Cnds.IsOnFloor,
      e.Behaviors.Timer.Acts.StartTimer,
      e.Behaviors.Platform.Acts.SetDeceleration,
      e.Behaviors.Platform.Acts.SetMaxSpeed,
      e.Behaviors.Platform.Cnds.IsByWall,
      e.Behaviors.Platform.Acts.SimulateControl,
      e.Behaviors.Platform.Acts.SetVectorX,
      e.Behaviors.Platform.Exps.VectorX,
      e.Plugins.Sprite.Cnds.IsOverlappingOffset,
      e.Behaviors.Platform.Cnds.IsFalling,
      e.Behaviors.Tween.Acts.TweenTwoProperties,
      e.Plugins.Sprite.Acts.RotateTowardAngle,
      e.Behaviors.Platform.Acts.SetVectorY,
      e.Plugins.Sprite.Acts.RotateCounterclockwise,
      e.Plugins.Sprite.Acts.RotateClockwise,
      e.Plugins.Sprite.Acts.SetBoolInstanceVar,
      e.Plugins.Sprite.Cnds.IsOverlapping,
      e.Plugins.Audio.Acts.FadeVolume,
      e.Plugins.TiledBg.Cnds.CompareInstanceVar,
      e.Plugins.TiledBg.Cnds.IsBoolInstanceVarSet,
      e.Plugins.Audio.Cnds.IsTagPlaying,
      e.Plugins.Sprite.Acts.SetOpacity,
      e.Plugins.Avix_PokiSDK_ForC3.Acts.NotifyGameplayStop,
      e.Plugins.Browser.Acts.ConsoleLog,
      e.Plugins.System.Acts.SubVar,
      e.Behaviors.scrollto.Acts.Shake,
      e.Plugins.System.Acts.Wait,
      e.Plugins.System.Acts.SetTimescale,
      e.Plugins.System.Exps.timescale,
      e.Plugins.Avix_PokiSDK_ForC3.Cnds.CommercialBreakPossible,
      e.Plugins.System.Acts.SetVar,
      e.Plugins.System.Acts.WaitForPreviousActions,
      e.Behaviors.Tween.Cnds.IsPlaying,
      e.Plugins.System.Acts.SetLayerOpacity,
      e.Behaviors.Tween.Exps.Value,
      e.Behaviors.Tween.Cnds.OnTweensFinished,
      e.Plugins.System.Acts.GoToLayout,
      e.Plugins.Sprite.Cnds.OnCollision,
      e.Plugins.Sprite.Acts.SetAnim,
      e.Plugins.TiledBg.Acts.SetBoolInstanceVar,
      e.Plugins.System.Cnds.PickByComparison,
      e.Plugins.Audio.Acts.SetPlaybackRate,
      e.Plugins.Sprite.Acts.SetCollisions,
      e.Behaviors.Tween.Acts.TweenOneProperty,
      e.Plugins.Avix_PokiSDK_ForC3.Acts.NotifyGameplayStart,
      e.Plugins.Touch.Cnds.OnTouchObject,
      e.Behaviors.Timer.Cnds.IsTimerRunning,
      e.Plugins.System.Cnds.Compare,
      e.Behaviors.Timer.Exps.CurrentTime,
      e.Plugins.Keyboard.Cnds.IsKeyDown,
      e.Plugins.gamepad.Cnds.IsButtonDown,
      e.Plugins.gamepad.Cnds.CompareAxis,
      e.Plugins.Touch.Cnds.IsTouchingObject,
      e.Behaviors.Platform.Exps.VectorY,
      e.Plugins.System.Exps.dt,
      e.Plugins.Sprite.Acts.SetHeight,
      e.Plugins.Sprite.Exps.Height,
      e.Behaviors.Timer.Acts.StopTimer,
      e.Plugins.Sprite.Acts.SetAngle,
      e.Behaviors.Platform.Cnds.OnLand,
      e.Behaviors.Tween.Acts.StopTweens,
      e.Plugins.Sprite.Cnds.OnAnimFinished,
      e.Plugins.Sprite.Acts.Spawn,
      e.Plugins.Sprite.Acts.SubInstanceVar,
      e.Behaviors.LOS.Acts.SetCone,
      e.Behaviors.LOS.Acts.SetRange,
      e.Plugins.Sprite.Acts.SetEffectEnabled,
      e.Behaviors.Sin.Acts.SetEnabled,
      e.Plugins.TiledBg.Acts.SetEffectParam,
      e.Behaviors.Bullet.Acts.SetGravity,
      e.Behaviors.Bullet.Acts.SetEnabled,
      e.Behaviors.Bullet.Acts.SetSpeed,
      e.Behaviors.Bullet.Acts.SetAcceleration,
      e.Plugins.System.Acts.ToggleBoolVar,
      e.Plugins.System.Cnds.OnLayoutStart,
      e.Plugins.Particles.Acts.SetPosToObject,
      e.Behaviors.Platform.Cnds.CompareSpeed,
      e.Plugins.Particles.Acts.SetSpraying,
      e.Plugins.Particles.Acts.SetVisible,
      e.Plugins.Sprite.Exps.Width,
      e.Plugins.Particles.Cnds.OnCreated,
      e.Plugins.Particles.Acts.SetXRandomiser,
      e.Plugins.Particles.Acts.SetYRandomiser,
      e.Plugins.Particles.Cnds.IsOnScreen,
      e.Behaviors.Flash.Acts.Flash,
      e.Behaviors.Rotate.Acts.SetSpeed,
      e.Plugins.TiledBg.Acts.SetInstanceVar,
      e.Plugins.Particles.Acts.SetAngle,
      e.Plugins.Sprite.Exps.Angle,
      e.Plugins.Sprite.Acts.SetPosToObject,
      e.Behaviors.Bullet.Acts.SetAngleOfMotion,
      e.Plugins.Sprite.Cnds.CompareY,
      e.Plugins.Sprite.Acts.StartAnim,
      e.Plugins.Sprite.Cnds.IsOnScreen,
      e.Behaviors.Orbit.Acts.SetEnabled,
      e.Plugins.TiledBg.Cnds.OnCreated,
      e.Plugins.TiledBg.Acts.SetWidth,
      e.Plugins.TiledBg.Acts.SetPos,
      e.Plugins.TiledBg.Acts.MoveToLayer,
      e.Plugins.TiledBg.Cnds.IsOnScreen,
      e.Plugins.TiledBg.Acts.SetImageOffsetX,
      e.Plugins.TiledBg.Exps.ImageOffsetX,
      e.Plugins.System.Exps.int,
      e.Plugins.System.Exps.random,
      e.Plugins.Sprite.Cnds.CompareOpacity,
      e.Behaviors.Physics.Acts.ApplyImpulseAtAngle,
      e.Behaviors.solid.Acts.SetEnabled,
      e.Plugins.System.Cnds.CompareBoolVar,
      e.Plugins.TiledBg.Acts.ToggleBoolInstanceVar,
      e.Plugins.TiledBg.Exps.Width,
      e.Plugins.TiledBg.Exps.Height,
      e.Plugins.TiledBg.Exps.Angle,
      e.Plugins.TiledBg.Exps.X,
      e.Plugins.TiledBg.Exps.Y,
      e.Plugins.System.Cnds.Else,
      e.Plugins.TiledBg.Acts.Destroy,
      e.Plugins.System.Exps.choose,
      e.Behaviors.Rotate.Acts.SetEnabled,
      e.Plugins.Sprite.Cnds.AngleWithin,
      e.Plugins.Sprite.Cnds.CompareX,
      e.Behaviors.Tween.Cnds.IsAnyPlaying,
      e.Plugins.Sprite.Cnds.PickDistance,
      e.Plugins.Sprite.Exps.UID,
      e.Plugins.Sprite.Cnds.IsBetweenAngles,
      e.Plugins.Particles.Acts.SetPos,
      e.Plugins.Sprite.Acts.SetX,
      e.Plugins.System.Exps.layoutwidth,
      e.Plugins.System.Exps.viewportleft,
      e.Plugins.System.Exps.viewportright,
      e.Behaviors.Turret.Acts.SetRange,
      e.Behaviors.Turret.Acts.SetRotateSpeed,
      e.Behaviors.LOS.Acts.AddObstacle,
      e.Behaviors.Orbit.Acts.SetSpeed,
      e.Behaviors.Orbit.Acts.SetAcceleration,
      e.Behaviors.Orbit.Exps.PrimaryRadius,
      e.Behaviors.Orbit.Exps.SecondaryRadius,
      e.Behaviors.LOS.Cnds.HasLOSToObject,
      e.Behaviors.Orbit.Acts.SetRadius,
      e.Behaviors.Orbit.Acts.SetRotation,
      e.Behaviors.Turret.Acts.AcquireTarget,
      e.Behaviors.Turret.Acts.UnacquireTarget,
      e.Behaviors.Orbit.Acts.SetTarget,
      e.Behaviors.Timer.Cnds.OnTimer,
      e.Behaviors.Turret.Cnds.OnShoot,
      e.Behaviors.Bullet.Exps.Speed,
      e.Plugins.TiledBg.Acts.SetImageOffsetY,
      e.Plugins.TiledBg.Acts.SetSize,
      e.Plugins.TiledBg.Acts.SetPosToObject,
      e.Plugins.TiledBg.Acts.SetAngle,
      e.Plugins.TiledBg.Acts.SetOpacity,
      e.Behaviors.Tween.Cnds.IsPaused,
      e.Behaviors.Tween.Acts.ResumeTweens,
      e.Behaviors.Tween.Acts.PauseTweens,
      e.Plugins.Sprite.Acts.SetEffectParam,
      e.Plugins.System.Cnds.OnLayoutEnd,
      e.Plugins.System.Exps.layoutname,
      e.Plugins.Dictionary.Acts.AddKey,
      e.Plugins.Arr.Exps.AsJSON,
      e.Plugins.LocalStorage.Acts.SetItem,
      e.Plugins.Dictionary.Exps.AsJSON,
      e.Plugins.LocalStorage.Cnds.IsProcessingSets,
      e.Plugins.LocalStorage.Cnds.OnAllSetsComplete,
      e.Plugins.Browser.Acts.Close,
      e.Plugins.Browser.Acts.Reload,
      e.Plugins.Touch.Cnds.OnHoldGesture,
      e.Plugins.Arr.Acts.Clear,
      e.Plugins.Dictionary.Acts.DeleteKey,
      e.Plugins.System.Cnds.OnLoadFinished,
      e.Plugins.Audio.Acts.Preload,
      e.Plugins.Avix_PokiSDK_ForC3.Cnds.PokiPluginEnabled,
      e.Plugins.System.Cnds.IsPreview,
      e.Plugins.PlatformInfo.Cnds.IsWebExport,
      e.ScriptsInEvents.GlobalSettings_Event5_Act1,
      e.Plugins.LocalStorage.Acts.GetItem,
      e.Plugins.AJAX.Acts.RequestFile,
      e.Plugins.LocalStorage.Cnds.OnItemGet,
      e.Plugins.Dictionary.Acts.JSONLoad,
      e.Plugins.LocalStorage.Exps.ItemValue,
      e.Plugins.Dictionary.Cnds.HasKey,
      e.Plugins.Dictionary.Exps.Get,
      e.Plugins.Dictionary.Cnds.CompareValue,
      e.Plugins.System.Acts.SetBoolVar,
      e.Plugins.Arr.Acts.JSONLoad,
      e.Plugins.AJAX.Cnds.OnComplete,
      e.Plugins.AJAX.Exps.LastData,
      e.Plugins.System.Acts.SetLayerTransparent,
      e.Plugins.System.Cnds.CompareTime,
      e.Plugins.Keyboard.Cnds.OnAnyKey,
      e.Plugins.gamepad.Cnds.OnAnyButtonDown,
      e.Plugins.Touch.Cnds.OnTouchStart,
      e.Plugins.Text.Cnds.CompareInstanceVar,
      e.Plugins.Text.Acts.TypewriterText,
      e.Plugins.Arr.Exps.At,
      e.Plugins.System.Exps.layeropacity,
      e.Plugins.System.Acts.SetLayoutEffectEnabled,
      e.Plugins.System.Acts.SetLayoutEffectParam,
      e.Behaviors.Platform.Acts.SetCeilingCollision,
      e.Behaviors.Pin.Acts.PinByProperties,
      e.Plugins.Text.Acts.AppendText,
      e.Plugins.System.Exps.projectversion,
      e.Plugins.TiledBg.Acts.SetVisible,
      e.Plugins.System.Exps.viewporttop,
      e.Plugins.System.Exps.viewportbottom,
      e.Plugins.System.Cnds.ForEach,
      e.Plugins.Sprite.Acts.SetY,
      e.Plugins.System.Acts.SetLayoutScale,
      e.Plugins.Particles.Acts.Destroy,
      e.Plugins.System.Acts.SetObjectTimescale,
      e.Behaviors.Platform.Cnds.IsMoving,
      e.Behaviors.Timer.Acts.PauseResumeTimer,
      e.Plugins.Text.Acts.SetVisible,
      e.Behaviors.MoveTo.Acts.SetEnabled,
      e.Behaviors.Timer.Cnds.IsTimerPaused,
      e.Plugins.Audio.Acts.UnloadAudio,
      e.Plugins.Audio.Acts.SetSilent,
      e.Plugins.Audio.Acts.Stop,
      e.Plugins.System.Exps.min,
      e.Plugins.System.Exps.max,
      e.Plugins.Text.Cnds.IsRunningTypewriterText,
      e.Plugins.Audio.Acts.SetMuted,
      e.Plugins.Audio.Acts.SetVolume,
      e.Plugins.Text.Cnds.OnCreated,
      e.Plugins.Text.Acts.SetInstanceVar,
      e.Plugins.Text.Exps.Height,
      e.Plugins.Text.Exps.Width,
      e.Plugins.Mouse.Cnds.IsOverObject,
      e.Plugins.Browser.Acts.GoToURLWindow,
      e.Plugins.System.Exps.find,
      e.Plugins.Sprite.Exps.LayerName,
      e.Plugins.System.Exps.originalwindowwidth,
      e.Plugins.System.Exps.originalwindowheight,
      e.Plugins.Text.Acts.SetWrapping,
      e.Plugins.Avix_PokiSDK_ForC3.Acts.RequestCommercialBreak,
      e.Plugins.Text.Acts.AddChild,
      e.Plugins.Sprite.Cnds.IsAnimPlaying,
      e.Plugins.Text.Cnds.IsBoolInstanceVarSet,
      e.Plugins.Text.Acts.SetPos,
      e.Plugins.Text.Acts.ToggleBoolInstanceVar,
      e.Plugins.Arr.Acts.SetX,
      e.Plugins.Arr.Acts.SetXY,
      e.Plugins.Text.Acts.SetText,
      e.Plugins.Text.Cnds.OnTypewriterTextFinished,
      e.Plugins.System.Cnds.Every,
      e.Plugins.Avix_PokiSDK_ForC3.Acts.HappyTime,
      e.Behaviors.Timer.Exps.Duration,
      e.Behaviors.MoveTo.Acts.Stop,
      e.Plugins.Sprite.Acts.AddInstanceVar,
      e.Plugins.System.Exps.zeropad,
      e.Plugins.Touch.Cnds.OnHoldGestureObject,
      e.Plugins.gamepad.Cnds.HasGamepads,
    ];
  };
  self.C3_JsPropNameTable = [
    { ClearText: 0 },
    { Var: 0 },
    { ControlsText: 0 },
    { CreditsText: 0 },
    { CreditsText2: 0 },
    { DeathsTxt: 0 },
    { Variable1: 0 },
    { debug: 0 },
    { Variable: 0 },
    { Debug_LB: 0 },
    { Active: 0 },
    { Tween: 0 },
    { Dialogue_Box: 0 },
    { FailedtoKillBS: 0 },
    { FailedtoRescueP: 0 },
    { index: 0 },
    { LB_RSC_SCR: 0 },
    { LB_RSC_USRNM: 0 },
    { LB_RVG_SCR: 0 },
    { LB_RVG_USR: 0 },
    { LB_USER_RES: 0 },
    { LD_USER_RVG: 0 },
    { Leaderboard: 0 },
    { Leaderboard_text: 0 },
    { PlayerStat_RescueTime: 0 },
    { StatsText: 0 },
    { CurrentBoard: 0 },
    { textKey: 0 },
    { textSmallSquares: 0 },
    { BestRescue: 0 },
    { BestRevengeDic: 0 },
    { Dictionary: 0 },
    { LB_Rescue_G10: 0 },
    { Audio: 0 },
    { Browser: 0 },
    { LocalStorage: 0 },
    { NWjs: 0 },
    { Bullet: 0 },
    { Bullet_0: 0 },
    { States: 0 },
    { Zone: 0 },
    { startHeight: 0 },
    { Lava: 0 },
    { ActiveZoneObject: 0 },
    { Saw_State: 0 },
    { Saw_Zones: 0 },
    { ZoneNumber: 0 },
    { State: 0 },
    { SinMove: 0 },
    { SinSize: 0 },
    { tweenMove: 0 },
    { portalState: 0 },
    { cutScene: 0 },
    { Solid: 0 },
    { SawNeon: 0 },
    { SinMover: 0 },
    { Orbiter: 0 },
    { Sine: 0 },
    { Orbit: 0 },
    { Timer: 0 },
    { AtlasSquare: 0 },
    { SawNeon2: 0 },
    { Distance: 0 },
    { angleStart: 0 },
    { Rotate: 0 },
    { SawPortal: 0 },
    { zone_P: 0 },
    { Particle_Death_Splat: 0 },
    { Particle_Red_1: 0 },
    { Particles_Explosion: 0 },
    { Particles_Fire: 0 },
    { Particles_Laser_Death: 0 },
    { Particles_Level_Exit: 0 },
    { Particles_Portal_Orange: 0 },
    { Particles_Respawn: 0 },
    { Particles_Self_Destruct: 0 },
    { Pin: 0 },
    { Particles_Trail_Player: 0 },
    { InstanceRate: 0 },
    { Particles_Water_Bubbles: 0 },
    { Particles_Water_Splash: 0 },
    { Particles_Blue_Portal: 0 },
    { Particles_Checkpoint: 0 },
    { particles_water: 0 },
    { Zones: 0 },
    { particles_water_spray: 0 },
    { Particle_Death_Fountain: 0 },
    { Level_Tilemap: 0 },
    { TMStructuralNEON: 0 },
    { TMStructuralFLAPPY: 0 },
    { StartX: 0 },
    { StartY: 0 },
    { Align: 0 },
    { Touch_Jump: 0 },
    { Touch_Left: 0 },
    { Touch_Right: 0 },
    { Gamepad: 0 },
    { Keyboard: 0 },
    { Mouse: 0 },
    { Touch: 0 },
    { CoD: 0 },
    { CharacterState_Meta: 0 },
    { normalState: 0 },
    { swimmingState: 0 },
    { Block_Affector: 0 },
    { conveyorState: 0 },
    { PausedState: 0 },
    { Jumped: 0 },
    { Floored: 0 },
    { WallFall: 0 },
    { Jump: 0 },
    { Move_Left: 0 },
    { Move_Right: 0 },
    { Color: 0 },
    { LightAffector: 0 },
    { zoneTransferState: 0 },
    { PowerBoost: 0 },
    { SafeZoneState: 0 },
    { BoxState: 0 },
    { MoveRight: 0 },
    { MoveLeft: 0 },
    { flappyJumps: 0 },
    { flappyRotate: 0 },
    { isFlappy: 0 },
    { Platform: 0 },
    { Flash: 0 },
    { Player: 0 },
    { PopUpText: 0 },
    { CP: 0 },
    { Checkpoint: 0 },
    { Direction: 0 },
    { Respawn: 0 },
    { particleRandomX: 0 },
    { particleRandomY: 0 },
    { Water: 0 },
    { Instance: 0 },
    { Entered: 0 },
    { Force: 0 },
    { OrangePortalEntrance: 0 },
    { OrangePortalExit: 0 },
    { BluePortalExit: 0 },
    { BluePortalEntrance: 0 },
    { Corpse_Lava: 0 },
    { Statess: 0 },
    { Zoness: 0 },
    { InstanceVar: 0 },
    { Dialogue: 0 },
    { Spoken: 0 },
    { AISmallSquares: 0 },
    { Platform_Slider: 0 },
    { Power: 0 },
    { startY: 0 },
    { Bouncer: 0 },
    { SwitchNumber: 0 },
    { Activate: 0 },
    { Type: 0 },
    { Inverted: 0 },
    { Switch: 0 },
    { ver: 0 },
    { TextDebug: 0 },
    { Water_Top: 0 },
    { Spikes: 0 },
    { Red: 0 },
    { Green: 0 },
    { Blue: 0 },
    { blood: 0 },
    { GameZone: 0 },
    { YTrans: 0 },
    { ScrollTo: 0 },
    { MoveTo: 0 },
    { Camera: 0 },
    { lightSaw: 0 },
    { lightPlayer: 0 },
    { lightWater: 0 },
    { lightRespawn: 0 },
    { StateSecurity: 0 },
    { DistanceX: 0 },
    { OrbitX: 0 },
    { OrbitY: 0 },
    { LineOfSight: 0 },
    { SecurityBot: 0 },
    { Timeline: 0 },
    { lightSecurity: 0 },
    { Number: 0 },
    { Closed: 0 },
    { Jumpthru: 0 },
    { Dash: 0 },
    { dtSpeed: 0 },
    { MoveDown: 0 },
    { PlayerActive: 0 },
    { playerTouching: 0 },
    { Conveyor: 0 },
    { lightConveyor: 0 },
    { DoorNumber: 0 },
    { Door: 0 },
    { LightDoor: 0 },
    { lightAngleMin: 0 },
    { lightAngleMax: 0 },
    { Spotted: 0 },
    { HP: 0 },
    { Engagable: 0 },
    { SafeBox: 0 },
    { Level: 0 },
    { lightWarp: 0 },
    { distance: 0 },
    { OriginalY: 0 },
    { Activated: 0 },
    { elevator: 0 },
    { ElevatorChains: 0 },
    { StartWidth: 0 },
    { Laser: 0 },
    { lightLaser: 0 },
    { PlatformInfo: 0 },
    { Gridbackground: 0 },
    { Logo: 0 },
    { NeonLogo: 0 },
    { AIExclaimation: 0 },
    { DialogueTop1: 0 },
    { DialogueTop2: 0 },
    { EndingDialogue: 0 },
    { BigSquare: 0 },
    { StartHeight: 0 },
    { UIStart: 0 },
    { MenuType: 0 },
    { MenuIndex: 0 },
    { UIMarker: 0 },
    { TouchMenu: 0 },
    { BigSquareTextMenu: 0 },
    { BigSquareTextBox: 0 },
    { AJAX: 0 },
    { ArraySquareDiag: 0 },
    { NormalHeight: 0 },
    { SquishedHeight: 0 },
    { PineApple: 0 },
    { lightPlayerDeath: 0 },
    { StartText: 0 },
    { lightSwitch: 0 },
    { lightSafeBox: 0 },
    { DashBox: 0 },
    { SecurityBubble: 0 },
    { PineAppleText: 0 },
    { CameraClassic: 0 },
    { CameraMode: 0 },
    { SliderBar: 0 },
    { On: 0 },
    { SecuritySwitch: 0 },
    { startwidth: 0 },
    { startheight: 0 },
    { SecurityBlock: 0 },
    { Turret: 0 },
    { SawTurret: 0 },
    { SawRound: 0 },
    { CheckerTexture: 0 },
    { lightPlatform: 0 },
    { UIOptions: 0 },
    { UIQuit: 0 },
    { Bar: 0 },
    { WidescreenBars: 0 },
    { Character: 0 },
    { TextOptions: 0 },
    { UIDash: 0 },
    { inTouch: 0 },
    { UISquare: 0 },
    { CamPlayer: 0 },
    { Heart: 0 },
    { HeartParticles: 0 },
    { Index: 0 },
    { UICherry: 0 },
    { Grabbed: 0 },
    { Collected: 0 },
    { InitialX: 0 },
    { InitialY: 0 },
    { Cherry: 0 },
    { ArraySmallSquaresDialogueCheck: 0 },
    { CameraOff: 0 },
    { CameraZoom: 0 },
    { MusicOn: 0 },
    { SFX: 0 },
    { languageUIIndex: 0 },
    { Language: 0 },
    { PerformanceMode: 0 },
    { Credits: 0 },
    { Back: 0 },
    { Controls: 0 },
    { Data: 0 },
    { ControlsImages: 0 },
    { ArrayBigSquareDiagRandom: 0 },
    { ArrayBigSquareTowerTop: 0 },
    { ArrayBigSquareTopFall: 0 },
    { X: 0 },
    { TextDeaths: 0 },
    { DeathScrolls: 0 },
    { KillScroll: 0 },
    { PineappleKills: 0 },
    { delay: 0 },
    { TextKill: 0 },
    { TextRevenge: 0 },
    { ArrayDiagend: 0 },
    { ArraySmallSquareDown: 0 },
    { StatVar: 0 },
    { TextStats: 0 },
    { TextReset: 0 },
    { EOFace80s: 0 },
    { LogoText: 0 },
    { var: 0 },
    { TextIntro: 0 },
    { PineAppleIMG: 0 },
    { "8Direction": 0 },
    { CharacterIMG: 0 },
    { ArrayIntroText: 0 },
    { Fullscreen: 0 },
    { Support: 0 },
    { ArrayOptionsLanguage: 0 },
    { ArrayCredits: 0 },
    { TextCredits: 0 },
    { LanguagesIndividual: 0 },
    { TextCopyRight: 0 },
    { SM_YouTube: 0 },
    { SM_Instagram: 0 },
    { SM_Facebook: 0 },
    { SM_Twitter: 0 },
    { SM_TikToc: 0 },
    { RotateWarning: 0 },
    { EraseData: 0 },
    { DataErase: 0 },
    { GameOver: 0 },
    { TextGameOver: 0 },
    { ArrayGameOver: 0 },
    { UIPurchase: 0 },
    { UIGORestart: 0 },
    { GameOverCam: 0 },
    { Discord: 0 },
    { SM_Discord: 0 },
    { UIRestorePurchase: 0 },
    { privacyspolicy: 0 },
    { SteamLogo: 0 },
    { SteamLogo2: 0 },
    { AppStoreWhite: 0 },
    { googleplaybadge: 0 },
    { itchbadge: 0 },
    { heightStart: 0 },
    { heightEnd: 0 },
    { Pipe: 0 },
    { pipeRedTube: 0 },
    { jumpCountPlayer: 0 },
    { RespawnEffect: 0 },
    { Mover: 0 },
    { moveLeft: 0 },
    { StartAngle: 0 },
    { Horizontal: 0 },
    { BulletX: 0 },
    { pipeRedFull: 0 },
    { Vertical: 0 },
    { pipePurple: 0 },
    { blowRight: 0 },
    { blowLeft: 0 },
    { PurplePipeVolume: 0 },
    { PurplePipeParticles: 0 },
    { scaleStart: 0 },
    { Zoom: 0 },
    { PipeRespawn: 0 },
    { Wings: 0 },
    { RedPipeTubeCurve: 0 },
    { RedPipeCorner: 0 },
    { RedPipeCurved: 0 },
    { flappyJumpVolume: 0 },
    { startX: 0 },
    { ActiveZone: 0 },
    { WingsPlayer: 0 },
    { particlesHeat: 0 },
    { BluePipeTube: 0 },
    { BluePipeTubeCurve2: 0 },
    { PlayerWingsFor: 0 },
    { PineappleWings: 0 },
    { EndZoomTriggeBox: 0 },
    { CameraMoveEndTrigger: 0 },
    { Anim: 0 },
    { Cloud: 0 },
    { Feather: 0 },
    { ParticleFeather: 0 },
    { ParticleFeatherP: 0 },
    { BigSquareWings: 0 },
    { PineappleExplosion: 0 },
    { BigTowerLogo: 0 },
    { PreviouslyOn: 0 },
    { FLAPPY: 0 },
    { Cloud2: 0 },
    { Credits2: 0 },
    { Controls2: 0 },
    { Stats: 0 },
    { Sprite: 0 },
    { Controls3: 0 },
    { EOFace80s2: 0 },
    { EODude: 0 },
    { EO_Dude_1024x: 0 },
    { EO_Dude_512x: 0 },
    { textLoading: 0 },
    { A: 0 },
    { D: 0 },
    { W: 0 },
    { space: 0 },
    { AButton: 0 },
    { Dpad: 0 },
    { EOTextLogo: 0 },
    { CMGLogo: 0 },
    { level: 0 },
    { triggerboxLevelTransfer: 0 },
    { tileCorner: 0 },
    { launchBox: 0 },
    { shootAngle: 0 },
    { turretOuter: 0 },
    { statePrevious: 0 },
    { turretEye: 0 },
    { turretBarrel: 0 },
    { bulletParticles: 0 },
    { checkpointEmpty: 0 },
    { checkpoint: 0 },
    { checkpointWrap: 0 },
    { dtMulti: 0 },
    { zone: 0 },
    { lava2: 0 },
    { BigTowerRedux: 0 },
    { purplePortalEnt: 0 },
    { purplePortalExit: 0 },
    { active: 0 },
    { lavaNoise: 0 },
    { pineappleHair: 0 },
    { lavaBubbleParticles: 0 },
    { lavaBubbleBurst: 0 },
    { dtmulti: 0 },
    { lava3: 0 },
    { backgroundTower: 0 },
    { OrangePortalEntrance2: 0 },
    { OrangePortalExit2: 0 },
    { dashAtlas: 0 },
    { lavaDrip: 0 },
    { PokiSDK: 0 },
    { Sprite2: 0 },
    { Sine_Movement: 0 },
    { Sine_Size: 0 },
    { Family_Saws: 0 },
    { BulletDestroyers: 0 },
    { TimeScalePause: 0 },
    { Physics: 0 },
    { Particles_Red: 0 },
    { Particles_Black: 0 },
    { UIText: 0 },
    { Leaderboards: 0 },
    { Family_Players: 0 },
    { Family_NPC: 0 },
    { Family_TMs: 0 },
    { Family_Particles: 0 },
    { Family_Zone_Delete: 0 },
    { Family_Particles_Flow: 0 },
    { SinMovers: 0 },
    { Family_Particle_Sprites: 0 },
    { Family_Splash_Stoppers: 0 },
    { WaterFam: 0 },
    { Family_Statics: 0 },
    { Theme_Changers: 0 },
    { ActiveTiled: 0 },
    { TiledDeath: 0 },
    { ActiveSprite: 0 },
    { ActiveSaw: 0 },
    { DoorsFam: 0 },
    { BridgeFam: 0 },
    { SecurityFam: 0 },
    { UIFam: 0 },
    { Anchor: 0 },
    { TouchFam: 0 },
    { LightFam: 0 },
    { UIButtonFam: 0 },
    { SocialMediaFam: 0 },
    { ResponsiveObjects: 0 },
    { EOLogos: 0 },
    { LavaFamily: 0 },
    { PrimaryAngle: 0 },
    { Player_Start_X: 0 },
    { Player_Start_Y: 0 },
    { RespawnCPGlobal: 0 },
    { Current_Checkpoint: 0 },
    { playerGravityNormal: 0 },
    { playerFallSpeedNormal: 0 },
    { playerDecelerationGround: 0 },
    { playerMaxSpeedGround: 0 },
    { playerDecelerationAir: 0 },
    { playerMaxSpeedAir: 0 },
    { TouchXBaseline: 0 },
    { TouchXMovement: 0 },
    { Wall_Fall_Slow: 0 },
    { Wall_Fall_Boost_X: 0 },
    { WallJumpBuffer: 0 },
    { PlayerY: 0 },
    { coveyorSpeedHorizontal: 0 },
    { conveyorSpeedVertical: 0 },
    { NormalJumpBuffer: 0 },
    { TouchXBase: 0 },
    { TouchDirection: 0 },
    { jumpSustainPower: 0 },
    { jumpSustainTime: 0 },
    { Jump_Strength: 0 },
    { Wall_Jump_Boost_Y: 0 },
    { Wall_Jump_Boost_X: 0 },
    { flappyJumpPower: 0 },
    { flappySustainPower: 0 },
    { flappySustainTime: 0 },
    { textime: 0 },
    { SawRotationNormal: 0 },
    { SawRotationReverse: 0 },
    { bouncerPower: 0 },
    { sawPortalDifference: 0 },
    { sawPortalDivider: 0 },
    { turretRange: 0 },
    { Last_Layout: 0 },
    { ResetSets: 0 },
    { Saved: 0 },
    { RevengeTime: 0 },
    { RescueTime: 0 },
    { FinishedState: 0 },
    { GameJumps: 0 },
    { GameDeaths: 0 },
    { GameTime: 0 },
    { BestRevenge: 0 },
    { TotalJumps: 0 },
    { TotalDeaths: 0 },
    { TotalTime: 0 },
    { gameName: 0 },
    { GameMode: 0 },
    { GameState: 0 },
    { UIType: 0 },
    { UIMenuIndex: 0 },
    { UIStartY: 0 },
    { UISelection: 0 },
    { LanguageIndex: 0 },
    { ScaleOutPC: 0 },
    { ScaleOutMobileL: 0 },
    { ScaleOutMobileP: 0 },
    { ScaleInPC: 0 },
    { ScaleInMobileL: 0 },
    { ScaleInMobileP: 0 },
    { VolumeSFX: 0 },
    { VolumeMusic: 0 },
    { Towerfall: 0 },
    { CherriesCollected: 0 },
    { LoadState: 0 },
    { UION: 0 },
    { UIOpacity: 0 },
    { UnlimitedLives: 0 },
    { GameLives: 0 },
    { domain: 0 },
    { followCam: 0 },
    { adReady: 0 },
    { CameraZoomMobileP: 0 },
    { CameraZoomMobileL: 0 },
    { CameraZoomNormal: 0 },
    { volumeStandard: 0 },
    { BarWidth: 0 },
    { LevelsUp: 0 },
    { LevelsDown: 0 },
    { LevelTransferCheck: 0 },
  ];
}
{
  const e = self.C3;
  function b(a, c) {
    return "string" === typeof a || "string" === typeof c
      ? ("number" === typeof a ? (Math.round(1e10 * a) / 1e10).toString() : a) +
          ("number" === typeof c ? (Math.round(1e10 * c) / 1e10).toString() : c)
      : a && c
      ? 1
      : 0;
  }
  self.C3_ExpressionFuncs = [
    () => "Character Initialization",
    () => 12,
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject();
    },
    (a) => {
      const c = a._GetNode(0).GetVar();
      return () => c.GetValue();
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject(2);
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject(2) - 32;
    },
    () => "UI",
    () => 32,
    () => 16,
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject() - 32;
    },
    () => "Character is In Play",
    () => "InPlay",
    () => 0,
    () => "ScaleDrop",
    (a) => {
      const c = a._GetNode(0).GetBoundMethod();
      return () => c();
    },
    () => 1,
    () => "Self Destruct",
    () => "Player",
    () => "",
    () => "SelfDestruct",
    () => "Death",
    () => "Normal State",
    (a) => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1).GetVar();
      return () => c() - d.GetValue();
    },
    () => 0.1,
    () => "Jumptimer",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar();
      return () => c.ExpBehavior() - d.GetValue();
    },
    () => "WallJumpRight",
    () => -2,
    () => "WallCling",
    () => 8,
    () => 14,
    () => 0.2,
    () => 15,
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar();
      return () => c.ExpBehavior() + d.GetValue();
    },
    () => "WallJumpLeft",
    () => 2,
    () => "Paused State",
    () => "Box State",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject(1);
    },
    () => "Conveyor Moveable",
    () => "lightride",
    () => -100,
    () => 0.5,
    () => "Horizontal",
    (a) => {
      const c = a._GetNode(0).GetVar();
      return () => -c.GetValue();
    },
    () => -150,
    () => "Vertical",
    () => "Swimming State",
    () => 150,
    () => 70,
    () => -75,
    () => 75,
    () => 100,
    () => "Death State",
    () => 10,
    () => 0.25,
    () => 0.05,
    (a) => {
      const c = a._GetNode(0).GetBoundMethod();
      return () => e.lerp(c(), 1, 1);
    },
    () => "Respawn",
    () => "An Ad was called but was unable to be served.",
    () => "GameOverFade",
    () => "FadeLayer",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("GameOverFade");
    },
    () => "Respawn State",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpInstVar();
    },
    () => "On",
    (a) => {
      const c = a._GetNode(0).GetVar();
      return () => "Checkpoint: " + c.GetValue();
    },
    () => "CheckpointBleep",
    () => "Default",
    () => "PlayerRespawnPosition",
    () => "Respawning...",
    () => "Respawned",
    () => -285,
    () => "Gameover State",
    () => "GameOver",
    () => "Level Change State",
    () => "LevelChange",
    () => "Movement Controls",
    (a) => {
      const c = a._GetNode(0);
      return () => b("jump", c.ExpInstVar());
    },
    () => "Flappy Jump",
    () => "Normal Jump",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("Jumptimer");
    },
    () => 0.09,
    () => "Move_Left",
    () => -60,
    () => "MoveLeft",
    () => "Move_Right",
    () => 60,
    () => "MoveRight",
    () => "Jump Functions (Normal)",
    () => "Sustain",
    () => "JumpOn",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod();
      return () => c.ExpBehavior() - 60 * d.GetValue() * f();
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1),
        f = a._GetNode(2).GetBoundMethod();
      return () => c.ExpObject() + 60 * (d.ExpBehavior("Sustain") + 0.2) * f();
    },
    () => "WallJump",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior();
    },
    () => "RotateValue",
    () => -180,
    () => "RotateRight",
    () => 180,
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("RotateValue");
    },
    () => -475,
    () => "Extend",
    () => 0.7,
    () => "Swimming",
    () => -90,
    () => "Landing",
    () => "HeightReset",
    () => "Jump Functions (Flappy)",
    () => "flappySustain",
    (a) => {
      const c = a._GetNode(0).GetVar();
      return () => c.GetValue() + 10;
    },
    () => "Animation 1",
    (a) => {
      const c = a._GetNode(0).GetVar();
      return () => 1.5 * -c.GetValue();
    },
    () => 0.10000000000000009,
    () => 360,
    () => 48,
    () => "Scanlines",
    () => "GlowHorizontal",
    () => "GlowVertical",
    () => "Confusion",
    () => "SecurityHum",
    () => "Sleep",
    () => "Chasing",
    () => "Spark",
    () => 3,
    () => 4,
    () => 5,
    () => 200,
    () => "flappyWingsTween",
    () => "wingsdeathtween",
    () => "NewWings",
    () => "flappyWingsTweenOn",
    () => "Bouncer",
    () => "bounceTween",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpInstVar() - 8;
    },
    () => "Player Particles",
    () => "Water Particles",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject() / 2;
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject(0);
    },
    () => "Interact",
    () => "Environment",
    () => "Death Effects",
    (a) => {
      const c = a._GetNode(0).GetVar();
      return () => c.GetValue() - 5;
    },
    () => 0.4,
    () => "conveyorSpeed",
    () => 240,
    () => "lightrideFast",
    () => "RotateSlow",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("RotateSlow");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("lightrideFast");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("conveyorSpeed");
    },
    () => "Portals",
    () => "OrangePortals",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1);
      return () => c.ExpBehavior() + d.ExpInstVar();
    },
    () => "Spin",
    () => "None",
    () => "Portaled",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar();
      return () => c.ExpObject() - d.GetValue();
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar();
      return () => c.ExpObject() + d.GetValue();
    },
    () => "BluePortal",
    (a) => {
      const c = a._GetNode(0);
      return () => -c.ExpInstVar();
    },
    () => "purple Portals",
    () => "Lava",
    () => "Corpse",
    () => "Lava Waves",
    () => "Fluids",
    () => "TowerRise",
    () => "LevelTransition",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1),
        f = a._GetNode(2).GetBoundMethod(),
        h = a._GetNode(3).GetBoundMethod(),
        g = a._GetNode(4).GetBoundMethod();
      return () => c.ExpObject() + d.ExpInstVar() * f(h(30, 61)) * g();
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1),
        f = a._GetNode(2).GetBoundMethod(),
        h = a._GetNode(3).GetBoundMethod(),
        g = a._GetNode(4).GetBoundMethod();
      return () => c.ExpObject() - d.ExpInstVar() * f(h(30, 61)) * g();
    },
    () => "Particle Physics",
    () => "Particles Red",
    () => 0.3,
    (a) => {
      const c = a._GetNode(0).GetBoundMethod();
      return () => c(30, 330);
    },
    () => "Particles Death",
    () => "DeadLights",
    () => 2e3,
    (a) => {
      const c = a._GetNode(0).GetBoundMethod();
      return () => c(300, 400);
    },
    (a) => {
      const c = a._GetNode(0).GetBoundMethod();
      return () => c(0, 360);
    },
    () => 1.5,
    () => "Switch and Door Triggers",
    () => "SwitchSpawn",
    () => "Normal Switch",
    () => -1,
    () => "Top",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1);
      return () => c.ExpObject() + d.ExpObject() / 2;
    },
    () => "Bottom",
    () => "Door",
    () => 2.5,
    () => "dooropen",
    () => "Bridge",
    () => "BridgeWithdraw",
    () => "bridgewithdraw",
    () => "Particles General",
    () => "Conveyor",
    () => "Towerfall",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod(),
        f = a._GetNode(2);
      return () => c.ExpObject() - d() * f.ExpInstVar();
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod(),
        f = a._GetNode(2);
      return () => c.ExpObject() + d() * f.ExpInstVar();
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod(),
        f = a._GetNode(2);
      return () => c.ExpObject() + d() * -f.ExpInstVar();
    },
    () => "Lights",
    (a) => {
      const c = a._GetNode(0);
      return () => 1.2 * c.ExpObject();
    },
    (a) => {
      const c = a._GetNode(0);
      return () => 2 * c.ExpObject();
    },
    () => "Doors",
    () => "Saw Neon",
    () => "Active",
    (a) => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetVar();
      return () => c(d.GetValue(), f.GetValue());
    },
    () => "SinMover",
    () => "Inactive",
    () => "SawAngleReset",
    () => "Elevator (ZoneTransfer)",
    () => "TransferTween",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1);
      return () => c.ExpObject() - d.ExpInstVar();
    },
    (a) => {
      const c = a._GetNode(0);
      return () => b("TransferTween", c.ExpObject());
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod();
      return () => c.ExpObject() + 300 * d();
    },
    () => "Actived Background Tiles",
    () => "Atlas Square",
    (a) => {
      const c = a._GetNode(0);
      return () => b("lavaDrip", c.ExpObject());
    },
    () => "Pipes",
    () => "Red Pipes",
    () => "Purple Pipe Volume",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod();
      return () => c.ExpBehavior() - 1500 * d();
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod();
      return () => c.ExpBehavior() + 1500 * d();
    },
    () => 300,
    () => 30,
    () => 80,
    () => 270,
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject() - 4;
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject() + 24;
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject() - 24;
    },
    () => "Clouds",
    (a) => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1).GetBoundMethod(),
        f = a._GetNode(2).GetBoundMethod();
      return () => c(d() / 2 - 500, f() / 2 + 500);
    },
    (a) => {
      const c = a._GetNode(0).GetBoundMethod();
      return () => c("Cloud_1", "Cloud_2", "Cloud_3");
    },
    (a) => {
      const c = a._GetNode(0).GetBoundMethod();
      return () => c(-20, -30, -40, -50);
    },
    () => "Paused",
    () => 1020,
    (a) => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1);
      return () => c(0) - d.ExpObject() / 2;
    },
    (a) => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1);
      return () => c(0) + d.ExpObject() / 2;
    },
    () => "Clouds2",
    (a) => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1).GetBoundMethod(),
        f = a._GetNode(2).GetBoundMethod();
      return () => c(d() / 2 - 1e3, f() / 2 + 1e3);
    },
    () => "Big Square",
    () => "Turrets",
    () => 44,
    () => "Idle",
    () => "Seek",
    () => 96,
    () => "eyeOrbitPrimary",
    (a) => {
      const c = a._GetNode(0).GetBoundMethod();
      return () => c(-2, 4);
    },
    () => "eyeOrbitSecondary",
    () => "Engaged",
    () => "turretLOS",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("eyeOrbitPrimary");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("eyeOrbitSecondary");
    },
    () => 40,
    () => "Red",
    () => "Green",
    () => "Stunned",
    () => "hitStun",
    () => "bulletShot",
    () => "Bullets",
    () => "bulletWall",
    (a) => {
      const c = a._GetNode(0);
      return () => -c.ExpBehavior();
    },
    () => "bulletReflect",
    () => "CheckpointWrap",
    () => 50,
    () => "Right",
    () => "Left",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod();
      return () => c.ExpObject() + 50 * d();
    },
    () => "Pineapple",
    () => "hairTween",
    () => -5,
    () => "bodyTween",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject() + 4;
    },
    () => "SimpleSkend",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("hairTween");
    },
    () => "Saw Portal",
    () => "GameTimer",
    () => "Last_Layout",
    () => "Save System",
    () => "Autosave",
    () => "Language",
    () => "GameLives",
    () => "UnlimitedLives",
    () => "Camera",
    () => "Fullscreen",
    () => "Music",
    () => "SFX",
    () => "Performance",
    () => "respawnCP",
    () => "GameTime",
    (a) => {
      const c = a._GetNode(0).GetVar(),
        d = a._GetNode(1).GetVar();
      return () => c.GetValue() + d.GetValue();
    },
    () => "TotalDeaths",
    () => "SquaresSpoken",
    () => "Rescue",
    () => "Revenge",
    () => "BestRescue",
    () => "BestRevenge",
    (a) => {
      const c = a._GetNode(0).GetVar();
      return () => c.GetValue() + "SaveGame";
    },
    () => "Processing Sets...",
    () => "All Sets Complete",
    () => "Quit",
    () => "Quiting",
    () => "ResetGame From Options",
    () => "Resetting",
    () => "Restart Game End",
    () => "Reset",
    () => "Clear Data",
    () => "SawDeaths",
    () => "LaserDeaths",
    () => "BotDeaths",
    () => "PlatformDeaths",
    () => "Loader Layout Complete",
    () => "Sitelock ", // changed from "Sitelock Check" to Sitelock with a space
    () => "Load Saved Items3",
    () => "AJAX Initial Request",
    () => "IntroText",
    () => "Load Requests",
    () => "LoadingDictionary",
    () => "SettingSaves",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject("Language");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject("GameLives");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject("Music");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject("SFX");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject("respawnCP");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject("GameTime");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject("TotalDeaths");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject("SquaresSpoken");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject("Rescue");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject("Revenge");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject("BestRescue");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject("BestRevenge");
    },
    () => "AJAX Requests",
    () => "SmallDiagLoad",
    () => "SmallSquareDown",
    () => "BigSquareDiagRandom",
    () => "BigSquareTowerTop",
    () => "BigSquareTopFall",
    () => "Diagend",
    () => "OptionsLanguage",
    () => "Splash Screen Layout Change",
    () => "SplashFade",
    () => "SplashFadeIn",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("SplashFadeIn");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("SplashFade");
    },
    () => 7,
    () => "Layout Start Events",
    () => "Splash Screen2",
    () => "Splash",
    () => "Menu",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2),
        h = a._GetNode(3).GetVar(),
        g = a._GetNode(4),
        k = a._GetNode(5).GetVar(),
        m = a._GetNode(6),
        q = a._GetNode(7).GetVar();
      return () =>
        b(
          b(
            b(
              b(
                b(
                  b(
                    b(
                      b(b(c.ExpObject(d.GetValue(), 0), "\n"), "\n"),
                      f.ExpObject(h.GetValue(), 1)
                    ),
                    "\n"
                  ),
                  "\n"
                ),
                g.ExpObject(k.GetValue(), 2)
              ),
              "\n"
            ),
            "\n"
          ),
          m.ExpObject(q.GetValue(), 3)
        );
    },
    () => "Main Tower Layout",
    () => "Remastered",
    (a) => {
      const c = a._GetNode(0).GetBoundMethod();
      return () => c("FadeLayer");
    },
    () => "Layout Initialize",
    () => "BlurVertical",
    (a) => {
      const c = a._GetNode(0).GetBoundMethod();
      return () => c("Widescreenbars");
    },
    () => "Start",
    () => "Index Objects",
    () => "Camera Starting Events",
    () => "CameraZoomEndOut",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod();
      return () => c.ExpObject() / 2 + 16 + d("Background");
    },
    () => "CameraZoomEnd",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("CameraZoomEnd");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("CameraZoomEndOut");
    },
    () => "Towerfall Initialization",
    () => "Game Modes",
    () => "Normal Mode",
    () => "Normal",
    () => "SUPERHOT Mode",
    () => "Superhot",
    () => "Game Is Paused",
    () => "Ending",
    () => "Scale Adjustment On Load",
    () => "Main",
    () => "UI Navigation",
    () => "MenuChangeInProgress",
    () => -30,
    () => "Play Button",
    () => "GameStart",
    () => "StartOn",
    () => "UIStartOn",
    (a) => {
      const c = a._GetNode(0);
      return () => 1.1 * c.ExpObject();
    },
    () => "StartOff",
    () => "Options Button",
    () => "UIOptionsOn",
    () => "Music Button",
    () => "SFX Button",
    () => "Language Button",
    () => "LanguageSwitch",
    () => "Quit Button",
    () => 6,
    () => "BSTextboxsize",
    () => "Fall",
    () => "Dropping",
    () => -200,
    () => "MainLoop",
    () => "OptionsCam",
    () => "Options",
    () => 960,
    () => "Game Is In Play",
    () => "menu",
    () => "Transition",
    () => "FadeIn",
    () => "QuickFade",
    () => 160,
    () => 84,
    () => "LogoUp",
    (a) => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1).GetBoundMethod(),
        f = a._GetNode(2);
      return () => c(5, d(2, f.ExpInstVar() / 2));
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("ScaleDrop");
    },
    () => "Zone Activation",
    () => "ZoneTransition",
    () => "FinalZoneOut",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("FinalZoneOut");
    },
    () => "FinalZoneIn",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("FinalZoneIn");
    },
    () => 0.6,
    () => "LogoDown",
    () => "BossTextReveal",
    () => 512,
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod();
      return () =>
        c.ExpObject(d.GetValue(), f(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
    },
    () => "Sound Controls",
    () => "MusicOn",
    () => "MusicOff",
    () => "SFXOn",
    () => "SFXOff",
    () => "WidescreenTween",
    () => "FadeInTouch",
    () => "UI Adjustments",
    () => "Social Media",
    () => "MouseOver",
    () => 1.1,
    () => "MouseNotOver",
    () => "https://www.youtube.com/channel/UChRDJjvNhwptVcEnqnbRG2A",
    () => "NewWindow",
    () => "https://twitter.com/EvilObjective",
    () => "https://www.facebook.com/EvilObjective",
    () => "https://www.instagram.com/evilobjective/",
    () => "https://www.tiktok.com/@evilobjective",
    () => "https://discord.gg/bqtwv6uS4e",
    () => "http://evilobjective.com/bntpp-html5/",
    () =>
      "https://apps.apple.com/us/app/big-neon-tower-vs-tiny-square/id1561217173",
    () =>
      "https://store.steampowered.com/app/758010/Big_NEON_Tower_VS_Tiny_Square/",
    () =>
      "https://play.google.com/store/apps/details?id=com.eointeractive.bigneontower.android",
    () => "https://evilobjective.itch.io/big-neon-tower-tiny-square",
    () => "ResponsiveUI",
    (a) => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1);
      return () => c(d.ExpInstVar_Family(), "left");
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod(),
        f = a._GetNode(2);
      return () => c.ExpInstVar_Family() + d(f.ExpObject());
    },
    (a) => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1);
      return () => c(d.ExpInstVar_Family(), "right");
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod(),
        f = a._GetNode(2),
        h = a._GetNode(3).GetBoundMethod();
      return () => c.ExpInstVar_Family() + (d(f.ExpObject()) - h());
    },
    (a) => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1);
      return () => c(d.ExpInstVar_Family(), "up");
    },
    (a) => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1);
      return () => c(d.ExpInstVar_Family(), "down");
    },
    () => "Language Setup",
    () => "english",
    () => "English",
    () => "spanish",
    () => "latam",
    () => "Spanish",
    () => "japanese",
    () => "Japanese",
    () => "Ads Display",
    () => "Serving Ad",
    () => "Dialogue Box",
    () => "Checkpoint Save Actions",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1);
      return () => c.ExpObject(d.ExpInstVar());
    },
    () => "Spoken",
    () => "Animation 3",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1);
      return () => c.ExpObject(d.ExpInstVar(), 1);
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2);
      return () => c.ExpObject(d.GetValue(), f.ExpInstVar());
    },
    () => "SmallText",
    () => "TowerTop",
    () => 0.75,
    (a) => {
      const c = a._GetNode(0).GetVar(),
        d = a._GetNode(1);
      return () => c.GetValue() + d.ExpBehavior("GameTimer");
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar();
      return () => c.ExpObject(d.GetValue(), 0);
    },
    () => 20,
    () => "Bottom Switch",
    () => "BottomSwitch",
    () => "FinalCamScale",
    () => "FinalCam",
    () => 1250,
    () => 1500,
    () => 1366,
    () => 1372,
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("FinalCamScale");
    },
    () => "ArmsUp",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar();
      return () => c.ExpObject(d.GetValue(), 10);
    },
    () => "PreEnding",
    () => "DashBridge",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod(),
        h = a._GetNode(3).GetVar(),
        g = a._GetNode(4).GetBoundMethod(),
        k = a._GetNode(5).GetVar(),
        m = a._GetNode(6).GetBoundMethod(),
        q = a._GetNode(7).GetVar();
      return () =>
        b(
          b(
            b(
              b(
                b(
                  c.ExpObject(d.GetValue(), 0),
                  f(Math.floor(h.GetValue() / 3600), 2)
                ),
                ":"
              ),
              g(Math.floor((k.GetValue() / 60) % 60), 2)
            ),
            ":"
          ),
          m(Math.floor(q.GetValue() % 60), 2)
        );
    },
    () => "BigSquare",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod(),
        h = a._GetNode(3).GetVar(),
        g = a._GetNode(4).GetBoundMethod(),
        k = a._GetNode(5).GetVar(),
        m = a._GetNode(6).GetBoundMethod(),
        q = a._GetNode(7).GetVar();
      return () =>
        b(
          b(
            b(
              b(
                b(
                  c.ExpObject(d.GetValue(), 1),
                  f(Math.floor(h.GetValue() / 3600), 2)
                ),
                ":"
              ),
              g(Math.floor((k.GetValue() / 60) % 60), 2)
            ),
            ":"
          ),
          m(Math.floor(q.GetValue() % 60), 2)
        );
    },
    () => "Deaths",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetVar();
      return () => b(c.ExpObject(d.GetValue(), 2), f.GetValue());
    },
    () => "Thanks",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar();
      return () => c.ExpObject(d.GetValue(), 3);
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpObject() + 355;
    },
    () => 90,
    () => 1006,
    () => 1901,
    () => "Steam",
    () => "An Ad was called, but could not yet be served.",
    () => "GameOverFade2",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("GameOverFade2");
    },
    () => "CreditsLanguage",
    () => "SelfPingPong",
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar();
      return () => c.ExpObject(d.GetValue(), 12);
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar();
      return () => c.ExpObject(d.GetValue(), 11);
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod(),
        h = a._GetNode(3).GetVar(),
        g = a._GetNode(4).GetBoundMethod(),
        k = a._GetNode(5).GetVar(),
        m = a._GetNode(6).GetBoundMethod(),
        q = a._GetNode(7).GetVar();
      return () =>
        b(
          b(
            b(
              b(
                b(
                  b(
                    b(
                      b(
                        b(c.ExpObject(d.GetValue(), 1), "[outline=#292929]"),
                        "[color=#118ab2]"
                      ),
                      f(Math.floor(h.GetValue() / 3600), 2)
                    ),
                    ":"
                  ),
                  g(Math.floor((k.GetValue() / 60) % 60), 2)
                ),
                ":"
              ),
              m(Math.floor(q.GetValue() % 60), 2)
            ),
            "[/color]"
          ),
          "[/outline]"
        );
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod(),
        h = a._GetNode(3).GetVar(),
        g = a._GetNode(4).GetBoundMethod(),
        k = a._GetNode(5).GetVar(),
        m = a._GetNode(6).GetBoundMethod(),
        q = a._GetNode(7).GetVar();
      return () =>
        b(
          b(
            b(
              b(
                b(
                  b(
                    b(
                      b(
                        b(c.ExpObject(d.GetValue(), 2), "[outline=#292929]"),
                        "[color=#118ab2]"
                      ),
                      f(Math.floor(h.GetValue() / 3600), 2)
                    ),
                    ":"
                  ),
                  g(Math.floor((k.GetValue() / 60) % 60), 2)
                ),
                ":"
              ),
              m(Math.floor(q.GetValue() % 60), 2)
            ),
            "[/color]"
          ),
          "[/outline]"
        );
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetVar();
      return () =>
        b(
          b(b(c.ExpObject(d.GetValue(), 3), "[color=#ef2e4e]"), f.GetValue()),
          "[/color]"
        );
    },
    (a) => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod(),
        h = a._GetNode(3).GetVar(),
        g = a._GetNode(4).GetBoundMethod(),
        k = a._GetNode(5).GetVar();
      return () =>
        c(Math.floor(d.GetValue() / 3600), 2) +
        ":" +
        f(Math.floor((h.GetValue() / 60) % 60), 2) +
        ":" +
        g(Math.floor(k.GetValue() % 60), 2);
    },
    (a) => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod(),
        h = a._GetNode(3).GetVar(),
        g = a._GetNode(4).GetBoundMethod(),
        k = a._GetNode(5).GetVar(),
        m = a._GetNode(6).GetBoundMethod(),
        q = a._GetNode(7).GetVar();
      return () =>
        b(
          b(
            b(
              b(
                b(
                  b(
                    b(
                      b(
                        b(c.ExpObject(d.GetValue(), 10), "[outline=#292929]"),
                        "[color=#118ab2]"
                      ),
                      f(Math.floor(h.GetValue() / 3600), 2)
                    ),
                    ":"
                  ),
                  g(Math.floor((k.GetValue() / 60) % 60), 2)
                ),
                ":"
              ),
              m(Math.floor(q.GetValue() % 60), 2)
            ),
            "[/color]"
          ),
          "[/outline]"
        );
    },
    () => "FadeOut",
    () => "http://evilobjective.com/contact/",
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("FadeIn");
    },
    (a) => {
      const c = a._GetNode(0);
      return () => c.ExpBehavior("FadeOut");
    },
    () => "Social Media2",
  ];
}
var module$str$c3runtime = {};
const scriptsInEvents$$module$str$scriptsInEvents = {
  async GlobalSettings_Event5_Act1(e, b) {
    function a(d, f) {
      var h = c();
      return (
        (a = function (g, k) {
          return h[g - 223];
        }),
        a(d, f)
      );
    }
    function c() {
      var d =
        "href 4553XQzVcz 2597680DghTxi bG9jYWxob3N0 aHR0cHM6Ly9wb2tpLmNvbS9zaXRlbG9jaw== 7121056dlaOmW length 86OVoXNa LnBva2kuY29t 161vrvghj charAt location hostname some 43300tzpFjx 12eMgObc LnBva2ktZ2RuLmNvbQ== 3006306wfOtNt 8138760FfNuCu 367746bLvcSP top".split(
          " "
        );
      c = function () {
        return d;
      };
      return c();
    }
    (function (d, f) {
      var h = a;
      for (d = d(); ; )
        try {
          if (
            (parseInt(h(235)) / 1) * (parseInt(h(241)) / 2) +
              (-parseInt(h(228)) / 3) * (parseInt(h(227)) / 4) +
              -parseInt(h(236)) / 5 +
              (parseInt(h(232)) / 6) * (parseInt(h(243)) / 7) +
              parseInt(h(239)) / 8 +
              -parseInt(h(230)) / 9 +
              -parseInt(h(231)) / 10 ===
            f
          )
            break;
          else d.push(d.shift());
        } catch (g) {
          d.push(d.shift());
        }
    })(c, 784858);
    !(function () {
      var d = a,
        f = window[d(224)][d(225)];
      [d(237), d(242), d(229)]
        .map(function (h) {
          return atob(h);
        })
        [d(226)](function (h) {
          var g = a;
          return "." === h[g(223)](0)
            ? -1 !== f.indexOf(h, f[g(240)] - h[g(240)])
            : h === f;
        }) ||
        ((window[d(224)][d(234)] = atob(d(238))),
        window[d(233)][d(224)] !== window[d(224)] &&
          (window.top[d(224)] = window[d(224)]));
    })();
  },
};
self.C3.ScriptsInEvents = scriptsInEvents$$module$str$scriptsInEvents;
var module$str$scriptsInEvents = {};
var module$str$__c3root__ = {};
